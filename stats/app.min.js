"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/highcharts@10.3.3/node_modules/highcharts/highcharts.src.js
  var require_highcharts_src = __commonJS({
    "node_modules/.pnpm/highcharts@10.3.3/node_modules/highcharts/highcharts.src.js"(exports, module) {
      (function(root2, factory) {
        if (typeof module === "object" && module.exports) {
          factory["default"] = factory;
          module.exports = root2.document ? factory(root2) : factory;
        } else if (typeof define === "function" && define.amd) {
          define("highcharts/highcharts", function() {
            return factory(root2);
          });
        } else {
          if (root2.Highcharts) {
            root2.Highcharts.error(16, true);
          }
          root2.Highcharts = factory(root2);
        }
      })(typeof window !== "undefined" ? window : exports, function(window2) {
        "use strict";
        var _modules = {};
        function _registerModule(obj, path, args, fn) {
          if (!obj.hasOwnProperty(path)) {
            obj[path] = fn.apply(null, args);
            if (typeof CustomEvent === "function") {
              window2.dispatchEvent(
                new CustomEvent(
                  "HighchartsModuleLoaded",
                  {
                    detail: { path, module: obj[path] }
                  }
                )
              );
            }
          }
        }
        _registerModule(_modules, "Core/Globals.js", [], function() {
          var Globals;
          (function(Globals2) {
            Globals2.SVG_NS = "http://www.w3.org/2000/svg", Globals2.product = "Highcharts", Globals2.version = "10.3.3", Globals2.win = typeof window2 !== "undefined" ? window2 : {}, // eslint-disable-line node/no-unsupported-features/es-builtins
            Globals2.doc = Globals2.win.document, Globals2.svg = Globals2.doc && Globals2.doc.createElementNS && !!Globals2.doc.createElementNS(Globals2.SVG_NS, "svg").createSVGRect, Globals2.userAgent = Globals2.win.navigator && Globals2.win.navigator.userAgent || "", Globals2.isChrome = Globals2.userAgent.indexOf("Chrome") !== -1, Globals2.isFirefox = Globals2.userAgent.indexOf("Firefox") !== -1, Globals2.isMS = /(edge|msie|trident)/i.test(Globals2.userAgent) && !Globals2.win.opera, Globals2.isSafari = !Globals2.isChrome && Globals2.userAgent.indexOf("Safari") !== -1, Globals2.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(Globals2.userAgent), Globals2.isWebKit = Globals2.userAgent.indexOf("AppleWebKit") !== -1, Globals2.deg2rad = Math.PI * 2 / 360, Globals2.hasBidiBug = Globals2.isFirefox && parseInt(Globals2.userAgent.split("Firefox/")[1], 10) < 4, Globals2.hasTouch = !!Globals2.win.TouchEvent, Globals2.marginNames = [
              "plotTop",
              "marginRight",
              "marginBottom",
              "plotLeft"
            ], Globals2.noop = function() {
            }, Globals2.supportsPassiveEvents = function() {
              var supportsPassive = false;
              if (!Globals2.isMS) {
                var opts = Object.defineProperty({}, "passive", {
                  get: function() {
                    supportsPassive = true;
                  }
                });
                if (Globals2.win.addEventListener && Globals2.win.removeEventListener) {
                  Globals2.win.addEventListener("testPassive", Globals2.noop, opts);
                  Globals2.win.removeEventListener("testPassive", Globals2.noop, opts);
                }
              }
              return supportsPassive;
            }();
            Globals2.charts = [];
            Globals2.dateFormats = {};
            Globals2.seriesTypes = {};
            Globals2.symbolSizes = {};
            Globals2.chartCount = 0;
          })(Globals || (Globals = {}));
          "";
          return Globals;
        });
        _registerModule(_modules, "Core/Utilities.js", [_modules["Core/Globals.js"]], function(H) {
          var charts = H.charts, doc = H.doc, win = H.win;
          function error(code, stop, chart, params) {
            var severity = stop ? "Highcharts error" : "Highcharts warning";
            if (code === 32) {
              code = "" + severity + ": Deprecated member";
            }
            var isCode = isNumber(code);
            var message = isCode ? "" + severity + " #" + code + ": www.highcharts.com/errors/" + code + "/" : code.toString();
            var defaultHandler = function() {
              if (stop) {
                throw new Error(message);
              }
              if (win.console && error.messages.indexOf(message) === -1) {
                console.warn(message);
              }
            };
            if (typeof params !== "undefined") {
              var additionalMessages_1 = "";
              if (isCode) {
                message += "?";
              }
              objectEach(params, function(value, key) {
                additionalMessages_1 += "\n - ".concat(key, ": ").concat(value);
                if (isCode) {
                  message += encodeURI(key) + "=" + encodeURI(value);
                }
              });
              message += additionalMessages_1;
            }
            fireEvent(H, "displayError", { chart, code, message, params }, defaultHandler);
            error.messages.push(message);
          }
          (function(error2) {
            error2.messages = [];
          })(error || (error = {}));
          function merge() {
            var i, args = arguments, ret = {};
            var doCopy = function(copy, original) {
              if (typeof copy !== "object") {
                copy = {};
              }
              objectEach(original, function(value, key) {
                if (key === "__proto__" || key === "constructor") {
                  return;
                }
                if (isObject(value, true) && !isClass(value) && !isDOMElement(value)) {
                  copy[key] = doCopy(copy[key] || {}, value);
                } else {
                  copy[key] = original[key];
                }
              });
              return copy;
            };
            if (args[0] === true) {
              ret = args[1];
              args = Array.prototype.slice.call(args, 2);
            }
            var len = args.length;
            for (i = 0; i < len; i++) {
              ret = doCopy(ret, args[i]);
            }
            return ret;
          }
          function clamp(value, min2, max2) {
            return value > min2 ? value < max2 ? value : max2 : min2;
          }
          function cleanRecursively(newer, older) {
            var result = {};
            objectEach(newer, function(_val, key) {
              var ob;
              if (isObject(newer[key], true) && !newer.nodeType && // #10044
              older[key]) {
                ob = cleanRecursively(newer[key], older[key]);
                if (Object.keys(ob).length) {
                  result[key] = ob;
                }
              } else if (isObject(newer[key]) || newer[key] !== older[key] || // If the newer key is explicitly undefined, keep it (#10525)
              key in newer && !(key in older)) {
                result[key] = newer[key];
              }
            });
            return result;
          }
          function pInt(s, mag) {
            return parseInt(s, mag || 10);
          }
          function isString(s) {
            return typeof s === "string";
          }
          function isArray(obj) {
            var str = Object.prototype.toString.call(obj);
            return str === "[object Array]" || str === "[object Array Iterator]";
          }
          function isObject(obj, strict) {
            return !!obj && typeof obj === "object" && (!strict || !isArray(obj));
          }
          function isDOMElement(obj) {
            return isObject(obj) && typeof obj.nodeType === "number";
          }
          function isClass(obj) {
            var c = obj && obj.constructor;
            return !!(isObject(obj, true) && !isDOMElement(obj) && (c && c.name && c.name !== "Object"));
          }
          function isNumber(n) {
            return typeof n === "number" && !isNaN(n) && n < Infinity && n > -Infinity;
          }
          function erase(arr, item) {
            var i = arr.length;
            while (i--) {
              if (arr[i] === item) {
                arr.splice(i, 1);
                break;
              }
            }
          }
          function defined(obj) {
            return typeof obj !== "undefined" && obj !== null;
          }
          function attr(elem, keyOrAttribs, value) {
            var isGetter = isString(keyOrAttribs) && !defined(value);
            var ret;
            var attrSingle = function(value2, key) {
              if (defined(value2)) {
                elem.setAttribute(
                  key,
                  value2
                );
              } else if (isGetter) {
                ret = elem.getAttribute(key);
                if (!ret && key === "class") {
                  ret = elem.getAttribute(key + "Name");
                }
              } else {
                elem.removeAttribute(key);
              }
            };
            if (isString(keyOrAttribs)) {
              attrSingle(value, keyOrAttribs);
            } else {
              objectEach(keyOrAttribs, attrSingle);
            }
            return ret;
          }
          function splat(obj) {
            return isArray(obj) ? obj : [obj];
          }
          function syncTimeout(fn, delay, context) {
            if (delay > 0) {
              return setTimeout(fn, delay, context);
            }
            fn.call(0, context);
            return -1;
          }
          function internalClearTimeout(id2) {
            if (defined(id2)) {
              clearTimeout(id2);
            }
          }
          function extend2(a, b) {
            var n;
            if (!a) {
              a = {};
            }
            for (n in b) {
              a[n] = b[n];
            }
            return a;
          }
          function pick() {
            var args = arguments;
            var length = args.length;
            for (var i = 0; i < length; i++) {
              var arg = args[i];
              if (typeof arg !== "undefined" && arg !== null) {
                return arg;
              }
            }
          }
          function css(el, styles) {
            if (H.isMS && !H.svg) {
              if (styles && defined(styles.opacity)) {
                styles.filter = "alpha(opacity=".concat(styles.opacity * 100, ")");
              }
            }
            extend2(el.style, styles);
          }
          function createElement(tag, attribs, styles, parent, nopad) {
            var el = doc.createElement(tag);
            if (attribs) {
              extend2(el, attribs);
            }
            if (nopad) {
              css(el, { padding: "0", border: "none", margin: "0" });
            }
            if (styles) {
              css(el, styles);
            }
            if (parent) {
              parent.appendChild(el);
            }
            return el;
          }
          function extendClass(parent, members) {
            var obj = function() {
            };
            obj.prototype = new parent();
            extend2(obj.prototype, members);
            return obj;
          }
          function pad2(number, length, padder) {
            return new Array((length || 2) + 1 - String(number).replace("-", "").length).join(padder || "0") + number;
          }
          function relativeLength(value, base, offset2) {
            return /%$/.test(value) ? base * parseFloat(value) / 100 + (offset2 || 0) : parseFloat(value);
          }
          function wrap(obj, method, func) {
            var proceed = obj[method];
            obj[method] = function() {
              var outerArgs = arguments, scope = this;
              return func.apply(this, [
                function() {
                  return proceed.apply(scope, arguments.length ? arguments : outerArgs);
                }
              ].concat([].slice.call(arguments)));
            };
          }
          function getMagnitude(num) {
            return Math.pow(10, Math.floor(Math.log(num) / Math.LN10));
          }
          function normalizeTickInterval(interval2, multiples, magnitude, allowDecimals, hasTickAmount) {
            var i, retInterval = interval2;
            magnitude = pick(magnitude, getMagnitude(interval2));
            var normalized = interval2 / magnitude;
            if (!multiples) {
              multiples = hasTickAmount ? (
                // Finer grained ticks when the tick amount is hard set, including
                // when alignTicks is true on multiple axes (#4580).
                [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10]
              ) : (
                // Else, let ticks fall on rounder numbers
                [1, 2, 2.5, 5, 10]
              );
              if (allowDecimals === false) {
                if (magnitude === 1) {
                  multiples = multiples.filter(function(num) {
                    return num % 1 === 0;
                  });
                } else if (magnitude <= 0.1) {
                  multiples = [1 / magnitude];
                }
              }
            }
            for (i = 0; i < multiples.length; i++) {
              retInterval = multiples[i];
              if (hasTickAmount && retInterval * magnitude >= interval2 || !hasTickAmount && normalized <= (multiples[i] + (multiples[i + 1] || multiples[i])) / 2) {
                break;
              }
            }
            retInterval = correctFloat(retInterval * magnitude, -Math.round(Math.log(1e-3) / Math.LN10));
            return retInterval;
          }
          function stableSort(arr, sortFunction) {
            var length = arr.length;
            var sortValue, i;
            for (i = 0; i < length; i++) {
              arr[i].safeI = i;
            }
            arr.sort(function(a, b) {
              sortValue = sortFunction(a, b);
              return sortValue === 0 ? a.safeI - b.safeI : sortValue;
            });
            for (i = 0; i < length; i++) {
              delete arr[i].safeI;
            }
          }
          function arrayMin(data) {
            var i = data.length, min2 = data[0];
            while (i--) {
              if (data[i] < min2) {
                min2 = data[i];
              }
            }
            return min2;
          }
          function arrayMax(data) {
            var i = data.length, max2 = data[0];
            while (i--) {
              if (data[i] > max2) {
                max2 = data[i];
              }
            }
            return max2;
          }
          function destroyObjectProperties(obj, except) {
            objectEach(obj, function(val, n) {
              if (val && val !== except && val.destroy) {
                val.destroy();
              }
              delete obj[n];
            });
          }
          function discardElement(element) {
            if (element && element.parentElement) {
              element.parentElement.removeChild(element);
            }
          }
          function correctFloat(num, prec) {
            return num > 1e14 ? num : parseFloat(num.toPrecision(prec || 14));
          }
          var timeUnits = {
            millisecond: 1,
            second: 1e3,
            minute: 6e4,
            hour: 36e5,
            day: 24 * 36e5,
            week: 7 * 24 * 36e5,
            month: 28 * 24 * 36e5,
            year: 364 * 24 * 36e5
          };
          Math.easeInOutSine = function(pos) {
            return -0.5 * (Math.cos(Math.PI * pos) - 1);
          };
          function getNestedProperty(path, parent) {
            var pathElements = path.split(".");
            while (pathElements.length && defined(parent)) {
              var pathElement = pathElements.shift();
              if (typeof pathElement === "undefined" || pathElement === "__proto__") {
                return;
              }
              var child = parent[pathElement];
              if (!defined(child) || typeof child === "function" || typeof child.nodeType === "number" || child === win) {
                return;
              }
              parent = child;
            }
            return parent;
          }
          function getStyle(el, prop, toInt) {
            var customGetStyle = H.getStyle || // oldie getStyle
            getStyle;
            var style;
            if (prop === "width") {
              var offsetWidth = Math.min(
                el.offsetWidth,
                el.scrollWidth
              );
              var boundingClientRectWidth = el.getBoundingClientRect && el.getBoundingClientRect().width;
              if (boundingClientRectWidth < offsetWidth && boundingClientRectWidth >= offsetWidth - 1) {
                offsetWidth = Math.floor(boundingClientRectWidth);
              }
              return Math.max(
                0,
                // #8377
                offsetWidth - (customGetStyle(el, "padding-left", true) || 0) - (customGetStyle(el, "padding-right", true) || 0)
              );
            }
            if (prop === "height") {
              return Math.max(
                0,
                // #8377
                Math.min(el.offsetHeight, el.scrollHeight) - (customGetStyle(el, "padding-top", true) || 0) - (customGetStyle(el, "padding-bottom", true) || 0)
              );
            }
            if (!win.getComputedStyle) {
              error(27, true);
            }
            var css2 = win.getComputedStyle(
              el,
              void 0
            );
            if (css2) {
              style = css2.getPropertyValue(prop);
              if (pick(toInt, prop !== "opacity")) {
                style = pInt(style);
              }
            }
            return style;
          }
          function inArray(item, arr, fromIndex) {
            error(32, false, void 0, { "Highcharts.inArray": "use Array.indexOf" });
            return arr.indexOf(item, fromIndex);
          }
          var find2 = Array.prototype.find ? function(arr, callback) {
            return arr.find(callback);
          } : (
            // Legacy implementation. PhantomJS, IE <= 11 etc. #7223.
            function(arr, callback) {
              var i;
              var length = arr.length;
              for (i = 0; i < length; i++) {
                if (callback(arr[i], i)) {
                  return arr[i];
                }
              }
            }
          );
          function keys(obj) {
            error(32, false, void 0, { "Highcharts.keys": "use Object.keys" });
            return Object.keys(obj);
          }
          function offset(el) {
            var docElem = doc.documentElement, box = el.parentElement || el.parentNode ? el.getBoundingClientRect() : {
              top: 0,
              left: 0,
              width: 0,
              height: 0
            };
            return {
              top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
              left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0),
              width: box.width,
              height: box.height
            };
          }
          function objectEach(obj, fn, ctx) {
            for (var key in obj) {
              if (Object.hasOwnProperty.call(obj, key)) {
                fn.call(ctx || obj[key], obj[key], key, obj);
              }
            }
          }
          objectEach({
            map: "map",
            each: "forEach",
            grep: "filter",
            reduce: "reduce",
            some: "some"
          }, function(val, key) {
            H[key] = function(arr) {
              var _a;
              error(32, false, void 0, (_a = {}, _a["Highcharts.".concat(key)] = "use Array.".concat(val), _a));
              return Array.prototype[val].apply(arr, [].slice.call(arguments, 1));
            };
          });
          function addEvent(el, type, fn, options) {
            if (options === void 0) {
              options = {};
            }
            var owner = typeof el === "function" && el.prototype || el;
            if (!Object.hasOwnProperty.call(owner, "hcEvents")) {
              owner.hcEvents = {};
            }
            var events = owner.hcEvents;
            if (H.Point && // without H a dependency loop occurs
            el instanceof H.Point && el.series && el.series.chart) {
              el.series.chart.runTrackerClick = true;
            }
            var addEventListener = el.addEventListener || H.addEventListenerPolyfill;
            if (addEventListener) {
              addEventListener.call(el, type, fn, H.supportsPassiveEvents ? {
                passive: options.passive === void 0 ? type.indexOf("touch") !== -1 : options.passive,
                capture: false
              } : false);
            }
            if (!events[type]) {
              events[type] = [];
            }
            var eventObject = {
              fn,
              order: typeof options.order === "number" ? options.order : Infinity
            };
            events[type].push(eventObject);
            events[type].sort(function(a, b) {
              return a.order - b.order;
            });
            return function() {
              removeEvent(el, type, fn);
            };
          }
          function removeEvent(el, type, fn) {
            function removeOneEvent(type2, fn2) {
              var removeEventListener = el.removeEventListener || H.removeEventListenerPolyfill;
              if (removeEventListener) {
                removeEventListener.call(el, type2, fn2, false);
              }
            }
            function removeAllEvents(eventCollection) {
              var types, len;
              if (!el.nodeName) {
                return;
              }
              if (type) {
                types = {};
                types[type] = true;
              } else {
                types = eventCollection;
              }
              objectEach(types, function(_val, n) {
                if (eventCollection[n]) {
                  len = eventCollection[n].length;
                  while (len--) {
                    removeOneEvent(n, eventCollection[n][len].fn);
                  }
                }
              });
            }
            var owner = typeof el === "function" && el.prototype || el;
            if (Object.hasOwnProperty.call(owner, "hcEvents")) {
              var events = owner.hcEvents;
              if (type) {
                var typeEvents = events[type] || [];
                if (fn) {
                  events[type] = typeEvents.filter(function(obj) {
                    return fn !== obj.fn;
                  });
                  removeOneEvent(type, fn);
                } else {
                  removeAllEvents(events);
                  events[type] = [];
                }
              } else {
                removeAllEvents(events);
                delete owner.hcEvents;
              }
            }
          }
          function fireEvent(el, type, eventArguments, defaultFunction) {
            var e, i;
            eventArguments = eventArguments || {};
            if (doc.createEvent && (el.dispatchEvent || el.fireEvent && // Enable firing events on Highcharts instance.
            el !== H)) {
              e = doc.createEvent("Events");
              e.initEvent(type, true, true);
              eventArguments = extend2(e, eventArguments);
              if (el.dispatchEvent) {
                el.dispatchEvent(eventArguments);
              } else {
                el.fireEvent(type, eventArguments);
              }
            } else if (el.hcEvents) {
              if (!eventArguments.target) {
                extend2(eventArguments, {
                  // Attach a simple preventDefault function to skip
                  // default handler if called. The built-in
                  // defaultPrevented property is not overwritable (#5112)
                  preventDefault: function() {
                    eventArguments.defaultPrevented = true;
                  },
                  // Setting target to native events fails with clicking
                  // the zoom-out button in Chrome.
                  target: el,
                  // If the type is not set, we're running a custom event
                  // (#2297). If it is set, we're running a browser event,
                  // and setting it will cause en error in IE8 (#2465).
                  type
                });
              }
              var events = [];
              var object = el;
              var multilevel = false;
              while (object.hcEvents) {
                if (Object.hasOwnProperty.call(object, "hcEvents") && object.hcEvents[type]) {
                  if (events.length) {
                    multilevel = true;
                  }
                  events.unshift.apply(events, object.hcEvents[type]);
                }
                object = Object.getPrototypeOf(object);
              }
              if (multilevel) {
                events.sort(function(a, b) {
                  return a.order - b.order;
                });
              }
              events.forEach(function(obj) {
                if (obj.fn.call(el, eventArguments) === false) {
                  eventArguments.preventDefault();
                }
              });
            }
            if (defaultFunction && !eventArguments.defaultPrevented) {
              defaultFunction.call(el, eventArguments);
            }
          }
          var serialMode;
          var uniqueKey = function() {
            var hash = Math.random().toString(36).substring(2, 9) + "-";
            var id2 = 0;
            return function() {
              return "highcharts-" + (serialMode ? "" : hash) + id2++;
            };
          }();
          function useSerialIds(mode) {
            return serialMode = pick(mode, serialMode);
          }
          function isFunction(obj) {
            return typeof obj === "function";
          }
          if (win.jQuery) {
            win.jQuery.fn.highcharts = function() {
              var args = [].slice.call(arguments);
              if (this[0]) {
                if (args[0]) {
                  new H[
                    // eslint-disable-line computed-property-spacing, no-new
                    // Constructor defaults to Chart
                    isString(args[0]) ? args.shift() : "Chart"
                  ](this[0], args[0], args[1]);
                  return this;
                }
                return charts[attr(this[0], "data-highcharts-chart")];
              }
            };
          }
          var Utilities = {
            addEvent,
            arrayMax,
            arrayMin,
            attr,
            clamp,
            cleanRecursively,
            clearTimeout: internalClearTimeout,
            correctFloat,
            createElement,
            css,
            defined,
            destroyObjectProperties,
            discardElement,
            erase,
            error,
            extend: extend2,
            extendClass,
            find: find2,
            fireEvent,
            getMagnitude,
            getNestedProperty,
            getStyle,
            inArray,
            isArray,
            isClass,
            isDOMElement,
            isFunction,
            isNumber,
            isObject,
            isString,
            keys,
            merge,
            normalizeTickInterval,
            objectEach,
            offset,
            pad: pad2,
            pick,
            pInt,
            relativeLength,
            removeEvent,
            splat,
            stableSort,
            syncTimeout,
            timeUnits,
            uniqueKey,
            useSerialIds,
            wrap
          };
          "";
          return Utilities;
        });
        _registerModule(_modules, "Core/Chart/ChartDefaults.js", [], function() {
          var ChartDefaults = {
            /**
                 * Default `mapData` for all series,
            in terms of a GeoJSON or TopoJSON
                 * object. If set to a string,
            it functions as an index into the
                 * `Highcharts.maps` array.
                 *
                 * For picking out individual shapes and geometries to use for each series
                 * of the map,
            see [series.mapData](#series.map.mapData).
                 *
                 * @sample    maps/demo/geojson
                 *            Loading GeoJSON data
                 * @sample    maps/chart/topojson
                 *            Loading TopoJSON data
                 *
                 * @type      {string|Array<*>|Highcharts.GeoJSON|Highcharts.TopoJSON}
                 * @since     5.0.0
                 * @product   highmaps
                 * @apioption chart.map
                 */
            /**
             * Set lat/lon transformation definitions for the chart. If not defined,
             * these are extracted from the map data.
             *
             * @type      {*}
             * @since     5.0.0
             * @product   highmaps
             * @apioption chart.mapTransforms
             */
            /**
                 * When using multiple axes,
            the ticks of two or more opposite axes
                 * will automatically be aligned by adding ticks to the axis or axes
                 * with the least ticks,
            as if `tickAmount` were specified.
                 *
                 * This can be prevented by setting `alignTicks` to false. If the grid
                 * lines look messy,
            it's a good idea to hide them for the secondary
                 * axis by setting `gridLineWidth` to 0.
                 *
                 * If `startOnTick` or `endOnTick` in the axis options are set to false,
                 * then the `alignTicks ` will be disabled for the axis.
                 *
                 * Disabled for logarithmic axes.
                 *
                 * @sample {highcharts} highcharts/chart/alignticks-true/
                 *         True by default
                 * @sample {highcharts} highcharts/chart/alignticks-false/
                 *         False
                 * @sample {highstock} stock/chart/alignticks-true/
                 *         True by default
                 * @sample {highstock} stock/chart/alignticks-false/
                 *         False
                 *
                 * @type      {boolean}
                 * @default   true
                 * @product   highcharts highstock gantt
                 * @apioption chart.alignTicks
                 */
            /**
                 * When using multiple axes,
            align the thresholds. When this is true,
            other
                 * ticks will also be aligned.
                 *
                 * Note that for line series and some other series types,
            the `threshold`
                 * option is set to `null` by default. This will in turn cause their y-axis
                 * to not have a threshold. In order to avoid that,
            set the series
                 * `threshold` to 0 or another number.
                 *
                 * If `startOnTick` or `endOnTick` in the axis options are set to false,
            or
                 * if the axis is logarithmic,
            the threshold will not be aligned.
                 *
                 * @sample {highcharts} highcharts/chart/alignthresholds/ Set to true
                 *
                 * @since 10.0.0
                 * @product   highcharts highstock gantt
                 * @apioption chart.alignThresholds
                 */
            alignThresholds: false,
            /**
                 * Set the overall animation for all chart updating. Animation can be
                 * disabled throughout the chart by setting it to false here. It can
                 * be overridden for each individual API method as a function parameter.
                 * The only animation not affected by this option is the initial series
                 * animation,
            see [plotOptions.series.animation](
                 * #plotOptions.series.animation).
                 *
                 * The animation can either be set as a boolean or a configuration
                 * object. If `true`,
            it will use the 'swing' jQuery easing and a
                 * duration of 500 ms. If used as a configuration object,
            the following
                 * properties are supported:
                 *
                 * - `defer`: The animation delay time in milliseconds.
                 *
                 * - `duration`: The duration of the animation in milliseconds.
                 *
                 * - `easing`: A string reference to an easing function set on the
                 *   `Math` object. See
                 *   [the easing demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-animation-easing/).
                 *
                 * When zooming on a series with less than 100 points,
            the chart redraw
                 * will be done with animation,
            but in case of more data points,
            it is
                 * necessary to set this option to ensure animation on zoom.
                 *
                 * @sample {highcharts} highcharts/chart/animation-none/
                 *         Updating with no animation
                 * @sample {highcharts} highcharts/chart/animation-duration/
                 *         With a longer duration
                 * @sample {highcharts} highcharts/chart/animation-easing/
                 *         With a jQuery UI easing
                 * @sample {highmaps} maps/chart/animation-none/
                 *         Updating with no animation
                 * @sample {highmaps} maps/chart/animation-duration/
                 *         With a longer duration
                 *
                 * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 * @default   undefined
                 * @apioption chart.animation
                 */
            /**
                 * A CSS class name to apply to the charts container `div`,
            allowing
                 * unique CSS styling for each chart.
                 *
                 * @type      {string}
                 * @apioption chart.className
                 */
            /**
             * Event listeners for the chart.
             *
             * @apioption chart.events
             */
            /**
                 * Fires when a series is added to the chart after load time,
            using the
                 * `addSeries` method. One parameter,
            `event`,
            is passed to the
                 * function,
            containing common event information. Through
                 * `event.options` you can access the series options that were passed to
                 * the `addSeries` method. Returning false prevents the series from
                 * being added.
                 *
                 * @sample {highcharts} highcharts/chart/events-addseries/
                 *         Alert on add series
                 * @sample {highstock} stock/chart/events-addseries/
                 *         Alert on add series
                 *
                 * @type      {Highcharts.ChartAddSeriesCallbackFunction}
                 * @since     1.2.0
                 * @context   Highcharts.Chart
                 * @apioption chart.events.addSeries
                 */
            /**
                 * Fires when clicking on the plot background. One parameter,
            `event`,
                 * is passed to the function,
            containing common event information.
                 *
                 * Information on the clicked spot can be found through `event.xAxis`
                 * and `event.yAxis`,
            which are arrays containing the axes of each
                 * dimension and each axis' value at the clicked spot. The primary axes
                 * are `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
                 * datetime axis is milliseconds since 1970-01-01 00:00:00.
                 *
                 * ```js
                 * click: function(e) {
                 *     console.log(
                 *         Highcharts.dateFormat('%Y-%m-%d %H:%M:%S',
            e.xAxis[0].value),
                 *         e.yAxis[0].value
                 *     )
                 * }
                 * ```
                 *
                 * @sample {highcharts} highcharts/chart/events-click/
                 *         Alert coordinates on click
                 * @sample {highcharts} highcharts/chart/events-container/
                 *         Alternatively,
            attach event to container
                 * @sample {highstock} stock/chart/events-click/
                 *         Alert coordinates on click
                 * @sample {highstock} highcharts/chart/events-container/
                 *         Alternatively,
            attach event to container
                 * @sample {highmaps} maps/chart/events-click/
                 *         Record coordinates on click
                 * @sample {highmaps} highcharts/chart/events-container/
                 *         Alternatively,
            attach event to container
                 *
                 * @type      {Highcharts.ChartClickCallbackFunction}
                 * @since     1.2.0
                 * @context   Highcharts.Chart
                 * @apioption chart.events.click
                 */
            /**
                 * Fires when the chart is finished loading. Since v4.2.2,
            it also waits
                 * for images to be loaded,
            for example from point markers. One
                 * parameter,
            `event`,
            is passed to the function,
            containing common
                 * event information.
                 *
                 * There is also a second parameter to the chart constructor where a
                 * callback function can be passed to be executed on chart.load.
                 *
                 * @sample {highcharts} highcharts/chart/events-load/
                 *         Alert on chart load
                 * @sample {highstock} stock/chart/events-load/
                 *         Alert on chart load
                 * @sample {highmaps} maps/chart/events-load/
                 *         Add series on chart load
                 *
                 * @type      {Highcharts.ChartLoadCallbackFunction}
                 * @context   Highcharts.Chart
                 * @apioption chart.events.load
                 */
            /**
                 * Fires when the chart is redrawn,
            either after a call to
                 * `chart.redraw()` or after an axis,
            series or point is modified with
                 * the `redraw` option set to `true`. One parameter,
            `event`,
            is passed
                 * to the function,
            containing common event information.
                 *
                 * @sample {highcharts} highcharts/chart/events-redraw/
                 *         Alert on chart redraw
                 * @sample {highstock} stock/chart/events-redraw/
                 *         Alert on chart redraw when adding a series or moving the
                 *         zoomed range
                 * @sample {highmaps} maps/chart/events-redraw/
                 *         Set subtitle on chart redraw
                 *
                 * @type      {Highcharts.ChartRedrawCallbackFunction}
                 * @since     1.2.0
                 * @context   Highcharts.Chart
                 * @apioption chart.events.redraw
                 */
            /**
                 * Fires after initial load of the chart (directly after the `load`
                 * event),
            and after each redraw (directly after the `redraw` event).
                 *
                 * @type      {Highcharts.ChartRenderCallbackFunction}
                 * @since     5.0.7
                 * @context   Highcharts.Chart
                 * @apioption chart.events.render
                 */
            /**
                 * Fires when an area of the chart has been selected. Selection is
                 * enabled by setting the chart's zoomType. One parameter,
            `event`,
            is
                 * passed to the function,
            containing common event information. The
                 * default action for the selection event is to zoom the chart to the
                 * selected area. It can be prevented by calling
                 * `event.preventDefault()` or return false.
                 *
                 * Information on the selected area can be found through `event.xAxis`
                 * and `event.yAxis`,
            which are arrays containing the axes of each
                 * dimension and each axis' min and max values. The primary axes are
                 * `event.xAxis[0]` and `event.yAxis[0]`. Remember the unit of a
                 * datetime axis is milliseconds since 1970-01-01 00:00:00.
                 *
                 * ```js
                 * selection: function(event) {
                 *     // log the min and max of the primary, datetime x-axis
                 *     console.log(
                 *         Highcharts.dateFormat(
                 *             '%Y-%m-%d %H:%M:%S',
                 *             event.xAxis[0].min
                 *         ),
                 *         Highcharts.dateFormat(
                 *             '%Y-%m-%d %H:%M:%S',
                 *             event.xAxis[0].max
                 *         )
                 *     );
             *     // log the min and max of the y axis
             *     console.log(event.yAxis[0].min, event.yAxis[0].max);
             * }
             * ```
             *
             * @sample {highcharts} highcharts/chart/events-selection/
             *         Report on selection and reset
             * @sample {highcharts} highcharts/chart/events-selection-points/
             *         Select a range of points through a drag selection
             * @sample {highstock} stock/chart/events-selection/
             *         Report on selection and reset
             * @sample {highstock} highcharts/chart/events-selection-points/
             *         Select a range of points through a drag selection
             *         (Highcharts)
             *
             * @type      {Highcharts.ChartSelectionCallbackFunction}
             * @apioption chart.events.selection
             */
            /**
             * The margin between the outer edge of the chart and the plot area.
             * The numbers in the array designate top, right, bottom and left
             * respectively. Use the options `marginTop`, `marginRight`,
             * `marginBottom` and `marginLeft` for shorthand setting of one option.
             *
             * By default there is no margin. The actual space is dynamically
             * calculated from the offset of axis labels, axis title, title,
             * subtitle and legend in addition to the `spacingTop`, `spacingRight`,
             * `spacingBottom` and `spacingLeft` options.
             *
             * @sample {highcharts} highcharts/chart/margins-zero/
             *         Zero margins
             * @sample {highstock} stock/chart/margin-zero/
             *         Zero margins
             *
             * @type      {number|Array<number>}
             * @apioption chart.margin
             */
            /**
             * The margin between the bottom outer edge of the chart and the plot
             * area. Use this to set a fixed pixel value for the margin as opposed
             * to the default dynamic margin. See also `spacingBottom`.
             *
             * @sample {highcharts} highcharts/chart/marginbottom/
             *         100px bottom margin
             * @sample {highstock} stock/chart/marginbottom/
             *         100px bottom margin
             * @sample {highmaps} maps/chart/margin/
             *         100px margins
             *
             * @type      {number}
             * @since     2.0
             * @apioption chart.marginBottom
             */
            /**
             * The margin between the left outer edge of the chart and the plot
             * area. Use this to set a fixed pixel value for the margin as opposed
             * to the default dynamic margin. See also `spacingLeft`.
             *
             * @sample {highcharts} highcharts/chart/marginleft/
             *         150px left margin
             * @sample {highstock} stock/chart/marginleft/
             *         150px left margin
             * @sample {highmaps} maps/chart/margin/
             *         100px margins
             *
             * @type      {number}
             * @since     2.0
             * @apioption chart.marginLeft
             */
            /**
             * The margin between the right outer edge of the chart and the plot
             * area. Use this to set a fixed pixel value for the margin as opposed
             * to the default dynamic margin. See also `spacingRight`.
             *
             * @sample {highcharts} highcharts/chart/marginright/
             *         100px right margin
             * @sample {highstock} stock/chart/marginright/
             *         100px right margin
             * @sample {highmaps} maps/chart/margin/
             *         100px margins
             *
             * @type      {number}
             * @since     2.0
             * @apioption chart.marginRight
             */
            /**
             * The margin between the top outer edge of the chart and the plot area.
             * Use this to set a fixed pixel value for the margin as opposed to
             * the default dynamic margin. See also `spacingTop`.
             *
             * @sample {highcharts} highcharts/chart/margintop/ 100px top margin
             * @sample {highstock} stock/chart/margintop/
             *         100px top margin
             * @sample {highmaps} maps/chart/margin/
             *         100px margins
             *
             * @type      {number}
             * @since     2.0
             * @apioption chart.marginTop
             */
            /**
             * Callback function to override the default function that formats all
             * the numbers in the chart. Returns a string with the formatted number.
             *
             * @sample highcharts/members/highcharts-numberformat
             *      Arabic digits in Highcharts
             * @type {Highcharts.NumberFormatterCallbackFunction}
             * @since 8.0.0
             * @apioption chart.numberFormatter
             */
            /**
             * Allows setting a key to switch between zooming and panning. Can be
             * one of `alt`, `ctrl`, `meta` (the command key on Mac and Windows
             * key on Windows) or `shift`. The keys are mapped directly to the key
             * properties of the click event argument (`event.altKey`,
             * `event.ctrlKey`, `event.metaKey` and `event.shiftKey`).
             *
             * @type       {string}
             * @since      4.0.3
             * @product    highcharts gantt
             * @validvalue ["alt", "ctrl", "meta", "shift"]
             * @apioption  chart.panKey
             */
            /**
             * Allow panning in a chart. Best used with [panKey](#chart.panKey)
             * to combine zooming and panning.
             *
             * On touch devices, when the [tooltip.followTouchMove](
             * #tooltip.followTouchMove) option is `true` (default), panning
             * requires two fingers. To allow panning with one finger, set
             * `followTouchMove` to `false`.
             *
             * @sample  {highcharts} highcharts/chart/pankey/ Zooming and panning
             * @sample  {highstock} stock/chart/panning/ Zooming and xy panning
             */
            panning: {
              /**
               * Enable or disable chart panning.
               *
               * @type      {boolean}
               * @default   {highcharts} false
               * @default   {highstock|highmaps} true
               */
              enabled: false,
              /**
               * Decides in what dimensions the user can pan the chart. Can be
               * one of `x`, `y`, or `xy`.
               *
               * @sample {highcharts} highcharts/chart/panning-type
               *         Zooming and xy panning
               *
               * @declare    Highcharts.OptionsChartPanningTypeValue
               * @type       {string}
               * @validvalue ["x", "y", "xy"]
               * @default    {highcharts|highstock} x
               * @product    highcharts highstock gantt
               */
              type: "x"
            },
            /**
             * Equivalent to [zoomType](#chart.zoomType), but for multitouch
             * gestures only. By default, the `pinchType` is the same as the
             * `zoomType` setting. However, pinching can be enabled separately in
             * some cases, for example in stock charts where a mouse drag pans the
             * chart, while pinching is enabled. When [tooltip.followTouchMove](
             * #tooltip.followTouchMove) is true, pinchType only applies to
             * two-finger touches.
             *
             * @type       {string}
             * @default    {highcharts} undefined
             * @default    {highstock} x
             * @since      3.0
             * @product    highcharts highstock gantt
             * @deprecated
             * @validvalue ["x", "y", "xy"]
             * @apioption  chart.pinchType
             */
            /**
             * Whether to apply styled mode. When in styled mode, no presentational
             * attributes or CSS are applied to the chart SVG. Instead, CSS rules
             * are required to style the chart. The default style sheet is
             * available from `https://code.highcharts.com/css/highcharts.css`.
             *
             * @type       {boolean}
             * @default    false
             * @since      7.0
             * @apioption  chart.styledMode
             */
            styledMode: false,
            /**
             * The corner radius of the outer chart border.
             *
             * @sample {highcharts} highcharts/chart/borderradius/
             *         20px radius
             * @sample {highstock} stock/chart/border/
             *         10px radius
             * @sample {highmaps} maps/chart/border/
             *         Border options
             *
             */
            borderRadius: 0,
            /**
             * In styled mode, this sets how many colors the class names
             * should rotate between. With ten colors, series (or points) are
             * given class names like `highcharts-color-0`, `highcharts-color-1`
             * [...] `highcharts-color-9`. The equivalent in non-styled mode
             * is to set colors using the [colors](#colors) setting.
             *
             * @since      5.0.0
             */
            colorCount: 10,
            /**
             * By default, (because of memory and performance reasons) the chart does
             * not copy the data but keeps it as a reference. In some cases, this might
             * result in mutating the original data source. In order to prevent that,
             * set that property to false. Please note that changing that might decrease
             * performance, especially with bigger sets of data.
             *
             * @type       {boolean}
             * @since 10.1.0
             */
            allowMutatingData: true,
            /**
             * Alias of `type`.
             *
             * @sample {highcharts} highcharts/chart/defaultseriestype/
             *         Bar
             *
             * @deprecated
             *
             * @product highcharts
             */
            defaultSeriesType: "line",
            /**
             * If true, the axes will scale to the remaining visible series once
             * one series is hidden. If false, hiding and showing a series will
             * not affect the axes or the other series. For stacks, once one series
             * within the stack is hidden, the rest of the stack will close in
             * around it even if the axis is not affected.
             *
             * @sample {highcharts} highcharts/chart/ignorehiddenseries-true/
             *         True by default
             * @sample {highcharts} highcharts/chart/ignorehiddenseries-false/
             *         False
             * @sample {highcharts} highcharts/chart/ignorehiddenseries-true-stacked/
             *         True with stack
             * @sample {highstock} stock/chart/ignorehiddenseries-true/
             *         True by default
             * @sample {highstock} stock/chart/ignorehiddenseries-false/
             *         False
             *
             * @since   1.2.0
             * @product highcharts highstock gantt
             */
            ignoreHiddenSeries: true,
            /**
             * Whether to invert the axes so that the x axis is vertical and y axis
             * is horizontal. When `true`, the x axis is [reversed](#xAxis.reversed)
             * by default.
             *
             * @productdesc {highcharts}
             * If a bar series is present in the chart, it will be inverted
             * automatically. Inverting the chart doesn't have an effect if there
             * are no cartesian series in the chart, or if the chart is
             * [polar](#chart.polar).
             *
             * @sample {highcharts} highcharts/chart/inverted/
             *         Inverted line
             * @sample {highstock} stock/navigator/inverted/
             *         Inverted stock chart
             *
             * @type      {boolean}
             * @default   false
             * @product   highcharts highstock gantt
             * @apioption chart.inverted
             */
            /**
             * The distance between the outer edge of the chart and the content,
             * like title or legend, or axis title and labels if present. The
             * numbers in the array designate top, right, bottom and left
             * respectively. Use the options spacingTop, spacingRight, spacingBottom
             * and spacingLeft options for shorthand setting of one option.
             *
             * @type    {Array<number>}
             * @see     [chart.margin](#chart.margin)
             * @default [10, 10, 15, 10]
             * @since   3.0.6
             */
            spacing: [10, 10, 15, 10],
            /**
             * The button that appears after a selection zoom, allowing the user
             * to reset zoom.
             *
             * @since      2.2
             * @deprecated 10.2.1
             */
            resetZoomButton: {
              /**
               * What frame the button placement should be related to. Can be
               * either `plotBox` or `spacingBox`.
               *
               * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
               *         Relative to the chart
               * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
               *         Relative to the chart
               *
               * @type      {Highcharts.ButtonRelativeToValue}
               * @default   plot
               * @apioption chart.resetZoomButton.relativeTo
               */
              /**
               * A collection of attributes for the button. The object takes SVG
               * attributes like `fill`, `stroke`, `stroke-width` or `r`, the
               * border radius. The theme also supports `style`, a collection of
               * CSS properties for the text. Equivalent attributes for the hover
               * state are given in `theme.states.hover`.
               *
               * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
               *         Theming the button
               * @sample {highstock} highcharts/chart/resetzoombutton-theme/
               *         Theming the button
               *
               * @type {Highcharts.SVGAttributes}
               */
              theme: {
                /**
                 * @internal
                 */
                zIndex: 6
              },
              /**
               * The position of the button.
               *
               * @sample {highcharts} highcharts/chart/resetzoombutton-position/
               *         Above the plot area
               * @sample {highstock} highcharts/chart/resetzoombutton-position/
               *         Above the plot area
               * @sample {highmaps} highcharts/chart/resetzoombutton-position/
               *         Above the plot area
               *
               * @type {Highcharts.AlignObject}
               */
              position: {
                /**
                 * The horizontal alignment of the button.
                 */
                align: "right",
                /**
                 * The horizontal offset of the button.
                 */
                x: -10,
                /**
                 * The vertical alignment of the button.
                 *
                 * @type      {Highcharts.VerticalAlignValue}
                 * @default   top
                 * @apioption chart.resetZoomButton.position.verticalAlign
                 */
                /**
                 * The vertical offset of the button.
                 */
                y: 10
              }
            },
            /**
             * The pixel width of the plot area border.
             *
             * @sample {highcharts} highcharts/chart/plotborderwidth/
             *         1px border
             * @sample {highstock} stock/chart/plotborder/
             *         2px border
             * @sample {highmaps} maps/chart/plotborder/
             *         Plot border options
             *
             * @type      {number}
             * @default   0
             * @apioption chart.plotBorderWidth
             */
            /**
             * Whether to apply a drop shadow to the plot area. Requires that
             * plotBackgroundColor be set. The shadow can be an object configuration
             * containing `color`, `offsetX`, `offsetY`, `opacity` and `width`.
             *
             * @sample {highcharts} highcharts/chart/plotshadow/
             *         Plot shadow
             * @sample {highstock} stock/chart/plotshadow/
             *         Plot shadow
             * @sample {highmaps} maps/chart/plotborder/
             *         Plot border options
             *
             * @type      {boolean|Highcharts.CSSObject}
             * @default   false
             * @apioption chart.plotShadow
             */
            /**
             * When true, cartesian charts like line, spline, area and column are
             * transformed into the polar coordinate system. This produces _polar
             * charts_, also known as _radar charts_.
             *
             * @sample {highcharts} highcharts/demo/polar/
             *         Polar chart
             * @sample {highcharts} highcharts/demo/polar-wind-rose/
             *         Wind rose, stacked polar column chart
             * @sample {highcharts} highcharts/demo/polar-spider/
             *         Spider web chart
             * @sample {highcharts} highcharts/parallel-coordinates/polar/
             *         Star plot, multivariate data in a polar chart
             *
             * @type      {boolean}
             * @default   false
             * @since     2.3.0
             * @product   highcharts
             * @requires  highcharts-more
             * @apioption chart.polar
             */
            /**
             * Whether to reflow the chart to fit the width of the container div
             * on resizing the window.
             *
             * @sample {highcharts} highcharts/chart/reflow-true/
             *         True by default
             * @sample {highcharts} highcharts/chart/reflow-false/
             *         False
             * @sample {highstock} stock/chart/reflow-true/
             *         True by default
             * @sample {highstock} stock/chart/reflow-false/
             *         False
             * @sample {highmaps} maps/chart/reflow-true/
             *         True by default
             * @sample {highmaps} maps/chart/reflow-false/
             *         False
             *
             * @type      {boolean}
             * @default   true
             * @since     2.1
             * @apioption chart.reflow
             */
            /**
             * The HTML element where the chart will be rendered. If it is a string,
             * the element by that id is used. The HTML element can also be passed
             * by direct reference, or as the first argument of the chart
             * constructor, in which case the option is not needed.
             *
             * @sample {highcharts} highcharts/chart/reflow-true/
             *         String
             * @sample {highcharts} highcharts/chart/renderto-object/
             *         Object reference
             * @sample {highstock} stock/chart/renderto-string/
             *         String
             * @sample {highstock} stock/chart/renderto-object/
             *         Object reference
             *
             * @type      {string|Highcharts.HTMLDOMElement}
             * @apioption chart.renderTo
             */
            /**
             * The background color of the marker square when selecting (zooming
             * in on) an area of the chart.
             *
             * @see In styled mode, the selection marker fill is set with the
             *      `.highcharts-selection-marker` class.
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @default   rgba(51,92,173,0.25)
             * @since     2.1.7
             * @apioption chart.selectionMarkerFill
             */
            /**
             * Whether to apply a drop shadow to the outer chart area. Requires
             * that backgroundColor be set. The shadow can be an object
             * configuration containing `color`, `offsetX`, `offsetY`, `opacity` and
             * `width`.
             *
             * @sample {highcharts} highcharts/chart/shadow/
             *         Shadow
             * @sample {highstock} stock/chart/shadow/
             *         Shadow
             * @sample {highmaps} maps/chart/border/
             *         Chart border and shadow
             *
             * @type      {boolean|Highcharts.CSSObject}
             * @default   false
             * @apioption chart.shadow
             */
            /**
             * Whether to show the axes initially. This only applies to empty charts
             * where series are added dynamically, as axes are automatically added
             * to cartesian series.
             *
             * @sample {highcharts} highcharts/chart/showaxes-false/
             *         False by default
             * @sample {highcharts} highcharts/chart/showaxes-true/
             *         True
             *
             * @type      {boolean}
             * @since     1.2.5
             * @product   highcharts gantt
             * @apioption chart.showAxes
             */
            /**
             * The space between the bottom edge of the chart and the content (plot
             * area, axis title and labels, title, subtitle or legend in top
             * position).
             *
             * @sample {highcharts} highcharts/chart/spacingbottom/
             *         Spacing bottom set to 100
             * @sample {highstock} stock/chart/spacingbottom/
             *         Spacing bottom set to 100
             * @sample {highmaps} maps/chart/spacing/
             *         Spacing 100 all around
             *
             * @type      {number}
             * @default   15
             * @since     2.1
             * @apioption chart.spacingBottom
             */
            /**
             * The space between the left edge of the chart and the content (plot
             * area, axis title and labels, title, subtitle or legend in top
             * position).
             *
             * @sample {highcharts} highcharts/chart/spacingleft/
             *         Spacing left set to 100
             * @sample {highstock} stock/chart/spacingleft/
             *         Spacing left set to 100
             * @sample {highmaps} maps/chart/spacing/
             *         Spacing 100 all around
             *
             * @type      {number}
             * @default   10
             * @since     2.1
             * @apioption chart.spacingLeft
             */
            /**
             * The space between the right edge of the chart and the content (plot
             * area, axis title and labels, title, subtitle or legend in top
             * position).
             *
             * @sample {highcharts} highcharts/chart/spacingright-100/
             *         Spacing set to 100
             * @sample {highcharts} highcharts/chart/spacingright-legend/
             *         Legend in right position with default spacing
             * @sample {highstock} stock/chart/spacingright/
             *         Spacing set to 100
             * @sample {highmaps} maps/chart/spacing/
             *         Spacing 100 all around
             *
             * @type      {number}
             * @default   10
             * @since     2.1
             * @apioption chart.spacingRight
             */
            /**
             * The space between the top edge of the chart and the content (plot
             * area, axis title and labels, title, subtitle or legend in top
             * position).
             *
             * @sample {highcharts} highcharts/chart/spacingtop-100/
             *         A top spacing of 100
             * @sample {highcharts} highcharts/chart/spacingtop-10/
             *         Floating chart title makes the plot area align to the default
             *         spacingTop of 10.
             * @sample {highstock} stock/chart/spacingtop/
             *         A top spacing of 100
             * @sample {highmaps} maps/chart/spacing/
             *         Spacing 100 all around
             *
             * @type      {number}
             * @default   10
             * @since     2.1
             * @apioption chart.spacingTop
             */
            /**
             * Additional CSS styles to apply inline to the container `div`. Note
             * that since the default font styles are applied in the renderer, it
             * is ignorant of the individual chart options and must be set globally.
             * Also note that changing the font size in the `chart.style` options only
             * applies to those elements that do not have a specific `fontSize` setting.
             *
             * @see    In styled mode, general chart styles can be set with the
             *         `.highcharts-root` class.
             * @sample {highcharts} highcharts/chart/style-serif-font/
             *         Using a serif type font
             * @sample {highcharts} highcharts/css/em/
             *         Styled mode with relative font sizes
             * @sample {highstock} stock/chart/style/
             *         Using a serif type font
             * @sample {highmaps} maps/chart/style-serif-font/
             *         Using a serif type font
             *
             * @type      {Highcharts.CSSObject}
             * @default   {"fontFamily": "\"Lucida Grande\", \"Lucida Sans Unicode\", Verdana, Arial, Helvetica, sans-serif","fontSize":"12px"}
             * @apioption chart.style
             */
            /**
             * The default series type for the chart. Can be any of the chart types
             * listed under [plotOptions](#plotOptions) and [series](#series) or can
             * be a series provided by an additional module.
             *
             * In TypeScript this option has no effect in sense of typing and
             * instead the `type` option must always be set in the series.
             *
             * @sample {highcharts} highcharts/chart/type-bar/
             *         Bar
             * @sample {highstock} stock/chart/type/
             *         Areaspline
             * @sample {highmaps} maps/chart/type-mapline/
             *         Mapline
             *
             * @type       {string}
             * @default    {highcharts} line
             * @default    {highstock} line
             * @default    {highmaps} map
             * @since      2.1.0
             * @apioption  chart.type
             */
            /**
             * Decides in what dimensions the user can zoom by dragging the mouse.
             * Can be one of `x`, `y` or `xy`.
             *
             * @see [panKey](#chart.panKey)
             *
             * @sample {highcharts} highcharts/chart/zoomtype-none/
             *         None by default
             * @sample {highcharts} highcharts/chart/zoomtype-x/
             *         X
             * @sample {highcharts} highcharts/chart/zoomtype-y/
             *         Y
             * @sample {highcharts} highcharts/chart/zoomtype-xy/
             *         Xy
             * @sample {highcharts} highcharts/chart/zoomtype-polar/
             *         Zoom on polar chart
             * @sample {highstock} stock/demo/basic-line/
             *         None by default
             * @sample {highstock} stock/chart/zoomtype-x/
             *         X
             * @sample {highstock} stock/chart/zoomtype-y/
             *         Y
             * @sample {highstock} stock/chart/zoomtype-xy/
             *         Xy
             * @sample {highmaps} maps/chart/zoomtype-xy/
             *         Map with selection zoom
             *
             * @type       {string}
             * @validvalue ["x", "y", "xy"]
             * @deprecated
             * @apioption  chart.zoomType
             */
            /**
             * Enables zooming by a single touch, in combination with
             * [chart.zoomType](#chart.zoomType). When enabled, two-finger pinch
             * will still work as set up by [chart.pinchType](#chart.pinchType).
             * However, `zoomBySingleTouch` will interfere with touch-dragging the
             * chart to read the tooltip. And especially when vertical zooming is
             * enabled, it will make it hard to scroll vertically on the page.
             * @since      9.0.0
             * @sample     highcharts/chart/zoombysingletouch
             *             Zoom by single touch enabled, with buttons to toggle
             * @product    highcharts highstock gantt
             * @deprecated
             */
            zoomBySingleTouch: false,
            /**
             * Chart zooming options.
             * @since 10.2.1
             */
            zooming: {
              /**
               * Equivalent to [type](#chart.zooming.type), but for multitouch
               * gestures only. By default, the `pinchType` is the same as the
               * `type` setting. However, pinching can be enabled separately in
               * some cases, for example in stock charts where a mouse drag pans the
               * chart, while pinching is enabled. When [tooltip.followTouchMove](
               * #tooltip.followTouchMove) is true, pinchType only applies to
               * two-finger touches.
               *
               * @type       {string}
               * @default    {highcharts} undefined
               * @default    {highstock} x
               * @product    highcharts highstock gantt
               * @validvalue ["x", "y", "xy"]
               * @apioption  chart.zooming.pinchType
               */
              /**
               * Decides in what dimensions the user can zoom by dragging the mouse.
               * Can be one of `x`, `y` or `xy`.
               *
               * @declare    Highcharts.OptionsChartZoomingTypeValue
               * @type       {string}
               * @default    {highcharts} undefined
               * @product    highcharts highstock gantt
               * @validvalue ["x", "y", "xy"]
               * @apioption  chart.zooming.type
               */
              /**
               * Set a key to hold when dragging to zoom the chart. This is useful to
               * avoid zooming while moving points. Should be set different than
               * [chart.panKey](#chart.panKey).
               *
               * @type       {string}
               * @default    {highcharts} undefined
               * @validvalue ["alt", "ctrl", "meta", "shift"]
               * @requires   modules/draggable-points
               * @apioption  chart.zooming.key
               */
              /**
               * Enables zooming by a single touch, in combination with
               * [chart.zooming.type](#chart.zooming.type). When enabled, two-finger
               * pinch will still work as set up by [chart.zooming.pinchType]
               * (#chart.zooming.pinchType). However, `singleTouch` will interfere
               * with touch-dragging the chart to read the tooltip. And especially
               * when vertical zooming is enabled, it will make it hard to scroll
               * vertically on the page.
               *
               * @sample  highcharts/chart/zoombysingletouch
               *          Zoom by single touch enabled, with buttons to toggle
               *
               * @product highcharts highstock gantt
               */
              singleTouch: false,
              /**
               * The button that appears after a selection zoom, allowing the user
               * to reset zoom.
               */
              resetButton: {
                /**
                 * What frame the button placement should be related to. Can be
                 * either `plotBox` or `spacingBox`.
                 *
                 * @sample {highcharts} highcharts/chart/resetzoombutton-relativeto/
                 *         Relative to the chart
                 * @sample {highstock} highcharts/chart/resetzoombutton-relativeto/
                 *         Relative to the chart
                 *
                 * @type      {Highcharts.ButtonRelativeToValue}
                 * @default   plot
                 * @apioption chart.zooming.resetButton.relativeTo
                 */
                /**
                 * A collection of attributes for the button. The object takes SVG
                 * attributes like `fill`, `stroke`, `stroke-width` or `r`, the
                 * border radius. The theme also supports `style`, a collection of
                 * CSS properties for the text. Equivalent attributes for the hover
                 * state are given in `theme.states.hover`.
                 *
                 * @sample {highcharts} highcharts/chart/resetzoombutton-theme/
                 *         Theming the button
                 * @sample {highstock} highcharts/chart/resetzoombutton-theme/
                 *         Theming the button
                 *
                 * @type  {Highcharts.SVGAttributes}
                 * @since 10.2.1
                 */
                theme: {
                  /** @internal */
                  zIndex: 6
                },
                /**
                 * The position of the button.
                 *
                 * @sample {highcharts} highcharts/chart/resetzoombutton-position/
                 *         Above the plot area
                 * @sample {highstock} highcharts/chart/resetzoombutton-position/
                 *         Above the plot area
                 * @sample {highmaps} highcharts/chart/resetzoombutton-position/
                 *         Above the plot area
                 *
                 * @type  {Highcharts.AlignObject}
                 * @since 10.2.1
                 */
                position: {
                  /**
                   * The horizontal alignment of the button.
                   */
                  align: "right",
                  /**
                   * The horizontal offset of the button.
                   */
                  x: -10,
                  /**
                   * The vertical alignment of the button.
                   *
                   * @type       {Highcharts.VerticalAlignValue}
                   * @default    top
                   * @apioption  chart.zooming.resetButton.position.verticalAlign
                   */
                  /**
                   * The vertical offset of the button.
                   */
                  y: 10
                }
              }
            },
            /**
             * An explicit width for the chart. By default (when `null`) the width
             * is calculated from the offset width of the containing element.
             *
             * @sample {highcharts} highcharts/chart/width/
             *         800px wide
             * @sample {highstock} stock/chart/width/
             *         800px wide
             * @sample {highmaps} maps/chart/size/
             *         Chart with explicit size
             *
             * @type {null|number|string}
             */
            width: null,
            /**
             * An explicit height for the chart. If a _number_, the height is
             * given in pixels. If given a _percentage string_ (for example
             * `'56%'`), the height is given as the percentage of the actual chart
             * width. This allows for preserving the aspect ratio across responsive
             * sizes.
             *
             * By default (when `null`) the height is calculated from the offset
             * height of the containing element, or 400 pixels if the containing
             * element's height is 0.
             *
             * @sample {highcharts} highcharts/chart/height/
             *         500px height
             * @sample {highstock} stock/chart/height/
             *         300px height
             * @sample {highmaps} maps/chart/size/
             *         Chart with explicit size
             * @sample highcharts/chart/height-percent/
             *         Highcharts with percentage height
             *
             * @type {null|number|string}
             */
            height: null,
            /**
             * The color of the outer chart border.
             *
             * @see In styled mode, the stroke is set with the
             *      `.highcharts-background` class.
             *
             * @sample {highcharts} highcharts/chart/bordercolor/
             *         Brown border
             * @sample {highstock} stock/chart/border/
             *         Brown border
             * @sample {highmaps} maps/chart/border/
             *         Border options
             *
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             */
            borderColor: "#335cad",
            /**
             * The pixel width of the outer chart border.
             *
             * @see In styled mode, the stroke is set with the
             *      `.highcharts-background` class.
             *
             * @sample {highcharts} highcharts/chart/borderwidth/
             *         5px border
             * @sample {highstock} stock/chart/border/
             *         2px border
             * @sample {highmaps} maps/chart/border/
             *         Border options
             *
             * @type      {number}
             * @default   0
             * @apioption chart.borderWidth
             */
            /**
             * The background color or gradient for the outer chart area.
             *
             * @see In styled mode, the background is set with the
             *      `.highcharts-background` class.
             *
             * @sample {highcharts} highcharts/chart/backgroundcolor-color/
             *         Color
             * @sample {highcharts} highcharts/chart/backgroundcolor-gradient/
             *         Gradient
             * @sample {highstock} stock/chart/backgroundcolor-color/
             *         Color
             * @sample {highstock} stock/chart/backgroundcolor-gradient/
             *         Gradient
             * @sample {highmaps} maps/chart/backgroundcolor-color/
             *         Color
             * @sample {highmaps} maps/chart/backgroundcolor-gradient/
             *         Gradient
             *
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             */
            backgroundColor: "#ffffff",
            /**
             * The background color or gradient for the plot area.
             *
             * @see In styled mode, the plot background is set with the
             *      `.highcharts-plot-background` class.
             *
             * @sample {highcharts} highcharts/chart/plotbackgroundcolor-color/
             *         Color
             * @sample {highcharts} highcharts/chart/plotbackgroundcolor-gradient/
             *         Gradient
             * @sample {highstock} stock/chart/plotbackgroundcolor-color/
             *         Color
             * @sample {highstock} stock/chart/plotbackgroundcolor-gradient/
             *         Gradient
             * @sample {highmaps} maps/chart/plotbackgroundcolor-color/
             *         Color
             * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
             *         Gradient
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @apioption chart.plotBackgroundColor
             */
            /**
             * The URL for an image to use as the plot background. To set an image
             * as the background for the entire chart, set a CSS background image
             * to the container element. Note that for the image to be applied to
             * exported charts, its URL needs to be accessible by the export server.
             *
             * @see In styled mode, a plot background image can be set with the
             *      `.highcharts-plot-background` class and a [custom pattern](
             *      https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns).
             *
             * @sample {highcharts} highcharts/chart/plotbackgroundimage/
             *         Skies
             * @sample {highstock} stock/chart/plotbackgroundimage/
             *         Skies
             *
             * @type      {string}
             * @apioption chart.plotBackgroundImage
             */
            /**
             * The color of the inner chart or plot area border.
             *
             * @see In styled mode, a plot border stroke can be set with the
             *      `.highcharts-plot-border` class.
             *
             * @sample {highcharts} highcharts/chart/plotbordercolor/
             *         Blue border
             * @sample {highstock} stock/chart/plotborder/
             *         Blue border
             * @sample {highmaps} maps/chart/plotborder/
             *         Plot border options
             *
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             */
            plotBorderColor: "#cccccc"
            /* Palette.neutralColor20 */
          };
          return ChartDefaults;
        });
        _registerModule(_modules, "Core/Color/Color.js", [_modules["Core/Globals.js"], _modules["Core/Utilities.js"]], function(H, U) {
          var isNumber = U.isNumber, merge = U.merge, pInt = U.pInt;
          var Color2 = (
            /** @class */
            function() {
              function Color3(input) {
                this.rgba = [NaN, NaN, NaN, NaN];
                this.input = input;
                var GlobalColor = H.Color;
                if (GlobalColor && GlobalColor !== Color3) {
                  return new GlobalColor(input);
                }
                if (!(this instanceof Color3)) {
                  return new Color3(input);
                }
                this.init(input);
              }
              Color3.parse = function(input) {
                return input ? new Color3(input) : Color3.None;
              };
              Color3.prototype.init = function(input) {
                var result, rgba2, i, parser;
                if (typeof input === "object" && typeof input.stops !== "undefined") {
                  this.stops = input.stops.map(function(stop) {
                    return new Color3(stop[1]);
                  });
                } else if (typeof input === "string") {
                  this.input = input = Color3.names[input.toLowerCase()] || input;
                  if (input.charAt(0) === "#") {
                    var len = input.length, col = parseInt(input.substr(1), 16);
                    if (len === 7) {
                      rgba2 = [
                        (col & 16711680) >> 16,
                        (col & 65280) >> 8,
                        col & 255,
                        1
                      ];
                    } else if (len === 4) {
                      rgba2 = [
                        (col & 3840) >> 4 | (col & 3840) >> 8,
                        (col & 240) >> 4 | col & 240,
                        (col & 15) << 4 | col & 15,
                        1
                      ];
                    }
                  }
                  if (!rgba2) {
                    i = Color3.parsers.length;
                    while (i-- && !rgba2) {
                      parser = Color3.parsers[i];
                      result = parser.regex.exec(input);
                      if (result) {
                        rgba2 = parser.parse(result);
                      }
                    }
                  }
                }
                if (rgba2) {
                  this.rgba = rgba2;
                }
              };
              Color3.prototype.get = function(format3) {
                var input = this.input, rgba2 = this.rgba;
                if (typeof input === "object" && typeof this.stops !== "undefined") {
                  var ret_1 = merge(input);
                  ret_1.stops = [].slice.call(ret_1.stops);
                  this.stops.forEach(function(stop, i) {
                    ret_1.stops[i] = [
                      ret_1.stops[i][0],
                      stop.get(format3)
                    ];
                  });
                  return ret_1;
                }
                if (rgba2 && isNumber(rgba2[0])) {
                  if (format3 === "rgb" || !format3 && rgba2[3] === 1) {
                    return "rgb(" + rgba2[0] + "," + rgba2[1] + "," + rgba2[2] + ")";
                  }
                  if (format3 === "a") {
                    return "".concat(rgba2[3]);
                  }
                  return "rgba(" + rgba2.join(",") + ")";
                }
                return input;
              };
              Color3.prototype.brighten = function(alpha) {
                var rgba2 = this.rgba;
                if (this.stops) {
                  this.stops.forEach(function(stop) {
                    stop.brighten(alpha);
                  });
                } else if (isNumber(alpha) && alpha !== 0) {
                  for (var i = 0; i < 3; i++) {
                    rgba2[i] += pInt(alpha * 255);
                    if (rgba2[i] < 0) {
                      rgba2[i] = 0;
                    }
                    if (rgba2[i] > 255) {
                      rgba2[i] = 255;
                    }
                  }
                }
                return this;
              };
              Color3.prototype.setOpacity = function(alpha) {
                this.rgba[3] = alpha;
                return this;
              };
              Color3.prototype.tweenTo = function(to, pos) {
                var fromRgba = this.rgba, toRgba = to.rgba;
                if (!isNumber(fromRgba[0]) || !isNumber(toRgba[0])) {
                  return to.input || "none";
                }
                var hasAlpha = toRgba[3] !== 1 || fromRgba[3] !== 1;
                return (hasAlpha ? "rgba(" : "rgb(") + Math.round(toRgba[0] + (fromRgba[0] - toRgba[0]) * (1 - pos)) + "," + Math.round(toRgba[1] + (fromRgba[1] - toRgba[1]) * (1 - pos)) + "," + Math.round(toRgba[2] + (fromRgba[2] - toRgba[2]) * (1 - pos)) + (hasAlpha ? "," + (toRgba[3] + (fromRgba[3] - toRgba[3]) * (1 - pos)) : "") + ")";
              };
              Color3.names = {
                white: "#ffffff",
                black: "#000000"
              };
              Color3.parsers = [{
                // RGBA color
                // eslint-disable-next-line max-len
                regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/,
                parse: function(result) {
                  return [
                    pInt(result[1]),
                    pInt(result[2]),
                    pInt(result[3]),
                    parseFloat(result[4], 10)
                  ];
                }
              }, {
                // RGB color
                regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/,
                parse: function(result) {
                  return [pInt(result[1]), pInt(result[2]), pInt(result[3]), 1];
                }
              }];
              Color3.None = new Color3("");
              return Color3;
            }()
          );
          "";
          return Color2;
        });
        _registerModule(_modules, "Core/Color/Palettes.js", [], function() {
          var SeriesPalettes = {
            /**
             * Colors for data series and points.
             */
            colors: [
              "#7cb5ec",
              "#434348",
              "#90ed7d",
              "#f7a35c",
              "#8085e9",
              "#f15c80",
              "#e4d354",
              "#2b908f",
              "#f45b5b",
              "#91e8e1"
            ]
          };
          return SeriesPalettes;
        });
        _registerModule(_modules, "Core/Time.js", [_modules["Core/Globals.js"], _modules["Core/Utilities.js"]], function(H, U) {
          var win = H.win;
          var defined = U.defined, error = U.error, extend2 = U.extend, isObject = U.isObject, merge = U.merge, objectEach = U.objectEach, pad2 = U.pad, pick = U.pick, splat = U.splat, timeUnits = U.timeUnits;
          var hasNewSafariBug = H.isSafari && win.Intl && win.Intl.DateTimeFormat.prototype.formatRange;
          var hasOldSafariBug = H.isSafari && win.Intl && !win.Intl.DateTimeFormat.prototype.formatRange;
          var Time = (
            /** @class */
            function() {
              function Time2(options) {
                this.options = {};
                this.useUTC = false;
                this.variableTimezone = false;
                this.Date = win.Date;
                this.getTimezoneOffset = this.timezoneOffsetFunction();
                this.update(options);
              }
              Time2.prototype.get = function(unit, date) {
                if (this.variableTimezone || this.timezoneOffset) {
                  var realMs = date.getTime();
                  var ms = realMs - this.getTimezoneOffset(date);
                  date.setTime(ms);
                  var ret = date["getUTC" + unit]();
                  date.setTime(realMs);
                  return ret;
                }
                if (this.useUTC) {
                  return date["getUTC" + unit]();
                }
                return date["get" + unit]();
              };
              Time2.prototype.set = function(unit, date, value) {
                if (this.variableTimezone || this.timezoneOffset) {
                  if (unit === "Milliseconds" || unit === "Seconds" || unit === "Minutes" && this.getTimezoneOffset(date) % 36e5 === 0) {
                    return date["setUTC" + unit](value);
                  }
                  var offset = this.getTimezoneOffset(date);
                  var ms = date.getTime() - offset;
                  date.setTime(ms);
                  date["setUTC" + unit](value);
                  var newOffset = this.getTimezoneOffset(date);
                  ms = date.getTime() + newOffset;
                  return date.setTime(ms);
                }
                if (this.useUTC || // leap calculation in UTC only
                hasNewSafariBug && unit === "FullYear") {
                  return date["setUTC" + unit](value);
                }
                return date["set" + unit](value);
              };
              Time2.prototype.update = function(options) {
                if (options === void 0) {
                  options = {};
                }
                var useUTC = pick(
                  options.useUTC,
                  true
                );
                this.options = options = merge(true, this.options, options);
                this.Date = options.Date || win.Date || Date;
                this.useUTC = useUTC;
                this.timezoneOffset = useUTC && options.timezoneOffset || void 0;
                this.getTimezoneOffset = this.timezoneOffsetFunction();
                this.variableTimezone = useUTC && !!(options.getTimezoneOffset || options.timezone);
              };
              Time2.prototype.makeTime = function(year, month, date, hours, minutes, seconds) {
                var d, offset, newOffset;
                if (this.useUTC) {
                  d = this.Date.UTC.apply(0, arguments);
                  offset = this.getTimezoneOffset(d);
                  d += offset;
                  newOffset = this.getTimezoneOffset(d);
                  if (offset !== newOffset) {
                    d += newOffset - offset;
                  } else if (offset - 36e5 === this.getTimezoneOffset(d - 36e5) && !hasOldSafariBug) {
                    d -= 36e5;
                  }
                } else {
                  d = new this.Date(year, month, pick(date, 1), pick(hours, 0), pick(minutes, 0), pick(seconds, 0)).getTime();
                }
                return d;
              };
              Time2.prototype.timezoneOffsetFunction = function() {
                var time = this, options = this.options, getTimezoneOffset = options.getTimezoneOffset, moment = options.moment || win.moment;
                if (!this.useUTC) {
                  return function(timestamp) {
                    return new Date(timestamp.toString()).getTimezoneOffset() * 6e4;
                  };
                }
                if (options.timezone) {
                  if (!moment) {
                    error(25);
                  } else {
                    return function(timestamp) {
                      return -moment.tz(timestamp, options.timezone).utcOffset() * 6e4;
                    };
                  }
                }
                if (this.useUTC && getTimezoneOffset) {
                  return function(timestamp) {
                    return getTimezoneOffset(timestamp.valueOf()) * 6e4;
                  };
                }
                return function() {
                  return (time.timezoneOffset || 0) * 6e4;
                };
              };
              Time2.prototype.dateFormat = function(format3, timestamp, capitalize) {
                if (!defined(timestamp) || isNaN(timestamp)) {
                  return H.defaultOptions.lang && H.defaultOptions.lang.invalidDate || "";
                }
                format3 = pick(format3, "%Y-%m-%d %H:%M:%S");
                var time = this, date = new this.Date(timestamp), hours = this.get("Hours", date), day = this.get("Day", date), dayOfMonth = this.get("Date", date), month = this.get("Month", date), fullYear = this.get("FullYear", date), lang = H.defaultOptions.lang, langWeekdays = lang && lang.weekdays, shortWeekdays = lang && lang.shortWeekdays, replacements = extend2({
                  // Day
                  // Short weekday, like 'Mon'
                  a: shortWeekdays ? shortWeekdays[day] : langWeekdays[day].substr(0, 3),
                  // Long weekday, like 'Monday'
                  A: langWeekdays[day],
                  // Two digit day of the month, 01 to 31
                  d: pad2(dayOfMonth),
                  // Day of the month, 1 through 31
                  e: pad2(dayOfMonth, 2, " "),
                  // Day of the week, 0 through 6
                  w: day,
                  // Week (none implemented)
                  // 'W': weekNumber(),
                  // Month
                  // Short month, like 'Jan'
                  b: lang.shortMonths[month],
                  // Long month, like 'January'
                  B: lang.months[month],
                  // Two digit month number, 01 through 12
                  m: pad2(month + 1),
                  // Month number, 1 through 12 (#8150)
                  o: month + 1,
                  // Year
                  // Two digits year, like 09 for 2009
                  y: fullYear.toString().substr(2, 2),
                  // Four digits year, like 2009
                  Y: fullYear,
                  // Time
                  // Two digits hours in 24h format, 00 through 23
                  H: pad2(hours),
                  // Hours in 24h format, 0 through 23
                  k: hours,
                  // Two digits hours in 12h format, 00 through 11
                  I: pad2(hours % 12 || 12),
                  // Hours in 12h format, 1 through 12
                  l: hours % 12 || 12,
                  // Two digits minutes, 00 through 59
                  M: pad2(this.get("Minutes", date)),
                  // Upper case AM or PM
                  p: hours < 12 ? "AM" : "PM",
                  // Lower case AM or PM
                  P: hours < 12 ? "am" : "pm",
                  // Two digits seconds, 00 through  59
                  S: pad2(date.getSeconds()),
                  // Milliseconds (naming from Ruby)
                  L: pad2(Math.floor(timestamp % 1e3), 3)
                }, H.dateFormats);
                objectEach(replacements, function(val, key) {
                  while (format3.indexOf("%" + key) !== -1) {
                    format3 = format3.replace("%" + key, typeof val === "function" ? val.call(time, timestamp) : val);
                  }
                });
                return capitalize ? format3.substr(0, 1).toUpperCase() + format3.substr(1) : format3;
              };
              Time2.prototype.resolveDTLFormat = function(f) {
                if (!isObject(f, true)) {
                  f = splat(f);
                  return {
                    main: f[0],
                    from: f[1],
                    to: f[2]
                  };
                }
                return f;
              };
              Time2.prototype.getTimeTicks = function(normalizedInterval, min2, max2, startOfWeek) {
                var time = this, Date2 = time.Date, tickPositions = [], higherRanks = {}, minDate = new Date2(min2), interval2 = normalizedInterval.unitRange, count = normalizedInterval.count || 1;
                var i, minYear, variableDayLength, minDay;
                startOfWeek = pick(startOfWeek, 1);
                if (defined(min2)) {
                  time.set("Milliseconds", minDate, interval2 >= timeUnits.second ? 0 : (
                    // #3935
                    count * Math.floor(time.get("Milliseconds", minDate) / count)
                  ));
                  if (interval2 >= timeUnits.second) {
                    time.set("Seconds", minDate, interval2 >= timeUnits.minute ? 0 : (
                      // #3935
                      count * Math.floor(time.get("Seconds", minDate) / count)
                    ));
                  }
                  if (interval2 >= timeUnits.minute) {
                    time.set("Minutes", minDate, interval2 >= timeUnits.hour ? 0 : count * Math.floor(time.get("Minutes", minDate) / count));
                  }
                  if (interval2 >= timeUnits.hour) {
                    time.set("Hours", minDate, interval2 >= timeUnits.day ? 0 : count * Math.floor(time.get("Hours", minDate) / count));
                  }
                  if (interval2 >= timeUnits.day) {
                    time.set("Date", minDate, interval2 >= timeUnits.month ? 1 : Math.max(1, count * Math.floor(time.get("Date", minDate) / count)));
                  }
                  if (interval2 >= timeUnits.month) {
                    time.set("Month", minDate, interval2 >= timeUnits.year ? 0 : count * Math.floor(time.get("Month", minDate) / count));
                    minYear = time.get("FullYear", minDate);
                  }
                  if (interval2 >= timeUnits.year) {
                    minYear -= minYear % count;
                    time.set("FullYear", minDate, minYear);
                  }
                  if (interval2 === timeUnits.week) {
                    minDay = time.get("Day", minDate);
                    time.set("Date", minDate, time.get("Date", minDate) - minDay + startOfWeek + // We don't want to skip days that are before
                    // startOfWeek (#7051)
                    (minDay < startOfWeek ? -7 : 0));
                  }
                  minYear = time.get("FullYear", minDate);
                  var minMonth = time.get("Month", minDate), minDateDate = time.get("Date", minDate), minHours = time.get("Hours", minDate);
                  min2 = minDate.getTime();
                  if ((time.variableTimezone || !time.useUTC) && defined(max2)) {
                    variableDayLength = // Long range, assume we're crossing over.
                    max2 - min2 > 4 * timeUnits.month || // Short range, check if min and max are in different time
                    // zones.
                    time.getTimezoneOffset(min2) !== time.getTimezoneOffset(max2);
                  }
                  var t = minDate.getTime();
                  i = 1;
                  while (t < max2) {
                    tickPositions.push(t);
                    if (interval2 === timeUnits.year) {
                      t = time.makeTime(minYear + i * count, 0);
                    } else if (interval2 === timeUnits.month) {
                      t = time.makeTime(minYear, minMonth + i * count);
                    } else if (variableDayLength && (interval2 === timeUnits.day || interval2 === timeUnits.week)) {
                      t = time.makeTime(minYear, minMonth, minDateDate + i * count * (interval2 === timeUnits.day ? 1 : 7));
                    } else if (variableDayLength && interval2 === timeUnits.hour && count > 1) {
                      t = time.makeTime(minYear, minMonth, minDateDate, minHours + i * count);
                    } else {
                      t += interval2 * count;
                    }
                    i++;
                  }
                  tickPositions.push(t);
                  if (interval2 <= timeUnits.hour && tickPositions.length < 1e4) {
                    tickPositions.forEach(function(t2) {
                      if (
                        // Speed optimization, no need to run dateFormat unless
                        // we're on a full or half hour
                        t2 % 18e5 === 0 && // Check for local or global midnight
                        time.dateFormat("%H%M%S%L", t2) === "000000000"
                      ) {
                        higherRanks[t2] = "day";
                      }
                    });
                  }
                }
                tickPositions.info = extend2(normalizedInterval, {
                  higherRanks,
                  totalRange: interval2 * count
                });
                return tickPositions;
              };
              Time2.prototype.getDateFormat = function(range, timestamp, startOfWeek, dateTimeLabelFormats) {
                var dateStr = this.dateFormat("%m-%d %H:%M:%S.%L", timestamp), blank = "01-01 00:00:00.000", strpos = {
                  millisecond: 15,
                  second: 12,
                  minute: 9,
                  hour: 6,
                  day: 3
                };
                var n = "millisecond", lastN = n;
                for (n in timeUnits) {
                  if (range === timeUnits.week && +this.dateFormat("%w", timestamp) === startOfWeek && dateStr.substr(6) === blank.substr(6)) {
                    n = "week";
                    break;
                  }
                  if (timeUnits[n] > range) {
                    n = lastN;
                    break;
                  }
                  if (strpos[n] && dateStr.substr(strpos[n]) !== blank.substr(strpos[n])) {
                    break;
                  }
                  if (n !== "week") {
                    lastN = n;
                  }
                }
                return this.resolveDTLFormat(dateTimeLabelFormats[n]).main;
              };
              return Time2;
            }()
          );
          "";
          return Time;
        });
        _registerModule(_modules, "Core/Defaults.js", [_modules["Core/Chart/ChartDefaults.js"], _modules["Core/Color/Color.js"], _modules["Core/Globals.js"], _modules["Core/Color/Palettes.js"], _modules["Core/Time.js"], _modules["Core/Utilities.js"]], function(ChartDefaults, Color2, H, Palettes, Time, U) {
          var color2 = Color2.parse;
          var isTouchDevice = H.isTouchDevice, svg = H.svg;
          var merge = U.merge;
          var defaultOptions = {
            /**
             * An array containing the default colors for the chart's series. When
             * all colors are used, new colors are pulled from the start again.
             *
             * Default colors can also be set on a series or series.type basis,
             * see [column.colors](#plotOptions.column.colors),
             * [pie.colors](#plotOptions.pie.colors).
             *
             * In styled mode, the colors option doesn't exist. Instead, colors
             * are defined in CSS and applied either through series or point class
             * names, or through the [chart.colorCount](#chart.colorCount) option.
             *
             *
             * ### Legacy
             *
             * In Highcharts 3.x, the default colors were:
             * ```js
             * colors: ['#2f7ed8', '#0d233a', '#8bbc21', '#910000', '#1aadce',
             *         '#492970', '#f28f43', '#77a1e5', '#c42525', '#a6c96a']
             * ```
             *
             * In Highcharts 2.x, the default colors were:
             * ```js
             * colors: ['#4572A7', '#AA4643', '#89A54E', '#80699B', '#3D96AE',
             *         '#DB843D', '#92A8CD', '#A47D7C', '#B5CA92']
             * ```
             *
             * @sample {highcharts} highcharts/chart/colors/
             *         Assign a global color theme
             *
             * @type    {Array<(Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject)>}
             * @default ["#7cb5ec", "#434348", "#90ed7d", "#f7a35c", "#8085e9",
             *          "#f15c80", "#e4d354", "#2b908f", "#f45b5b", "#91e8e1"]
             */
            colors: Palettes.colors,
            /**
             * Styled mode only. Configuration object for adding SVG definitions for
             * reusable elements. See [gradients, shadows and
             * patterns](https://www.highcharts.com/docs/chart-design-and-style/gradients-shadows-and-patterns)
             * for more information and code examples.
             *
             * @type      {*}
             * @since     5.0.0
             * @apioption defs
             */
            /**
             * @ignore-option
             */
            symbols: ["circle", "diamond", "square", "triangle", "triangle-down"],
            /**
                * The language object is global and it can't be set on each chart
                * initialization. Instead, use `Highcharts.setOptions` to set it before any
                * chart is initialized.
                *
                * ```js
                * Highcharts.setOptions({
                *     lang: {
                *         months: [
                *             'Janvier', 'Février', 'Mars', 'Avril',
                *             'Mai', 'Juin', 'Juillet', 'Août',
                *             'Septembre', 'Octobre', 'Novembre', 'Décembre'
                *         ],
                *         weekdays: [
                *             'Dimanche', 'Lundi', 'Mardi', 'Mercredi',
                *             'Jeudi', 'Vendredi', 'Samedi'
                *         ]
                *     }
                * });
            * ```
            */
            lang: {
              /**
               * The loading text that appears when the chart is set into the loading
               * state following a call to `chart.showLoading`.
               */
              loading: "Loading...",
              /**
               * An array containing the months names. Corresponds to the `%B` format
               * in `Highcharts.dateFormat()`.
               *
               * @type    {Array<string>}
               * @default ["January", "February", "March", "April", "May", "June",
               *          "July", "August", "September", "October", "November",
               *          "December"]
               */
              months: [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December"
              ],
              /**
               * An array containing the months names in abbreviated form. Corresponds
               * to the `%b` format in `Highcharts.dateFormat()`.
               *
               * @type    {Array<string>}
               * @default ["Jan", "Feb", "Mar", "Apr", "May", "Jun",
               *          "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
               */
              shortMonths: [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec"
              ],
              /**
               * An array containing the weekday names.
               *
               * @type    {Array<string>}
               * @default ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday",
               *          "Friday", "Saturday"]
               */
              weekdays: [
                "Sunday",
                "Monday",
                "Tuesday",
                "Wednesday",
                "Thursday",
                "Friday",
                "Saturday"
              ],
              /**
               * Short week days, starting Sunday. If not specified, Highcharts uses
               * the first three letters of the `lang.weekdays` option.
               *
               * @sample highcharts/lang/shortweekdays/
               *         Finnish two-letter abbreviations
               *
               * @type      {Array<string>}
               * @since     4.2.4
               * @apioption lang.shortWeekdays
               */
              /**
               * What to show in a date field for invalid dates. Defaults to an empty
               * string.
               *
               * @type      {string}
               * @since     4.1.8
               * @product   highcharts highstock
               * @apioption lang.invalidDate
               */
              /**
               * The title appearing on hovering the zoom in button. The text itself
               * defaults to "+" and can be changed in the button options.
               *
               * @type      {string}
               * @default   Zoom in
               * @product   highmaps
               * @apioption lang.zoomIn
               */
              /**
               * The title appearing on hovering the zoom out button. The text itself
               * defaults to "-" and can be changed in the button options.
               *
               * @type      {string}
               * @default   Zoom out
               * @product   highmaps
               * @apioption lang.zoomOut
               */
              /**
               * The default decimal point used in the `Highcharts.numberFormat`
               * method unless otherwise specified in the function arguments.
               *
               * @since 1.2.2
               */
              decimalPoint: ".",
              /**
               * [Metric prefixes](https://en.wikipedia.org/wiki/Metric_prefix) used
               * to shorten high numbers in axis labels. Replacing any of the
               * positions with `null` causes the full number to be written. Setting
               * `numericSymbols` to `null` disables shortening altogether.
               *
               * @sample {highcharts} highcharts/lang/numericsymbols/
               *         Replacing the symbols with text
               * @sample {highstock} highcharts/lang/numericsymbols/
               *         Replacing the symbols with text
               *
               * @type    {Array<string>}
               * @default ["k", "M", "G", "T", "P", "E"]
               * @since   2.3.0
               */
              numericSymbols: ["k", "M", "G", "T", "P", "E"],
              /**
               * The magnitude of [numericSymbols](#lang.numericSymbol) replacements.
               * Use 10000 for Japanese, Korean and various Chinese locales, which
               * use symbols for 10^4, 10^8 and 10^12.
               *
               * @sample highcharts/lang/numericsymbolmagnitude/
               *         10000 magnitude for Japanese
               *
               * @type      {number}
               * @default   1000
               * @since     5.0.3
               * @apioption lang.numericSymbolMagnitude
               */
              /**
               * The text for the label appearing when a chart is zoomed.
               *
               * @since 1.2.4
               */
              resetZoom: "Reset zoom",
              /**
               * The tooltip title for the label appearing when a chart is zoomed.
               *
               * @since 1.2.4
               */
              resetZoomTitle: "Reset zoom level 1:1",
              /**
               * The default thousands separator used in the `Highcharts.numberFormat`
               * method unless otherwise specified in the function arguments. Defaults
               * to a single space character, which is recommended in
               * [ISO 31-0](https://en.wikipedia.org/wiki/ISO_31-0#Numbers) and works
               * across Anglo-American and continental European languages.
               *
               * @default \u0020
               * @since   1.2.2
               */
              thousandsSep: " "
            },
            /**
             * Global options that don't apply to each chart. These options, like
             * the `lang` options, must be set using the `Highcharts.setOptions`
             * method.
             *
             * ```js
             * Highcharts.setOptions({
             *     global: {
             *         useUTC: false
             *     }
             * });
             * ```
             */
            /**
             * _Canvg rendering for Android 2.x is removed as of Highcharts 5.0\.
             * Use the [libURL](#exporting.libURL) option to configure exporting._
             *
             * The URL to the additional file to lazy load for Android 2.x devices.
             * These devices don't support SVG, so we download a helper file that
             * contains [canvg](https://github.com/canvg/canvg), its dependency
             * rbcolor, and our own CanVG Renderer class. To avoid hotlinking to
             * our site, you can install canvas-tools.js on your own server and
             * change this option accordingly.
             *
             * @deprecated
             *
             * @type      {string}
             * @default   https://code.highcharts.com/{version}/modules/canvas-tools.js
             * @product   highcharts highmaps
             * @apioption global.canvasToolsURL
             */
            /**
             * This option is deprecated since v6.0.5. Instead, use
             * [time.useUTC](#time.useUTC) that supports individual time settings
             * per chart.
             *
             * @deprecated
             *
             * @type      {boolean}
             * @apioption global.useUTC
             */
            /**
             * This option is deprecated since v6.0.5. Instead, use
             * [time.Date](#time.Date) that supports individual time settings
             * per chart.
             *
             * @deprecated
             *
             * @type      {Function}
             * @product   highcharts highstock
             * @apioption global.Date
             */
            /**
             * This option is deprecated since v6.0.5. Instead, use
             * [time.getTimezoneOffset](#time.getTimezoneOffset) that supports
             * individual time settings per chart.
             *
             * @deprecated
             *
             * @type      {Function}
             * @product   highcharts highstock
             * @apioption global.getTimezoneOffset
             */
            /**
             * This option is deprecated since v6.0.5. Instead, use
             * [time.timezone](#time.timezone) that supports individual time
             * settings per chart.
             *
             * @deprecated
             *
             * @type      {string}
             * @product   highcharts highstock
             * @apioption global.timezone
             */
            /**
             * This option is deprecated since v6.0.5. Instead, use
             * [time.timezoneOffset](#time.timezoneOffset) that supports individual
             * time settings per chart.
             *
             * @deprecated
             *
             * @type      {number}
             * @product   highcharts highstock
             * @apioption global.timezoneOffset
             */
            global: {},
            /**
             * Time options that can apply globally or to individual charts. These
             * settings affect how `datetime` axes are laid out, how tooltips are
             * formatted, how series
             * [pointIntervalUnit](#plotOptions.series.pointIntervalUnit) works and how
             * the Highcharts Stock range selector handles time.
             *
             * The common use case is that all charts in the same Highcharts object
             * share the same time settings, in which case the global settings are set
             * using `setOptions`.
             *
             * ```js
             * // Apply time settings globally
             * Highcharts.setOptions({
             *     time: {
             *         timezone: 'Europe/London'
             *     }
             * });
             * // Apply time settings by instance
             * let chart = Highcharts.chart('container', {
             *     time: {
             *         timezone: 'America/New_York'
             *     },
             *     series: [{
             *         data: [1, 4, 3, 5]
             *     }]
             * });
             *
             * // Use the Time object
             * console.log(
             *        'Current time in New York',
             *        chart.time.dateFormat('%Y-%m-%d %H:%M:%S', Date.now())
             * );
             * ```
             *
             * Since v6.0.5, the time options were moved from the `global` obect to the
             * `time` object, and time options can be set on each individual chart.
             *
             * @sample {highcharts|highstock}
             *         highcharts/time/timezone/
             *         Set the timezone globally
             * @sample {highcharts}
             *         highcharts/time/individual/
             *         Set the timezone per chart instance
             * @sample {highstock}
             *         stock/time/individual/
             *         Set the timezone per chart instance
             *
             * @since     6.0.5
             * @optionparent time
             */
            time: {
              /**
               * A custom `Date` class for advanced date handling. For example,
               * [JDate](https://github.com/tahajahangir/jdate) can be hooked in to
               * handle Jalali dates.
               *
               * @type      {*}
               * @since     4.0.4
               * @product   highcharts highstock gantt
               */
              Date: void 0,
              /**
               * A callback to return the time zone offset for a given datetime. It
               * takes the timestamp in terms of milliseconds since January 1 1970,
               * and returns the timezone offset in minutes. This provides a hook
               * for drawing time based charts in specific time zones using their
               * local DST crossover dates, with the help of external libraries.
               *
               * @see [global.timezoneOffset](#global.timezoneOffset)
               *
               * @sample {highcharts|highstock} highcharts/time/gettimezoneoffset/
               *         Use moment.js to draw Oslo time regardless of browser locale
               *
               * @type      {Highcharts.TimezoneOffsetCallbackFunction}
               * @since     4.1.0
               * @product   highcharts highstock gantt
               */
              getTimezoneOffset: void 0,
              /**
               * Requires [moment.js](https://momentjs.com/). If the timezone option
               * is specified, it creates a default
               * [getTimezoneOffset](#time.getTimezoneOffset) function that looks
               * up the specified timezone in moment.js. If moment.js is not included,
               * this throws a Highcharts error in the console, but does not crash the
               * chart.
               *
               * @see [getTimezoneOffset](#time.getTimezoneOffset)
               *
               * @sample {highcharts|highstock} highcharts/time/timezone/
               *         Europe/Oslo
               *
               * @type      {string}
               * @since     5.0.7
               * @product   highcharts highstock gantt
               */
              timezone: void 0,
              /**
               * The timezone offset in minutes. Positive values are west, negative
               * values are east of UTC, as in the ECMAScript
               * [getTimezoneOffset](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset)
               * method. Use this to display UTC based data in a predefined time zone.
               *
               * @see [time.getTimezoneOffset](#time.getTimezoneOffset)
               *
               * @sample {highcharts|highstock} highcharts/time/timezoneoffset/
               *         Timezone offset
               *
               * @since     3.0.8
               * @product   highcharts highstock gantt
               */
              timezoneOffset: 0,
              /**
               * Whether to use UTC time for axis scaling, tickmark placement and
               * time display in `Highcharts.dateFormat`. Advantages of using UTC
               * is that the time displays equally regardless of the user agent's
               * time zone settings. Local time can be used when the data is loaded
               * in real time or when correct Daylight Saving Time transitions are
               * required.
               *
               * @sample {highcharts} highcharts/time/useutc-true/
               *         True by default
               * @sample {highcharts} highcharts/time/useutc-false/
               *         False
               */
              useUTC: true
            },
            chart: ChartDefaults,
            /**
             * The chart's main title.
             *
             * @sample {highmaps} maps/title/title/
             *         Title options demonstrated
             */
            title: {
              /**
               * When the title is floating, the plot area will not move to make space
               * for it.
               *
               * @sample {highcharts} highcharts/chart/zoomtype-none/
               *         False by default
               * @sample {highcharts} highcharts/title/floating/
               *         True - title on top of the plot area
               * @sample {highstock} stock/chart/title-floating/
               *         True - title on top of the plot area
               *
               * @type      {boolean}
               * @default   false
               * @since     2.1
               * @apioption title.floating
               */
              /**
               * CSS styles for the title. Use this for font styling, but use `align`,
               * `x` and `y` for text alignment.
               *
               * In styled mode, the title style is given in the `.highcharts-title`
               * class.
               *
               * @sample {highcharts} highcharts/title/style/
               *         Custom color and weight
               * @sample {highstock} stock/chart/title-style/
               *         Custom color and weight
               * @sample highcharts/css/titles/
               *         Styled mode
               *
               * @type      {Highcharts.CSSObject}
               * @default   {highcharts|highmaps} { "color": "#333333", "fontSize": "18px" }
               * @default   {highstock} { "color": "#333333", "fontSize": "16px" }
               * @apioption title.style
               */
              /**
               * Whether to
               * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
               * to render the text.
               *
               * @type      {boolean}
               * @default   false
               * @apioption title.useHTML
               */
              /**
               * The vertical alignment of the title. Can be one of `"top"`,
               * `"middle"` and `"bottom"`. When a value is given, the title behaves
               * as if [floating](#title.floating) were `true`.
               *
               * @sample {highcharts} highcharts/title/verticalalign/
               *         Chart title in bottom right corner
               * @sample {highstock} stock/chart/title-verticalalign/
               *         Chart title in bottom right corner
               *
               * @type      {Highcharts.VerticalAlignValue}
               * @since     2.1
               * @apioption title.verticalAlign
               */
              /**
               * The x position of the title relative to the alignment within
               * `chart.spacingLeft` and `chart.spacingRight`.
               *
               * @sample {highcharts} highcharts/title/align/
               *         Aligned to the plot area (x = 70px = margin left - spacing
               *         left)
               * @sample {highstock} stock/chart/title-align/
               *         Aligned to the plot area (x = 50px = margin left - spacing
               *         left)
               *
               * @type      {number}
               * @default   0
               * @since     2.0
               * @apioption title.x
               */
              /**
               * The y position of the title relative to the alignment within
               * [chart.spacingTop](#chart.spacingTop) and [chart.spacingBottom](
               * #chart.spacingBottom). By default it depends on the font size.
               *
               * @sample {highcharts} highcharts/title/y/
               *         Title inside the plot area
               * @sample {highstock} stock/chart/title-verticalalign/
               *         Chart title in bottom right corner
               *
               * @type      {number}
               * @since     2.0
               * @apioption title.y
               */
              /**
               * The title of the chart. To disable the title, set the `text` to
               * `undefined`.
               *
               * @sample {highcharts} highcharts/title/text/
               *         Custom title
               * @sample {highstock} stock/chart/title-text/
               *         Custom title
               *
               * @default {highcharts|highmaps} Chart title
               * @default {highstock} undefined
               */
              text: "Chart title",
              /**
               * The horizontal alignment of the title. Can be one of "left", "center"
               * and "right".
               *
               * @sample {highcharts} highcharts/title/align/
               *         Aligned to the plot area (x = 70px = margin left - spacing
               *         left)
               * @sample {highstock} stock/chart/title-align/
               *         Aligned to the plot area (x = 50px = margin left - spacing
               *         left)
               *
               * @type  {Highcharts.AlignValue}
               * @since 2.0
               */
              align: "center",
              /**
               * The margin between the title and the plot area, or if a subtitle
               * is present, the margin between the subtitle and the plot area.
               *
               * @sample {highcharts} highcharts/title/margin-50/
               *         A chart title margin of 50
               * @sample {highcharts} highcharts/title/margin-subtitle/
               *         The same margin applied with a subtitle
               * @sample {highstock} stock/chart/title-margin/
               *         A chart title margin of 50
               *
               * @since 2.1
               */
              margin: 15,
              /**
               * Adjustment made to the title width, normally to reserve space for
               * the exporting burger menu.
               *
               * @sample highcharts/title/widthadjust/
               *         Wider menu, greater padding
               *
               * @since 4.2.5
               */
              widthAdjust: -44
            },
            /**
             * The chart's subtitle. This can be used both to display a subtitle below
             * the main title, and to display random text anywhere in the chart. The
             * subtitle can be updated after chart initialization through the
             * `Chart.setTitle` method.
             *
             * @sample {highmaps} maps/title/subtitle/
             *         Subtitle options demonstrated
             */
            subtitle: {
              /**
               * When the subtitle is floating, the plot area will not move to make
               * space for it.
               *
               * @sample {highcharts} highcharts/subtitle/floating/
               *         Floating title and subtitle
               * @sample {highstock} stock/chart/subtitle-footnote
               *         Footnote floating at bottom right of plot area
               *
               * @type      {boolean}
               * @default   false
               * @since     2.1
               * @apioption subtitle.floating
               */
              /**
               * CSS styles for the title.
               *
               * In styled mode, the subtitle style is given in the
               * `.highcharts-subtitle` class.
               *
               * @sample {highcharts} highcharts/subtitle/style/
               *         Custom color and weight
               * @sample {highcharts} highcharts/css/titles/
               *         Styled mode
               * @sample {highstock} stock/chart/subtitle-style
               *         Custom color and weight
               * @sample {highstock} highcharts/css/titles/
               *         Styled mode
               * @sample {highmaps} highcharts/css/titles/
               *         Styled mode
               *
               * @type      {Highcharts.CSSObject}
               * @default   {"color": "#666666"}
               * @apioption subtitle.style
               */
              /**
               * Whether to
               * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
               * to render the text.
               *
               * @type      {boolean}
               * @default   false
               * @apioption subtitle.useHTML
               */
              /**
               * The vertical alignment of the title. Can be one of `"top"`,
               * `"middle"` and `"bottom"`. When middle, the subtitle behaves as
               * floating.
               *
               * @sample {highcharts} highcharts/subtitle/verticalalign/
               *         Footnote at the bottom right of plot area
               * @sample {highstock} stock/chart/subtitle-footnote
               *         Footnote at the bottom right of plot area
               *
               * @type      {Highcharts.VerticalAlignValue}
               * @since     2.1
               * @apioption subtitle.verticalAlign
               */
              /**
               * The x position of the subtitle relative to the alignment within
               * `chart.spacingLeft` and `chart.spacingRight`.
               *
               * @sample {highcharts} highcharts/subtitle/align/
               *         Footnote at right of plot area
               * @sample {highstock} stock/chart/subtitle-footnote
               *         Footnote at the bottom right of plot area
               *
               * @type      {number}
               * @default   0
               * @since     2.0
               * @apioption subtitle.x
               */
              /**
               * The y position of the subtitle relative to the alignment within
               * `chart.spacingTop` and `chart.spacingBottom`. By default the subtitle
               * is laid out below the title unless the title is floating.
               *
               * @sample {highcharts} highcharts/subtitle/verticalalign/
               *         Footnote at the bottom right of plot area
               * @sample {highstock} stock/chart/subtitle-footnote
               *         Footnote at the bottom right of plot area
               *
               * @type      {number}
               * @since     2.0
               * @apioption subtitle.y
               */
              /**
               * The subtitle of the chart.
               *
               * @sample {highcharts|highstock} highcharts/subtitle/text/
               *         Custom subtitle
               * @sample {highcharts|highstock} highcharts/subtitle/text-formatted/
               *         Formatted and linked text.
               */
              text: "",
              /**
               * The horizontal alignment of the subtitle. Can be one of "left",
               *  "center" and "right".
               *
               * @sample {highcharts} highcharts/subtitle/align/
               *         Footnote at right of plot area
               * @sample {highstock} stock/chart/subtitle-footnote
               *         Footnote at bottom right of plot area
               *
               * @type  {Highcharts.AlignValue}
               * @since 2.0
               */
              align: "center",
              /**
               * Adjustment made to the subtitle width, normally to reserve space
               * for the exporting burger menu.
               *
               * @see [title.widthAdjust](#title.widthAdjust)
               *
               * @sample highcharts/title/widthadjust/
               *         Wider menu, greater padding
               *
               * @since 4.2.5
               */
              widthAdjust: -44
            },
            /**
             * The chart's caption, which will render below the chart and will be part
             * of exported charts. The caption can be updated after chart initialization
             * through the `Chart.update` or `Chart.caption.update` methods.
             *
             * @sample highcharts/caption/text/
             *         A chart with a caption
             * @since  7.2.0
             */
            caption: {
              /**
               * When the caption is floating, the plot area will not move to make
               * space for it.
               *
               * @type      {boolean}
               * @default   false
               * @apioption caption.floating
               */
              /**
               * The margin between the caption and the plot area.
               */
              margin: 15,
              /**
               * CSS styles for the caption.
               *
               * In styled mode, the caption style is given in the
               * `.highcharts-caption` class.
               *
               * @sample {highcharts} highcharts/css/titles/
               *         Styled mode
               *
               * @type      {Highcharts.CSSObject}
               * @default   {"color": "#666666"}
               * @apioption caption.style
               */
              /**
               * Whether to
               * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
               * to render the text.
               *
               * @type      {boolean}
               * @default   false
               * @apioption caption.useHTML
               */
              /**
               * The x position of the caption relative to the alignment within
               * `chart.spacingLeft` and `chart.spacingRight`.
               *
               * @type      {number}
               * @default   0
               * @apioption caption.x
               */
              /**
               * The y position of the caption relative to the alignment within
               * `chart.spacingTop` and `chart.spacingBottom`.
               *
               * @type      {number}
               * @apioption caption.y
               */
              /**
               * The caption text of the chart.
               *
               * @sample {highcharts} highcharts/caption/text/
               *         Custom caption
               */
              text: "",
              /**
               * The horizontal alignment of the caption. Can be one of "left",
               *  "center" and "right".
               *
               * @type  {Highcharts.AlignValue}
               */
              align: "left",
              /**
               * The vertical alignment of the caption. Can be one of `"top"`,
               * `"middle"` and `"bottom"`. When middle, the caption behaves as
               * floating.
               *
               * @type      {Highcharts.VerticalAlignValue}
               */
              verticalAlign: "bottom"
            },
            /**
             * The plotOptions is a wrapper object for config objects for each series
             * type. The config objects for each series can also be overridden for
             * each series item as given in the series array.
             *
             * Configuration options for the series are given in three levels. Options
             * for all series in a chart are given in the [plotOptions.series](
             * #plotOptions.series) object. Then options for all series of a specific
             * type are given in the plotOptions of that type, for example
             * `plotOptions.line`. Next, options for one single series are given in
             * [the series array](#series).
             */
            plotOptions: {},
            /**
             * HTML labels that can be positioned anywhere in the chart area.
             *
             * This option is deprecated since v7.1.2. Instead, use
             * [annotations](#annotations) that support labels.
             *
             * @deprecated
             * @product   highcharts highstock
             */
            labels: {
              /**
               * An HTML label that can be positioned anywhere in the chart area.
               *
               * @deprecated
               * @type      {Array<*>}
               * @apioption labels.items
               */
              /**
               * Inner HTML or text for the label.
               *
               * @deprecated
               * @type      {string}
               * @apioption labels.items.html
               */
              /**
               * CSS styles for each label. To position the label, use left and top
               * like this:
               * ```js
               * style: {
               *     left: '100px',
               *     top: '100px'
               * }
               * ```
               *
               * @deprecated
               * @type      {Highcharts.CSSObject}
               * @apioption labels.items.style
               */
              /**
               * Shared CSS styles for all labels.
               *
               * @deprecated
               * @type    {Highcharts.CSSObject}
               * @default {"color": "#333333", "position": "absolute"}
               */
              style: {
                /**
                 * @ignore-option
                 */
                position: "absolute",
                /**
                 * @ignore-option
                 */
                color: "#333333"
                /* Palette.neutralColor80 */
              }
            },
            /**
             * The legend is a box containing a symbol and name for each series
             * item or point item in the chart. Each series (or points in case
             * of pie charts) is represented by a symbol and its name in the legend.
             *
             * It is possible to override the symbol creator function and create
             * [custom legend symbols](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/studies/legend-custom-symbol/).
             *
             * @productdesc {highmaps}
             * A Highmaps legend by default contains one legend item per series, but if
             * a `colorAxis` is defined, the axis will be displayed in the legend.
             * Either as a gradient, or as multiple legend items for `dataClasses`.
             */
            legend: {
              /**
               * The background color of the legend.
               *
               * @see In styled mode, the legend background fill can be applied with
               *      the `.highcharts-legend-box` class.
               *
               * @sample {highcharts} highcharts/legend/backgroundcolor/
               *         Yellowish background
               * @sample {highstock} stock/legend/align/
               *         Various legend options
               * @sample {highmaps} maps/legend/border-background/
               *         Border and background options
               *
               * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               * @apioption legend.backgroundColor
               */
              /**
               * The width of the drawn border around the legend.
               *
               * @see In styled mode, the legend border stroke width can be applied
               *      with the `.highcharts-legend-box` class.
               *
               * @sample {highcharts} highcharts/legend/borderwidth/
               *         2px border width
               * @sample {highstock} stock/legend/align/
               *         Various legend options
               * @sample {highmaps} maps/legend/border-background/
               *         Border and background options
               *
               * @type      {number}
               * @default   0
               * @apioption legend.borderWidth
               */
              /**
               * Enable or disable the legend. There is also a series-specific option,
               * [showInLegend](#plotOptions.series.showInLegend), that can hide the
               * series from the legend. In some series types this is `false` by
               * default, so it must set to `true` in order to show the legend for the
               * series.
               *
               * @sample {highcharts} highcharts/legend/enabled-false/ Legend disabled
               * @sample {highstock} stock/legend/align/ Various legend options
               * @sample {highmaps} maps/legend/enabled-false/ Legend disabled
               *
               * @default {highstock} false
               * @default {highmaps} true
               * @default {gantt} false
               */
              enabled: true,
              /**
               * The horizontal alignment of the legend box within the chart area.
               * Valid values are `left`, `center` and `right`.
               *
               * In the case that the legend is aligned in a corner position, the
               * `layout` option will determine whether to place it above/below
               * or on the side of the plot area.
               *
               * @sample {highcharts} highcharts/legend/align/
               *         Legend at the right of the chart
               * @sample {highstock} stock/legend/align/
               *         Various legend options
               * @sample {highmaps} maps/legend/alignment/
               *         Legend alignment
               *
               * @type  {Highcharts.AlignValue}
               * @since 2.0
               */
              align: "center",
              /**
               * If the [layout](legend.layout) is `horizontal` and the legend items
               * span over two lines or more, whether to align the items into vertical
               * columns. Setting this to `false` makes room for more items, but will
               * look more messy.
               *
               * @since 6.1.0
               */
              alignColumns: true,
              /**
               * A CSS class name to apply to the legend group.
               */
              className: "highcharts-no-tooltip",
              /**
               * When the legend is floating, the plot area ignores it and is allowed
               * to be placed below it.
               *
               * @sample {highcharts} highcharts/legend/floating-false/
               *         False by default
               * @sample {highcharts} highcharts/legend/floating-true/
               *         True
               * @sample {highmaps} maps/legend/alignment/
               *         Floating legend
               *
               * @type      {boolean}
               * @default   false
               * @since     2.1
               * @apioption legend.floating
               */
              /**
               * The layout of the legend items. Can be one of `horizontal` or
               * `vertical` or `proximate`. When `proximate`, the legend items will be
               * placed as close as possible to the graphs they're representing,
               * except in inverted charts or when the legend position doesn't allow
               * it.
               *
               * @sample {highcharts} highcharts/legend/layout-horizontal/
               *         Horizontal by default
               * @sample {highcharts} highcharts/legend/layout-vertical/
               *         Vertical
               * @sample highcharts/legend/layout-proximate
               *         Labels proximate to the data
               * @sample {highstock} stock/legend/layout-horizontal/
               *         Horizontal by default
               * @sample {highmaps} maps/legend/padding-itemmargin/
               *         Vertical with data classes
               * @sample {highmaps} maps/legend/layout-vertical/
               *         Vertical with color axis gradient
               *
               * @validvalue ["horizontal", "vertical", "proximate"]
               */
              layout: "horizontal",
              /**
               * In a legend with horizontal layout, the itemDistance defines the
               * pixel distance between each item.
               *
               * @sample {highcharts} highcharts/legend/layout-horizontal/
               *         50px item distance
               * @sample {highstock} highcharts/legend/layout-horizontal/
               *         50px item distance
               *
               * @type      {number}
               * @default   {highcharts} 20
               * @default   {highstock} 20
               * @default   {highmaps} 8
               * @since     3.0.3
               * @apioption legend.itemDistance
               */
              /**
               * The pixel bottom margin for each legend item.
               *
               * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
               *         Padding and item margins demonstrated
               * @sample {highmaps} maps/legend/padding-itemmargin/
               *         Padding and item margins demonstrated
               *
               * @type      {number}
               * @default   0
               * @since     2.2.0
               * @apioption legend.itemMarginBottom
               */
              /**
               * The pixel top margin for each legend item.
               *
               * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
               *         Padding and item margins demonstrated
               * @sample {highmaps} maps/legend/padding-itemmargin/
               *         Padding and item margins demonstrated
               *
               * @type      {number}
               * @default   0
               * @since     2.2.0
               * @apioption legend.itemMarginTop
               */
              /**
               * The width for each legend item. By default the items are laid out
               * successively. In a [horizontal layout](legend.layout), if the items
               * are laid out across two rows or more, they will be vertically aligned
               * depending on the [legend.alignColumns](legend.alignColumns) option.
               *
               * @sample {highcharts} highcharts/legend/itemwidth-default/
               *         Undefined by default
               * @sample {highcharts} highcharts/legend/itemwidth-80/
               *         80 for aligned legend items
               *
               * @type      {number}
               * @since     2.0
               * @apioption legend.itemWidth
               */
              /**
               * A [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
               * for each legend label. Available variables relates to properties on
               * the series, or the point in case of pies.
               *
               * @type      {string}
               * @default   {name}
               * @since     1.3
               * @apioption legend.labelFormat
               */
              /* eslint-disable valid-jsdoc */
              /**
               * Callback function to format each of the series' labels. The `this`
               * keyword refers to the series object, or the point object in case of
               * pie charts. By default the series or point name is printed.
               *
               * @productdesc {highmaps}
               * In Highmaps the context can also be a data class in case of a
               * `colorAxis`.
               *
               * @sample {highcharts} highcharts/legend/labelformatter/
               *         Add text
               * @sample {highmaps} maps/legend/labelformatter/
               *         Data classes with label formatter
               *
               * @type {Highcharts.FormatterCallbackFunction<Point|Series>}
               */
              labelFormatter: function() {
                return this.name;
              },
              /**
               * Line height for the legend items. Deprecated as of 2.1\. Instead,
               * the line height for each item can be set using
               * `itemStyle.lineHeight`, and the padding between items using
               * `itemMarginTop` and `itemMarginBottom`.
               *
               * @sample {highcharts} highcharts/legend/lineheight/
               *         Setting padding
               *
               * @deprecated
               *
               * @type      {number}
               * @default   16
               * @since     2.0
               * @product   highcharts gantt
               * @apioption legend.lineHeight
               */
              /**
               * If the plot area sized is calculated automatically and the legend is
               * not floating, the legend margin is the space between the legend and
               * the axis labels or plot area.
               *
               * @sample {highcharts} highcharts/legend/margin-default/
               *         12 pixels by default
               * @sample {highcharts} highcharts/legend/margin-30/
               *         30 pixels
               *
               * @type      {number}
               * @default   12
               * @since     2.1
               * @apioption legend.margin
               */
              /**
               * Maximum pixel height for the legend. When the maximum height is
               * extended, navigation will show.
               *
               * @type      {number}
               * @since     2.3.0
               * @apioption legend.maxHeight
               */
              /**
               * The color of the drawn border around the legend.
               *
               * @see In styled mode, the legend border stroke can be applied with the
               *      `.highcharts-legend-box` class.
               *
               * @sample {highcharts} highcharts/legend/bordercolor/
               *         Brown border
               * @sample {highstock} stock/legend/align/
               *         Various legend options
               * @sample {highmaps} maps/legend/border-background/
               *         Border and background options
               *
               * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               */
              borderColor: "#999999",
              /**
               * The border corner radius of the legend.
               *
               * @sample {highcharts} highcharts/legend/borderradius-default/
               *         Square by default
               * @sample {highcharts} highcharts/legend/borderradius-round/
               *         5px rounded
               * @sample {highmaps} maps/legend/border-background/
               *         Border and background options
               */
              borderRadius: 0,
              /**
               * Options for the paging or navigation appearing when the legend is
               * overflown. Navigation works well on screen, but not in static
               * exported images. One way of working around that is to
               * [increase the chart height in
               * export](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/legend/navigation-enabled-false/).
               */
              navigation: {
                /**
                 * How to animate the pages when navigating up or down. A value of
                 * `true` applies the default navigation given in the
                 * `chart.animation` option. Additional options can be given as an
                 * object containing values for easing and duration.
                 *
                 * @sample {highcharts} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 * @sample {highstock} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 *
                 * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 * @default   true
                 * @since     2.2.4
                 * @apioption legend.navigation.animation
                 */
                /**
                 * The pixel size of the up and down arrows in the legend paging
                 * navigation.
                 *
                 * @sample {highcharts} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 * @sample {highstock} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 *
                 * @type      {number}
                 * @default   12
                 * @since     2.2.4
                 * @apioption legend.navigation.arrowSize
                 */
                /**
                 * Whether to enable the legend navigation. In most cases, disabling
                 * the navigation results in an unwanted overflow.
                 *
                 * See also the
                 * [adapt chart to legend](https://github.com/highcharts/adapt-chart-to-legend)
                 * plugin for a solution to extend the chart height to make room for
                 * the legend, optionally in exported charts only.
                 *
                 * @type      {boolean}
                 * @default   true
                 * @since     4.2.4
                 * @apioption legend.navigation.enabled
                 */
                /**
                 * Text styles for the legend page navigation.
                 *
                 * @see In styled mode, the navigation items are styled with the
                 *      `.highcharts-legend-navigation` class.
                 *
                 * @sample {highcharts} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 * @sample {highstock} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 *
                 * @type      {Highcharts.CSSObject}
                 * @since     2.2.4
                 * @apioption legend.navigation.style
                 */
                /**
                 * The color for the active up or down arrow in the legend page
                 * navigation.
                 *
                 * @see In styled mode, the active arrow be styled with the
                 *      `.highcharts-legend-nav-active` class.
                 *
                 * @sample  {highcharts} highcharts/legend/navigation/
                 *          Legend page navigation demonstrated
                 * @sample  {highstock} highcharts/legend/navigation/
                 *          Legend page navigation demonstrated
                 *
                 * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @since 2.2.4
                 */
                activeColor: "#003399",
                /**
                 * The color of the inactive up or down arrow in the legend page
                 * navigation. .
                 *
                 * @see In styled mode, the inactive arrow be styled with the
                 *      `.highcharts-legend-nav-inactive` class.
                 *
                 * @sample {highcharts} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 * @sample {highstock} highcharts/legend/navigation/
                 *         Legend page navigation demonstrated
                 *
                 * @type  {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @since 2.2.4
                 */
                inactiveColor: "#cccccc"
                /* Palette.neutralColor20 */
              },
              /**
               * The inner padding of the legend box.
               *
               * @sample {highcharts|highstock} highcharts/legend/padding-itemmargin/
               *         Padding and item margins demonstrated
               * @sample {highmaps} maps/legend/padding-itemmargin/
               *         Padding and item margins demonstrated
               *
               * @type      {number}
               * @default   8
               * @since     2.2.0
               * @apioption legend.padding
               */
              /**
               * Whether to reverse the order of the legend items compared to the
               * order of the series or points as defined in the configuration object.
               *
               * @see [yAxis.reversedStacks](#yAxis.reversedStacks),
               *      [series.legendIndex](#series.legendIndex)
               *
               * @sample {highcharts} highcharts/legend/reversed/
               *         Stacked bar with reversed legend
               *
               * @type      {boolean}
               * @default   false
               * @since     1.2.5
               * @apioption legend.reversed
               */
              /**
               * Whether to show the symbol on the right side of the text rather than
               * the left side. This is common in Arabic and Hebrew.
               *
               * @sample {highcharts} highcharts/legend/rtl/
               *         Symbol to the right
               *
               * @type      {boolean}
               * @default   false
               * @since     2.2
               * @apioption legend.rtl
               */
              /**
               * CSS styles for the legend area. In the 1.x versions the position
               * of the legend area was determined by CSS. In 2.x, the position is
               * determined by properties like `align`, `verticalAlign`, `x` and `y`,
               * but the styles are still parsed for backwards compatibility.
               *
               * @deprecated
               *
               * @type      {Highcharts.CSSObject}
               * @product   highcharts highstock
               * @apioption legend.style
               */
              /**
               * CSS styles for each legend item. Only a subset of CSS is supported,
               * notably those options related to text. The default `textOverflow`
               * property makes long texts truncate. Set it to `undefined` to wrap
               * text instead. A `width` property can be added to control the text
               * width.
               *
               * @see In styled mode, the legend items can be styled with the
               *      `.highcharts-legend-item` class.
               *
               * @sample {highcharts} highcharts/legend/itemstyle/
               *         Bold black text
               * @sample {highmaps} maps/legend/itemstyle/
               *         Item text styles
               *
               * @type    {Highcharts.CSSObject}
               * @default {"color": "#333333", "cursor": "pointer", "fontSize": "12px", "fontWeight": "bold", "textOverflow": "ellipsis"}
               */
              itemStyle: {
                /**
                 * @ignore
                 */
                color: "#333333",
                /**
                 * @ignore
                 */
                cursor: "pointer",
                /**
                 * @ignore
                 */
                fontSize: "12px",
                /**
                 * @ignore
                 */
                fontWeight: "bold",
                /**
                 * @ignore
                 */
                textOverflow: "ellipsis"
              },
              /**
               * CSS styles for each legend item in hover mode. Only a subset of
               * CSS is supported, notably those options related to text. Properties
               * are inherited from `style` unless overridden here.
               *
               * @see In styled mode, the hovered legend items can be styled with
               *      the `.highcharts-legend-item:hover` pesudo-class.
               *
               * @sample {highcharts} highcharts/legend/itemhoverstyle/
               *         Red on hover
               * @sample {highmaps} maps/legend/itemstyle/
               *         Item text styles
               *
               * @type    {Highcharts.CSSObject}
               * @default {"color": "#000000"}
               */
              itemHoverStyle: {
                /**
                 * @ignore
                 */
                color: "#000000"
                /* Palette.neutralColor100 */
              },
              /**
               * CSS styles for each legend item when the corresponding series or
               * point is hidden. Only a subset of CSS is supported, notably those
               * options related to text. Properties are inherited from `style`
               * unless overridden here.
               *
               * @see In styled mode, the hidden legend items can be styled with
               *      the `.highcharts-legend-item-hidden` class.
               *
               * @sample {highcharts} highcharts/legend/itemhiddenstyle/
               *         Darker gray color
               *
               * @type    {Highcharts.CSSObject}
               * @default {"color": "#cccccc"}
               */
              itemHiddenStyle: {
                /**
                 * @ignore
                 */
                color: "#cccccc"
                /* Palette.neutralColor20 */
              },
              /**
               * Whether to apply a drop shadow to the legend. A `backgroundColor`
               * also needs to be applied for this to take effect. The shadow can be
               * an object configuration containing `color`, `offsetX`, `offsetY`,
               * `opacity` and `width`.
               *
               * @sample {highcharts} highcharts/legend/shadow/
               *         White background and drop shadow
               * @sample {highstock} stock/legend/align/
               *         Various legend options
               * @sample {highmaps} maps/legend/border-background/
               *         Border and background options
               *
               * @type {boolean|Highcharts.CSSObject}
               */
              shadow: false,
              /**
               * Default styling for the checkbox next to a legend item when
               * `showCheckbox` is true.
               *
               * @type {Highcharts.CSSObject}
               * @default {"width": "13px", "height": "13px", "position":"absolute"}
               */
              itemCheckboxStyle: {
                /**
                 * @ignore
                 */
                position: "absolute",
                /**
                 * @ignore
                 */
                width: "13px",
                /**
                 * @ignore
                 */
                height: "13px"
              },
              // itemWidth: undefined,
              /**
               * When this is true, the legend symbol width will be the same as
               * the symbol height, which in turn defaults to the font size of the
               * legend items.
               *
               * @since 5.0.0
               */
              squareSymbol: true,
              /**
               * The pixel height of the symbol for series types that use a rectangle
               * in the legend. Defaults to the font size of legend items.
               *
               * @productdesc {highmaps}
               * In Highmaps, when the symbol is the gradient of a vertical color
               * axis, the height defaults to 200.
               *
               * @sample {highmaps} maps/legend/layout-vertical-sized/
               *         Sized vertical gradient
               * @sample {highmaps} maps/legend/padding-itemmargin/
               *         No distance between data classes
               *
               * @type      {number}
               * @since     3.0.8
               * @apioption legend.symbolHeight
               */
              /**
               * The border radius of the symbol for series types that use a rectangle
               * in the legend. Defaults to half the `symbolHeight`.
               *
               * @sample {highcharts} highcharts/legend/symbolradius/
               *         Round symbols
               * @sample {highstock} highcharts/legend/symbolradius/
               *         Round symbols
               * @sample {highmaps} highcharts/legend/symbolradius/
               *         Round symbols
               *
               * @type      {number}
               * @since     3.0.8
               * @apioption legend.symbolRadius
               */
              /**
               * The pixel width of the legend item symbol. When the `squareSymbol`
               * option is set, this defaults to the `symbolHeight`, otherwise 16.
               *
               * @productdesc {highmaps}
               * In Highmaps, when the symbol is the gradient of a horizontal color
               * axis, the width defaults to 200.
               *
               * @sample {highcharts} highcharts/legend/symbolwidth/
               *         Greater symbol width and padding
               * @sample {highmaps} maps/legend/padding-itemmargin/
               *         Padding and item margins demonstrated
               * @sample {highmaps} maps/legend/layout-vertical-sized/
               *         Sized vertical gradient
               *
               * @type      {number}
               * @apioption legend.symbolWidth
               */
              /**
               * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
               * to render the legend item texts.
               *
               * Prior to 4.1.7, when using HTML, [legend.navigation](
               * #legend.navigation) was disabled.
               *
               * @type      {boolean}
               * @default   false
               * @apioption legend.useHTML
               */
              /**
               * For a color axis with data classes, how many decimals to render in
               * the legend. The default preserves the decimals of the range numbers.
               *
               * @type      {number}
               * @default   -1
               * @product   highcharts highmaps
               * @apioption legend.valueDecimals
               */
              /**
               * For a color axis with data classes, a suffix for the range numbers in
               * the legend.
               *
               * @type      {string}
               * @default   ''
               * @product   highcharts highmaps
               * @apioption legend.valueSuffix
               */
              /**
               * The width of the legend box. If a number is set, it translates to
               * pixels. Since v7.0.2 it allows setting a percent string of the full
               * chart width, for example `40%`.
               *
               * Defaults to the full chart width for legends below or above the
               * chart, half the chart width for legends to the left and right.
               *
               * @sample {highcharts} highcharts/legend/width/
               *         Aligned to the plot area
               * @sample {highcharts} highcharts/legend/width-percent/
               *         A percent of the chart width
               *
               * @type      {number|string}
               * @since     2.0
               * @apioption legend.width
               */
              /**
               * The pixel padding between the legend item symbol and the legend
               * item text.
               *
               * @sample {highcharts} highcharts/legend/symbolpadding/
               *         Greater symbol width and padding
               */
              symbolPadding: 5,
              /**
               * The vertical alignment of the legend box. Can be one of `top`,
               * `middle` or `bottom`. Vertical position can be further determined
               * by the `y` option.
               *
               * In the case that the legend is aligned in a corner position, the
               * `layout` option will determine whether to place it above/below
               * or on the side of the plot area.
               *
               * When the [layout](#legend.layout) option is `proximate`, the
               * `verticalAlign` option doesn't apply.
               *
               * @sample {highcharts} highcharts/legend/verticalalign/
               *         Legend 100px from the top of the chart
               * @sample {highstock} stock/legend/align/
               *         Various legend options
               * @sample {highmaps} maps/legend/alignment/
               *         Legend alignment
               *
               * @type  {Highcharts.VerticalAlignValue}
               * @since 2.0
               */
              verticalAlign: "bottom",
              // width: undefined,
              /**
               * The x offset of the legend relative to its horizontal alignment
               * `align` within chart.spacingLeft and chart.spacingRight. Negative
               * x moves it to the left, positive x moves it to the right.
               *
               * @sample {highcharts} highcharts/legend/width/
               *         Aligned to the plot area
               *
               * @since 2.0
               */
              x: 0,
              /**
               * The vertical offset of the legend relative to it's vertical alignment
               * `verticalAlign` within chart.spacingTop and chart.spacingBottom.
               *  Negative y moves it up, positive y moves it down.
               *
               * @sample {highcharts} highcharts/legend/verticalalign/
               *         Legend 100px from the top of the chart
               * @sample {highstock} stock/legend/align/
               *         Various legend options
               * @sample {highmaps} maps/legend/alignment/
               *         Legend alignment
               *
               * @since 2.0
               */
              y: 0,
              /**
               * A title to be added on top of the legend.
               *
               * @sample {highcharts} highcharts/legend/title/
               *         Legend title
               * @sample {highmaps} maps/legend/alignment/
               *         Legend with title
               *
               * @since 3.0
               */
              title: {
                /**
                 * A text or HTML string for the title.
                 *
                 * @type      {string}
                 * @since     3.0
                 * @apioption legend.title.text
                 */
                /**
                 * Generic CSS styles for the legend title.
                 *
                 * @see In styled mode, the legend title is styled with the
                 *      `.highcharts-legend-title` class.
                 *
                 * @type    {Highcharts.CSSObject}
                 * @default {"fontWeight": "bold"}
                 * @since   3.0
                 */
                style: {
                  /**
                   * @ignore
                   */
                  fontWeight: "bold"
                }
              }
            },
            /**
             * The loading options control the appearance of the loading screen
             * that covers the plot area on chart operations. This screen only
             * appears after an explicit call to `chart.showLoading()`. It is a
             * utility for developers to communicate to the end user that something
             * is going on, for example while retrieving new data via an XHR connection.
             * The "Loading..." text itself is not part of this configuration
             * object, but part of the `lang` object.
             */
            loading: {
              /**
               * The duration in milliseconds of the fade out effect.
               *
               * @sample highcharts/loading/hideduration/
               *         Fade in and out over a second
               *
               * @type      {number}
               * @default   100
               * @since     1.2.0
               * @apioption loading.hideDuration
               */
              /**
               * The duration in milliseconds of the fade in effect.
               *
               * @sample highcharts/loading/hideduration/
               *         Fade in and out over a second
               *
               * @type      {number}
               * @default   100
               * @since     1.2.0
               * @apioption loading.showDuration
               */
              /**
               * CSS styles for the loading label `span`.
               *
               * @see In styled mode, the loading label is styled with the
               *      `.highcharts-loading-inner` class.
               *
               * @sample {highcharts|highmaps} highcharts/loading/labelstyle/
               *         Vertically centered
               * @sample {highstock} stock/loading/general/
               *         Label styles
               *
               * @type    {Highcharts.CSSObject}
               * @default {"fontWeight": "bold", "position": "relative", "top": "45%"}
               * @since   1.2.0
               */
              labelStyle: {
                /**
                 * @ignore
                 */
                fontWeight: "bold",
                /**
                 * @ignore
                 */
                position: "relative",
                /**
                 * @ignore
                 */
                top: "45%"
              },
              /**
               * CSS styles for the loading screen that covers the plot area.
               *
               * In styled mode, the loading label is styled with the
               * `.highcharts-loading` class.
               *
               * @sample  {highcharts|highmaps} highcharts/loading/style/
               *          Gray plot area, white text
               * @sample  {highstock} stock/loading/general/
               *          Gray plot area, white text
               *
               * @type    {Highcharts.CSSObject}
               * @default {"position": "absolute", "backgroundColor": "#ffffff", "opacity": 0.5, "textAlign": "center"}
               * @since   1.2.0
               */
              style: {
                /**
                 * @ignore
                 */
                position: "absolute",
                /**
                 * @ignore
                 */
                backgroundColor: "#ffffff",
                /**
                 * @ignore
                 */
                opacity: 0.5,
                /**
                 * @ignore
                 */
                textAlign: "center"
              }
            },
            /**
             * Options for the tooltip that appears when the user hovers over a
             * series or point.
             *
             * @declare Highcharts.TooltipOptions
             */
            tooltip: {
              /**
               * The color of the tooltip border. When `undefined`, the border takes
               * the color of the corresponding series or point.
               *
               * @sample {highcharts} highcharts/tooltip/bordercolor-default/
               *         Follow series by default
               * @sample {highcharts} highcharts/tooltip/bordercolor-black/
               *         Black border
               * @sample {highstock} stock/tooltip/general/
               *         Styled tooltip
               * @sample {highmaps} maps/tooltip/background-border/
               *         Background and border demo
               *
               * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               * @apioption tooltip.borderColor
               */
              /**
               * A CSS class name to apply to the tooltip's container div,
               * allowing unique CSS styling for each chart.
               *
               * @type      {string}
               * @apioption tooltip.className
               */
              /**
               * Since 4.1, the crosshair definitions are moved to the Axis object
               * in order for a better separation from the tooltip. See
               * [xAxis.crosshair](#xAxis.crosshair).
               *
               * @sample {highcharts} highcharts/tooltip/crosshairs-x/
               *         Enable a crosshair for the x value
               *
               * @deprecated
               *
               * @type      {*}
               * @default   true
               * @apioption tooltip.crosshairs
               */
              /**
               * Distance from point to tooltip in pixels.
               *
               * @type      {number}
               * @default   16
               * @apioption tooltip.distance
               */
              /**
               * Whether the tooltip should follow the mouse as it moves across
               * columns, pie slices and other point types with an extent.
               * By default it behaves this way for pie, polygon, map, sankey
               * and wordcloud series by override in the `plotOptions`
               * for those series types.
               *
               * Does not apply if [split](#tooltip.split) is `true`.
               *
               * For touch moves to behave the same way, [followTouchMove](
               * #tooltip.followTouchMove) must be `true` also.
               *
               * @type      {boolean}
               * @default   {highcharts} false
               * @default   {highstock} false
               * @default   {highmaps} true
               * @since     3.0
               * @apioption tooltip.followPointer
               */
              /**
               * Whether the tooltip should update as the finger moves on a touch
               * device. If this is `true` and [chart.panning](#chart.panning) is
               * set,`followTouchMove` will take over one-finger touches, so the user
               * needs to use two fingers for zooming and panning.
               *
               * Note the difference to [followPointer](#tooltip.followPointer) that
               * only defines the _position_ of the tooltip. If `followPointer` is
               * false in for example a column series, the tooltip will show above or
               * below the column, but as `followTouchMove` is true, the tooltip will
               * jump from column to column as the user swipes across the plot area.
               *
               * @type      {boolean}
               * @default   {highcharts} true
               * @default   {highstock} true
               * @default   {highmaps} false
               * @since     3.0.1
               * @apioption tooltip.followTouchMove
               */
              /**
               * Callback function to format the text of the tooltip from scratch. In
               * case of single or [shared](#tooltip.shared) tooltips, a string should
               * be returned. In case of [split](#tooltip.split) tooltips, it should
               * return an array where the first item is the header, and subsequent
               * items are mapped to the points. Return `false` to disable tooltip for
               * a specific point on series.
               *
               * A subset of HTML is supported. Unless `useHTML` is true, the HTML of
               * the tooltip is parsed and converted to SVG, therefore this isn't a
               * complete HTML renderer. The following HTML tags are supported: `b`,
               * `br`, `em`, `i`, `span`, `strong`. Spans can be styled with a `style`
               * attribute, but only text-related CSS, that is shared with SVG, is
               * handled.
               *
               * The available data in the formatter differ a bit depending on whether
               * the tooltip is shared or split, or belongs to a single point. In a
               * shared/split tooltip, all properties except `x`, which is common for
               * all points, are kept in an array, `this.points`.
               *
               * Available data are:
               *
               * - **this.percentage (not shared) /**
               *   **this.points[i].percentage (shared)**:
               *   Stacked series and pies only. The point's percentage of the total.
               *
               * - **this.point (not shared) / this.points[i].point (shared)**:
               *   The point object. The point name, if defined, is available through
               *   `this.point.name`.
               *
               * - **this.points**:
               *   In a shared tooltip, this is an array containing all other
               *   properties for each point.
               *
               * - **this.series (not shared) / this.points[i].series (shared)**:
               *   The series object. The series name is available through
               *   `this.series.name`.
               *
               * - **this.total (not shared) / this.points[i].total (shared)**:
               *   Stacked series only. The total value at this point's x value.
               *
               * - **this.x**:
               *   The x value. This property is the same regardless of the tooltip
               *   being shared or not.
               *
               * - **this.y (not shared) / this.points[i].y (shared)**:
               *   The y value.
               *
               * @sample {highcharts} highcharts/tooltip/formatter-simple/
               *         Simple string formatting
               * @sample {highcharts} highcharts/tooltip/formatter-shared/
               *         Formatting with shared tooltip
               * @sample {highcharts|highstock} highcharts/tooltip/formatter-split/
               *         Formatting with split tooltip
               * @sample highcharts/tooltip/formatter-conditional-default/
               *         Extending default formatter
               * @sample {highstock} stock/tooltip/formatter/
               *         Formatting with shared tooltip
               * @sample {highmaps} maps/tooltip/formatter/
               *         String formatting
               *
               * @type      {Highcharts.TooltipFormatterCallbackFunction}
               * @apioption tooltip.formatter
               */
              /**
               * Callback function to format the text of the tooltip for
               * visible null points.
               * Works analogously to [formatter](#tooltip.formatter).
               *
               * @sample highcharts/plotoptions/series-nullformat
               *         Format data label and tooltip for null point.
               *
               * @type      {Highcharts.TooltipFormatterCallbackFunction}
               * @apioption tooltip.nullFormatter
               */
              /**
               * Whether to allow the tooltip to render outside the chart's SVG
               * element box. By default (`false`), the tooltip is rendered within the
               * chart's SVG element, which results in the tooltip being aligned
               * inside the chart area. For small charts, this may result in clipping
               * or overlapping. When `true`, a separate SVG element is created and
               * overlaid on the page, allowing the tooltip to be aligned inside the
               * page itself.
               *
               * Defaults to `true` if `chart.scrollablePlotArea` is activated,
               * otherwise `false`.
               *
               * @sample highcharts/tooltip/outside
               *         Small charts with tooltips outside
               *
               * @type      {boolean|undefined}
               * @default   undefined
               * @since     6.1.1
               * @apioption tooltip.outside
               */
              /**
               * A callback function for formatting the HTML output for a single point
               * in the tooltip. Like the `pointFormat` string, but with more
               * flexibility.
               *
               * @type      {Highcharts.FormatterCallbackFunction<Highcharts.Point>}
               * @since     4.1.0
               * @context   Highcharts.Point
               * @apioption tooltip.pointFormatter
               */
              /**
               * A callback function to place the tooltip in a custom position. The
               * callback receives three parameters: `labelWidth`, `labelHeight` and
               * `point`, where point contains values for `plotX` and `plotY` telling
               * where the reference point is in the plot area. Add `chart.plotLeft`
               * and `chart.plotTop` to get the full coordinates.
               *
               * To find the actual hovered `Point` instance, use
               * `this.chart.hoverPoint`. For shared or split tooltips, all the hover
               * points are available in `this.chart.hoverPoints`.
               *
               * Since v7, when [tooltip.split](#tooltip.split) option is enabled,
               * positioner is called for each of the boxes separately, including
               * xAxis header. xAxis header is not a point, instead `point` argument
               * contains info: `{ plotX: Number, plotY: Number, isHeader: Boolean }`
               *
               * The return should be an object containing x and y values, for example
               * `{ x: 100, y: 100 }`.
               *
               * @sample {highcharts} highcharts/tooltip/positioner/
               *         A fixed tooltip position
               * @sample {highstock} stock/tooltip/positioner/
               *         A fixed tooltip position on top of the chart
               * @sample {highmaps} maps/tooltip/positioner/
               *         A fixed tooltip position
               * @sample {highstock} stock/tooltip/split-positioner/
               *         Split tooltip with fixed positions
               * @sample {highstock} stock/tooltip/positioner-scrollable-plotarea/
               *         Scrollable plot area combined with tooltip positioner
               *
               * @type      {Highcharts.TooltipPositionerCallbackFunction}
               * @since     2.2.4
               * @apioption tooltip.positioner
               */
              /**
               * Split the tooltip into one label per series, with the header close
               * to the axis. This is recommended over [shared](#tooltip.shared)
               * tooltips for charts with multiple line series, generally making them
               * easier to read. This option takes precedence over `tooltip.shared`.
               *
               * @productdesc {highstock} In Highcharts Stock, tooltips are split
               * by default since v6.0.0. Stock charts typically contain
               * multi-dimension points and multiple panes, making split tooltips
               * the preferred layout over
               * the previous `shared` tooltip.
               *
               * @sample highcharts/tooltip/split/
               *         Split tooltip
               * @sample {highcharts|highstock} highcharts/tooltip/formatter-split/
               *         Split tooltip and custom formatter callback
               *
               * @type      {boolean}
               * @default   {highcharts} false
               * @default   {highstock} true
               * @since     5.0.0
               * @product   highcharts highstock
               * @apioption tooltip.split
               */
              /**
               * Prevents the tooltip from switching or closing, when touched or
               * pointed.
               *
               * @sample highcharts/tooltip/stickoncontact/
               *         Tooltip sticks on pointer contact
               *
               * @type      {boolean}
               * @since     8.0.1
               * @apioption tooltip.stickOnContact
               */
              /**
               * Use HTML to render the contents of the tooltip instead of SVG. Using
               * HTML allows advanced formatting like tables and images in the
               * tooltip. It is also recommended for rtl languages as it works around
               * rtl bugs in early Firefox.
               *
               * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
               *         A table for value alignment
               * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
               *         Full HTML tooltip
               * @sample {highmaps} maps/tooltip/usehtml/
               *         Pure HTML tooltip
               *
               * @type      {boolean}
               * @default   false
               * @since     2.2
               * @apioption tooltip.useHTML
               */
              /**
               * How many decimals to show in each series' y value. This is
               * overridable in each series' tooltip options object. The default is to
               * preserve all decimals.
               *
               * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
               *         Set decimals, prefix and suffix for the value
               * @sample {highmaps} maps/tooltip/valuedecimals/
               *         Set decimals, prefix and suffix for the value
               *
               * @type      {number|undefined}
               * @since     2.2
               * @apioption tooltip.valueDecimals
               */
              /**
               * A string to prepend to each series' y value. Overridable in each
               * series' tooltip options object.
               *
               * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
               *         Set decimals, prefix and suffix for the value
               * @sample {highmaps} maps/tooltip/valuedecimals/
               *         Set decimals, prefix and suffix for the value
               *
               * @type      {string}
               * @since     2.2
               * @apioption tooltip.valuePrefix
               */
              /**
               * A string to append to each series' y value. Overridable in each
               * series' tooltip options object.
               *
               * @sample {highcharts|highstock} highcharts/tooltip/valuedecimals/
               *         Set decimals, prefix and suffix for the value
               * @sample {highmaps} maps/tooltip/valuedecimals/
               *         Set decimals, prefix and suffix for the value
               *
               * @type      {string}
               * @since     2.2
               * @apioption tooltip.valueSuffix
               */
              /**
               * The format for the date in the tooltip header if the X axis is a
               * datetime axis. The default is a best guess based on the smallest
               * distance between points in the chart.
               *
               * @sample {highcharts} highcharts/tooltip/xdateformat/
               *         A different format
               *
               * @type      {string}
               * @product   highcharts highstock gantt
               * @apioption tooltip.xDateFormat
               */
              /**
               * How many decimals to show for the `point.change`
               * or the `point.cumulativeSum` value when the `series.compare`
               * or the `series.cumulative` option is set.
               * This is overridable in each series' tooltip options object.
               *
               * @type      {number}
               * @default   2
               * @since     1.0.1
               * @product   highstock
               * @apioption tooltip.changeDecimals
               */
              /**
               * Enable or disable the tooltip.
               *
               * @sample {highcharts} highcharts/tooltip/enabled/
               *         Disabled
               * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
               *         Disable tooltip and show values on chart instead
               */
              enabled: true,
              /**
               * Enable or disable animation of the tooltip.
               *
               * @type       {boolean}
               * @default    true
               * @since      2.3.0
               */
              animation: svg,
              /**
               * The radius of the rounded border corners.
               *
               * @sample {highcharts} highcharts/tooltip/bordercolor-default/
               *         5px by default
               * @sample {highcharts} highcharts/tooltip/borderradius-0/
               *         Square borders
               * @sample {highmaps} maps/tooltip/background-border/
               *         Background and border demo
               */
              borderRadius: 3,
              /**
               * For series on datetime axes, the date format in the tooltip's
               * header will by default be guessed based on the closest data points.
               * This member gives the default string representations used for
               * each unit. For an overview of the replacement codes, see
               * [dateFormat](/class-reference/Highcharts.Time#dateFormat).
               *
               * @see [xAxis.dateTimeLabelFormats](#xAxis.dateTimeLabelFormats)
               *
               * @type    {Highcharts.Dictionary<string>}
               * @product highcharts highstock gantt
               */
              dateTimeLabelFormats: {
                /** @internal */
                millisecond: "%A, %b %e, %H:%M:%S.%L",
                /** @internal */
                second: "%A, %b %e, %H:%M:%S",
                /** @internal */
                minute: "%A, %b %e, %H:%M",
                /** @internal */
                hour: "%A, %b %e, %H:%M",
                /** @internal */
                day: "%A, %b %e, %Y",
                /** @internal */
                week: "Week from %A, %b %e, %Y",
                /** @internal */
                month: "%B %Y",
                /** @internal */
                year: "%Y"
              },
              /**
               * A string to append to the tooltip format.
               *
               * @sample {highcharts} highcharts/tooltip/footerformat/
               *         A table for value alignment
               * @sample {highmaps} maps/tooltip/format/
               *         Format demo
               *
               * @since 2.2
               */
              footerFormat: "",
              /**
               * The name of a symbol to use for the border around the tooltip
               * header. Applies only when [tooltip.split](#tooltip.split) is
               * enabled.
               *
               * Custom callbacks for symbol path generation can also be added to
               * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
               * [series.marker.symbol](plotOptions.line.marker.symbol).
               *
               * @see [tooltip.shape](#tooltip.shape)
               *
               * @sample {highstock} stock/tooltip/split-positioner/
               *         Different shapes for header and split boxes
               *
               * @type       {Highcharts.TooltipShapeValue}
               * @validvalue ["callout", "square"]
               * @since      7.0
               */
              headerShape: "callout",
              /**
               * The number of milliseconds to wait until the tooltip is hidden when
               * mouse out from a point or chart.
               *
               * @since     3.0
               */
              hideDelay: 500,
              /**
               * Padding inside the tooltip, in pixels.
               *
               * @since      5.0.0
               */
              padding: 8,
              /**
               * The name of a symbol to use for the border around the tooltip. Can
               * be one of: `"callout"`, `"circle"` or `"rect"`. When
               * [tooltip.split](#tooltip.split)
               * option is enabled, shape is applied to all boxes except header, which
               * is controlled by
               * [tooltip.headerShape](#tooltip.headerShape).
               *
               * Custom callbacks for symbol path generation can also be added to
               * `Highcharts.SVGRenderer.prototype.symbols` the same way as for
               * [series.marker.symbol](plotOptions.line.marker.symbol).
               *
               * @type      {Highcharts.TooltipShapeValue}
               * @since     4.0
               */
              shape: "callout",
              /**
               * When the tooltip is shared, the entire plot area will capture mouse
               * movement or touch events. Tooltip texts for series types with ordered
               * data (not pie, scatter, flags etc) will be shown in a single bubble.
               * This is recommended for single series charts and for tablet/mobile
               * optimized charts.
               *
               * See also [tooltip.split](#tooltip.split), that is better suited for
               * charts with many series, especially line-type series. The
               * `tooltip.split` option takes precedence over `tooltip.shared`.
               *
               * @sample {highcharts} highcharts/tooltip/shared-false/
               *         False by default
               * @sample {highcharts} highcharts/tooltip/shared-true/
               *         True
               * @sample {highcharts} highcharts/tooltip/shared-x-crosshair/
               *         True with x axis crosshair
               * @sample {highcharts} highcharts/tooltip/shared-true-mixed-types/
               *         True with mixed series types
               *
               * @since     2.1
               * @product   highcharts highstock
               */
              shared: false,
              /**
               * Proximity snap for graphs or single points. It defaults to 10 for
               * mouse-powered devices and 25 for touch devices.
               *
               * Note that in most cases the whole plot area captures the mouse
               * movement, and in these cases `tooltip.snap` doesn't make sense. This
               * applies when [stickyTracking](#plotOptions.series.stickyTracking)
               * is `true` (default) and when the tooltip is [shared](#tooltip.shared)
               * or [split](#tooltip.split).
               *
               * @sample {highcharts} highcharts/tooltip/bordercolor-default/
               *         10 px by default
               * @sample {highcharts} highcharts/tooltip/snap-50/
               *         50 px on graph
               *
               * @type    {number}
               * @default 10/25
               * @since   1.2.0
               * @product highcharts highstock
               */
              snap: isTouchDevice ? 25 : 10,
              /**
               * The HTML of the tooltip header line. Variables are enclosed by
               * curly brackets. Available variables are `point.key`, `series.name`,
               * `series.color` and other members from the `point` and `series`
               * objects. The `point.key` variable contains the category name, x
               * value or datetime string depending on the type of axis. For datetime
               * axes, the `point.key` date format can be set using
               * `tooltip.xDateFormat`.
               *
               * @sample {highcharts} highcharts/tooltip/footerformat/
               *         An HTML table in the tooltip
               * @sample {highstock} highcharts/tooltip/footerformat/
               *         An HTML table in the tooltip
               * @sample {highmaps} maps/tooltip/format/
               *         Format demo
               *
               * @type       {string}
               * @apioption  tooltip.headerFormat
               */
              headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
              /**
               * The HTML of the null point's line in the tooltip. Works analogously
               * to [pointFormat](#tooltip.pointFormat).
               *
               * @sample {highcharts} highcharts/plotoptions/series-nullformat
               *         Format data label and tooltip for null point.
               *
               * @type      {string}
               * @apioption tooltip.nullFormat
               */
              /**
               * The HTML of the point's line in the tooltip. Variables are enclosed
               * by curly brackets. Available variables are `point.x`, `point.y`,
               * `series.name` and `series.color` and other properties on the same
               * form. Furthermore, `point.y` can be extended by the
               * `tooltip.valuePrefix` and `tooltip.valueSuffix` variables. This can
               * also be overridden for each series, which makes it a good hook for
               * displaying units.
               *
               * In styled mode, the dot is colored by a class name rather
               * than the point color.
               *
               * @sample {highcharts} highcharts/tooltip/pointformat/
               *         A different point format with value suffix
               * @sample {highcharts|highstock} highcharts/tooltip/pointformat-extra-information/
               *         Show extra information about points in the tooltip
               * @sample {highmaps} maps/tooltip/format/
               *         Format demo
               *
               * @type       {string}
               * @since      2.2
               * @apioption  tooltip.pointFormat
               */
              pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
              /**
               * The background color or gradient for the tooltip.
               *
               * In styled mode, the stroke width is set in the
               * `.highcharts-tooltip-box` class.
               *
               * @sample {highcharts} highcharts/tooltip/backgroundcolor-solid/
               *         Yellowish background
               * @sample {highcharts} highcharts/tooltip/backgroundcolor-gradient/
               *         Gradient
               * @sample {highcharts} highcharts/css/tooltip-border-background/
               *         Tooltip in styled mode
               * @sample {highstock} stock/tooltip/general/
               *         Custom tooltip
               * @sample {highstock} highcharts/css/tooltip-border-background/
               *         Tooltip in styled mode
               * @sample {highmaps} maps/tooltip/background-border/
               *         Background and border demo
               * @sample {highmaps} highcharts/css/tooltip-border-background/
               *         Tooltip in styled mode
               *
               * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               */
              backgroundColor: color2(
                "#f7f7f7"
                /* Palette.neutralColor3 */
              ).setOpacity(0.85).get(),
              /**
               * The pixel width of the tooltip border.
               *
               * In styled mode, the stroke width is set in the
               * `.highcharts-tooltip-box` class.
               *
               * @sample {highcharts} highcharts/tooltip/bordercolor-default/
               *         2px by default
               * @sample {highcharts} highcharts/tooltip/borderwidth/
               *         No border (shadow only)
               * @sample {highcharts} highcharts/css/tooltip-border-background/
               *         Tooltip in styled mode
               * @sample {highstock} stock/tooltip/general/
               *         Custom tooltip
               * @sample {highstock} highcharts/css/tooltip-border-background/
               *         Tooltip in styled mode
               * @sample {highmaps} maps/tooltip/background-border/
               *         Background and border demo
               * @sample {highmaps} highcharts/css/tooltip-border-background/
               *         Tooltip in styled mode
               */
              borderWidth: 1,
              /**
               * Whether to apply a drop shadow to the tooltip.
               *
               * @sample {highcharts} highcharts/tooltip/bordercolor-default/
               *         True by default
               * @sample {highcharts} highcharts/tooltip/shadow/
               *         False
               * @sample {highmaps} maps/tooltip/positioner/
               *         Fixed tooltip position, border and shadow disabled
               *
               * @type {boolean|Highcharts.ShadowOptionsObject}
               */
              shadow: true,
              /**
               * Prevents the tooltip from switching or closing when touched or
               * pointed.
               *
               * @sample highcharts/tooltip/stickoncontact/
               *         Tooltip sticks on pointer contact
               *
               * @since     8.0.1
               */
              stickOnContact: false,
              /**
               * CSS styles for the tooltip. The tooltip can also be styled through
               * the CSS class `.highcharts-tooltip`.
               *
               * Note that the default `pointerEvents` style makes the tooltip ignore
               * mouse events, so in order to use clickable tooltips, this value must
               * be set to `auto`.
               *
               * @sample {highcharts} highcharts/tooltip/style/
               *         Greater padding, bold text
               *
               * @type {Highcharts.CSSObject}
               */
              style: {
                /** @internal */
                color: "#333333",
                /** @internal */
                cursor: "default",
                /** @internal */
                fontSize: "12px",
                /** @internal */
                whiteSpace: "nowrap"
              },
              /**
               * Use HTML to render the contents of the tooltip instead of SVG. Using
               * HTML allows advanced formatting like tables and images in the
               * tooltip. It is also recommended for rtl languages as it works around
               * rtl bugs in early Firefox.
               *
               * @sample {highcharts|highstock} highcharts/tooltip/footerformat/
               *         A table for value alignment
               * @sample {highcharts|highstock} highcharts/tooltip/fullhtml/
               *         Full HTML tooltip
               * @sample {highmaps} maps/tooltip/usehtml/
               *         Pure HTML tooltip
               *
               * @since     2.2
               */
              useHTML: false
            },
            /**
             * Highchart by default puts a credits label in the lower right corner
             * of the chart. This can be changed using these options.
             */
            credits: {
              /**
               * Credits for map source to be concatenated with conventional credit
               * text. By default this is a format string that collects copyright
               * information from the map if available.
               *
               * @see [mapTextFull](#credits.mapTextFull)
               * @see [text](#credits.text)
               *
               * @type      {string}
               * @default   \u00a9 <a href="{geojson.copyrightUrl}">{geojson.copyrightShort}</a>
               * @since     4.2.2
               * @product   highmaps
               * @apioption credits.mapText
               */
              /**
               * Detailed credits for map source to be displayed on hover of credits
               * text. By default this is a format string that collects copyright
               * information from the map if available.
               *
               * @see [mapText](#credits.mapText)
               * @see [text](#credits.text)
               *
               * @type      {string}
               * @default   {geojson.copyright}
               * @since     4.2.2
               * @product   highmaps
               * @apioption credits.mapTextFull
               */
              /**
               * Whether to show the credits text.
               *
               * @sample {highcharts} highcharts/credits/enabled-false/
               *         Credits disabled
               * @sample {highstock} stock/credits/enabled/
               *         Credits disabled
               * @sample {highmaps} maps/credits/enabled-false/
               *         Credits disabled
               */
              enabled: true,
              /**
               * The URL for the credits label.
               *
               * @sample {highcharts} highcharts/credits/href/
               *         Custom URL and text
               * @sample {highmaps} maps/credits/customized/
               *         Custom URL and text
               */
              href: "https://www.highcharts.com?credits",
              /**
               * Position configuration for the credits label.
               *
               * @sample {highcharts} highcharts/credits/position-left/
               *         Left aligned
               * @sample {highcharts} highcharts/credits/position-left/
               *         Left aligned
               * @sample {highmaps} maps/credits/customized/
               *         Left aligned
               * @sample {highmaps} maps/credits/customized/
               *         Left aligned
               *
               * @type    {Highcharts.AlignObject}
               * @since   2.1
               */
              position: {
                /** @internal */
                align: "right",
                /** @internal */
                x: -10,
                /** @internal */
                verticalAlign: "bottom",
                /** @internal */
                y: -5
              },
              /**
               * CSS styles for the credits label.
               *
               * @see In styled mode, credits styles can be set with the
               *      `.highcharts-credits` class.
               *
               * @type {Highcharts.CSSObject}
               */
              style: {
                /** @internal */
                cursor: "pointer",
                /** @internal */
                color: "#999999",
                /** @internal */
                fontSize: "9px"
              },
              /**
               * The text for the credits label.
               *
               * @productdesc {highmaps}
               * If a map is loaded as GeoJSON, the text defaults to
               * `Highcharts @ {map-credits}`. Otherwise, it defaults to
               * `Highcharts.com`.
               *
               * @sample {highcharts} highcharts/credits/href/
               *         Custom URL and text
               * @sample {highmaps} maps/credits/customized/
               *         Custom URL and text
               */
              text: "Highcharts.com"
            }
          };
          defaultOptions.chart.styledMode = false;
          "";
          var defaultTime = new Time(merge(
            defaultOptions.global,
            defaultOptions.time
          ));
          function getOptions() {
            return defaultOptions;
          }
          function setOptions(options) {
            merge(true, defaultOptions, options);
            if (options.time || options.global) {
              if (H.time) {
                H.time.update(merge(defaultOptions.global, defaultOptions.time, options.global, options.time));
              } else {
                H.time = defaultTime;
              }
            }
            return defaultOptions;
          }
          var DefaultOptions = {
            defaultOptions,
            defaultTime,
            getOptions,
            setOptions
          };
          "";
          return DefaultOptions;
        });
        _registerModule(_modules, "Core/Animation/Fx.js", [_modules["Core/Color/Color.js"], _modules["Core/Globals.js"], _modules["Core/Utilities.js"]], function(Color2, H, U) {
          var color2 = Color2.parse;
          var win = H.win;
          var isNumber = U.isNumber, objectEach = U.objectEach;
          var Fx = (
            /** @class */
            function() {
              function Fx2(elem, options, prop) {
                this.pos = NaN;
                this.options = options;
                this.elem = elem;
                this.prop = prop;
              }
              Fx2.prototype.dSetter = function() {
                var paths = this.paths, start2 = paths && paths[0], end = paths && paths[1], now2 = this.now || 0;
                var path = [];
                if (now2 === 1 || !start2 || !end) {
                  path = this.toD || [];
                } else if (start2.length === end.length && now2 < 1) {
                  for (var i = 0; i < end.length; i++) {
                    var startSeg = start2[i];
                    var endSeg = end[i];
                    var tweenSeg = [];
                    for (var j = 0; j < endSeg.length; j++) {
                      var startItem = startSeg[j];
                      var endItem = endSeg[j];
                      if (isNumber(startItem) && isNumber(endItem) && // Arc boolean flags
                      !(endSeg[0] === "A" && (j === 4 || j === 5))) {
                        tweenSeg[j] = startItem + now2 * (endItem - startItem);
                      } else {
                        tweenSeg[j] = endItem;
                      }
                    }
                    path.push(tweenSeg);
                  }
                } else {
                  path = end;
                }
                this.elem.attr("d", path, void 0, true);
              };
              Fx2.prototype.update = function() {
                var elem = this.elem, prop = this.prop, now2 = this.now, step = this.options.step;
                if (this[prop + "Setter"]) {
                  this[prop + "Setter"]();
                } else if (elem.attr) {
                  if (elem.element) {
                    elem.attr(prop, now2, null, true);
                  }
                } else {
                  elem.style[prop] = now2 + this.unit;
                }
                if (step) {
                  step.call(elem, now2, this);
                }
              };
              Fx2.prototype.run = function(from, to, unit) {
                var self = this, options = self.options, timer2 = function(gotoEnd) {
                  return timer2.stopped ? false : self.step(gotoEnd);
                }, requestAnimationFrame = win.requestAnimationFrame || function(step2) {
                  setTimeout(step2, 13);
                }, step = function() {
                  for (var i = 0; i < Fx2.timers.length; i++) {
                    if (!Fx2.timers[i]()) {
                      Fx2.timers.splice(i--, 1);
                    }
                  }
                  if (Fx2.timers.length) {
                    requestAnimationFrame(step);
                  }
                };
                if (from === to && !this.elem["forceAnimate:" + this.prop]) {
                  delete options.curAnim[this.prop];
                  if (options.complete && Object.keys(options.curAnim).length === 0) {
                    options.complete.call(this.elem);
                  }
                } else {
                  this.startTime = +/* @__PURE__ */ new Date();
                  this.start = from;
                  this.end = to;
                  this.unit = unit;
                  this.now = this.start;
                  this.pos = 0;
                  timer2.elem = this.elem;
                  timer2.prop = this.prop;
                  if (timer2() && Fx2.timers.push(timer2) === 1) {
                    requestAnimationFrame(step);
                  }
                }
              };
              Fx2.prototype.step = function(gotoEnd) {
                var t = +/* @__PURE__ */ new Date(), options = this.options, elem = this.elem, complete = options.complete, duration = options.duration, curAnim = options.curAnim;
                var ret, done;
                if (elem.attr && !elem.element) {
                  ret = false;
                } else if (gotoEnd || t >= duration + this.startTime) {
                  this.now = this.end;
                  this.pos = 1;
                  this.update();
                  curAnim[this.prop] = true;
                  done = true;
                  objectEach(curAnim, function(val) {
                    if (val !== true) {
                      done = false;
                    }
                  });
                  if (done && complete) {
                    complete.call(elem);
                  }
                  ret = false;
                } else {
                  this.pos = options.easing((t - this.startTime) / duration);
                  this.now = this.start + (this.end - this.start) * this.pos;
                  this.update();
                  ret = true;
                }
                return ret;
              };
              Fx2.prototype.initPath = function(elem, fromD, toD) {
                var startX = elem.startX, endX = elem.endX, end = toD.slice(), isArea = elem.isArea, positionFactor = isArea ? 2 : 1;
                var shift, fullLength, i, reverse, start2 = fromD && fromD.slice();
                if (!start2) {
                  return [
                    end,
                    end
                  ];
                }
                function prepend(arr, other) {
                  while (arr.length < fullLength) {
                    var moveSegment = arr[0], otherSegment = other[fullLength - arr.length];
                    if (otherSegment && moveSegment[0] === "M") {
                      if (otherSegment[0] === "C") {
                        arr[0] = [
                          "C",
                          moveSegment[1],
                          moveSegment[2],
                          moveSegment[1],
                          moveSegment[2],
                          moveSegment[1],
                          moveSegment[2]
                        ];
                      } else {
                        arr[0] = ["L", moveSegment[1], moveSegment[2]];
                      }
                    }
                    arr.unshift(moveSegment);
                    if (isArea) {
                      var z = arr.pop();
                      arr.push(arr[arr.length - 1], z);
                    }
                  }
                }
                function append(arr, other) {
                  while (arr.length < fullLength) {
                    var segmentToAdd = arr[Math.floor(arr.length / positionFactor) - 1].slice();
                    if (segmentToAdd[0] === "C") {
                      segmentToAdd[1] = segmentToAdd[5];
                      segmentToAdd[2] = segmentToAdd[6];
                    }
                    if (!isArea) {
                      arr.push(segmentToAdd);
                    } else {
                      var lowerSegmentToAdd = arr[Math.floor(arr.length / positionFactor)].slice();
                      arr.splice(arr.length / 2, 0, segmentToAdd, lowerSegmentToAdd);
                    }
                  }
                }
                if (startX && endX && endX.length) {
                  for (i = 0; i < startX.length; i++) {
                    if (startX[i] === endX[0]) {
                      shift = i;
                      break;
                    } else if (startX[0] === endX[endX.length - startX.length + i]) {
                      shift = i;
                      reverse = true;
                      break;
                    } else if (startX[startX.length - 1] === endX[endX.length - startX.length + i]) {
                      shift = startX.length - i;
                      break;
                    }
                  }
                  if (typeof shift === "undefined") {
                    start2 = [];
                  }
                }
                if (start2.length && isNumber(shift)) {
                  fullLength = end.length + shift * positionFactor;
                  if (!reverse) {
                    prepend(end, start2);
                    append(start2, end);
                  } else {
                    prepend(start2, end);
                    append(end, start2);
                  }
                }
                return [start2, end];
              };
              Fx2.prototype.fillSetter = function() {
                Fx2.prototype.strokeSetter.apply(this, arguments);
              };
              Fx2.prototype.strokeSetter = function() {
                this.elem.attr(this.prop, color2(this.start).tweenTo(color2(this.end), this.pos), void 0, true);
              };
              Fx2.timers = [];
              return Fx2;
            }()
          );
          return Fx;
        });
        _registerModule(_modules, "Core/Animation/AnimationUtilities.js", [_modules["Core/Animation/Fx.js"], _modules["Core/Utilities.js"]], function(Fx, U) {
          var defined = U.defined, getStyle = U.getStyle, isArray = U.isArray, isNumber = U.isNumber, isObject = U.isObject, merge = U.merge, objectEach = U.objectEach, pick = U.pick;
          function setAnimation(animation, chart) {
            chart.renderer.globalAnimation = pick(animation, chart.options.chart.animation, true);
          }
          function animObject(animation) {
            return isObject(animation) ? merge({ duration: 500, defer: 0 }, animation) : { duration: animation ? 500 : 0, defer: 0 };
          }
          function getDeferredAnimation(chart, animation, series) {
            var labelAnimation = animObject(animation), s = series ? [series] : chart.series;
            var defer = 0, duration = 0;
            s.forEach(function(series2) {
              var seriesAnim = animObject(series2.options.animation);
              defer = animation && defined(animation.defer) ? labelAnimation.defer : Math.max(defer, seriesAnim.duration + seriesAnim.defer);
              duration = Math.min(labelAnimation.duration, seriesAnim.duration);
            });
            if (chart.renderer.forExport) {
              defer = 0;
            }
            var anim = {
              defer: Math.max(
                0,
                defer - duration
              ),
              duration: Math.min(
                defer,
                duration
              )
            };
            return anim;
          }
          function animate(el, params, opt) {
            var start2, unit = "", end, fx, args;
            if (!isObject(opt)) {
              args = arguments;
              opt = {
                duration: args[2],
                easing: args[3],
                complete: args[4]
              };
            }
            if (!isNumber(opt.duration)) {
              opt.duration = 400;
            }
            opt.easing = typeof opt.easing === "function" ? opt.easing : Math[opt.easing] || Math.easeInOutSine;
            opt.curAnim = merge(params);
            objectEach(params, function(val, prop) {
              stop(el, prop);
              fx = new Fx(el, opt, prop);
              end = void 0;
              if (prop === "d" && isArray(params.d)) {
                fx.paths = fx.initPath(el, el.pathArray, params.d);
                fx.toD = params.d;
                start2 = 0;
                end = 1;
              } else if (el.attr) {
                start2 = el.attr(prop);
              } else {
                start2 = parseFloat(getStyle(el, prop)) || 0;
                if (prop !== "opacity") {
                  unit = "px";
                }
              }
              if (!end) {
                end = val;
              }
              if (typeof end === "string" && end.match("px")) {
                end = end.replace(/px/g, "");
              }
              fx.run(start2, end, unit);
            });
          }
          function stop(el, prop) {
            var i = Fx.timers.length;
            while (i--) {
              if (Fx.timers[i].elem === el && (!prop || prop === Fx.timers[i].prop)) {
                Fx.timers[i].stopped = true;
              }
            }
          }
          var animationExports = {
            animate,
            animObject,
            getDeferredAnimation,
            setAnimation,
            stop
          };
          return animationExports;
        });
        _registerModule(_modules, "Core/Renderer/HTML/AST.js", [_modules["Core/Globals.js"], _modules["Core/Utilities.js"]], function(H, U) {
          var SVG_NS = H.SVG_NS, win = H.win;
          var attr = U.attr, createElement = U.createElement, css = U.css, error = U.error, isFunction = U.isFunction, isString = U.isString, objectEach = U.objectEach, splat = U.splat;
          var trustedTypes = win.trustedTypes;
          var trustedTypesPolicy = trustedTypes && isFunction(trustedTypes.createPolicy) && trustedTypes.createPolicy("highcharts", {
            createHTML: function(s) {
              return s;
            }
          });
          var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
          var hasValidDOMParser = function() {
            try {
              return Boolean(new DOMParser().parseFromString(emptyHTML, "text/html"));
            } catch (e) {
              return false;
            }
          }();
          var AST = (
            /** @class */
            function() {
              function AST2(source) {
                this.nodes = typeof source === "string" ? this.parseMarkup(source) : source;
              }
              AST2.filterUserAttributes = function(attributes) {
                objectEach(attributes, function(val, key) {
                  var valid = true;
                  if (AST2.allowedAttributes.indexOf(key) === -1) {
                    valid = false;
                  }
                  if (["background", "dynsrc", "href", "lowsrc", "src"].indexOf(key) !== -1) {
                    valid = isString(val) && AST2.allowedReferences.some(function(ref) {
                      return val.indexOf(ref) === 0;
                    });
                  }
                  if (!valid) {
                    error(33, false, void 0, {
                      "Invalid attribute in config": "".concat(key)
                    });
                    delete attributes[key];
                  }
                  if (isString(val) && attributes[key]) {
                    attributes[key] = val.replace(/</g, "&lt;");
                  }
                });
                return attributes;
              };
              AST2.parseStyle = function(style) {
                return style.split(";").reduce(function(styles, line) {
                  var pair = line.split(":").map(function(s) {
                    return s.trim();
                  }), key = pair.shift();
                  if (key && pair.length) {
                    styles[key.replace(/-([a-z])/g, function(g) {
                      return g[1].toUpperCase();
                    })] = pair.join(":");
                  }
                  return styles;
                }, {});
              };
              AST2.setElementHTML = function(el, html) {
                el.innerHTML = AST2.emptyHTML;
                if (html) {
                  var ast = new AST2(html);
                  ast.addToDOM(el);
                }
              };
              AST2.prototype.addToDOM = function(parent) {
                function recurse(subtree, subParent) {
                  var ret;
                  splat(subtree).forEach(function(item) {
                    var tagName = item.tagName;
                    var textNode = item.textContent ? H.doc.createTextNode(item.textContent) : void 0;
                    var bypassHTMLFiltering = AST2.bypassHTMLFiltering;
                    var node;
                    if (tagName) {
                      if (tagName === "#text") {
                        node = textNode;
                      } else if (AST2.allowedTags.indexOf(tagName) !== -1 || bypassHTMLFiltering) {
                        var NS = tagName === "svg" ? SVG_NS : subParent.namespaceURI || SVG_NS;
                        var element = H.doc.createElementNS(
                          NS,
                          tagName
                        );
                        var attributes_1 = item.attributes || {};
                        objectEach(item, function(val, key) {
                          if (key !== "tagName" && key !== "attributes" && key !== "children" && key !== "style" && key !== "textContent") {
                            attributes_1[key] = val;
                          }
                        });
                        attr(element, bypassHTMLFiltering ? attributes_1 : AST2.filterUserAttributes(attributes_1));
                        if (item.style) {
                          css(element, item.style);
                        }
                        if (textNode) {
                          element.appendChild(textNode);
                        }
                        recurse(item.children || [], element);
                        node = element;
                      } else {
                        error(33, false, void 0, {
                          "Invalid tagName in config": tagName
                        });
                      }
                    }
                    if (node) {
                      subParent.appendChild(node);
                    }
                    ret = node;
                  });
                  return ret;
                }
                return recurse(this.nodes, parent);
              };
              AST2.prototype.parseMarkup = function(markup) {
                var nodes = [];
                markup = markup.trim().replace(/ style=(["'])/g, " data-style=$1");
                var doc;
                if (hasValidDOMParser) {
                  doc = new DOMParser().parseFromString(trustedTypesPolicy ? trustedTypesPolicy.createHTML(markup) : markup, "text/html");
                } else {
                  var body = createElement("div");
                  body.innerHTML = markup;
                  doc = { body };
                }
                var appendChildNodes = function(node, addTo) {
                  var tagName = node.nodeName.toLowerCase();
                  var astNode = {
                    tagName
                  };
                  if (tagName === "#text") {
                    astNode.textContent = node.textContent || "";
                  }
                  var parsedAttributes = node.attributes;
                  if (parsedAttributes) {
                    var attributes_2 = {};
                    [].forEach.call(parsedAttributes, function(attrib) {
                      if (attrib.name === "data-style") {
                        astNode.style = AST2.parseStyle(attrib.value);
                      } else {
                        attributes_2[attrib.name] = attrib.value;
                      }
                    });
                    astNode.attributes = attributes_2;
                  }
                  if (node.childNodes.length) {
                    var children_1 = [];
                    [].forEach.call(node.childNodes, function(childNode) {
                      appendChildNodes(childNode, children_1);
                    });
                    if (children_1.length) {
                      astNode.children = children_1;
                    }
                  }
                  addTo.push(astNode);
                };
                [].forEach.call(doc.body.childNodes, function(childNode) {
                  return appendChildNodes(childNode, nodes);
                });
                return nodes;
              };
              AST2.allowedAttributes = [
                "aria-controls",
                "aria-describedby",
                "aria-expanded",
                "aria-haspopup",
                "aria-hidden",
                "aria-label",
                "aria-labelledby",
                "aria-live",
                "aria-pressed",
                "aria-readonly",
                "aria-roledescription",
                "aria-selected",
                "class",
                "clip-path",
                "color",
                "colspan",
                "cx",
                "cy",
                "d",
                "dx",
                "dy",
                "disabled",
                "fill",
                "height",
                "href",
                "id",
                "in",
                "markerHeight",
                "markerWidth",
                "offset",
                "opacity",
                "orient",
                "padding",
                "paddingLeft",
                "paddingRight",
                "patternUnits",
                "r",
                "refX",
                "refY",
                "role",
                "scope",
                "slope",
                "src",
                "startOffset",
                "stdDeviation",
                "stroke",
                "stroke-linecap",
                "stroke-width",
                "style",
                "tableValues",
                "result",
                "rowspan",
                "summary",
                "target",
                "tabindex",
                "text-align",
                "text-anchor",
                "textAnchor",
                "textLength",
                "title",
                "type",
                "valign",
                "width",
                "x",
                "x1",
                "x2",
                "xlink:href",
                "y",
                "y1",
                "y2",
                "zIndex"
              ];
              AST2.allowedReferences = [
                "https://",
                "http://",
                "mailto:",
                "/",
                "../",
                "./",
                "#"
              ];
              AST2.allowedTags = [
                "a",
                "abbr",
                "b",
                "br",
                "button",
                "caption",
                "circle",
                "clipPath",
                "code",
                "dd",
                "defs",
                "div",
                "dl",
                "dt",
                "em",
                "feComponentTransfer",
                "feFuncA",
                "feFuncB",
                "feFuncG",
                "feFuncR",
                "feGaussianBlur",
                "feOffset",
                "feMerge",
                "feMergeNode",
                "filter",
                "h1",
                "h2",
                "h3",
                "h4",
                "h5",
                "h6",
                "hr",
                "i",
                "img",
                "li",
                "linearGradient",
                "marker",
                "ol",
                "p",
                "path",
                "pattern",
                "pre",
                "rect",
                "small",
                "span",
                "stop",
                "strong",
                "style",
                "sub",
                "sup",
                "svg",
                "table",
                "text",
                "textPath",
                "thead",
                "title",
                "tbody",
                "tspan",
                "td",
                "th",
                "tr",
                "u",
                "ul",
                "#text"
              ];
              AST2.emptyHTML = emptyHTML;
              AST2.bypassHTMLFiltering = false;
              return AST2;
            }()
          );
          "";
          return AST;
        });
        _registerModule(_modules, "Core/FormatUtilities.js", [_modules["Core/Defaults.js"], _modules["Core/Utilities.js"]], function(D, U) {
          var defaultOptions = D.defaultOptions, defaultTime = D.defaultTime;
          var getNestedProperty = U.getNestedProperty, isNumber = U.isNumber, pick = U.pick, pInt = U.pInt;
          function dateFormat(format4, timestamp, capitalize) {
            return defaultTime.dateFormat(format4, timestamp, capitalize);
          }
          function format3(str, ctx, chart) {
            var splitter = "{", isInside = false, segment, valueAndFormat, val, index;
            var floatRegex = /f$/;
            var decRegex = /\.([0-9])/;
            var lang = defaultOptions.lang;
            var time = chart && chart.time || defaultTime;
            var numberFormatter = chart && chart.numberFormatter || numberFormat;
            var ret = [];
            while (str) {
              index = str.indexOf(splitter);
              if (index === -1) {
                break;
              }
              segment = str.slice(0, index);
              if (isInside) {
                valueAndFormat = segment.split(":");
                val = getNestedProperty(valueAndFormat.shift() || "", ctx);
                if (valueAndFormat.length && typeof val === "number") {
                  segment = valueAndFormat.join(":");
                  if (floatRegex.test(segment)) {
                    var decimals = parseInt((segment.match(decRegex) || ["", "-1"])[1], 10);
                    if (val !== null) {
                      val = numberFormatter(val, decimals, lang.decimalPoint, segment.indexOf(",") > -1 ? lang.thousandsSep : "");
                    }
                  } else {
                    val = time.dateFormat(segment, val);
                  }
                }
                ret.push(val);
              } else {
                ret.push(segment);
              }
              str = str.slice(index + 1);
              isInside = !isInside;
              splitter = isInside ? "}" : "{";
            }
            ret.push(str);
            return ret.join("");
          }
          function numberFormat(number, decimals, decimalPoint, thousandsSep) {
            number = +number || 0;
            decimals = +decimals;
            var ret, fractionDigits;
            var lang = defaultOptions.lang, origDec = (number.toString().split(".")[1] || "").split("e")[0].length, exponent = number.toString().split("e"), firstDecimals = decimals;
            if (decimals === -1) {
              decimals = Math.min(origDec, 20);
            } else if (!isNumber(decimals)) {
              decimals = 2;
            } else if (decimals && exponent[1] && exponent[1] < 0) {
              fractionDigits = decimals + +exponent[1];
              if (fractionDigits >= 0) {
                exponent[0] = (+exponent[0]).toExponential(fractionDigits).split("e")[0];
                decimals = fractionDigits;
              } else {
                exponent[0] = exponent[0].split(".")[0] || 0;
                if (decimals < 20) {
                  number = (exponent[0] * Math.pow(10, exponent[1])).toFixed(decimals);
                } else {
                  number = 0;
                }
                exponent[1] = 0;
              }
            }
            var roundedNumber = (Math.abs(exponent[1] ? exponent[0] : number) + Math.pow(10, -Math.max(
              decimals,
              origDec
            ) - 1)).toFixed(decimals);
            var strinteger = String(pInt(roundedNumber));
            var thousands = strinteger.length > 3 ? strinteger.length % 3 : 0;
            decimalPoint = pick(decimalPoint, lang.decimalPoint);
            thousandsSep = pick(thousandsSep, lang.thousandsSep);
            ret = number < 0 ? "-" : "";
            ret += thousands ? strinteger.substr(0, thousands) + thousandsSep : "";
            if (+exponent[1] < 0 && !firstDecimals) {
              ret = "0";
            } else {
              ret += strinteger.substr(thousands).replace(/(\d{3})(?=\d)/g, "$1" + thousandsSep);
            }
            if (decimals) {
              ret += decimalPoint + roundedNumber.slice(-decimals);
            }
            if (exponent[1] && +ret !== 0) {
              ret += "e" + exponent[1];
            }
            return ret;
          }
          var FormatUtilities = {
            dateFormat,
            format: format3,
            numberFormat
          };
          return FormatUtilities;
        });
        _registerModule(_modules, "Core/Renderer/RendererUtilities.js", [_modules["Core/Utilities.js"]], function(U) {
          var clamp = U.clamp, pick = U.pick, stableSort = U.stableSort;
          var RendererUtilities;
          (function(RendererUtilities2) {
            function distribute(boxes, len, maxDistance) {
              var origBoxes = boxes, reducedLen = origBoxes.reducedLen || len, sortByRank = function(a, b) {
                return (b.rank || 0) - (a.rank || 0);
              }, sortByTarget = function(a, b) {
                return a.target - b.target;
              };
              var i, overlapping = true, restBoxes = [], box, target, total = 0;
              i = boxes.length;
              while (i--) {
                total += boxes[i].size;
              }
              if (total > reducedLen) {
                stableSort(boxes, sortByRank);
                i = 0;
                total = 0;
                while (total <= reducedLen) {
                  total += boxes[i].size;
                  i++;
                }
                restBoxes = boxes.splice(i - 1, boxes.length);
              }
              stableSort(boxes, sortByTarget);
              boxes = boxes.map(function(box2) {
                return {
                  size: box2.size,
                  targets: [box2.target],
                  align: pick(box2.align, 0.5)
                };
              });
              while (overlapping) {
                i = boxes.length;
                while (i--) {
                  box = boxes[i];
                  target = (Math.min.apply(0, box.targets) + Math.max.apply(0, box.targets)) / 2;
                  box.pos = clamp(target - box.size * box.align, 0, len - box.size);
                }
                i = boxes.length;
                overlapping = false;
                while (i--) {
                  if (i > 0 && boxes[i - 1].pos + boxes[i - 1].size > boxes[i].pos) {
                    boxes[i - 1].size += boxes[i].size;
                    boxes[i - 1].targets = boxes[i - 1].targets.concat(boxes[i].targets);
                    boxes[i - 1].align = 0.5;
                    if (boxes[i - 1].pos + boxes[i - 1].size > len) {
                      boxes[i - 1].pos = len - boxes[i - 1].size;
                    }
                    boxes.splice(i, 1);
                    overlapping = true;
                  }
                }
              }
              origBoxes.push.apply(origBoxes, restBoxes);
              i = 0;
              boxes.some(function(box2) {
                var posInCompositeBox = 0;
                return (box2.targets || []).some(function() {
                  origBoxes[i].pos = box2.pos + posInCompositeBox;
                  if (typeof maxDistance !== "undefined" && Math.abs(origBoxes[i].pos - origBoxes[i].target) > maxDistance) {
                    origBoxes.slice(0, i + 1).forEach(function(box3) {
                      return delete box3.pos;
                    });
                    origBoxes.reducedLen = (origBoxes.reducedLen || len) - len * 0.1;
                    if (origBoxes.reducedLen > len * 0.1) {
                      distribute(origBoxes, len, maxDistance);
                    }
                    return true;
                  }
                  posInCompositeBox += origBoxes[i].size;
                  i++;
                  return false;
                });
              });
              stableSort(origBoxes, sortByTarget);
              return origBoxes;
            }
            RendererUtilities2.distribute = distribute;
          })(RendererUtilities || (RendererUtilities = {}));
          return RendererUtilities;
        });
        _registerModule(_modules, "Core/Renderer/SVG/SVGElement.js", [_modules["Core/Animation/AnimationUtilities.js"], _modules["Core/Color/Color.js"], _modules["Core/Globals.js"], _modules["Core/Utilities.js"]], function(A, Color2, H, U) {
          var animate = A.animate, animObject = A.animObject, stop = A.stop;
          var deg2rad = H.deg2rad, doc = H.doc, noop2 = H.noop, svg = H.svg, SVG_NS = H.SVG_NS, win = H.win;
          var addEvent = U.addEvent, attr = U.attr, createElement = U.createElement, css = U.css, defined = U.defined, erase = U.erase, extend2 = U.extend, fireEvent = U.fireEvent, isArray = U.isArray, isFunction = U.isFunction, isNumber = U.isNumber, isString = U.isString, merge = U.merge, objectEach = U.objectEach, pick = U.pick, pInt = U.pInt, removeEvent = U.removeEvent, syncTimeout = U.syncTimeout, uniqueKey = U.uniqueKey;
          var SVGElement = (
            /** @class */
            function() {
              function SVGElement2() {
                this.element = void 0;
                this.onEvents = {};
                this.opacity = 1;
                this.renderer = void 0;
                this.SVG_NS = SVG_NS;
                this.symbolCustomAttribs = [
                  "x",
                  "y",
                  "width",
                  "height",
                  "r",
                  "start",
                  "end",
                  "innerR",
                  "anchorX",
                  "anchorY",
                  "rounded"
                ];
              }
              SVGElement2.prototype._defaultGetter = function(key) {
                var ret = pick(
                  this[key + "Value"],
                  // align getter
                  this[key],
                  this.element ? this.element.getAttribute(key) : null,
                  0
                );
                if (/^[\-0-9\.]+$/.test(ret)) {
                  ret = parseFloat(ret);
                }
                return ret;
              };
              SVGElement2.prototype._defaultSetter = function(value, key, element) {
                element.setAttribute(key, value);
              };
              SVGElement2.prototype.add = function(parent) {
                var renderer = this.renderer, element = this.element;
                var inserted;
                if (parent) {
                  this.parentGroup = parent;
                }
                if (typeof this.textStr !== "undefined" && this.element.nodeName === "text") {
                  renderer.buildText(this);
                }
                this.added = true;
                if (!parent || parent.handleZ || this.zIndex) {
                  inserted = this.zIndexSetter();
                }
                if (!inserted) {
                  (parent ? parent.element : renderer.box).appendChild(element);
                }
                if (this.onAdd) {
                  this.onAdd();
                }
                return this;
              };
              SVGElement2.prototype.addClass = function(className, replace) {
                var currentClassName = replace ? "" : this.attr("class") || "";
                className = (className || "").split(/ /g).reduce(function(newClassName, name) {
                  if (currentClassName.indexOf(name) === -1) {
                    newClassName.push(name);
                  }
                  return newClassName;
                }, currentClassName ? [currentClassName] : []).join(" ");
                if (className !== currentClassName) {
                  this.attr("class", className);
                }
                return this;
              };
              SVGElement2.prototype.afterSetters = function() {
                if (this.doTransform) {
                  this.updateTransform();
                  this.doTransform = false;
                }
              };
              SVGElement2.prototype.align = function(alignOptions, alignByTranslate, box) {
                var attribs = {}, renderer = this.renderer, alignedObjects = renderer.alignedObjects;
                var x, y, alignTo, alignFactor, vAlignFactor;
                if (alignOptions) {
                  this.alignOptions = alignOptions;
                  this.alignByTranslate = alignByTranslate;
                  if (!box || isString(box)) {
                    this.alignTo = alignTo = box || "renderer";
                    erase(alignedObjects, this);
                    alignedObjects.push(this);
                    box = void 0;
                  }
                } else {
                  alignOptions = this.alignOptions;
                  alignByTranslate = this.alignByTranslate;
                  alignTo = this.alignTo;
                }
                box = pick(box, renderer[alignTo], alignTo === "scrollablePlotBox" ? renderer.plotBox : void 0, renderer);
                var align = alignOptions.align, vAlign = alignOptions.verticalAlign;
                x = (box.x || 0) + (alignOptions.x || 0);
                y = (box.y || 0) + (alignOptions.y || 0);
                if (align === "right") {
                  alignFactor = 1;
                } else if (align === "center") {
                  alignFactor = 2;
                }
                if (alignFactor) {
                  x += (box.width - (alignOptions.width || 0)) / alignFactor;
                }
                attribs[alignByTranslate ? "translateX" : "x"] = Math.round(x);
                if (vAlign === "bottom") {
                  vAlignFactor = 1;
                } else if (vAlign === "middle") {
                  vAlignFactor = 2;
                }
                if (vAlignFactor) {
                  y += (box.height - (alignOptions.height || 0)) / vAlignFactor;
                }
                attribs[alignByTranslate ? "translateY" : "y"] = Math.round(y);
                this[this.placed ? "animate" : "attr"](attribs);
                this.placed = true;
                this.alignAttr = attribs;
                return this;
              };
              SVGElement2.prototype.alignSetter = function(value) {
                var convert = {
                  left: "start",
                  center: "middle",
                  right: "end"
                };
                if (convert[value]) {
                  this.alignValue = value;
                  this.element.setAttribute("text-anchor", convert[value]);
                }
              };
              SVGElement2.prototype.animate = function(params, options, complete) {
                var _this = this;
                var animOptions = animObject(pick(
                  options,
                  this.renderer.globalAnimation,
                  true
                )), deferTime = animOptions.defer;
                if (pick(doc.hidden, doc.msHidden, doc.webkitHidden, false)) {
                  animOptions.duration = 0;
                }
                if (animOptions.duration !== 0) {
                  if (complete) {
                    animOptions.complete = complete;
                  }
                  syncTimeout(function() {
                    if (_this.element) {
                      animate(_this, params, animOptions);
                    }
                  }, deferTime);
                } else {
                  this.attr(params, void 0, complete || animOptions.complete);
                  objectEach(params, function(val, prop) {
                    if (animOptions.step) {
                      animOptions.step.call(this, val, { prop, pos: 1, elem: this });
                    }
                  }, this);
                }
                return this;
              };
              SVGElement2.prototype.applyTextOutline = function(textOutline) {
                var elem = this.element, hasContrast = textOutline.indexOf("contrast") !== -1, styles = {};
                if (hasContrast) {
                  styles.textOutline = textOutline = textOutline.replace(/contrast/g, this.renderer.getContrast(elem.style.fill));
                }
                var parts = textOutline.split(" ");
                var color2 = parts[parts.length - 1];
                var strokeWidth = parts[0];
                if (strokeWidth && strokeWidth !== "none" && H.svg) {
                  this.fakeTS = true;
                  strokeWidth = strokeWidth.replace(/(^[\d\.]+)(.*?)$/g, function(match, digit, unit) {
                    return 2 * Number(digit) + unit;
                  });
                  this.removeTextOutline();
                  var outline_1 = doc.createElementNS(SVG_NS, "tspan");
                  attr(outline_1, {
                    "class": "highcharts-text-outline",
                    fill: color2,
                    stroke: color2,
                    "stroke-width": strokeWidth,
                    "stroke-linejoin": "round"
                  });
                  var parentElem = elem.querySelector("textPath") || elem;
                  [].forEach.call(parentElem.childNodes, function(childNode) {
                    var clone = childNode.cloneNode(true);
                    if (clone.removeAttribute) {
                      ["fill", "stroke", "stroke-width", "stroke"].forEach(function(prop) {
                        return clone.removeAttribute(prop);
                      });
                    }
                    outline_1.appendChild(clone);
                  });
                  var totalHeight_1 = 0;
                  [].forEach.call(parentElem.querySelectorAll("text tspan"), function(element) {
                    totalHeight_1 += Number(element.getAttribute("dy"));
                  });
                  var br = doc.createElementNS(SVG_NS, "tspan");
                  br.textContent = "\u200B";
                  attr(br, {
                    x: Number(elem.getAttribute("x")),
                    dy: -totalHeight_1
                  });
                  outline_1.appendChild(br);
                  parentElem.insertBefore(outline_1, parentElem.firstChild);
                }
              };
              SVGElement2.prototype.attr = function(hash, val, complete, continueAnimation) {
                var element = this.element, symbolCustomAttribs = this.symbolCustomAttribs;
                var key, hasSetSymbolSize, ret = this, skipAttr, setter;
                if (typeof hash === "string" && typeof val !== "undefined") {
                  key = hash;
                  hash = {};
                  hash[key] = val;
                }
                if (typeof hash === "string") {
                  ret = (this[hash + "Getter"] || this._defaultGetter).call(this, hash, element);
                } else {
                  objectEach(hash, function eachAttribute(val2, key2) {
                    skipAttr = false;
                    if (!continueAnimation) {
                      stop(this, key2);
                    }
                    if (this.symbolName && symbolCustomAttribs.indexOf(key2) !== -1) {
                      if (!hasSetSymbolSize) {
                        this.symbolAttr(hash);
                        hasSetSymbolSize = true;
                      }
                      skipAttr = true;
                    }
                    if (this.rotation && (key2 === "x" || key2 === "y")) {
                      this.doTransform = true;
                    }
                    if (!skipAttr) {
                      setter = this[key2 + "Setter"] || this._defaultSetter;
                      setter.call(this, val2, key2, element);
                      if (!this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(key2)) {
                        this.updateShadows(key2, val2, setter);
                      }
                    }
                  }, this);
                  this.afterSetters();
                }
                if (complete) {
                  complete.call(this);
                }
                return ret;
              };
              SVGElement2.prototype.clip = function(clipRect) {
                return this.attr("clip-path", clipRect ? "url(" + this.renderer.url + "#" + clipRect.id + ")" : "none");
              };
              SVGElement2.prototype.crisp = function(rect, strokeWidth) {
                var wrapper = this;
                strokeWidth = strokeWidth || rect.strokeWidth || 0;
                var normalizer = Math.round(strokeWidth) % 2 / 2;
                rect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;
                rect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;
                rect.width = Math.floor((rect.width || wrapper.width || 0) - 2 * normalizer);
                rect.height = Math.floor((rect.height || wrapper.height || 0) - 2 * normalizer);
                if (defined(rect.strokeWidth)) {
                  rect.strokeWidth = strokeWidth;
                }
                return rect;
              };
              SVGElement2.prototype.complexColor = function(colorOptions, prop, elem) {
                var renderer = this.renderer;
                var colorObject, gradName, gradAttr, radAttr, gradients, stops, stopColor, stopOpacity, radialReference, id2, key = [], value;
                fireEvent(this.renderer, "complexColor", {
                  args: arguments
                }, function() {
                  if (colorOptions.radialGradient) {
                    gradName = "radialGradient";
                  } else if (colorOptions.linearGradient) {
                    gradName = "linearGradient";
                  }
                  if (gradName) {
                    gradAttr = colorOptions[gradName];
                    gradients = renderer.gradients;
                    stops = colorOptions.stops;
                    radialReference = elem.radialReference;
                    if (isArray(gradAttr)) {
                      colorOptions[gradName] = gradAttr = {
                        x1: gradAttr[0],
                        y1: gradAttr[1],
                        x2: gradAttr[2],
                        y2: gradAttr[3],
                        gradientUnits: "userSpaceOnUse"
                      };
                    }
                    if (gradName === "radialGradient" && radialReference && !defined(gradAttr.gradientUnits)) {
                      radAttr = gradAttr;
                      gradAttr = merge(gradAttr, renderer.getRadialAttr(radialReference, radAttr), { gradientUnits: "userSpaceOnUse" });
                    }
                    objectEach(gradAttr, function(value2, n) {
                      if (n !== "id") {
                        key.push(n, value2);
                      }
                    });
                    objectEach(stops, function(val) {
                      key.push(val);
                    });
                    key = key.join(",");
                    if (gradients[key]) {
                      id2 = gradients[key].attr("id");
                    } else {
                      gradAttr.id = id2 = uniqueKey();
                      var gradientObject_1 = gradients[key] = renderer.createElement(gradName).attr(gradAttr).add(renderer.defs);
                      gradientObject_1.radAttr = radAttr;
                      gradientObject_1.stops = [];
                      stops.forEach(function(stop2) {
                        if (stop2[1].indexOf("rgba") === 0) {
                          colorObject = Color2.parse(stop2[1]);
                          stopColor = colorObject.get("rgb");
                          stopOpacity = colorObject.get("a");
                        } else {
                          stopColor = stop2[1];
                          stopOpacity = 1;
                        }
                        var stopObject = renderer.createElement("stop").attr({
                          offset: stop2[0],
                          "stop-color": stopColor,
                          "stop-opacity": stopOpacity
                        }).add(gradientObject_1);
                        gradientObject_1.stops.push(stopObject);
                      });
                    }
                    value = "url(" + renderer.url + "#" + id2 + ")";
                    elem.setAttribute(prop, value);
                    elem.gradient = key;
                    colorOptions.toString = function() {
                      return value;
                    };
                  }
                });
              };
              SVGElement2.prototype.css = function(styles) {
                var oldStyles = this.styles, newStyles = {}, elem = this.element;
                var textWidth, hasNew = !oldStyles;
                if (styles.color) {
                  styles.fill = styles.color;
                }
                if (oldStyles) {
                  objectEach(styles, function(value, n) {
                    if (oldStyles && oldStyles[n] !== value) {
                      newStyles[n] = value;
                      hasNew = true;
                    }
                  });
                }
                if (hasNew) {
                  if (oldStyles) {
                    styles = extend2(oldStyles, newStyles);
                  }
                  if (styles.width === null || styles.width === "auto") {
                    delete this.textWidth;
                  } else if (elem.nodeName.toLowerCase() === "text" && styles.width) {
                    textWidth = this.textWidth = pInt(styles.width);
                  }
                  this.styles = styles;
                  if (textWidth && (!svg && this.renderer.forExport)) {
                    delete styles.width;
                  }
                  var stylesToApply_1 = merge(styles);
                  if (elem.namespaceURI === this.SVG_NS) {
                    ["textOutline", "textOverflow", "width"].forEach(function(key) {
                      return stylesToApply_1 && delete stylesToApply_1[key];
                    });
                  }
                  css(elem, stylesToApply_1);
                  if (this.added) {
                    if (this.element.nodeName === "text") {
                      this.renderer.buildText(this);
                    }
                    if (styles.textOutline) {
                      this.applyTextOutline(styles.textOutline);
                    }
                  }
                }
                return this;
              };
              SVGElement2.prototype.dashstyleSetter = function(value) {
                var i, strokeWidth = this["stroke-width"];
                if (strokeWidth === "inherit") {
                  strokeWidth = 1;
                }
                value = value && value.toLowerCase();
                if (value) {
                  var v = value.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
                  i = v.length;
                  while (i--) {
                    v[i] = "" + pInt(v[i]) * pick(strokeWidth, NaN);
                  }
                  value = v.join(",").replace(/NaN/g, "none");
                  this.element.setAttribute("stroke-dasharray", value);
                }
              };
              SVGElement2.prototype.destroy = function() {
                var wrapper = this, element = wrapper.element || {}, renderer = wrapper.renderer, ownerSVGElement = element.ownerSVGElement;
                var parentToClean = renderer.isSVG && element.nodeName === "SPAN" && wrapper.parentGroup || void 0, grandParent, i;
                element.onclick = element.onmouseout = element.onmouseover = element.onmousemove = element.point = null;
                stop(wrapper);
                if (wrapper.clipPath && ownerSVGElement) {
                  var clipPath_1 = wrapper.clipPath;
                  [].forEach.call(ownerSVGElement.querySelectorAll("[clip-path],[CLIP-PATH]"), function(el) {
                    if (el.getAttribute("clip-path").indexOf(clipPath_1.element.id) > -1) {
                      el.removeAttribute("clip-path");
                    }
                  });
                  wrapper.clipPath = clipPath_1.destroy();
                }
                if (wrapper.stops) {
                  for (i = 0; i < wrapper.stops.length; i++) {
                    wrapper.stops[i].destroy();
                  }
                  wrapper.stops.length = 0;
                  wrapper.stops = void 0;
                }
                wrapper.safeRemoveChild(element);
                if (!renderer.styledMode) {
                  wrapper.destroyShadows();
                }
                while (parentToClean && parentToClean.div && parentToClean.div.childNodes.length === 0) {
                  grandParent = parentToClean.parentGroup;
                  wrapper.safeRemoveChild(parentToClean.div);
                  delete parentToClean.div;
                  parentToClean = grandParent;
                }
                if (wrapper.alignTo) {
                  erase(renderer.alignedObjects, wrapper);
                }
                objectEach(wrapper, function(val, key) {
                  if (wrapper[key] && wrapper[key].parentGroup === wrapper && wrapper[key].destroy) {
                    wrapper[key].destroy();
                  }
                  delete wrapper[key];
                });
                return;
              };
              SVGElement2.prototype.destroyShadows = function() {
                (this.shadows || []).forEach(function(shadow) {
                  this.safeRemoveChild(shadow);
                }, this);
                this.shadows = void 0;
              };
              SVGElement2.prototype.dSetter = function(value, key, element) {
                if (isArray(value)) {
                  if (typeof value[0] === "string") {
                    value = this.renderer.pathToSegments(value);
                  }
                  this.pathArray = value;
                  value = value.reduce(function(acc, seg, i) {
                    if (!seg || !seg.join) {
                      return (seg || "").toString();
                    }
                    return (i ? acc + " " : "") + seg.join(" ");
                  }, "");
                }
                if (/(NaN| {2}|^$)/.test(value)) {
                  value = "M 0 0";
                }
                if (this[key] !== value) {
                  element.setAttribute(key, value);
                  this[key] = value;
                }
              };
              SVGElement2.prototype.fadeOut = function(duration) {
                var elemWrapper = this;
                elemWrapper.animate({
                  opacity: 0
                }, {
                  duration: pick(duration, 150),
                  complete: function() {
                    elemWrapper.hide();
                  }
                });
              };
              SVGElement2.prototype.fillSetter = function(value, key, element) {
                if (typeof value === "string") {
                  element.setAttribute(key, value);
                } else if (value) {
                  this.complexColor(value, key, element);
                }
              };
              SVGElement2.prototype.getBBox = function(reload, rot) {
                var wrapper = this, alignValue = wrapper.alignValue, element = wrapper.element, renderer = wrapper.renderer, styles = wrapper.styles, textStr = wrapper.textStr, cache = renderer.cache, cacheKeys = renderer.cacheKeys, isSVG = element.namespaceURI === wrapper.SVG_NS, rotation = pick(
                  rot,
                  wrapper.rotation,
                  0
                ), fontSize = renderer.styledMode ? element && SVGElement2.prototype.getStyle.call(element, "font-size") : styles && styles.fontSize;
                var bBox, width, height, toggleTextShadowShim, cacheKey;
                if (defined(textStr)) {
                  cacheKey = textStr.toString();
                  if (cacheKey.indexOf("<") === -1) {
                    cacheKey = cacheKey.replace(/[0-9]/g, "0");
                  }
                  cacheKey += [
                    "",
                    rotation,
                    fontSize,
                    wrapper.textWidth,
                    alignValue,
                    styles && styles.textOverflow,
                    styles && styles.fontWeight
                    // #12163
                  ].join(",");
                }
                if (cacheKey && !reload) {
                  bBox = cache[cacheKey];
                }
                if (!bBox) {
                  if (isSVG || renderer.forExport) {
                    try {
                      toggleTextShadowShim = this.fakeTS && function(display) {
                        var outline = element.querySelector(".highcharts-text-outline");
                        if (outline) {
                          css(outline, { display });
                        }
                      };
                      if (isFunction(toggleTextShadowShim)) {
                        toggleTextShadowShim("none");
                      }
                      bBox = element.getBBox ? (
                        // SVG: use extend because IE9 is not allowed to change
                        // width and height in case of rotation (below)
                        extend2({}, element.getBBox())
                      ) : {
                        // HTML elements with `exporting.allowHTML` and
                        // legacy IE in export mode
                        width: element.offsetWidth,
                        height: element.offsetHeight,
                        x: 0,
                        y: 0
                      };
                      if (isFunction(toggleTextShadowShim)) {
                        toggleTextShadowShim("");
                      }
                    } catch (e) {
                      "";
                    }
                    if (!bBox || bBox.width < 0) {
                      bBox = { x: 0, y: 0, width: 0, height: 0 };
                    }
                  } else {
                    bBox = wrapper.htmlGetBBox();
                  }
                  if (renderer.isSVG) {
                    width = bBox.width;
                    height = bBox.height;
                    if (isSVG) {
                      bBox.height = height = {
                        "11px,17": 14,
                        "13px,20": 16
                      }["" + (fontSize || "") + ",".concat(Math.round(height))] || height;
                    }
                    if (rotation) {
                      var baseline = Number(element.getAttribute("y") || 0) - bBox.y, alignFactor = {
                        "right": 1,
                        "center": 0.5
                      }[alignValue || 0] || 0, rad = rotation * deg2rad, rad90 = (rotation - 90) * deg2rad, wCosRad = width * Math.cos(rad), wSinRad = width * Math.sin(rad), cosRad90 = Math.cos(rad90), sinRad90 = Math.sin(rad90), pX = bBox.x + alignFactor * (width - wCosRad), pY = bBox.y + baseline - alignFactor * wSinRad, aX = pX + baseline * cosRad90, bX = aX + wCosRad, cX = bX - height * cosRad90, dX = cX - wCosRad, aY = pY + baseline * sinRad90, bY = aY + wSinRad, cY = bY - height * sinRad90, dY = cY - wSinRad;
                      bBox.x = Math.min(aX, bX, cX, dX);
                      bBox.y = Math.min(aY, bY, cY, dY);
                      bBox.width = Math.max(aX, bX, cX, dX) - bBox.x;
                      bBox.height = Math.max(aY, bY, cY, dY) - bBox.y;
                    }
                  }
                  if (cacheKey && (textStr === "" || bBox.height > 0)) {
                    while (cacheKeys.length > 250) {
                      delete cache[cacheKeys.shift()];
                    }
                    if (!cache[cacheKey]) {
                      cacheKeys.push(cacheKey);
                    }
                    cache[cacheKey] = bBox;
                  }
                }
                return bBox;
              };
              SVGElement2.prototype.getStyle = function(prop) {
                return win.getComputedStyle(this.element || this, "").getPropertyValue(prop);
              };
              SVGElement2.prototype.hasClass = function(className) {
                return ("" + this.attr("class")).split(" ").indexOf(className) !== -1;
              };
              SVGElement2.prototype.hide = function() {
                return this.attr({ visibility: "hidden" });
              };
              SVGElement2.prototype.htmlGetBBox = function() {
                return { height: 0, width: 0, x: 0, y: 0 };
              };
              SVGElement2.prototype.init = function(renderer, nodeName) {
                this.element = nodeName === "span" ? createElement(nodeName) : doc.createElementNS(this.SVG_NS, nodeName);
                this.renderer = renderer;
                fireEvent(this, "afterInit");
              };
              SVGElement2.prototype.on = function(eventType, handler) {
                var onEvents = this.onEvents;
                if (onEvents[eventType]) {
                  onEvents[eventType]();
                }
                onEvents[eventType] = addEvent(this.element, eventType, handler);
                return this;
              };
              SVGElement2.prototype.opacitySetter = function(value, key, element) {
                var opacity = Number(Number(value).toFixed(3));
                this.opacity = opacity;
                element.setAttribute(key, opacity);
              };
              SVGElement2.prototype.removeClass = function(className) {
                return this.attr("class", ("" + this.attr("class")).replace(isString(className) ? new RegExp("(^| )".concat(className, "( |$)")) : (
                  // #12064, #13590
                  className
                ), " ").replace(/ +/g, " ").trim());
              };
              SVGElement2.prototype.removeTextOutline = function() {
                var outline = this.element.querySelector("tspan.highcharts-text-outline");
                if (outline) {
                  this.safeRemoveChild(outline);
                }
              };
              SVGElement2.prototype.safeRemoveChild = function(element) {
                var parentNode = element.parentNode;
                if (parentNode) {
                  parentNode.removeChild(element);
                }
              };
              SVGElement2.prototype.setRadialReference = function(coordinates) {
                var existingGradient = this.element.gradient && this.renderer.gradients[this.element.gradient];
                this.element.radialReference = coordinates;
                if (existingGradient && existingGradient.radAttr) {
                  existingGradient.animate(this.renderer.getRadialAttr(coordinates, existingGradient.radAttr));
                }
                return this;
              };
              SVGElement2.prototype.setTextPath = function(path, textPathOptions) {
                var _this = this;
                textPathOptions = merge(true, {
                  enabled: true,
                  attributes: {
                    dy: -5,
                    startOffset: "50%",
                    textAnchor: "middle"
                  }
                }, textPathOptions);
                var url = this.renderer.url, textWrapper = this.text || this, textPath = textWrapper.textPath, attributes = textPathOptions.attributes, enabled = textPathOptions.enabled;
                path = path || textPath && textPath.path;
                if (textPath) {
                  textPath.undo();
                }
                if (path && enabled) {
                  var undo = addEvent(
                    textWrapper,
                    "afterModifyTree",
                    function(e) {
                      if (path && enabled) {
                        var textPathId = path.attr("id");
                        if (!textPathId) {
                          path.attr("id", textPathId = uniqueKey());
                        }
                        var textAttribs = {
                          // dx/dy options must by set on <text> (parent), the
                          // rest should be set on <textPath>
                          x: 0,
                          y: 0
                        };
                        if (defined(attributes.dx)) {
                          textAttribs.dx = attributes.dx;
                          delete attributes.dx;
                        }
                        if (defined(attributes.dy)) {
                          textAttribs.dy = attributes.dy;
                          delete attributes.dy;
                        }
                        textWrapper.attr(textAttribs);
                        _this.attr({ transform: "" });
                        if (_this.box) {
                          _this.box = _this.box.destroy();
                        }
                        var children2 = e.nodes.slice(0);
                        e.nodes.length = 0;
                        e.nodes[0] = {
                          tagName: "textPath",
                          attributes: extend2(attributes, {
                            "text-anchor": attributes.textAnchor,
                            href: "" + url + "#".concat(textPathId)
                          }),
                          children: children2
                        };
                      }
                    }
                  );
                  textWrapper.textPath = { path, undo };
                } else {
                  textWrapper.attr({ dx: 0, dy: 0 });
                  delete textWrapper.textPath;
                }
                if (this.added) {
                  textWrapper.textCache = "";
                  this.renderer.buildText(textWrapper);
                }
                return this;
              };
              SVGElement2.prototype.shadow = function(shadowOptions, group, cutOff) {
                var shadows = [], _a = this, element = _a.element, oldShadowOptions = _a.oldShadowOptions, parentGroup = _a.parentGroup, parentInverted = parentGroup && parentGroup.rotation === 90, defaultShadowOptions = {
                  color: "#000000",
                  offsetX: parentInverted ? -1 : 1,
                  offsetY: parentInverted ? -1 : 1,
                  opacity: 0.15,
                  width: 3
                };
                var i, shadow, strokeWidth, shadowElementOpacity, update = false, transform, options;
                if (shadowOptions === true) {
                  options = defaultShadowOptions;
                } else if (typeof shadowOptions === "object") {
                  options = extend2(defaultShadowOptions, shadowOptions);
                }
                if (options) {
                  if (options && oldShadowOptions) {
                    objectEach(options, function(value, key) {
                      if (value !== oldShadowOptions[key]) {
                        update = true;
                      }
                    });
                  }
                  if (update) {
                    this.destroyShadows();
                  }
                  this.oldShadowOptions = options;
                }
                if (!options) {
                  this.destroyShadows();
                } else if (!this.shadows) {
                  shadowElementOpacity = options.opacity / options.width;
                  transform = parentInverted ? "translate(".concat(options.offsetY, ", ").concat(options.offsetX, ")") : "translate(".concat(options.offsetX, ", ").concat(options.offsetY, ")");
                  for (i = 1; i <= options.width; i++) {
                    shadow = element.cloneNode(false);
                    strokeWidth = options.width * 2 + 1 - 2 * i;
                    attr(shadow, {
                      stroke: shadowOptions.color || "#000000",
                      "stroke-opacity": shadowElementOpacity * i,
                      "stroke-width": strokeWidth,
                      transform,
                      fill: "none"
                    });
                    shadow.setAttribute("class", (shadow.getAttribute("class") || "") + " highcharts-shadow");
                    if (cutOff) {
                      attr(shadow, "height", Math.max(attr(shadow, "height") - strokeWidth, 0));
                      shadow.cutHeight = strokeWidth;
                    }
                    if (group) {
                      group.element.appendChild(shadow);
                    } else if (element.parentNode) {
                      element.parentNode.insertBefore(shadow, element);
                    }
                    shadows.push(shadow);
                  }
                  this.shadows = shadows;
                }
                return this;
              };
              SVGElement2.prototype.show = function(inherit2) {
                if (inherit2 === void 0) {
                  inherit2 = true;
                }
                return this.attr({ visibility: inherit2 ? "inherit" : "visible" });
              };
              SVGElement2.prototype["stroke-widthSetter"] = function(value, key, element) {
                this[key] = value;
                element.setAttribute(key, value);
              };
              SVGElement2.prototype.strokeWidth = function() {
                if (!this.renderer.styledMode) {
                  return this["stroke-width"] || 0;
                }
                var val = this.getStyle("stroke-width");
                var ret = 0, dummy;
                if (val.indexOf("px") === val.length - 2) {
                  ret = pInt(val);
                } else if (val !== "") {
                  dummy = doc.createElementNS(SVG_NS, "rect");
                  attr(dummy, {
                    width: val,
                    "stroke-width": 0
                  });
                  this.element.parentNode.appendChild(dummy);
                  ret = dummy.getBBox().width;
                  dummy.parentNode.removeChild(dummy);
                }
                return ret;
              };
              SVGElement2.prototype.symbolAttr = function(hash) {
                var wrapper = this;
                [
                  "x",
                  "y",
                  "r",
                  "start",
                  "end",
                  "width",
                  "height",
                  "innerR",
                  "anchorX",
                  "anchorY",
                  "clockwise"
                ].forEach(function(key) {
                  wrapper[key] = pick(hash[key], wrapper[key]);
                });
                wrapper.attr({
                  d: wrapper.renderer.symbols[wrapper.symbolName](wrapper.x, wrapper.y, wrapper.width, wrapper.height, wrapper)
                });
              };
              SVGElement2.prototype.textSetter = function(value) {
                if (value !== this.textStr) {
                  delete this.textPxLength;
                  this.textStr = value;
                  if (this.added) {
                    this.renderer.buildText(this);
                  }
                }
              };
              SVGElement2.prototype.titleSetter = function(value) {
                var el = this.element;
                var titleNode = el.getElementsByTagName("title")[0] || doc.createElementNS(this.SVG_NS, "title");
                if (el.insertBefore) {
                  el.insertBefore(titleNode, el.firstChild);
                } else {
                  el.appendChild(titleNode);
                }
                titleNode.textContent = // #3276, #3895
                String(pick(value, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
              };
              SVGElement2.prototype.toFront = function() {
                var element = this.element;
                element.parentNode.appendChild(element);
                return this;
              };
              SVGElement2.prototype.translate = function(x, y) {
                return this.attr({
                  translateX: x,
                  translateY: y
                });
              };
              SVGElement2.prototype.updateShadows = function(key, value, setter) {
                var shadows = this.shadows;
                if (shadows) {
                  var i = shadows.length;
                  while (i--) {
                    setter.call(shadows[i], key === "height" ? Math.max(value - (shadows[i].cutHeight || 0), 0) : key === "d" ? this.d : value, key, shadows[i]);
                  }
                }
              };
              SVGElement2.prototype.updateTransform = function() {
                var _a = this, element = _a.element, matrix = _a.matrix, _b = _a.rotation, rotation = _b === void 0 ? 0 : _b, scaleX = _a.scaleX, scaleY = _a.scaleY, _c = _a.translateX, translateX = _c === void 0 ? 0 : _c, _d = _a.translateY, translateY = _d === void 0 ? 0 : _d;
                var transform = ["translate(" + translateX + "," + translateY + ")"];
                if (defined(matrix)) {
                  transform.push("matrix(" + matrix.join(",") + ")");
                }
                if (rotation) {
                  transform.push("rotate(" + rotation + " " + pick(this.rotationOriginX, element.getAttribute("x"), 0) + " " + pick(this.rotationOriginY, element.getAttribute("y") || 0) + ")");
                }
                if (defined(scaleX) || defined(scaleY)) {
                  transform.push("scale(" + pick(scaleX, 1) + " " + pick(scaleY, 1) + ")");
                }
                if (transform.length && !(this.text || this).textPath) {
                  element.setAttribute("transform", transform.join(" "));
                }
              };
              SVGElement2.prototype.visibilitySetter = function(value, key, element) {
                if (value === "inherit") {
                  element.removeAttribute(key);
                } else if (this[key] !== value) {
                  element.setAttribute(key, value);
                }
                this[key] = value;
              };
              SVGElement2.prototype.xGetter = function(key) {
                if (this.element.nodeName === "circle") {
                  if (key === "x") {
                    key = "cx";
                  } else if (key === "y") {
                    key = "cy";
                  }
                }
                return this._defaultGetter(key);
              };
              SVGElement2.prototype.zIndexSetter = function(value, key) {
                var renderer = this.renderer, parentGroup = this.parentGroup, parentWrapper = parentGroup || renderer, parentNode = parentWrapper.element || renderer.box, element = this.element, svgParent = parentNode === renderer.box;
                var childNodes, otherElement, otherZIndex, inserted = false, undefinedOtherZIndex, run = this.added, i;
                if (defined(value)) {
                  element.setAttribute("data-z-index", value);
                  value = +value;
                  if (this[key] === value) {
                    run = false;
                  }
                } else if (defined(this[key])) {
                  element.removeAttribute("data-z-index");
                }
                this[key] = value;
                if (run) {
                  value = this.zIndex;
                  if (value && parentGroup) {
                    parentGroup.handleZ = true;
                  }
                  childNodes = parentNode.childNodes;
                  for (i = childNodes.length - 1; i >= 0 && !inserted; i--) {
                    otherElement = childNodes[i];
                    otherZIndex = otherElement.getAttribute("data-z-index");
                    undefinedOtherZIndex = !defined(otherZIndex);
                    if (otherElement !== element) {
                      if (
                        // Negative zIndex versus no zIndex:
                        // On all levels except the highest. If the parent is
                        // <svg>, then we don't want to put items before <desc>
                        // or <defs>
                        value < 0 && undefinedOtherZIndex && !svgParent && !i
                      ) {
                        parentNode.insertBefore(element, childNodes[i]);
                        inserted = true;
                      } else if (
                        // Insert after the first element with a lower zIndex
                        pInt(otherZIndex) <= value || // If negative zIndex, add this before first undefined
                        // zIndex element
                        undefinedOtherZIndex && (!defined(value) || value >= 0)
                      ) {
                        parentNode.insertBefore(
                          element,
                          childNodes[i + 1] || null
                          // null for oldIE export
                        );
                        inserted = true;
                      }
                    }
                  }
                  if (!inserted) {
                    parentNode.insertBefore(
                      element,
                      childNodes[svgParent ? 3 : 0] || null
                      // null for oldIE
                    );
                    inserted = true;
                  }
                }
                return inserted;
              };
              return SVGElement2;
            }()
          );
          SVGElement.prototype.strokeSetter = SVGElement.prototype.fillSetter;
          SVGElement.prototype.yGetter = SVGElement.prototype.xGetter;
          SVGElement.prototype.matrixSetter = SVGElement.prototype.rotationOriginXSetter = SVGElement.prototype.rotationOriginYSetter = SVGElement.prototype.rotationSetter = SVGElement.prototype.scaleXSetter = SVGElement.prototype.scaleYSetter = SVGElement.prototype.translateXSetter = SVGElement.prototype.translateYSetter = SVGElement.prototype.verticalAlignSetter = function(value, key) {
            this[key] = value;
            this.doTransform = true;
          };
          "";
          return SVGElement;
        });
        _registerModule(_modules, "Core/Renderer/RendererRegistry.js", [_modules["Core/Globals.js"]], function(H) {
          var RendererRegistry;
          (function(RendererRegistry2) {
            RendererRegistry2.rendererTypes = {};
            var defaultRenderer;
            function getRendererType(rendererType) {
              if (rendererType === void 0) {
                rendererType = defaultRenderer;
              }
              return RendererRegistry2.rendererTypes[rendererType] || RendererRegistry2.rendererTypes[defaultRenderer];
            }
            RendererRegistry2.getRendererType = getRendererType;
            function registerRendererType(rendererType, rendererClass, setAsDefault) {
              RendererRegistry2.rendererTypes[rendererType] = rendererClass;
              if (!defaultRenderer || setAsDefault) {
                defaultRenderer = rendererType;
                H.Renderer = rendererClass;
              }
            }
            RendererRegistry2.registerRendererType = registerRendererType;
          })(RendererRegistry || (RendererRegistry = {}));
          return RendererRegistry;
        });
        _registerModule(_modules, "Core/Renderer/SVG/SVGLabel.js", [_modules["Core/Renderer/SVG/SVGElement.js"], _modules["Core/Utilities.js"]], function(SVGElement, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var defined = U.defined, extend2 = U.extend, isNumber = U.isNumber, merge = U.merge, pick = U.pick, removeEvent = U.removeEvent;
          var SVGLabel = (
            /** @class */
            function(_super) {
              __extends(SVGLabel2, _super);
              function SVGLabel2(renderer, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
                var _this = _super.call(this) || this;
                _this.paddingLeftSetter = _this.paddingSetter;
                _this.paddingRightSetter = _this.paddingSetter;
                _this.init(renderer, "g");
                _this.textStr = str;
                _this.x = x;
                _this.y = y;
                _this.anchorX = anchorX;
                _this.anchorY = anchorY;
                _this.baseline = baseline;
                _this.className = className;
                _this.addClass(className === "button" ? "highcharts-no-tooltip" : "highcharts-label");
                if (className) {
                  _this.addClass("highcharts-" + className);
                }
                _this.text = renderer.text(void 0, 0, 0, useHTML).attr({ zIndex: 1 });
                var hasBGImage;
                if (typeof shape === "string") {
                  hasBGImage = /^url\((.*?)\)$/.test(shape);
                  if (hasBGImage || _this.renderer.symbols[shape]) {
                    _this.symbolKey = shape;
                  }
                }
                _this.bBox = SVGLabel2.emptyBBox;
                _this.padding = 3;
                _this.baselineOffset = 0;
                _this.needsBox = renderer.styledMode || hasBGImage;
                _this.deferredAttr = {};
                _this.alignFactor = 0;
                return _this;
              }
              SVGLabel2.prototype.alignSetter = function(value) {
                var alignFactor = {
                  left: 0,
                  center: 0.5,
                  right: 1
                }[value];
                if (alignFactor !== this.alignFactor) {
                  this.alignFactor = alignFactor;
                  if (this.bBox && isNumber(this.xSetting)) {
                    this.attr({ x: this.xSetting });
                  }
                }
              };
              SVGLabel2.prototype.anchorXSetter = function(value, key) {
                this.anchorX = value;
                this.boxAttr(key, Math.round(value) - this.getCrispAdjust() - this.xSetting);
              };
              SVGLabel2.prototype.anchorYSetter = function(value, key) {
                this.anchorY = value;
                this.boxAttr(key, value - this.ySetting);
              };
              SVGLabel2.prototype.boxAttr = function(key, value) {
                if (this.box) {
                  this.box.attr(key, value);
                } else {
                  this.deferredAttr[key] = value;
                }
              };
              SVGLabel2.prototype.css = function(styles) {
                if (styles) {
                  var textStyles_1 = {};
                  styles = merge(styles);
                  SVGLabel2.textProps.forEach(function(prop) {
                    if (typeof styles[prop] !== "undefined") {
                      textStyles_1[prop] = styles[prop];
                      delete styles[prop];
                    }
                  });
                  this.text.css(textStyles_1);
                  if ("fontSize" in textStyles_1 || "fontWeight" in textStyles_1) {
                    this.updateTextPadding();
                  } else if ("width" in textStyles_1 || "textOverflow" in textStyles_1) {
                    this.updateBoxSize();
                  }
                }
                return SVGElement.prototype.css.call(this, styles);
              };
              SVGLabel2.prototype.destroy = function() {
                removeEvent(this.element, "mouseenter");
                removeEvent(this.element, "mouseleave");
                if (this.text) {
                  this.text.destroy();
                }
                if (this.box) {
                  this.box = this.box.destroy();
                }
                SVGElement.prototype.destroy.call(this);
                return void 0;
              };
              SVGLabel2.prototype.fillSetter = function(value, key) {
                if (value) {
                  this.needsBox = true;
                }
                this.fill = value;
                this.boxAttr(key, value);
              };
              SVGLabel2.prototype.getBBox = function() {
                if (this.textStr && this.bBox.width === 0 && this.bBox.height === 0) {
                  this.updateBoxSize();
                }
                var padding = this.padding;
                var paddingLeft = pick(
                  this.paddingLeft,
                  padding
                );
                return {
                  width: this.width,
                  height: this.height,
                  x: this.bBox.x - paddingLeft,
                  y: this.bBox.y - padding
                };
              };
              SVGLabel2.prototype.getCrispAdjust = function() {
                return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
              };
              SVGLabel2.prototype.heightSetter = function(value) {
                this.heightSetting = value;
              };
              SVGLabel2.prototype.onAdd = function() {
                this.text.add(this);
                this.attr({
                  // Alignment is available now  (#3295, 0 not rendered if given
                  // as a value)
                  text: pick(this.textStr, ""),
                  x: this.x || 0,
                  y: this.y || 0
                });
                if (this.box && defined(this.anchorX)) {
                  this.attr({
                    anchorX: this.anchorX,
                    anchorY: this.anchorY
                  });
                }
              };
              SVGLabel2.prototype.paddingSetter = function(value, key) {
                if (!isNumber(value)) {
                  this[key] = void 0;
                } else if (value !== this[key]) {
                  this[key] = value;
                  this.updateTextPadding();
                }
              };
              SVGLabel2.prototype.rSetter = function(value, key) {
                this.boxAttr(key, value);
              };
              SVGLabel2.prototype.shadow = function(b) {
                if (b && !this.renderer.styledMode) {
                  this.updateBoxSize();
                  if (this.box) {
                    this.box.shadow(b);
                  }
                }
                return this;
              };
              SVGLabel2.prototype.strokeSetter = function(value, key) {
                this.stroke = value;
                this.boxAttr(key, value);
              };
              SVGLabel2.prototype["stroke-widthSetter"] = function(value, key) {
                if (value) {
                  this.needsBox = true;
                }
                this["stroke-width"] = value;
                this.boxAttr(key, value);
              };
              SVGLabel2.prototype["text-alignSetter"] = function(value) {
                this.textAlign = value;
              };
              SVGLabel2.prototype.textSetter = function(text) {
                if (typeof text !== "undefined") {
                  this.text.attr({ text });
                }
                this.updateTextPadding();
              };
              SVGLabel2.prototype.updateBoxSize = function() {
                var text = this.text, style = text.element.style, attribs = {}, padding = this.padding, bBox = this.bBox = (!isNumber(this.widthSetting) || !isNumber(this.heightSetting) || this.textAlign) && defined(text.textStr) ? text.getBBox() : SVGLabel2.emptyBBox;
                var crispAdjust;
                this.width = this.getPaddedWidth();
                this.height = (this.heightSetting || bBox.height || 0) + 2 * padding;
                var metrics = this.renderer.fontMetrics(
                  style && style.fontSize,
                  text
                );
                this.baselineOffset = padding + Math.min(
                  // When applicable, use the font size of the first line (#15707)
                  (this.text.firstLineMetrics || metrics).b,
                  // When the height is 0, there is no bBox, so go with the font
                  // metrics. Highmaps CSS demos.
                  bBox.height || Infinity
                );
                if (this.heightSetting) {
                  this.baselineOffset += (this.heightSetting - metrics.h) / 2;
                }
                if (this.needsBox && !text.textPath) {
                  if (!this.box) {
                    var box = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect();
                    box.addClass(
                      // Don't use label className for buttons
                      (this.className === "button" ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")
                    );
                    box.add(this);
                  }
                  crispAdjust = this.getCrispAdjust();
                  attribs.x = crispAdjust;
                  attribs.y = (this.baseline ? -this.baselineOffset : 0) + crispAdjust;
                  attribs.width = Math.round(this.width);
                  attribs.height = Math.round(this.height);
                  this.box.attr(extend2(attribs, this.deferredAttr));
                  this.deferredAttr = {};
                }
              };
              SVGLabel2.prototype.updateTextPadding = function() {
                var text = this.text;
                if (!text.textPath) {
                  this.updateBoxSize();
                  var textY = this.baseline ? 0 : this.baselineOffset;
                  var textX = pick(
                    this.paddingLeft,
                    this.padding
                  );
                  if (defined(this.widthSetting) && this.bBox && (this.textAlign === "center" || this.textAlign === "right")) {
                    textX += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width);
                  }
                  if (textX !== text.x || textY !== text.y) {
                    text.attr("x", textX);
                    if (text.hasBoxWidthChanged) {
                      this.bBox = text.getBBox(true);
                    }
                    if (typeof textY !== "undefined") {
                      text.attr("y", textY);
                    }
                  }
                  text.x = textX;
                  text.y = textY;
                }
              };
              SVGLabel2.prototype.widthSetter = function(value) {
                this.widthSetting = isNumber(value) ? value : void 0;
              };
              SVGLabel2.prototype.getPaddedWidth = function() {
                var padding = this.padding;
                var paddingLeft = pick(
                  this.paddingLeft,
                  padding
                );
                var paddingRight = pick(
                  this.paddingRight,
                  padding
                );
                return (this.widthSetting || this.bBox.width || 0) + paddingLeft + paddingRight;
              };
              SVGLabel2.prototype.xSetter = function(value) {
                this.x = value;
                if (this.alignFactor) {
                  value -= this.alignFactor * this.getPaddedWidth();
                  this["forceAnimate:x"] = true;
                }
                this.xSetting = Math.round(value);
                this.attr("translateX", this.xSetting);
              };
              SVGLabel2.prototype.ySetter = function(value) {
                this.ySetting = this.y = Math.round(value);
                this.attr("translateY", this.ySetting);
              };
              SVGLabel2.emptyBBox = {
                width: 0,
                height: 0,
                x: 0,
                y: 0
              };
              SVGLabel2.textProps = [
                "color",
                "direction",
                "fontFamily",
                "fontSize",
                "fontStyle",
                "fontWeight",
                "lineHeight",
                "textAlign",
                "textDecoration",
                "textOutline",
                "textOverflow",
                "width"
              ];
              return SVGLabel2;
            }(SVGElement)
          );
          return SVGLabel;
        });
        _registerModule(_modules, "Core/Renderer/SVG/Symbols.js", [_modules["Core/Utilities.js"]], function(U) {
          var defined = U.defined, isNumber = U.isNumber, pick = U.pick;
          function arc(x, y, w, h3, options) {
            var arc2 = [];
            if (options) {
              var start2 = options.start || 0, rx = pick(
                options.r,
                w
              ), ry = pick(
                options.r,
                h3 || w
              ), proximity = 1e-3, fullCircle = Math.abs((options.end || 0) - start2 - 2 * Math.PI) < proximity, end = (options.end || 0) - proximity, innerRadius = options.innerR, open_1 = pick(
                options.open,
                fullCircle
              ), cosStart = Math.cos(start2), sinStart = Math.sin(start2), cosEnd = Math.cos(end), sinEnd = Math.sin(end), longArc = pick(
                options.longArc,
                end - start2 - Math.PI < proximity ? 0 : 1
              );
              arc2.push([
                "M",
                x + rx * cosStart,
                y + ry * sinStart
              ], [
                "A",
                rx,
                ry,
                0,
                longArc,
                pick(options.clockwise, 1),
                x + rx * cosEnd,
                y + ry * sinEnd
              ]);
              if (defined(innerRadius)) {
                arc2.push(open_1 ? [
                  "M",
                  x + innerRadius * cosEnd,
                  y + innerRadius * sinEnd
                ] : [
                  "L",
                  x + innerRadius * cosEnd,
                  y + innerRadius * sinEnd
                ], [
                  "A",
                  innerRadius,
                  innerRadius,
                  0,
                  longArc,
                  // Clockwise - opposite to the outer arc clockwise
                  defined(options.clockwise) ? 1 - options.clockwise : 0,
                  x + innerRadius * cosStart,
                  y + innerRadius * sinStart
                ]);
              }
              if (!open_1) {
                arc2.push(["Z"]);
              }
            }
            return arc2;
          }
          function callout(x, y, w, h3, options) {
            var arrowLength = 6, halfDistance = 6, r = Math.min(
              options && options.r || 0,
              w,
              h3
            ), safeDistance = r + halfDistance, anchorX = options && options.anchorX, anchorY = options && options.anchorY || 0;
            var path = roundedRect(
              x,
              y,
              w,
              h3,
              { r }
            );
            if (!isNumber(anchorX)) {
              return path;
            }
            if (x + anchorX >= w) {
              if (anchorY > y + safeDistance && anchorY < y + h3 - safeDistance) {
                path.splice(3, 1, ["L", x + w, anchorY - halfDistance], ["L", x + w + arrowLength, anchorY], ["L", x + w, anchorY + halfDistance], ["L", x + w, y + h3 - r]);
              } else {
                path.splice(3, 1, ["L", x + w, h3 / 2], ["L", anchorX, anchorY], ["L", x + w, h3 / 2], ["L", x + w, y + h3 - r]);
              }
            } else if (x + anchorX <= 0) {
              if (anchorY > y + safeDistance && anchorY < y + h3 - safeDistance) {
                path.splice(7, 1, ["L", x, anchorY + halfDistance], ["L", x - arrowLength, anchorY], ["L", x, anchorY - halfDistance], ["L", x, y + r]);
              } else {
                path.splice(7, 1, ["L", x, h3 / 2], ["L", anchorX, anchorY], ["L", x, h3 / 2], ["L", x, y + r]);
              }
            } else if (
              // replace bottom
              anchorY && anchorY > h3 && anchorX > x + safeDistance && anchorX < x + w - safeDistance
            ) {
              path.splice(5, 1, ["L", anchorX + halfDistance, y + h3], ["L", anchorX, y + h3 + arrowLength], ["L", anchorX - halfDistance, y + h3], ["L", x + r, y + h3]);
            } else if (
              // replace top
              anchorY && anchorY < 0 && anchorX > x + safeDistance && anchorX < x + w - safeDistance
            ) {
              path.splice(1, 1, ["L", anchorX - halfDistance, y], ["L", anchorX, y - arrowLength], ["L", anchorX + halfDistance, y], ["L", w - r, y]);
            }
            return path;
          }
          function circle(x, y, w, h3) {
            return arc(x + w / 2, y + h3 / 2, w / 2, h3 / 2, {
              start: Math.PI * 0.5,
              end: Math.PI * 2.5,
              open: false
            });
          }
          function diamond(x, y, w, h3) {
            return [
              ["M", x + w / 2, y],
              ["L", x + w, y + h3 / 2],
              ["L", x + w / 2, y + h3],
              ["L", x, y + h3 / 2],
              ["Z"]
            ];
          }
          function rect(x, y, w, h3, options) {
            if (options && options.r) {
              return roundedRect(x, y, w, h3, options);
            }
            return [
              ["M", x, y],
              ["L", x + w, y],
              ["L", x + w, y + h3],
              ["L", x, y + h3],
              ["Z"]
            ];
          }
          function roundedRect(x, y, w, h3, options) {
            var r = options && options.r || 0;
            return [
              ["M", x + r, y],
              ["L", x + w - r, y],
              ["C", x + w, y, x + w, y, x + w, y + r],
              ["L", x + w, y + h3 - r],
              ["C", x + w, y + h3, x + w, y + h3, x + w - r, y + h3],
              ["L", x + r, y + h3],
              ["C", x, y + h3, x, y + h3, x, y + h3 - r],
              ["L", x, y + r],
              ["C", x, y, x, y, x + r, y]
              // top-left corner
            ];
          }
          function triangle(x, y, w, h3) {
            return [
              ["M", x + w / 2, y],
              ["L", x + w, y + h3],
              ["L", x, y + h3],
              ["Z"]
            ];
          }
          function triangleDown(x, y, w, h3) {
            return [
              ["M", x, y],
              ["L", x + w, y],
              ["L", x + w / 2, y + h3],
              ["Z"]
            ];
          }
          var Symbols = {
            arc,
            callout,
            circle,
            diamond,
            rect,
            roundedRect,
            square: rect,
            triangle,
            "triangle-down": triangleDown
          };
          return Symbols;
        });
        _registerModule(_modules, "Core/Renderer/SVG/TextBuilder.js", [_modules["Core/Renderer/HTML/AST.js"], _modules["Core/Globals.js"], _modules["Core/Utilities.js"]], function(AST, H, U) {
          var doc = H.doc, SVG_NS = H.SVG_NS, win = H.win;
          var attr = U.attr, extend2 = U.extend, fireEvent = U.fireEvent, isString = U.isString, objectEach = U.objectEach, pick = U.pick;
          var TextBuilder = (
            /** @class */
            function() {
              function TextBuilder2(svgElement) {
                var textStyles = svgElement.styles;
                this.renderer = svgElement.renderer;
                this.svgElement = svgElement;
                this.width = svgElement.textWidth;
                this.textLineHeight = textStyles && textStyles.lineHeight;
                this.textOutline = textStyles && textStyles.textOutline;
                this.ellipsis = Boolean(textStyles && textStyles.textOverflow === "ellipsis");
                this.noWrap = Boolean(textStyles && textStyles.whiteSpace === "nowrap");
                this.fontSize = textStyles && textStyles.fontSize;
              }
              TextBuilder2.prototype.buildSVG = function() {
                var wrapper = this.svgElement, textNode = wrapper.element, renderer = wrapper.renderer, textStr = pick(wrapper.textStr, "").toString(), hasMarkup = textStr.indexOf("<") !== -1, childNodes = textNode.childNodes, tempParent = this.width && !wrapper.added && renderer.box, regexMatchBreaks = /<br.*?>/g, textCache = [
                  textStr,
                  this.ellipsis,
                  this.noWrap,
                  this.textLineHeight,
                  this.textOutline,
                  this.fontSize,
                  this.width
                ].join(",");
                if (textCache === wrapper.textCache) {
                  return;
                }
                wrapper.textCache = textCache;
                delete wrapper.actualWidth;
                for (var i = childNodes.length; i--; ) {
                  textNode.removeChild(childNodes[i]);
                }
                if (!hasMarkup && !this.ellipsis && !this.width && !wrapper.textPath && (textStr.indexOf(" ") === -1 || this.noWrap && !regexMatchBreaks.test(textStr))) {
                  textNode.appendChild(doc.createTextNode(this.unescapeEntities(textStr)));
                } else if (textStr !== "") {
                  if (tempParent) {
                    tempParent.appendChild(textNode);
                  }
                  var ast = new AST(textStr);
                  this.modifyTree(ast.nodes);
                  ast.addToDOM(textNode);
                  this.modifyDOM();
                  if (this.ellipsis && (textNode.textContent || "").indexOf("\u2026") !== -1) {
                    wrapper.attr(
                      "title",
                      this.unescapeEntities(wrapper.textStr || "", ["&lt;", "&gt;"])
                      // #7179
                    );
                  }
                  if (tempParent) {
                    tempParent.removeChild(textNode);
                  }
                }
                if (isString(this.textOutline) && wrapper.applyTextOutline) {
                  wrapper.applyTextOutline(this.textOutline);
                }
              };
              TextBuilder2.prototype.modifyDOM = function() {
                var _this = this;
                var wrapper = this.svgElement;
                var x = attr(wrapper.element, "x");
                wrapper.firstLineMetrics = void 0;
                var firstChild;
                while (firstChild = wrapper.element.firstChild) {
                  if (/^[\s\u200B]*$/.test(firstChild.textContent || " ")) {
                    wrapper.element.removeChild(firstChild);
                  } else {
                    break;
                  }
                }
                [].forEach.call(wrapper.element.querySelectorAll("tspan.highcharts-br"), function(br, i) {
                  if (br.nextSibling && br.previousSibling) {
                    if (i === 0 && br.previousSibling.nodeType === 1) {
                      wrapper.firstLineMetrics = wrapper.renderer.fontMetrics(void 0, br.previousSibling);
                    }
                    attr(br, {
                      // Since the break is inserted in front of the next
                      // line, we need to use the next sibling for the line
                      // height
                      dy: _this.getLineHeight(br.nextSibling),
                      x
                    });
                  }
                });
                var width = this.width || 0;
                if (!width) {
                  return;
                }
                var modifyTextNode = function(textNode, parentElement) {
                  var text = textNode.textContent || "";
                  var words = text.replace(/([^\^])-/g, "$1- ").split(" ");
                  var hasWhiteSpace = !_this.noWrap && (words.length > 1 || wrapper.element.childNodes.length > 1);
                  var dy = _this.getLineHeight(parentElement);
                  var lineNo = 0;
                  var startAt = wrapper.actualWidth;
                  if (_this.ellipsis) {
                    if (text) {
                      _this.truncate(
                        textNode,
                        text,
                        void 0,
                        0,
                        // Target width
                        Math.max(
                          0,
                          // Substract the font face to make room for the
                          // ellipsis itself
                          width - parseInt(_this.fontSize || 12, 10)
                        ),
                        // Build the text to test for
                        function(text2, currentIndex) {
                          return text2.substring(0, currentIndex) + "\u2026";
                        }
                      );
                    }
                  } else if (hasWhiteSpace) {
                    var lines = [];
                    var precedingSiblings = [];
                    while (parentElement.firstChild && parentElement.firstChild !== textNode) {
                      precedingSiblings.push(parentElement.firstChild);
                      parentElement.removeChild(parentElement.firstChild);
                    }
                    while (words.length) {
                      if (words.length && !_this.noWrap && lineNo > 0) {
                        lines.push(textNode.textContent || "");
                        textNode.textContent = words.join(" ").replace(/- /g, "-");
                      }
                      _this.truncate(
                        textNode,
                        void 0,
                        words,
                        lineNo === 0 ? startAt || 0 : 0,
                        width,
                        // Build the text to test for
                        function(t, currentIndex) {
                          return words.slice(0, currentIndex).join(" ").replace(/- /g, "-");
                        }
                      );
                      startAt = wrapper.actualWidth;
                      lineNo++;
                    }
                    precedingSiblings.forEach(function(childNode) {
                      parentElement.insertBefore(childNode, textNode);
                    });
                    lines.forEach(function(line) {
                      parentElement.insertBefore(doc.createTextNode(line), textNode);
                      var br = doc.createElementNS(SVG_NS, "tspan");
                      br.textContent = "\u200B";
                      attr(br, { dy, x });
                      parentElement.insertBefore(br, textNode);
                    });
                  }
                };
                var modifyChildren = function(node) {
                  var childNodes = [].slice.call(node.childNodes);
                  childNodes.forEach(function(childNode) {
                    if (childNode.nodeType === win.Node.TEXT_NODE) {
                      modifyTextNode(childNode, node);
                    } else {
                      if (childNode.className.baseVal.indexOf("highcharts-br") !== -1) {
                        wrapper.actualWidth = 0;
                      }
                      modifyChildren(childNode);
                    }
                  });
                };
                modifyChildren(wrapper.element);
              };
              TextBuilder2.prototype.getLineHeight = function(node) {
                var fontSizeStyle;
                var element = node.nodeType === win.Node.TEXT_NODE ? node.parentElement : node;
                if (!this.renderer.styledMode) {
                  fontSizeStyle = element && /(px|em)$/.test(element.style.fontSize) ? element.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12;
                }
                return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(fontSizeStyle, element || this.svgElement.element).h;
              };
              TextBuilder2.prototype.modifyTree = function(nodes) {
                var _this = this;
                var modifyChild = function(node, i) {
                  var _a = node.attributes, attributes = _a === void 0 ? {} : _a, children2 = node.children, _b = node.style, style = _b === void 0 ? {} : _b, tagName = node.tagName, styledMode = _this.renderer.styledMode;
                  if (tagName === "b" || tagName === "strong") {
                    if (styledMode) {
                      attributes["class"] = "highcharts-strong";
                    } else {
                      style.fontWeight = "bold";
                    }
                  } else if (tagName === "i" || tagName === "em") {
                    if (styledMode) {
                      attributes["class"] = "highcharts-emphasized";
                    } else {
                      style.fontStyle = "italic";
                    }
                  }
                  if (style && style.color) {
                    style.fill = style.color;
                  }
                  if (tagName === "br") {
                    attributes["class"] = "highcharts-br";
                    node.textContent = "\u200B";
                    var nextNode = nodes[i + 1];
                    if (nextNode && nextNode.textContent) {
                      nextNode.textContent = nextNode.textContent.replace(/^ +/gm, "");
                    }
                  } else if (tagName === "a" && children2 && children2.some(function(child) {
                    return child.tagName === "#text";
                  })) {
                    node.children = [{ children: children2, tagName: "tspan" }];
                  }
                  if (tagName !== "#text" && tagName !== "a") {
                    node.tagName = "tspan";
                  }
                  extend2(node, { attributes, style });
                  if (children2) {
                    children2.filter(function(c) {
                      return c.tagName !== "#text";
                    }).forEach(modifyChild);
                  }
                };
                nodes.forEach(modifyChild);
                fireEvent(this.svgElement, "afterModifyTree", { nodes });
              };
              TextBuilder2.prototype.truncate = function(textNode, text, words, startAt, width, getString) {
                var svgElement = this.svgElement;
                var renderer = svgElement.renderer, rotation = svgElement.rotation;
                var lengths = [];
                var minIndex = words ? 1 : 0;
                var maxIndex = (text || words || "").length;
                var currentIndex = maxIndex;
                var str;
                var actualWidth;
                var getSubStringLength = function(charEnd, concatenatedEnd) {
                  var end = concatenatedEnd || charEnd;
                  var parentNode = textNode.parentNode;
                  if (parentNode && typeof lengths[end] === "undefined") {
                    if (parentNode.getSubStringLength) {
                      try {
                        lengths[end] = startAt + parentNode.getSubStringLength(0, words ? end + 1 : end);
                      } catch (e) {
                        "";
                      }
                    } else if (renderer.getSpanWidth) {
                      textNode.textContent = getString(text || words, charEnd);
                      lengths[end] = startAt + renderer.getSpanWidth(svgElement, textNode);
                    }
                  }
                  return lengths[end];
                };
                svgElement.rotation = 0;
                actualWidth = getSubStringLength(textNode.textContent.length);
                if (startAt + actualWidth > width) {
                  while (minIndex <= maxIndex) {
                    currentIndex = Math.ceil((minIndex + maxIndex) / 2);
                    if (words) {
                      str = getString(words, currentIndex);
                    }
                    actualWidth = getSubStringLength(currentIndex, str && str.length - 1);
                    if (minIndex === maxIndex) {
                      minIndex = maxIndex + 1;
                    } else if (actualWidth > width) {
                      maxIndex = currentIndex - 1;
                    } else {
                      minIndex = currentIndex;
                    }
                  }
                  if (maxIndex === 0) {
                    textNode.textContent = "";
                  } else if (!(text && maxIndex === text.length - 1)) {
                    textNode.textContent = str || getString(text || words, currentIndex);
                  }
                }
                if (words) {
                  words.splice(0, currentIndex);
                }
                svgElement.actualWidth = actualWidth;
                svgElement.rotation = rotation;
              };
              TextBuilder2.prototype.unescapeEntities = function(inputStr, except) {
                objectEach(this.renderer.escapes, function(value, key) {
                  if (!except || except.indexOf(value) === -1) {
                    inputStr = inputStr.toString().replace(new RegExp(value, "g"), key);
                  }
                });
                return inputStr;
              };
              return TextBuilder2;
            }()
          );
          return TextBuilder;
        });
        _registerModule(_modules, "Core/Renderer/SVG/SVGRenderer.js", [_modules["Core/Renderer/HTML/AST.js"], _modules["Core/Color/Color.js"], _modules["Core/Globals.js"], _modules["Core/Renderer/RendererRegistry.js"], _modules["Core/Renderer/SVG/SVGElement.js"], _modules["Core/Renderer/SVG/SVGLabel.js"], _modules["Core/Renderer/SVG/Symbols.js"], _modules["Core/Renderer/SVG/TextBuilder.js"], _modules["Core/Utilities.js"]], function(AST, Color2, H, RendererRegistry, SVGElement, SVGLabel, Symbols, TextBuilder, U) {
          var charts = H.charts, deg2rad = H.deg2rad, doc = H.doc, isFirefox = H.isFirefox, isMS = H.isMS, isWebKit = H.isWebKit, noop2 = H.noop, SVG_NS = H.SVG_NS, symbolSizes = H.symbolSizes, win = H.win;
          var addEvent = U.addEvent, attr = U.attr, createElement = U.createElement, css = U.css, defined = U.defined, destroyObjectProperties = U.destroyObjectProperties, extend2 = U.extend, isArray = U.isArray, isNumber = U.isNumber, isObject = U.isObject, isString = U.isString, merge = U.merge, pick = U.pick, pInt = U.pInt, uniqueKey = U.uniqueKey;
          var hasInternalReferenceBug;
          var SVGRenderer = (
            /** @class */
            function() {
              function SVGRenderer2(container, width, height, style, forExport, allowHTML, styledMode) {
                this.alignedObjects = void 0;
                this.box = void 0;
                this.boxWrapper = void 0;
                this.cache = void 0;
                this.cacheKeys = void 0;
                this.chartIndex = void 0;
                this.defs = void 0;
                this.globalAnimation = void 0;
                this.gradients = void 0;
                this.height = void 0;
                this.imgCount = void 0;
                this.isSVG = void 0;
                this.style = void 0;
                this.url = void 0;
                this.width = void 0;
                this.init(container, width, height, style, forExport, allowHTML, styledMode);
              }
              SVGRenderer2.prototype.init = function(container, width, height, style, forExport, allowHTML, styledMode) {
                var renderer = this, boxWrapper = renderer.createElement("svg").attr({
                  version: "1.1",
                  "class": "highcharts-root"
                }), element = boxWrapper.element;
                if (!styledMode) {
                  boxWrapper.css(this.getStyle(style));
                }
                container.appendChild(element);
                attr(container, "dir", "ltr");
                if (container.innerHTML.indexOf("xmlns") === -1) {
                  attr(element, "xmlns", this.SVG_NS);
                }
                renderer.isSVG = true;
                this.box = element;
                this.boxWrapper = boxWrapper;
                renderer.alignedObjects = [];
                this.url = this.getReferenceURL();
                var desc = this.createElement("desc").add();
                desc.element.appendChild(doc.createTextNode("Created with Highcharts 10.3.3"));
                renderer.defs = this.createElement("defs").add();
                renderer.allowHTML = allowHTML;
                renderer.forExport = forExport;
                renderer.styledMode = styledMode;
                renderer.gradients = {};
                renderer.cache = {};
                renderer.cacheKeys = [];
                renderer.imgCount = 0;
                renderer.setSize(width, height, false);
                var subPixelFix, rect;
                if (isFirefox && container.getBoundingClientRect) {
                  subPixelFix = function() {
                    css(container, { left: 0, top: 0 });
                    rect = container.getBoundingClientRect();
                    css(container, {
                      left: Math.ceil(rect.left) - rect.left + "px",
                      top: Math.ceil(rect.top) - rect.top + "px"
                    });
                  };
                  subPixelFix();
                  renderer.unSubPixelFix = addEvent(win, "resize", subPixelFix);
                }
              };
              SVGRenderer2.prototype.definition = function(def) {
                var ast = new AST([def]);
                return ast.addToDOM(this.defs.element);
              };
              SVGRenderer2.prototype.getReferenceURL = function() {
                if ((isFirefox || isWebKit) && doc.getElementsByTagName("base").length) {
                  if (!defined(hasInternalReferenceBug)) {
                    var id2 = uniqueKey();
                    var ast = new AST([{
                      tagName: "svg",
                      attributes: {
                        width: 8,
                        height: 8
                      },
                      children: [{
                        tagName: "defs",
                        children: [{
                          tagName: "clipPath",
                          attributes: {
                            id: id2
                          },
                          children: [{
                            tagName: "rect",
                            attributes: {
                              width: 4,
                              height: 4
                            }
                          }]
                        }]
                      }, {
                        tagName: "rect",
                        attributes: {
                          id: "hitme",
                          width: 8,
                          height: 8,
                          "clip-path": "url(#".concat(id2, ")"),
                          fill: "rgba(0,0,0,0.001)"
                        }
                      }]
                    }]);
                    var svg = ast.addToDOM(doc.body);
                    css(svg, {
                      position: "fixed",
                      top: 0,
                      left: 0,
                      zIndex: 9e5
                    });
                    var hitElement = doc.elementFromPoint(6, 6);
                    hasInternalReferenceBug = (hitElement && hitElement.id) === "hitme";
                    doc.body.removeChild(svg);
                  }
                  if (hasInternalReferenceBug) {
                    return win.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
                  }
                }
                return "";
              };
              SVGRenderer2.prototype.getStyle = function(style) {
                this.style = extend2({
                  fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif',
                  fontSize: "12px"
                }, style);
                return this.style;
              };
              SVGRenderer2.prototype.setStyle = function(style) {
                this.boxWrapper.css(this.getStyle(style));
              };
              SVGRenderer2.prototype.isHidden = function() {
                return !this.boxWrapper.getBBox().width;
              };
              SVGRenderer2.prototype.destroy = function() {
                var renderer = this, rendererDefs = renderer.defs;
                renderer.box = null;
                renderer.boxWrapper = renderer.boxWrapper.destroy();
                destroyObjectProperties(renderer.gradients || {});
                renderer.gradients = null;
                if (rendererDefs) {
                  renderer.defs = rendererDefs.destroy();
                }
                if (renderer.unSubPixelFix) {
                  renderer.unSubPixelFix();
                }
                renderer.alignedObjects = null;
                return null;
              };
              SVGRenderer2.prototype.createElement = function(nodeName) {
                var wrapper = new this.Element();
                wrapper.init(this, nodeName);
                return wrapper;
              };
              SVGRenderer2.prototype.getRadialAttr = function(radialReference, gradAttr) {
                return {
                  cx: radialReference[0] - radialReference[2] / 2 + (gradAttr.cx || 0) * radialReference[2],
                  cy: radialReference[1] - radialReference[2] / 2 + (gradAttr.cy || 0) * radialReference[2],
                  r: (gradAttr.r || 0) * radialReference[2]
                };
              };
              SVGRenderer2.prototype.buildText = function(wrapper) {
                new TextBuilder(wrapper).buildSVG();
              };
              SVGRenderer2.prototype.getContrast = function(color2) {
                var rgba2 = Color2.parse(color2).rgba.map(function(b8) {
                  var c = b8 / 255;
                  return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
                });
                var l = 0.2126 * rgba2[0] + 0.7152 * rgba2[1] + 0.0722 * rgba2[2];
                return 1.05 / (l + 0.05) > (l + 0.05) / 0.05 ? "#FFFFFF" : "#000000";
              };
              SVGRenderer2.prototype.button = function(text, x, y, callback, theme, hoverState, selectState, disabledState, shape, useHTML) {
                if (theme === void 0) {
                  theme = {};
                }
                var label = this.label(
                  text,
                  x,
                  y,
                  shape,
                  void 0,
                  void 0,
                  useHTML,
                  void 0,
                  "button"
                ), styledMode = this.styledMode, states = theme.states || {};
                var curState = 0;
                theme = merge(theme);
                delete theme.states;
                var normalStyle = merge(
                  {
                    color: "#333333",
                    cursor: "pointer",
                    fontWeight: "normal"
                  },
                  theme.style
                );
                delete theme.style;
                var normalState = AST.filterUserAttributes(theme);
                label.attr(merge({ padding: 8, r: 2 }, normalState));
                var hoverStyle, selectStyle, disabledStyle;
                if (!styledMode) {
                  normalState = merge({
                    fill: "#f7f7f7",
                    stroke: "#cccccc",
                    "stroke-width": 1
                  }, normalState);
                  hoverState = merge(normalState, {
                    fill: "#e6e6e6"
                    /* Palette.neutralColor10 */
                  }, AST.filterUserAttributes(hoverState || states.hover || {}));
                  hoverStyle = hoverState.style;
                  delete hoverState.style;
                  selectState = merge(normalState, {
                    fill: "#e6ebf5",
                    style: {
                      color: "#000000",
                      fontWeight: "bold"
                    }
                  }, AST.filterUserAttributes(selectState || states.select || {}));
                  selectStyle = selectState.style;
                  delete selectState.style;
                  disabledState = merge(normalState, {
                    style: {
                      color: "#cccccc"
                      /* Palette.neutralColor20 */
                    }
                  }, AST.filterUserAttributes(disabledState || states.disabled || {}));
                  disabledStyle = disabledState.style;
                  delete disabledState.style;
                }
                addEvent(label.element, isMS ? "mouseover" : "mouseenter", function() {
                  if (curState !== 3) {
                    label.setState(1);
                  }
                });
                addEvent(label.element, isMS ? "mouseout" : "mouseleave", function() {
                  if (curState !== 3) {
                    label.setState(curState);
                  }
                });
                label.setState = function(state) {
                  if (state !== 1) {
                    label.state = curState = state;
                  }
                  label.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][state || 0]);
                  if (!styledMode) {
                    label.attr([
                      normalState,
                      hoverState,
                      selectState,
                      disabledState
                    ][state || 0]);
                    var css_1 = [
                      normalStyle,
                      hoverStyle,
                      selectStyle,
                      disabledStyle
                    ][state || 0];
                    if (isObject(css_1)) {
                      label.css(css_1);
                    }
                  }
                };
                if (!styledMode) {
                  label.attr(normalState).css(extend2({ cursor: "default" }, normalStyle));
                  if (useHTML) {
                    label.text.css({ pointerEvents: "none" });
                  }
                }
                return label.on("touchstart", function(e) {
                  return e.stopPropagation();
                }).on("click", function(e) {
                  if (curState !== 3) {
                    callback.call(label, e);
                  }
                });
              };
              SVGRenderer2.prototype.crispLine = function(points, width, roundingFunction) {
                if (roundingFunction === void 0) {
                  roundingFunction = "round";
                }
                var start2 = points[0];
                var end = points[1];
                if (defined(start2[1]) && start2[1] === end[1]) {
                  start2[1] = end[1] = Math[roundingFunction](start2[1]) - width % 2 / 2;
                }
                if (defined(start2[2]) && start2[2] === end[2]) {
                  start2[2] = end[2] = Math[roundingFunction](start2[2]) + width % 2 / 2;
                }
                return points;
              };
              SVGRenderer2.prototype.path = function(path) {
                var attribs = this.styledMode ? {} : {
                  fill: "none"
                };
                if (isArray(path)) {
                  attribs.d = path;
                } else if (isObject(path)) {
                  extend2(attribs, path);
                }
                return this.createElement("path").attr(attribs);
              };
              SVGRenderer2.prototype.circle = function(x, y, r) {
                var attribs = isObject(x) ? x : typeof x === "undefined" ? {} : { x, y, r }, wrapper = this.createElement("circle");
                wrapper.xSetter = wrapper.ySetter = function(value, key, element) {
                  element.setAttribute("c" + key, value);
                };
                return wrapper.attr(attribs);
              };
              SVGRenderer2.prototype.arc = function(x, y, r, innerR, start2, end) {
                var options;
                if (isObject(x)) {
                  options = x;
                  y = options.y;
                  r = options.r;
                  innerR = options.innerR;
                  start2 = options.start;
                  end = options.end;
                  x = options.x;
                } else {
                  options = { innerR, start: start2, end };
                }
                var arc = this.symbol(
                  "arc",
                  x,
                  y,
                  r,
                  r,
                  options
                );
                arc.r = r;
                return arc;
              };
              SVGRenderer2.prototype.rect = function(x, y, width, height, r, strokeWidth) {
                r = isObject(x) ? x.r : r;
                var wrapper = this.createElement("rect");
                var attribs = isObject(x) ? x : typeof x === "undefined" ? {} : {
                  x,
                  y,
                  width: Math.max(width, 0),
                  height: Math.max(height, 0)
                };
                if (!this.styledMode) {
                  if (typeof strokeWidth !== "undefined") {
                    attribs["stroke-width"] = strokeWidth;
                    attribs = wrapper.crisp(attribs);
                  }
                  attribs.fill = "none";
                }
                if (r) {
                  attribs.r = r;
                }
                wrapper.rSetter = function(value, _key, element) {
                  wrapper.r = value;
                  attr(element, {
                    rx: value,
                    ry: value
                  });
                };
                wrapper.rGetter = function() {
                  return wrapper.r || 0;
                };
                return wrapper.attr(attribs);
              };
              SVGRenderer2.prototype.setSize = function(width, height, animate) {
                var renderer = this;
                renderer.width = width;
                renderer.height = height;
                renderer.boxWrapper.animate({
                  width,
                  height
                }, {
                  step: function() {
                    this.attr({
                      viewBox: "0 0 " + this.attr("width") + " " + this.attr("height")
                    });
                  },
                  duration: pick(animate, true) ? void 0 : 0
                });
                renderer.alignElements();
              };
              SVGRenderer2.prototype.g = function(name) {
                var elem = this.createElement("g");
                return name ? elem.attr({ "class": "highcharts-" + name }) : elem;
              };
              SVGRenderer2.prototype.image = function(src, x, y, width, height, onload) {
                var attribs = { preserveAspectRatio: "none" }, setSVGImageSource = function(el, src2) {
                  if (el.setAttributeNS) {
                    el.setAttributeNS("http://www.w3.org/1999/xlink", "href", src2);
                  } else {
                    el.setAttribute("hc-svg-href", src2);
                  }
                };
                if (isNumber(x)) {
                  attribs.x = x;
                }
                if (isNumber(y)) {
                  attribs.y = y;
                }
                if (isNumber(width)) {
                  attribs.width = width;
                }
                if (isNumber(height)) {
                  attribs.height = height;
                }
                var elemWrapper = this.createElement("image").attr(attribs), onDummyLoad = function(e) {
                  setSVGImageSource(
                    elemWrapper.element,
                    src
                  );
                  onload.call(elemWrapper, e);
                };
                if (onload) {
                  setSVGImageSource(
                    elemWrapper.element,
                    "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
                    /* eslint-disable-line */
                  );
                  var dummy = new win.Image();
                  addEvent(dummy, "load", onDummyLoad);
                  dummy.src = src;
                  if (dummy.complete) {
                    onDummyLoad({});
                  }
                } else {
                  setSVGImageSource(elemWrapper.element, src);
                }
                return elemWrapper;
              };
              SVGRenderer2.prototype.symbol = function(symbol, x, y, width, height, options) {
                var ren = this, imageRegex = /^url\((.*?)\)$/, isImage = imageRegex.test(symbol), sym = !isImage && (this.symbols[symbol] ? symbol : "circle"), symbolFn = sym && this.symbols[sym];
                var obj, path, imageSrc, centerImage;
                if (symbolFn) {
                  if (typeof x === "number") {
                    path = symbolFn.call(this.symbols, Math.round(x || 0), Math.round(y || 0), width || 0, height || 0, options);
                  }
                  obj = this.path(path);
                  if (!ren.styledMode) {
                    obj.attr("fill", "none");
                  }
                  extend2(obj, {
                    symbolName: sym || void 0,
                    x,
                    y,
                    width,
                    height
                  });
                  if (options) {
                    extend2(obj, options);
                  }
                } else if (isImage) {
                  imageSrc = symbol.match(imageRegex)[1];
                  var img_1 = obj = this.image(imageSrc);
                  img_1.imgwidth = pick(symbolSizes[imageSrc] && symbolSizes[imageSrc].width, options && options.width);
                  img_1.imgheight = pick(symbolSizes[imageSrc] && symbolSizes[imageSrc].height, options && options.height);
                  centerImage = function(obj2) {
                    return obj2.attr({
                      width: obj2.width,
                      height: obj2.height
                    });
                  };
                  ["width", "height"].forEach(function(key) {
                    img_1[key + "Setter"] = function(value, key2) {
                      this[key2] = value;
                      var _a = this, alignByTranslate = _a.alignByTranslate, element = _a.element, width2 = _a.width, height2 = _a.height, imgwidth = _a.imgwidth, imgheight = _a.imgheight;
                      var imgSize = this["img" + key2];
                      if (defined(imgSize)) {
                        var scale = 1;
                        if (options && options.backgroundSize === "within" && width2 && height2) {
                          scale = Math.min(width2 / imgwidth, height2 / imgheight);
                          imgSize = Math.round(imgSize * scale);
                          attr(element, {
                            width: Math.round(imgwidth * scale),
                            height: Math.round(imgheight * scale)
                          });
                        } else if (element) {
                          element.setAttribute(key2, imgSize);
                        }
                        if (!alignByTranslate) {
                          this.translate(((width2 || 0) - imgSize * scale) / 2, ((height2 || 0) - imgSize * scale) / 2);
                        }
                      }
                    };
                  });
                  if (defined(x)) {
                    img_1.attr({
                      x,
                      y
                    });
                  }
                  img_1.isImg = true;
                  if (defined(img_1.imgwidth) && defined(img_1.imgheight)) {
                    centerImage(img_1);
                  } else {
                    img_1.attr({ width: 0, height: 0 });
                    createElement("img", {
                      onload: function() {
                        var chart = charts[ren.chartIndex];
                        if (this.width === 0) {
                          css(this, {
                            position: "absolute",
                            top: "-999em"
                          });
                          doc.body.appendChild(this);
                        }
                        symbolSizes[imageSrc] = {
                          width: this.width,
                          height: this.height
                        };
                        img_1.imgwidth = this.width;
                        img_1.imgheight = this.height;
                        if (img_1.element) {
                          centerImage(img_1);
                        }
                        if (this.parentNode) {
                          this.parentNode.removeChild(this);
                        }
                        ren.imgCount--;
                        if (!ren.imgCount && chart && !chart.hasLoaded) {
                          chart.onload();
                        }
                      },
                      src: imageSrc
                    });
                    this.imgCount++;
                  }
                }
                return obj;
              };
              SVGRenderer2.prototype.clipRect = function(x, y, width, height) {
                var id2 = uniqueKey() + "-", clipPath = this.createElement("clipPath").attr({
                  id: id2
                }).add(this.defs), wrapper = this.rect(x, y, width, height, 0).add(clipPath);
                wrapper.id = id2;
                wrapper.clipPath = clipPath;
                wrapper.count = 0;
                return wrapper;
              };
              SVGRenderer2.prototype.text = function(str, x, y, useHTML) {
                var renderer = this, attribs = {};
                if (useHTML && (renderer.allowHTML || !renderer.forExport)) {
                  return renderer.html(str, x, y);
                }
                attribs.x = Math.round(x || 0);
                if (y) {
                  attribs.y = Math.round(y);
                }
                if (defined(str)) {
                  attribs.text = str;
                }
                var wrapper = renderer.createElement("text").attr(attribs);
                if (!useHTML || renderer.forExport && !renderer.allowHTML) {
                  wrapper.xSetter = function(value, key, element) {
                    var tspans = element.getElementsByTagName("tspan"), parentVal = element.getAttribute(key);
                    for (var i = 0, tspan = void 0; i < tspans.length; i++) {
                      tspan = tspans[i];
                      if (tspan.getAttribute(key) === parentVal) {
                        tspan.setAttribute(key, value);
                      }
                    }
                    element.setAttribute(key, value);
                  };
                }
                return wrapper;
              };
              SVGRenderer2.prototype.fontMetrics = function(fontSize, elem) {
                if ((this.styledMode || !/px/.test(fontSize)) && win.getComputedStyle) {
                  fontSize = elem && SVGElement.prototype.getStyle.call(elem, "font-size");
                } else {
                  fontSize = fontSize || // When the elem is a DOM element (#5932)
                  elem && elem.style && elem.style.fontSize || // Fall back on the renderer style default
                  this.style && this.style.fontSize;
                }
                if (/px/.test(fontSize)) {
                  fontSize = pInt(fontSize);
                } else {
                  fontSize = 12;
                }
                var lineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2), baseline = Math.round(lineHeight * 0.8);
                return {
                  h: lineHeight,
                  b: baseline,
                  f: fontSize
                };
              };
              SVGRenderer2.prototype.rotCorr = function(baseline, rotation, alterY) {
                var y = baseline;
                if (rotation && alterY) {
                  y = Math.max(y * Math.cos(rotation * deg2rad), 4);
                }
                return {
                  x: -baseline / 3 * Math.sin(rotation * deg2rad),
                  y
                };
              };
              SVGRenderer2.prototype.pathToSegments = function(path) {
                var ret = [];
                var segment = [];
                var commandLength = {
                  A: 8,
                  C: 7,
                  H: 2,
                  L: 3,
                  M: 3,
                  Q: 5,
                  S: 5,
                  T: 3,
                  V: 2
                };
                for (var i = 0; i < path.length; i++) {
                  if (isString(segment[0]) && isNumber(path[i]) && segment.length === commandLength[segment[0].toUpperCase()]) {
                    path.splice(i, 0, segment[0].replace("M", "L").replace("m", "l"));
                  }
                  if (typeof path[i] === "string") {
                    if (segment.length) {
                      ret.push(segment.slice(0));
                    }
                    segment.length = 0;
                  }
                  segment.push(path[i]);
                }
                ret.push(segment.slice(0));
                return ret;
              };
              SVGRenderer2.prototype.label = function(str, x, y, shape, anchorX, anchorY, useHTML, baseline, className) {
                return new SVGLabel(this, str, x, y, shape, anchorX, anchorY, useHTML, baseline, className);
              };
              SVGRenderer2.prototype.alignElements = function() {
                this.alignedObjects.forEach(function(el) {
                  return el.align();
                });
              };
              return SVGRenderer2;
            }()
          );
          extend2(SVGRenderer.prototype, {
            /**
             * A pointer to the renderer's associated Element class. The VMLRenderer
             * will have a pointer to VMLElement here.
             *
             * @name Highcharts.SVGRenderer#Element
             * @type {Highcharts.SVGElement}
             */
            Element: SVGElement,
            SVG_NS,
            /**
             * A collection of characters mapped to HTML entities. When `useHTML` on an
             * element is true, these entities will be rendered correctly by HTML. In
             * the SVG pseudo-HTML, they need to be unescaped back to simple characters,
             * so for example `&lt;` will render as `<`.
             *
             * @example
             * // Add support for unescaping quotes
             * Highcharts.SVGRenderer.prototype.escapes['"'] = '&quot;';
             *
             * @name Highcharts.SVGRenderer#escapes
             * @type {Highcharts.Dictionary<string>}
             */
            escapes: {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              "'": "&#39;",
              '"': "&quot;"
            },
            /**
             * An extendable collection of functions for defining symbol paths.
             *
             * @name Highcharts.SVGRenderer#symbols
             * @type {Highcharts.SymbolDictionary}
             */
            symbols: Symbols,
            /**
             * Dummy function for plugins, called every time the renderer is updated.
             * Prior to Highcharts 5, this was used for the canvg renderer.
             *
             * @deprecated
             * @function Highcharts.SVGRenderer#draw
             */
            draw: noop2
          });
          RendererRegistry.registerRendererType("svg", SVGRenderer, true);
          "";
          return SVGRenderer;
        });
        _registerModule(_modules, "Core/Renderer/HTML/HTMLElement.js", [_modules["Core/Globals.js"], _modules["Core/Renderer/SVG/SVGElement.js"], _modules["Core/Utilities.js"]], function(H, SVGElement, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var isFirefox = H.isFirefox, isMS = H.isMS, isWebKit = H.isWebKit, win = H.win;
          var css = U.css, defined = U.defined, extend2 = U.extend, pick = U.pick, pInt = U.pInt;
          var HTMLElement = (
            /** @class */
            function(_super) {
              __extends(HTMLElement2, _super);
              function HTMLElement2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              HTMLElement2.compose = function(SVGElementClass) {
                if (HTMLElement2.composedClasses.indexOf(SVGElementClass) === -1) {
                  HTMLElement2.composedClasses.push(SVGElementClass);
                  var htmlElementProto = HTMLElement2.prototype, svgElementProto = SVGElementClass.prototype;
                  svgElementProto.getSpanCorrection = htmlElementProto.getSpanCorrection;
                  svgElementProto.htmlCss = htmlElementProto.htmlCss;
                  svgElementProto.htmlGetBBox = htmlElementProto.htmlGetBBox;
                  svgElementProto.htmlUpdateTransform = htmlElementProto.htmlUpdateTransform;
                  svgElementProto.setSpanRotation = htmlElementProto.setSpanRotation;
                }
                return SVGElementClass;
              };
              HTMLElement2.prototype.getSpanCorrection = function(width, baseline, alignCorrection) {
                this.xCorr = -width * alignCorrection;
                this.yCorr = -baseline;
              };
              HTMLElement2.prototype.htmlCss = function(styles) {
                var wrapper = this, element = wrapper.element, isSettingWidth = element.tagName === "SPAN" && styles && "width" in styles, textWidth = pick(
                  isSettingWidth && styles.width,
                  void 0
                );
                var doTransform;
                if (isSettingWidth) {
                  delete styles.width;
                  wrapper.textWidth = textWidth;
                  doTransform = true;
                }
                if (styles && styles.textOverflow === "ellipsis") {
                  styles.whiteSpace = "nowrap";
                  styles.overflow = "hidden";
                }
                wrapper.styles = extend2(wrapper.styles, styles);
                css(wrapper.element, styles);
                if (doTransform) {
                  wrapper.htmlUpdateTransform();
                }
                return wrapper;
              };
              HTMLElement2.prototype.htmlGetBBox = function() {
                var wrapper = this, element = wrapper.element;
                return {
                  x: element.offsetLeft,
                  y: element.offsetTop,
                  width: element.offsetWidth,
                  height: element.offsetHeight
                };
              };
              HTMLElement2.prototype.htmlUpdateTransform = function() {
                if (!this.added) {
                  this.alignOnAdd = true;
                  return;
                }
                var wrapper = this, renderer = wrapper.renderer, elem = wrapper.element, translateX = wrapper.translateX || 0, translateY = wrapper.translateY || 0, x = wrapper.x || 0, y = wrapper.y || 0, align = wrapper.textAlign || "left", alignCorrection = {
                  left: 0,
                  center: 0.5,
                  right: 1
                }[align], styles = wrapper.styles, whiteSpace = styles && styles.whiteSpace;
                function getTextPxLength() {
                  if (wrapper.textPxLength) {
                    return wrapper.textPxLength;
                  }
                  css(elem, {
                    width: "",
                    whiteSpace: whiteSpace || "nowrap"
                  });
                  return elem.offsetWidth;
                }
                css(elem, {
                  marginLeft: translateX,
                  marginTop: translateY
                });
                if (!renderer.styledMode && wrapper.shadows) {
                  wrapper.shadows.forEach(function(shadow) {
                    css(shadow, {
                      marginLeft: translateX + 1,
                      marginTop: translateY + 1
                    });
                  });
                }
                if (wrapper.inverted) {
                  [].forEach.call(elem.childNodes, function(child) {
                    renderer.invertChild(child, elem);
                  });
                }
                if (elem.tagName === "SPAN") {
                  var rotation = wrapper.rotation, textWidth = wrapper.textWidth && pInt(wrapper.textWidth), currentTextTransform = [
                    rotation,
                    align,
                    elem.innerHTML,
                    wrapper.textWidth,
                    wrapper.textAlign
                  ].join(",");
                  var baseline = void 0, hasBoxWidthChanged = false;
                  if (textWidth !== wrapper.oldTextWidth) {
                    var textPxLength = getTextPxLength();
                    if ((textWidth > wrapper.oldTextWidth || textPxLength > textWidth) && // Only set the width if the text is able to word-wrap,
                    // or text-overflow is ellipsis (#9537)
                    (/[ \-]/.test(elem.textContent || elem.innerText) || elem.style.textOverflow === "ellipsis")) {
                      css(elem, {
                        width: textPxLength > textWidth || rotation ? textWidth + "px" : "auto",
                        display: "block",
                        whiteSpace: whiteSpace || "normal"
                        // #3331
                      });
                      wrapper.oldTextWidth = textWidth;
                      hasBoxWidthChanged = true;
                    }
                  }
                  wrapper.hasBoxWidthChanged = hasBoxWidthChanged;
                  if (currentTextTransform !== wrapper.cTT) {
                    baseline = renderer.fontMetrics(elem.style.fontSize, elem).b;
                    if (defined(rotation) && (rotation !== (wrapper.oldRotation || 0) || align !== wrapper.oldAlign)) {
                      wrapper.setSpanRotation(rotation, alignCorrection, baseline);
                    }
                    wrapper.getSpanCorrection(
                      // Avoid elem.offsetWidth if we can, it affects rendering
                      // time heavily (#7656)
                      !defined(rotation) && wrapper.textPxLength || // #7920
                      elem.offsetWidth,
                      baseline,
                      alignCorrection,
                      rotation,
                      align
                    );
                  }
                  css(elem, {
                    left: x + (wrapper.xCorr || 0) + "px",
                    top: y + (wrapper.yCorr || 0) + "px"
                  });
                  wrapper.cTT = currentTextTransform;
                  wrapper.oldRotation = rotation;
                  wrapper.oldAlign = align;
                }
              };
              HTMLElement2.prototype.setSpanRotation = function(rotation, alignCorrection, baseline) {
                var getTransformKey = function() {
                  return isMS && !/Edge/.test(win.navigator.userAgent) ? "-ms-transform" : isWebKit ? "-webkit-transform" : isFirefox ? "MozTransform" : win.opera ? "-o-transform" : void 0;
                };
                var rotationStyle = {}, cssTransformKey = getTransformKey();
                if (cssTransformKey) {
                  rotationStyle[cssTransformKey] = rotationStyle.transform = "rotate(" + rotation + "deg)";
                  rotationStyle[cssTransformKey + (isFirefox ? "Origin" : "-origin")] = rotationStyle.transformOrigin = alignCorrection * 100 + "% " + baseline + "px";
                  css(this.element, rotationStyle);
                }
              };
              HTMLElement2.composedClasses = [];
              return HTMLElement2;
            }(SVGElement)
          );
          return HTMLElement;
        });
        _registerModule(_modules, "Core/Renderer/HTML/HTMLRenderer.js", [_modules["Core/Renderer/HTML/AST.js"], _modules["Core/Renderer/SVG/SVGElement.js"], _modules["Core/Renderer/SVG/SVGRenderer.js"], _modules["Core/Utilities.js"]], function(AST, SVGElement, SVGRenderer, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var attr = U.attr, createElement = U.createElement, extend2 = U.extend, pick = U.pick;
          var HTMLRenderer = (
            /** @class */
            function(_super) {
              __extends(HTMLRenderer2, _super);
              function HTMLRenderer2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              HTMLRenderer2.compose = function(SVGRendererClass) {
                if (HTMLRenderer2.composedClasses.indexOf(SVGRendererClass) === -1) {
                  HTMLRenderer2.composedClasses.push(SVGRendererClass);
                  var htmlRendererProto = HTMLRenderer2.prototype, svgRendererProto = SVGRendererClass.prototype;
                  svgRendererProto.html = htmlRendererProto.html;
                }
                return SVGRendererClass;
              };
              HTMLRenderer2.prototype.html = function(str, x, y) {
                var wrapper = this.createElement("span"), element = wrapper.element, renderer = wrapper.renderer, isSVG = renderer.isSVG, addSetters = function(gWrapper, style) {
                  ["opacity", "visibility"].forEach(function(prop) {
                    gWrapper[prop + "Setter"] = function(value, key, elem) {
                      var styleObject = gWrapper.div ? gWrapper.div.style : style;
                      SVGElement.prototype[prop + "Setter"].call(this, value, key, elem);
                      if (styleObject) {
                        styleObject[key] = value;
                      }
                    };
                  });
                  gWrapper.addedSetters = true;
                };
                wrapper.textSetter = function(value) {
                  if (value !== this.textStr) {
                    delete this.bBox;
                    delete this.oldTextWidth;
                    AST.setElementHTML(this.element, pick(value, ""));
                    this.textStr = value;
                    wrapper.doTransform = true;
                  }
                };
                if (isSVG) {
                  addSetters(wrapper, wrapper.element.style);
                }
                wrapper.xSetter = wrapper.ySetter = wrapper.alignSetter = wrapper.rotationSetter = function(value, key) {
                  if (key === "align") {
                    wrapper.alignValue = wrapper.textAlign = value;
                  } else {
                    wrapper[key] = value;
                  }
                  wrapper.doTransform = true;
                };
                wrapper.afterSetters = function() {
                  if (this.doTransform) {
                    this.htmlUpdateTransform();
                    this.doTransform = false;
                  }
                };
                wrapper.attr({
                  text: str,
                  x: Math.round(x),
                  y: Math.round(y)
                }).css({
                  position: "absolute"
                });
                if (!renderer.styledMode) {
                  wrapper.css({
                    fontFamily: this.style.fontFamily,
                    fontSize: this.style.fontSize
                  });
                }
                element.style.whiteSpace = "nowrap";
                wrapper.css = wrapper.htmlCss;
                if (isSVG) {
                  wrapper.add = function(svgGroupWrapper) {
                    var container = renderer.box.parentNode, parents = [];
                    var htmlGroup, parentGroup;
                    this.parentGroup = svgGroupWrapper;
                    if (svgGroupWrapper) {
                      htmlGroup = svgGroupWrapper.div;
                      if (!htmlGroup) {
                        parentGroup = svgGroupWrapper;
                        while (parentGroup) {
                          parents.push(parentGroup);
                          parentGroup = parentGroup.parentGroup;
                        }
                        parents.reverse().forEach(function(parentGroup2) {
                          var cls = attr(parentGroup2.element, "class");
                          function translateSetter(value, key) {
                            parentGroup2[key] = value;
                            if (key === "translateX") {
                              htmlGroupStyle.left = value + "px";
                            } else {
                              htmlGroupStyle.top = value + "px";
                            }
                            parentGroup2.doTransform = true;
                          }
                          var parentGroupStyles = parentGroup2.styles || {};
                          htmlGroup = parentGroup2.div = parentGroup2.div || createElement("div", cls ? { className: cls } : void 0, {
                            position: "absolute",
                            left: (parentGroup2.translateX || 0) + "px",
                            top: (parentGroup2.translateY || 0) + "px",
                            display: parentGroup2.display,
                            opacity: parentGroup2.opacity,
                            cursor: parentGroupStyles.cursor,
                            pointerEvents: (
                              // #5595
                              parentGroupStyles.pointerEvents
                            ),
                            visibility: parentGroup2.visibility
                            // the top group is appended to container
                          }, htmlGroup || container);
                          var htmlGroupStyle = htmlGroup.style;
                          extend2(parentGroup2, {
                            // (#7287) Pass htmlGroup to use
                            // the related group
                            classSetter: function(htmlGroup2) {
                              return function(value) {
                                this.element.setAttribute("class", value);
                                htmlGroup2.className = value;
                              };
                            }(htmlGroup),
                            on: function() {
                              if (parents[0].div) {
                                wrapper.on.apply({
                                  element: parents[0].div,
                                  onEvents: parentGroup2.onEvents
                                }, arguments);
                              }
                              return parentGroup2;
                            },
                            translateXSetter: translateSetter,
                            translateYSetter: translateSetter
                          });
                          if (!parentGroup2.addedSetters) {
                            addSetters(parentGroup2);
                          }
                        });
                      }
                    } else {
                      htmlGroup = container;
                    }
                    htmlGroup.appendChild(element);
                    wrapper.added = true;
                    if (wrapper.alignOnAdd) {
                      wrapper.htmlUpdateTransform();
                    }
                    return wrapper;
                  };
                }
                return wrapper;
              };
              HTMLRenderer2.composedClasses = [];
              return HTMLRenderer2;
            }(SVGRenderer)
          );
          return HTMLRenderer;
        });
        _registerModule(_modules, "Core/Axis/AxisDefaults.js", [], function() {
          var AxisDefaults;
          (function(AxisDefaults2) {
            AxisDefaults2.defaultXAxisOptions = {
              /**
               * When using multiple axis, the ticks of two or more opposite axes
               * will automatically be aligned by adding ticks to the axis or axes
               * with the least ticks, as if `tickAmount` were specified.
               *
               * This can be prevented by setting `alignTicks` to false. If the grid
               * lines look messy, it's a good idea to hide them for the secondary
               * axis by setting `gridLineWidth` to 0.
               *
               * If `startOnTick` or `endOnTick` in an Axis options are set to false,
               * then the `alignTicks ` will be disabled for the Axis.
               *
               * Disabled for logarithmic axes.
               *
               * @product   highcharts highstock gantt
               */
              alignTicks: true,
              /**
               * Whether to allow decimals in this axis' ticks. When counting
               * integers, like persons or hits on a web page, decimals should
               * be avoided in the labels. By default, decimals are allowed on small
               * scale axes.
               *
               * @see [minTickInterval](#xAxis.minTickInterval)
               *
               * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-true/
               *         True by default
               * @sample {highcharts|highstock} highcharts/yaxis/allowdecimals-false/
               *         False
               *
               * @type      {boolean|undefined}
               * @default   undefined
               * @since     2.0
               */
              allowDecimals: void 0,
              /**
               * When using an alternate grid color, a band is painted across the
               * plot area between every other grid line.
               *
               * @sample {highcharts} highcharts/yaxis/alternategridcolor/
               *         Alternate grid color on the Y axis
               * @sample {highstock} stock/xaxis/alternategridcolor/
               *         Alternate grid color on the Y axis
               *
               * @type      {Highcharts.ColorType}
               * @apioption xAxis.alternateGridColor
               */
              /**
               * An array defining breaks in the axis, the sections defined will be
               * left out and all the points shifted closer to each other.
               *
               * @productdesc {highcharts}
               * Requires that the broken-axis.js module is loaded.
               *
               * @sample {highcharts} highcharts/axisbreak/break-simple/
               *         Simple break
               * @sample {highcharts|highstock} highcharts/axisbreak/break-visualized/
               *         Advanced with callback
               * @sample {highstock} stock/demo/intraday-breaks/
               *         Break on nights and weekends
               *
               * @type      {Array<*>}
               * @since     4.1.0
               * @product   highcharts highstock gantt
               * @apioption xAxis.breaks
               */
              /**
               * A number indicating how much space should be left between the start
               * and the end of the break. The break size is given in axis units,
               * so for instance on a `datetime` axis, a break size of 3600000 would
               * indicate the equivalent of an hour.
               *
               * @type      {number}
               * @default   0
               * @since     4.1.0
               * @product   highcharts highstock gantt
               * @apioption xAxis.breaks.breakSize
               */
              /**
               * The point where the break starts.
               *
               * @type      {number}
               * @since     4.1.0
               * @product   highcharts highstock gantt
               * @apioption xAxis.breaks.from
               */
              /**
               * Defines an interval after which the break appears again. By default
               * the breaks do not repeat.
               *
               * @type      {number}
               * @default   0
               * @since     4.1.0
               * @product   highcharts highstock gantt
               * @apioption xAxis.breaks.repeat
               */
              /**
               * The point where the break ends.
               *
               * @type      {number}
               * @since     4.1.0
               * @product   highcharts highstock gantt
               * @apioption xAxis.breaks.to
               */
              /**
               * If categories are present for the xAxis, names are used instead of
               * numbers for that axis.
               *
               * Since Highcharts 3.0, categories can also
               * be extracted by giving each point a [name](#series.data) and setting
               * axis [type](#xAxis.type) to `category`. However, if you have multiple
               * series, best practice remains defining the `categories` array.
               *
               * Example: `categories: ['Apples', 'Bananas', 'Oranges']`
               *
               * @sample {highcharts} highcharts/demo/line-labels/
               *         With
               * @sample {highcharts} highcharts/xaxis/categories/
               *         Without
               *
               * @type      {Array<string>}
               * @product   highcharts gantt
               * @apioption xAxis.categories
               */
              /**
               * The highest allowed value for automatically computed axis extremes.
               *
               * @see [floor](#xAxis.floor)
               *
               * @sample {highcharts|highstock} highcharts/yaxis/floor-ceiling/
               *         Floor and ceiling
               *
               * @type       {number}
               * @since      4.0
               * @product    highcharts highstock gantt
               * @apioption  xAxis.ceiling
               */
              /**
               * A class name that opens for styling the axis by CSS, especially in
               * Highcharts styled mode. The class name is applied to group elements
               * for the grid, axis elements and labels.
               *
               * @sample {highcharts|highstock|highmaps} highcharts/css/axis/
               *         Multiple axes with separate styling
               *
               * @type      {string}
               * @since     5.0.0
               * @apioption xAxis.className
               */
              /**
               * Configure a crosshair that follows either the mouse pointer or the
               * hovered point.
               *
               * In styled mode, the crosshairs are styled in the
               * `.highcharts-crosshair`, `.highcharts-crosshair-thin` or
               * `.highcharts-xaxis-category` classes.
               *
               * @productdesc {highstock}
               * In Highcharts stock, by default, the crosshair is enabled on the
               * X axis and disabled on the Y axis.
               *
               * @sample {highcharts} highcharts/xaxis/crosshair-both/
               *         Crosshair on both axes
               * @sample {highstock} stock/xaxis/crosshairs-xy/
               *         Crosshair on both axes, with y axis label
               * @sample {highmaps} highcharts/xaxis/crosshair-both/
               *         Crosshair on both axes
               *
               * @declare   Highcharts.AxisCrosshairOptions
               * @type      {boolean|*}
               * @default   false
               * @since     4.1
               * @apioption xAxis.crosshair
               */
              /**
               * A class name for the crosshair, especially as a hook for styling.
               *
               * @type      {string}
               * @since     5.0.0
               * @apioption xAxis.crosshair.className
               */
              /**
               * The color of the crosshair. Defaults to `#cccccc` for numeric and
               * datetime axes, and `rgba(204,214,235,0.25)` for category axes, where
               * the crosshair by default highlights the whole category.
               *
               * @sample {highcharts|highstock|highmaps} highcharts/xaxis/crosshair-customized/
               *         Customized crosshairs
               *
               * @type      {Highcharts.ColorType}
               * @default   #cccccc
               * @since     4.1
               * @apioption xAxis.crosshair.color
               */
              /**
               * The dash style for the crosshair. See
               * [plotOptions.series.dashStyle](#plotOptions.series.dashStyle)
               * for possible values.
               *
               * @sample {highcharts|highmaps} highcharts/xaxis/crosshair-dotted/
               *         Dotted crosshair
               * @sample {highstock} stock/xaxis/crosshair-dashed/
               *         Dashed X axis crosshair
               *
               * @type      {Highcharts.DashStyleValue}
               * @default   Solid
               * @since     4.1
               * @apioption xAxis.crosshair.dashStyle
               */
              /**
               * A label on the axis next to the crosshair.
               *
               * In styled mode, the label is styled with the
               * `.highcharts-crosshair-label` class.
               *
               * @sample {highstock} stock/xaxis/crosshair-label/
               *         Crosshair labels
               * @sample {highstock} highcharts/css/crosshair-label/
               *         Style mode
               *
               * @declare   Highcharts.AxisCrosshairLabelOptions
               * @since     2.1
               * @product   highstock
               * @apioption xAxis.crosshair.label
               */
              /**
               * Alignment of the label compared to the axis. Defaults to `"left"` for
               * right-side axes, `"right"` for left-side axes and `"center"` for
               * horizontal axes.
               *
               * @type      {Highcharts.AlignValue}
               * @since     2.1
               * @product   highstock
               * @apioption xAxis.crosshair.label.align
               */
              /**
               * The background color for the label. Defaults to the related series
               * color, or `#666666` if that is not available.
               *
               * @type      {Highcharts.ColorType}
               * @since     2.1
               * @product   highstock
               * @apioption xAxis.crosshair.label.backgroundColor
               */
              /**
               * The border color for the crosshair label
               *
               * @type      {Highcharts.ColorType}
               * @since     2.1
               * @product   highstock
               * @apioption xAxis.crosshair.label.borderColor
               */
              /**
               * The border corner radius of the crosshair label.
               *
               * @type      {number}
               * @default   3
               * @since     2.1.10
               * @product   highstock
               * @apioption xAxis.crosshair.label.borderRadius
               */
              /**
               * The border width for the crosshair label.
               *
               * @type      {number}
               * @default   0
               * @since     2.1
               * @product   highstock
               * @apioption xAxis.crosshair.label.borderWidth
               */
              /**
               * Flag to enable crosshair's label.
               *
               * @sample {highstock} stock/xaxis/crosshairs-xy/
               *         Enabled label for yAxis' crosshair
               *
               * @type      {boolean}
               * @default   false
               * @since     2.1
               * @product   highstock
               * @apioption xAxis.crosshair.label.enabled
               */
              /**
               * A format string for the crosshair label. Defaults to `{value}` for
               * numeric axes and `{value:%b %d, %Y}` for datetime axes.
               *
               * @type      {string}
               * @since     2.1
               * @product   highstock
               * @apioption xAxis.crosshair.label.format
               */
              /**
               * Formatter function for the label text.
               *
               * @type      {Highcharts.XAxisCrosshairLabelFormatterCallbackFunction}
               * @since     2.1
               * @product   highstock
               * @apioption xAxis.crosshair.label.formatter
               */
              /**
               * Padding inside the crosshair label.
               *
               * @type      {number}
               * @default   8
               * @since     2.1
               * @product   highstock
               * @apioption xAxis.crosshair.label.padding
               */
              /**
               * The shape to use for the label box.
               *
               * @type      {string}
               * @default   callout
               * @since     2.1
               * @product   highstock
               * @apioption xAxis.crosshair.label.shape
               */
              /**
               * Text styles for the crosshair label.
               *
               * @type      {Highcharts.CSSObject}
               * @default   {"color": "white", "fontWeight": "normal", "fontSize": "11px", "textAlign": "center"}
               * @since     2.1
               * @product   highstock
               * @apioption xAxis.crosshair.label.style
               */
              /**
               * Whether the crosshair should snap to the point or follow the pointer
               * independent of points.
               *
               * @sample {highcharts|highstock} highcharts/xaxis/crosshair-snap-false/
               *         True by default
               * @sample {highmaps} maps/demo/latlon-advanced/
               *         Snap is false
               *
               * @type      {boolean}
               * @default   true
               * @since     4.1
               * @apioption xAxis.crosshair.snap
               */
              /**
               * The pixel width of the crosshair. Defaults to 1 for numeric or
               * datetime axes, and for one category width for category axes.
               *
               * @sample {highcharts} highcharts/xaxis/crosshair-customized/
               *         Customized crosshairs
               * @sample {highstock} highcharts/xaxis/crosshair-customized/
               *         Customized crosshairs
               * @sample {highmaps} highcharts/xaxis/crosshair-customized/
               *         Customized crosshairs
               *
               * @type      {number}
               * @default   1
               * @since     4.1
               * @apioption xAxis.crosshair.width
               */
              /**
               * The Z index of the crosshair. Higher Z indices allow drawing the
               * crosshair on top of the series or behind the grid lines.
               *
               * @type      {number}
               * @default   2
               * @since     4.1
               * @apioption xAxis.crosshair.zIndex
               */
              /**
               * Whether to pan axis. If `chart.panning` is enabled, the option
               * allows to disable panning on an individual axis.
               */
              panningEnabled: true,
              /**
               * The Z index for the axis group.
               */
              zIndex: 2,
              /**
               * Whether to zoom axis. If `chart.zoomType` is set, the option allows
               * to disable zooming on an individual axis.
               *
               * @sample {highcharts} highcharts/xaxis/zoomenabled/
               *         Zoom enabled is false
               */
              zoomEnabled: true,
              /**
               * For a datetime axis, the scale will automatically adjust to the
               * appropriate unit. This member gives the default string
               * representations used for each unit. For intermediate values,
               * different units may be used, for example the `day` unit can be used
               * on midnight and `hour` unit be used for intermediate values on the
               * same axis.
               *
               * For an overview of the replacement codes, see
               * [dateFormat](/class-reference/Highcharts.Time#dateFormat).
               *
               * Defaults to:
               * ```js
               * {
               *     millisecond: '%H:%M:%S.%L',
               *     second: '%H:%M:%S',
               *     minute: '%H:%M',
               *     hour: '%H:%M',
               *     day: '%e. %b',
               *     week: '%e. %b',
               *     month: '%b \'%y',
               *     year: '%Y'
               * }
               * ```
               *
               * @sample {highcharts} highcharts/xaxis/datetimelabelformats/
               *         Different day format on X axis
               * @sample {highstock} stock/xaxis/datetimelabelformats/
               *         More information in x axis labels
               *
               * @declare Highcharts.AxisDateTimeLabelFormatsOptions
               * @product highcharts highstock gantt
               */
              dateTimeLabelFormats: {
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                millisecond: {
                  main: "%H:%M:%S.%L",
                  range: false
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                second: {
                  main: "%H:%M:%S",
                  range: false
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                minute: {
                  main: "%H:%M",
                  range: false
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                hour: {
                  main: "%H:%M",
                  range: false
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                day: {
                  main: "%e. %b"
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                week: {
                  main: "%e. %b"
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                month: {
                  main: "%b '%y"
                },
                /**
                 * @declare Highcharts.AxisDateTimeLabelFormatsOptionsObject
                 * @type {string|*}
                 */
                year: {
                  main: "%Y"
                }
              },
              /**
               * Whether to force the axis to end on a tick. Use this option with
               * the `maxPadding` option to control the axis end.
               *
               * @productdesc {highstock}
               * In Highcharts Stock, `endOnTick` is always `false` when the navigator
               * is enabled, to prevent jumpy scrolling.
               *
               * @sample {highcharts} highcharts/yaxis/endontick/
               *         True by default
               * @sample {highcharts} highcharts/yaxis/endontick-false/
               *         False
               * @sample {highstock} stock/demo/basic-line/
               *         True by default
               * @sample {highstock} stock/xaxis/endontick/
               *         False
               *
               * @since 1.2.0
               */
              endOnTick: false,
              /**
               * Event handlers for the axis.
               *
               * @type      {*}
               * @apioption xAxis.events
               */
              /**
               * An event fired after the breaks have rendered.
               *
               * @see [breaks](#xAxis.breaks)
               *
               * @sample {highcharts} highcharts/axisbreak/break-event/
               *         AfterBreak Event
               *
               * @type      {Highcharts.AxisEventCallbackFunction}
               * @since     4.1.0
               * @product   highcharts gantt
               * @apioption xAxis.events.afterBreaks
               */
              /**
               * As opposed to the `setExtremes` event, this event fires after the
               * final min and max values are computed and corrected for `minRange`.
               *
               * Fires when the minimum and maximum is set for the axis, either by
               * calling the `.setExtremes()` method or by selecting an area in the
               * chart. One parameter, `event`, is passed to the function, containing
               * common event information.
               *
               * The new user set minimum and maximum values can be found by
               * `event.min` and `event.max`. These reflect the axis minimum and
               * maximum in axis values. The actual data extremes are found in
               * `event.dataMin` and `event.dataMax`.
               *
               * @type      {Highcharts.AxisSetExtremesEventCallbackFunction}
               * @since     2.3
               * @context   Highcharts.Axis
               * @apioption xAxis.events.afterSetExtremes
               */
              /**
               * An event fired when a break from this axis occurs on a point.
               *
               * @see [breaks](#xAxis.breaks)
               *
               * @sample {highcharts} highcharts/axisbreak/break-visualized/
               *         Visualization of a Break
               *
               * @type      {Highcharts.AxisPointBreakEventCallbackFunction}
               * @since     4.1.0
               * @product   highcharts gantt
               * @context   Highcharts.Axis
               * @apioption xAxis.events.pointBreak
               */
              /**
               * An event fired when a point falls inside a break from this axis.
               *
               * @type      {Highcharts.AxisPointBreakEventCallbackFunction}
               * @product   highcharts highstock gantt
               * @context   Highcharts.Axis
               * @apioption xAxis.events.pointInBreak
               */
              /**
               * Fires when the minimum and maximum is set for the axis, either by
               * calling the `.setExtremes()` method or by selecting an area in the
               * chart. One parameter, `event`, is passed to the function,
               * containing common event information.
               *
               * The new user set minimum and maximum values can be found by
               * `event.min` and `event.max`. These reflect the axis minimum and
               * maximum in data values. When an axis is zoomed all the way out from
               * the "Reset zoom" button, `event.min` and `event.max` are null, and
               * the new extremes are set based on `this.dataMin` and `this.dataMax`.
               *
               * @sample {highstock} stock/xaxis/events-setextremes/
               *         Log new extremes on x axis
               *
               * @type      {Highcharts.AxisSetExtremesEventCallbackFunction}
               * @since     1.2.0
               * @context   Highcharts.Axis
               * @apioption xAxis.events.setExtremes
               */
              /**
               * The lowest allowed value for automatically computed axis extremes.
               *
               * @see [ceiling](#yAxis.ceiling)
               *
               * @sample {highcharts} highcharts/yaxis/floor-ceiling/
               *         Floor and ceiling
               * @sample {highstock} stock/demo/lazy-loading/
               *         Prevent negative stock price on Y axis
               *
               * @type      {number}
               * @since     4.0
               * @product   highcharts highstock gantt
               * @apioption xAxis.floor
               */
              /**
               * The dash or dot style of the grid lines. For possible values, see
               * [this demonstration](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-dashstyle-all/).
               *
               * @sample {highcharts} highcharts/yaxis/gridlinedashstyle/
               *         Long dashes
               * @sample {highstock} stock/xaxis/gridlinedashstyle/
               *         Long dashes
               *
               * @type      {Highcharts.DashStyleValue}
               * @since     1.2
               */
              gridLineDashStyle: "Solid",
              /**
               * The Z index of the grid lines.
               *
               * @sample {highcharts|highstock} highcharts/xaxis/gridzindex/
               *         A Z index of 4 renders the grid above the graph
               *
               * @product   highcharts highstock gantt
               */
              gridZIndex: 1,
              /**
               * An id for the axis. This can be used after render time to get
               * a pointer to the axis object through `chart.get()`.
               *
               * @sample {highcharts} highcharts/xaxis/id/
               *         Get the object
               * @sample {highstock} stock/xaxis/id/
               *         Get the object
               *
               * @type      {string}
               * @since     1.2.0
               * @apioption xAxis.id
               */
              /**
               * The axis labels show the number or category for each tick.
               *
               * Since v8.0.0: Labels are animated in categorized x-axis with
               * updating data if `tickInterval` and `step` is set to 1.
               *
               * @productdesc {highmaps}
               * X and Y axis labels are by default disabled in Highmaps, but the
               * functionality is inherited from Highcharts and used on `colorAxis`,
               * and can be enabled on X and Y axes too.
               */
              labels: {
                /**
                 * What part of the string the given position is anchored to.
                 * If `left`, the left side of the string is at the axis position.
                 * Can be one of `"left"`, `"center"` or `"right"`. Defaults to
                 * an intelligent guess based on which side of the chart the axis
                 * is on and the rotation of the label.
                 *
                 * @see [reserveSpace](#xAxis.labels.reserveSpace)
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-align-left/
                 *         Left
                 * @sample {highcharts} highcharts/xaxis/labels-align-right/
                 *         Right
                 * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
                 *         Left-aligned labels on a vertical category axis
                 *
                 * @type       {Highcharts.AlignValue}
                 * @apioption  xAxis.labels.align
                 */
                /**
                 * Whether to allow the axis labels to overlap.
                 * When false, overlapping labels are hidden.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-allowoverlap-true/
                 *         X axis labels overlap enabled
                 *
                 * @type {boolean}
                 * @default false
                 * @apioption xAxis.labels.allowOverlap
                 *
                 */
                /**
                 * For horizontal axes, the allowed degrees of label rotation
                 * to prevent overlapping labels. If there is enough space,
                 * labels are not rotated. As the chart gets narrower, it
                 * will start rotating the labels -45 degrees, then remove
                 * every second label and try again with rotations 0 and -45 etc.
                 * Set it to `undefined` to disable rotation, which will
                 * cause the labels to word-wrap if possible. Defaults to `[-45]``
                 * on bottom and top axes, `undefined` on left and right axes.
                 *
                 * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-default/
                 *         Default auto rotation of 0 or -45
                 * @sample {highcharts|highstock} highcharts/xaxis/labels-autorotation-0-90/
                 *         Custom graded auto rotation
                 *
                 * @type      {Array<number>}
                 * @default   undefined
                 * @since     4.1.0
                 * @product   highcharts highstock gantt
                 * @apioption xAxis.labels.autoRotation
                 */
                autoRotation: void 0,
                /**
                 * When each category width is more than this many pixels, we don't
                 * apply auto rotation. Instead, we lay out the axis label with word
                 * wrap. A lower limit makes sense when the label contains multiple
                 * short words that don't extend the available horizontal space for
                 * each label.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-autorotationlimit/
                 *         Lower limit
                 *
                 * @since     4.1.5
                 * @product   highcharts gantt
                 */
                autoRotationLimit: 80,
                /**
                 * Polar charts only. The label's pixel distance from the perimeter
                 * of the plot area.
                 *
                 * @type      {number}
                 * @default   undefined
                 * @product   highcharts gantt
                 */
                distance: void 0,
                /**
                 * Enable or disable the axis labels.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-enabled/
                 *         X axis labels disabled
                 * @sample {highstock} stock/xaxis/labels-enabled/
                 *         X axis labels disabled
                 *
                 * @default {highcharts|highstock|gantt} true
                 * @default {highmaps} false
                 */
                enabled: true,
                /**
                 * A format string for the axis label. The context is available as
                 * format string variables. For example, you can use `{text}` to
                 * insert the default formatted text. The recommended way of adding
                 * units for the label is using `text`, for example `{text} km`.
                 *
                 * To add custom numeric or datetime formatting, use `{value}` with
                 * formatting, for example `{value:.1f}` or `{value:%Y-%m-%d}`.
                 *
                 * See
                 * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
                 * for more examples of formatting.
                 *
                 * The default value is not specified due to the dynamic
                 * nature of the default implementation.
                 *
                 * @sample {highcharts|highstock} highcharts/yaxis/labels-format/
                 *         Add units to Y axis label
                 * @sample {highcharts} highcharts/xaxis/labels-format-linked/
                 *         Linked category names
                 * @sample {highcharts} highcharts/xaxis/labels-format-custom/
                 *         Custom number format
                 *
                 * @type      {string}
                 * @since     3.0
                 * @apioption xAxis.labels.format
                 */
                /**
                 * Callback JavaScript function to format the label. The value
                 * is given by `this.value`. Additional properties for `this` are
                 * `axis`, `chart`, `isFirst`, `isLast` and `text` which holds the
                 * value of the default formatter.
                 *
                 * Defaults to a built in function returning a formatted string
                 * depending on whether the axis is `category`, `datetime`,
                 * `numeric` or other.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-formatter-linked/
                 *         Linked category names
                 * @sample {highcharts} highcharts/xaxis/labels-formatter-extended/
                 *         Modified numeric labels
                 * @sample {highstock} stock/xaxis/labels-formatter/
                 *         Added units on Y axis
                 *
                 * @type      {Highcharts.AxisLabelsFormatterCallbackFunction}
                 * @apioption xAxis.labels.formatter
                 */
                /**
                 * The number of pixels to indent the labels per level in a treegrid
                 * axis.
                 *
                 * @sample gantt/treegrid-axis/demo
                 *         Indentation 10px by default.
                 * @sample gantt/treegrid-axis/indentation-0px
                 *         Indentation set to 0px.
                 *
                 * @product gantt
                 */
                indentation: 10,
                /**
                 * Horizontal axis only. When `staggerLines` is not set,
                 * `maxStaggerLines` defines how many lines the axis is allowed to
                 * add to automatically avoid overlapping X labels. Set to `1` to
                 * disable overlap detection.
                 *
                 * @deprecated
                 * @type      {number}
                 * @default   5
                 * @since     1.3.3
                 * @apioption xAxis.labels.maxStaggerLines
                 */
                /**
                 * How to handle overflowing labels on horizontal axis. If set to
                 * `"allow"`, it will not be aligned at all. By default it
                 * `"justify"` labels inside the chart area. If there is room to
                 * move it, it will be aligned to the edge, else it will be removed.
                 *
                 * @since      2.2.5
                 * @validvalue ["allow", "justify"]
                 */
                overflow: "justify",
                /**
                 * The pixel padding for axis labels, to ensure white space between
                 * them.
                 *
                 * @product   highcharts gantt
                 */
                padding: 5,
                /**
                 * Whether to reserve space for the labels. By default, space is
                 * reserved for the labels in these cases:
                 *
                 * * On all horizontal axes.
                 * * On vertical axes if `label.align` is `right` on a left-side
                 * axis or `left` on a right-side axis.
                 * * On vertical axes if `label.align` is `center`.
                 *
                 * This can be turned off when for example the labels are rendered
                 * inside the plot area instead of outside.
                 *
                 * @see [labels.align](#xAxis.labels.align)
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-reservespace/
                 *         No reserved space, labels inside plot
                 * @sample {highcharts} highcharts/xaxis/labels-reservespace-true/
                 *         Left-aligned labels on a vertical category axis
                 *
                 * @type      {boolean}
                 * @since     4.1.10
                 * @product   highcharts gantt
                 * @apioption xAxis.labels.reserveSpace
                 */
                reserveSpace: void 0,
                /**
                 * Rotation of the labels in degrees. When `undefined`, the
                 * `autoRotation` option takes precedence.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-rotation/
                 *         X axis labels rotated 90°
                 *
                 * @type      {number}
                 * @default   0
                 * @apioption xAxis.labels.rotation
                 */
                rotation: void 0,
                /**
                 * Horizontal axes only. The number of lines to spread the labels
                 * over to make room or tighter labels. 0 disables staggering.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-staggerlines/
                 *         Show labels over two lines
                 * @sample {highstock} stock/xaxis/labels-staggerlines/
                 *         Show labels over two lines
                 *
                 * @since     2.1
                 */
                staggerLines: 0,
                /**
                 * To show only every _n_'th label on the axis, set the step to _n_.
                 * Setting the step to 2 shows every other label.
                 *
                 * By default, when 0, the step is calculated automatically to avoid
                 * overlap. To prevent this, set it to 1\. This usually only
                 * happens on a category axis, and is often a sign that you have
                 * chosen the wrong axis type.
                 *
                 * Read more at
                 * [Axis docs](https://www.highcharts.com/docs/chart-concepts/axes)
                 * => What axis should I use?
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-step/
                 *         Showing only every other axis label on a categorized
                 *         x-axis
                 * @sample {highcharts} highcharts/xaxis/labels-step-auto/
                 *         Auto steps on a category axis
                 *
                 * @since     2.1
                 */
                step: 0,
                /**
                 * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
                 * to render the labels.
                 */
                useHTML: false,
                /**
                 * The x position offset of all labels relative to the tick
                 * positions on the axis.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-x/
                 *         Y axis labels placed on grid lines
                 */
                x: 0,
                /**
                 * The y position offset of all labels relative to the tick
                 * positions on the axis. The default makes it adapt to the font
                 * size of the bottom axis.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-x/
                 *         Y axis labels placed on grid lines
                 *
                 * @type      {number}
                 * @apioption xAxis.labels.y
                 */
                /**
                 * The Z index for the axis labels.
                 */
                zIndex: 7,
                /**
                 * CSS styles for the label. Use `whiteSpace: 'nowrap'` to prevent
                 * wrapping of category labels. Use `textOverflow: 'none'` to
                 * prevent ellipsis (dots).
                 *
                 * In styled mode, the labels are styled with the
                 * `.highcharts-axis-labels` class.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-style/
                 *         Red X axis labels
                 *
                 * @type      {Highcharts.CSSObject}
                 */
                style: {
                  /** @internal */
                  color: "#666666",
                  /** @internal */
                  cursor: "default",
                  /** @internal */
                  fontSize: "11px"
                }
              },
              /**
               * The left position as the horizontal axis. If it's a number, it is
               * interpreted as pixel position relative to the chart.
               *
               * Since Highcharts v5.0.13: If it's a percentage string, it is
               * interpreted as percentages of the plot width, offset from plot area
               * left.
               *
               * @type      {number|string}
               * @product   highcharts highstock
               * @apioption xAxis.left
               */
              /**
               * The top position as the vertical axis. If it's a number, it is
               * interpreted as pixel position relative to the chart.
               *
               * Since Highcharts 2: If it's a percentage string, it is interpreted
               * as percentages of the plot height, offset from plot area top.
               *
               * @type      {number|string}
               * @product   highcharts highstock
               * @apioption xAxis.top
               */
              /**
               * Index of another axis that this axis is linked to. When an axis is
               * linked to a master axis, it will take the same extremes as
               * the master, but as assigned by min or max or by setExtremes.
               * It can be used to show additional info, or to ease reading the
               * chart by duplicating the scales.
               *
               * @sample {highcharts} highcharts/xaxis/linkedto/
               *         Different string formats of the same date
               * @sample {highcharts} highcharts/yaxis/linkedto/
               *         Y values on both sides
               *
               * @type      {number}
               * @since     2.0.2
               * @product   highcharts highstock gantt
               * @apioption xAxis.linkedTo
               */
              /**
               * The maximum value of the axis. If `null`, the max value is
               * automatically calculated.
               *
               * If the [endOnTick](#yAxis.endOnTick) option is true, the `max` value
               * might be rounded up.
               *
               * If a [tickAmount](#yAxis.tickAmount) is set, the axis may be extended
               * beyond the set max in order to reach the given number of ticks. The
               * same may happen in a chart with multiple axes, determined by [chart.
               * alignTicks](#chart), where a `tickAmount` is applied internally.
               *
               * @sample {highcharts} highcharts/yaxis/max-200/
               *         Y axis max of 200
               * @sample {highcharts} highcharts/yaxis/max-logarithmic/
               *         Y axis max on logarithmic axis
               * @sample {highstock} stock/xaxis/min-max/
               *         Fixed min and max on X axis
               *
               * @type      {number|null}
               * @apioption xAxis.max
               */
              /**
               * Padding of the max value relative to the length of the axis. A
               * padding of 0.05 will make a 100px axis 5px longer. This is useful
               * when you don't want the highest data value to appear on the edge
               * of the plot area. When the axis' `max` option is set or a max extreme
               * is set using `axis.setExtremes()`, the maxPadding will be ignored.
               *
               * @productdesc {highstock}
               * For an [ordinal](#xAxis.ordinal) axis, `minPadding` and `maxPadding`
               * are ignored. Use [overscroll](#xAxis.overscroll) instead.
               *
               * @sample {highcharts} highcharts/yaxis/maxpadding/
               *         Max padding of 0.25 on y axis
               * @sample {highstock} stock/xaxis/minpadding-maxpadding/
               *         Greater min- and maxPadding
               * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
               *         Add some padding
               *
               * @default   {highcharts} 0.01
               * @default   {highstock|highmaps} 0
               * @since     1.2.0
               */
              maxPadding: 0.01,
              /**
               * Deprecated. Use `minRange` instead.
               *
               * @deprecated
               * @type      {number}
               * @product   highcharts highstock
               * @apioption xAxis.maxZoom
               */
              /**
               * The minimum value of the axis. If `null` the min value is
               * automatically calculated.
               *
               * If the [startOnTick](#yAxis.startOnTick) option is true (default),
               * the `min` value might be rounded down.
               *
               * The automatically calculated minimum value is also affected by
               * [floor](#yAxis.floor), [softMin](#yAxis.softMin),
               * [minPadding](#yAxis.minPadding), [minRange](#yAxis.minRange)
               * as well as [series.threshold](#plotOptions.series.threshold)
               * and [series.softThreshold](#plotOptions.series.softThreshold).
               *
               * @sample {highcharts} highcharts/yaxis/min-startontick-false/
               *         -50 with startOnTick to false
               * @sample {highcharts} highcharts/yaxis/min-startontick-true/
               *         -50 with startOnTick true by default
               * @sample {highstock} stock/xaxis/min-max/
               *         Set min and max on X axis
               *
               * @type      {number|null}
               * @apioption xAxis.min
               */
              /**
               * The dash or dot style of the minor grid lines. For possible values,
               * see [this demonstration](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/plotoptions/series-dashstyle-all/).
               *
               * @sample {highcharts} highcharts/yaxis/minorgridlinedashstyle/
               *         Long dashes on minor grid lines
               * @sample {highstock} stock/xaxis/minorgridlinedashstyle/
               *         Long dashes on minor grid lines
               *
               * @type      {Highcharts.DashStyleValue}
               * @since     1.2
               */
              minorGridLineDashStyle: "Solid",
              /**
               * Specific tick interval in axis units for the minor ticks. On a linear
               * axis, if `"auto"`, the minor tick interval is calculated as a fifth
               * of the tickInterval. If `null` or `undefined`, minor ticks are not
               * shown.
               *
               * On logarithmic axes, the unit is the power of the value. For example,
               * setting the minorTickInterval to 1 puts one tick on each of 0.1, 1,
               * 10, 100 etc. Setting the minorTickInterval to 0.1 produces 9 ticks
               * between 1 and 10, 10 and 100 etc.
               *
               * If user settings dictate minor ticks to become too dense, they don't
               * make sense, and will be ignored to prevent performance problems.
               *
               * @sample {highcharts} highcharts/yaxis/minortickinterval-null/
               *         Null by default
               * @sample {highcharts} highcharts/yaxis/minortickinterval-5/
               *         5 units
               * @sample {highcharts} highcharts/yaxis/minortickinterval-log-auto/
               *         "auto"
               * @sample {highcharts} highcharts/yaxis/minortickinterval-log/
               *         0.1
               * @sample {highstock} stock/demo/basic-line/
               *         Null by default
               * @sample {highstock} stock/xaxis/minortickinterval-auto/
               *         "auto"
               *
               * @type      {number|string|null}
               * @apioption xAxis.minorTickInterval
               */
              /**
               * The pixel length of the minor tick marks.
               *
               * @sample {highcharts} highcharts/yaxis/minorticklength/
               *         10px on Y axis
               * @sample {highstock} stock/xaxis/minorticks/
               *         10px on Y axis
               */
              minorTickLength: 2,
              /**
               * The position of the minor tick marks relative to the axis line.
               *  Can be one of `inside` and `outside`.
               *
               * @sample {highcharts} highcharts/yaxis/minortickposition-outside/
               *         Outside by default
               * @sample {highcharts} highcharts/yaxis/minortickposition-inside/
               *         Inside
               * @sample {highstock} stock/xaxis/minorticks/
               *         Inside
               *
               * @validvalue ["inside", "outside"]
               */
              minorTickPosition: "outside",
              /**
               * Enable or disable minor ticks. Unless
               * [minorTickInterval](#xAxis.minorTickInterval) is set, the tick
               * interval is calculated as a fifth of the `tickInterval`.
               *
               * On a logarithmic axis, minor ticks are laid out based on a best
               * guess, attempting to enter approximately 5 minor ticks between
               * each major tick.
               *
               * Prior to v6.0.0, ticks were unabled in auto layout by setting
               * `minorTickInterval` to `"auto"`.
               *
               * @productdesc {highcharts}
               * On axes using [categories](#xAxis.categories), minor ticks are not
               * supported.
               *
               * @sample {highcharts} highcharts/yaxis/minorticks-true/
               *         Enabled on linear Y axis
               *
               * @type      {boolean}
               * @default   false
               * @since     6.0.0
               * @apioption xAxis.minorTicks
               */
              /**
               * The pixel width of the minor tick mark.
               *
               * @sample {highcharts} highcharts/yaxis/minortickwidth/
               *         3px width
               * @sample {highstock} stock/xaxis/minorticks/
               *         1px width
               *
               * @type      {number}
               * @default   0
               * @apioption xAxis.minorTickWidth
               */
              /**
               * Padding of the min value relative to the length of the axis. A
               * padding of 0.05 will make a 100px axis 5px longer. This is useful
               * when you don't want the lowest data value to appear on the edge
               * of the plot area. When the axis' `min` option is set or a min extreme
               * is set using `axis.setExtremes()`, the minPadding will be ignored.
               *
               * @productdesc {highstock}
               * For an [ordinal](#xAxis.ordinal) axis, `minPadding` and `maxPadding`
               * are ignored. Use [overscroll](#xAxis.overscroll) instead.
               *
               * @sample {highcharts} highcharts/yaxis/minpadding/
               *         Min padding of 0.2
               * @sample {highstock} stock/xaxis/minpadding-maxpadding/
               *         Greater min- and maxPadding
               * @sample {highmaps} maps/chart/plotbackgroundcolor-gradient/
               *         Add some padding
               *
               * @default    {highcharts} 0.01
               * @default    {highstock|highmaps} 0
               * @since      1.2.0
               * @product    highcharts highstock gantt
               */
              minPadding: 0.01,
              /**
               * The minimum range to display on this axis. The entire axis will not
               * be allowed to span over a smaller interval than this. For example,
               * for a datetime axis the main unit is milliseconds. If minRange is
               * set to 3600000, you can't zoom in more than to one hour.
               *
               * The default minRange for the x axis is five times the smallest
               * interval between any of the data points.
               *
               * On a logarithmic axis, the unit for the minimum range is the power.
               * So a minRange of 1 means that the axis can be zoomed to 10-100,
               * 100-1000, 1000-10000 etc.
               *
               * **Note**: The `minPadding`, `maxPadding`, `startOnTick` and
               * `endOnTick` settings also affect how the extremes of the axis
               * are computed.
               *
               * @sample {highcharts} highcharts/xaxis/minrange/
               *         Minimum range of 5
               * @sample {highstock} stock/xaxis/minrange/
               *         Max zoom of 6 months overrides user selections
               *
               * @type      {number}
               * @apioption xAxis.minRange
               */
              /**
               * The minimum tick interval allowed in axis values. For example on
               * zooming in on an axis with daily data, this can be used to prevent
               * the axis from showing hours. Defaults to the closest distance between
               * two points on the axis.
               *
               * @type      {number}
               * @since     2.3.0
               * @apioption xAxis.minTickInterval
               */
              /**
               * The distance in pixels from the plot area to the axis line.
               * A positive offset moves the axis with it's line, labels and ticks
               * away from the plot area. This is typically used when two or more
               * axes are displayed on the same side of the plot. With multiple
               * axes the offset is dynamically adjusted to avoid collision, this
               * can be overridden by setting offset explicitly.
               *
               * @sample {highcharts} highcharts/yaxis/offset/
               *         Y axis offset of 70
               * @sample {highcharts} highcharts/yaxis/offset-centered/
               *         Axes positioned in the center of the plot
               * @sample {highstock} stock/xaxis/offset/
               *         Y axis offset by 70 px
               *
               * @type {number}
               */
              offset: void 0,
              /**
               * Whether to display the axis on the opposite side of the normal. The
               * normal is on the left side for vertical axes and bottom for
               * horizontal, so the opposite sides will be right and top respectively.
               * This is typically used with dual or multiple axes.
               *
               * @sample {highcharts} highcharts/yaxis/opposite/
               *         Secondary Y axis opposite
               * @sample {highstock} stock/xaxis/opposite/
               *         Y axis on left side
               *
               * @default   {highcharts|highstock|highmaps} false
               * @default   {gantt} true
               */
              opposite: false,
              /**
               * In an ordinal axis, the points are equally spaced in the chart
               * regardless of the actual time or x distance between them. This means
               * that missing data periods (e.g. nights or weekends for a stock chart)
               * will not take up space in the chart.
               * Having `ordinal: false` will show any gaps created by the `gapSize`
               * setting proportionate to their duration.
               *
               * In stock charts the X axis is ordinal by default, unless
               * the boost module is used and at least one of the series' data length
               * exceeds the [boostThreshold](#series.line.boostThreshold).
               *
               * For an ordinal axis, `minPadding` and `maxPadding` are ignored. Use
               * [overscroll](#xAxis.overscroll) instead.
               *
               * @sample {highstock} stock/xaxis/ordinal-true/
               *         True by default
               * @sample {highstock} stock/xaxis/ordinal-false/
               *         False
               *
               * @see [overscroll](#xAxis.overscroll)
               *
               * @type      {boolean}
               * @default   true
               * @since     1.1
               * @product   highstock
               * @apioption xAxis.ordinal
               */
              /**
               * Additional range on the right side of the xAxis. Works similar to
               * `xAxis.maxPadding`, but value is set in milliseconds. Can be set for
               * both main `xAxis` and the navigator's `xAxis`.
               *
               * @sample {highstock} stock/xaxis/overscroll/
               *         One minute overscroll with live data
               *
               * @type      {number}
               * @default   0
               * @since     6.0.0
               * @product   highstock
               * @apioption xAxis.overscroll
               */
              /**
               * Refers to the index in the [panes](#panes) array. Used for circular
               * gauges and polar charts. When the option is not set then first pane
               * will be used.
               *
               * @sample highcharts/demo/gauge-vu-meter
               *         Two gauges with different center
               *
               * @type      {number}
               * @product   highcharts
               * @apioption xAxis.pane
               */
              /**
               * The zoomed range to display when only defining one or none of `min`
               * or `max`. For example, to show the latest month, a range of one month
               * can be set.
               *
               * @sample {highstock} stock/xaxis/range/
               *         Setting a zoomed range when the rangeSelector is disabled
               *
               * @type      {number}
               * @product   highstock
               * @apioption xAxis.range
               */
              /**
               * Whether to reverse the axis so that the highest number is closest
               * to the origin. If the chart is inverted, the x axis is reversed by
               * default.
               *
               * @sample {highcharts} highcharts/yaxis/reversed/
               *         Reversed Y axis
               * @sample {highstock} stock/xaxis/reversed/
               *         Reversed Y axis
               *
               * @type      {boolean}
               * @default   undefined
               * @apioption xAxis.reversed
               */
              reversed: void 0,
              /**
               * This option determines how stacks should be ordered within a group.
               * For example reversed xAxis also reverses stacks, so first series
               * comes last in a group. To keep order like for non-reversed xAxis
               * enable this option.
               *
               * @sample {highcharts} highcharts/xaxis/reversedstacks/
               *         Reversed stacks comparison
               * @sample {highstock} highcharts/xaxis/reversedstacks/
               *         Reversed stacks comparison
               *
               * @since     6.1.1
               * @product   highcharts highstock
               */
              reversedStacks: false,
              /**
               * An optional scrollbar to display on the X axis in response to
               * limiting the minimum and maximum of the axis values.
               *
               * In styled mode, all the presentational options for the scrollbar are
               * replaced by the classes `.highcharts-scrollbar-thumb`,
               * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
               * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
               *
               * @sample {highstock} stock/yaxis/heatmap-scrollbars/
               *         Heatmap with both scrollbars
               *
               * @extends   scrollbar
               * @since     4.2.6
               * @product   highstock
               * @apioption xAxis.scrollbar
               */
              /**
               * Whether to show the axis line and title when the axis has no data.
               *
               * @sample {highcharts} highcharts/yaxis/showempty/
               *         When clicking the legend to hide series, one axis preserves
               *         line and title, the other doesn't
               * @sample {highstock} highcharts/yaxis/showempty/
               *         When clicking the legend to hide series, one axis preserves
               *         line and title, the other doesn't
               *
               * @since     1.1
               */
              showEmpty: true,
              /**
               * Whether to show the first tick label.
               *
               * @sample {highcharts} highcharts/xaxis/showfirstlabel-false/
               *         Set to false on X axis
               * @sample {highstock} stock/xaxis/showfirstlabel/
               *         Labels below plot lines on Y axis
               */
              showFirstLabel: true,
              /**
               * Whether to show the last tick label. Defaults to `true` on cartesian
               * charts, and `false` on polar charts.
               *
               * @sample {highcharts} highcharts/xaxis/showlastlabel-true/
               *         Set to true on X axis
               * @sample {highstock} stock/xaxis/showfirstlabel/
               *         Labels below plot lines on Y axis
               *
               * @type    {boolean}
               * @default undefined
               * @product highcharts highstock gantt
               */
              showLastLabel: true,
              /**
               * A soft maximum for the axis. If the series data maximum is less than
               * this, the axis will stay at this maximum, but if the series data
               * maximum is higher, the axis will flex to show all data.
               *
               * @sample highcharts/yaxis/softmin-softmax/
               *         Soft min and max
               *
               * @type      {number}
               * @since     5.0.1
               * @product   highcharts highstock gantt
               * @apioption xAxis.softMax
               */
              /**
               * A soft minimum for the axis. If the series data minimum is greater
               * than this, the axis will stay at this minimum, but if the series
               * data minimum is lower, the axis will flex to show all data.
               *
               * @sample highcharts/yaxis/softmin-softmax/
               *         Soft min and max
               *
               * @type      {number}
               * @since     5.0.1
               * @product   highcharts highstock gantt
               * @apioption xAxis.softMin
               */
              /**
               * For datetime axes, this decides where to put the tick between weeks.
               *  0 = Sunday, 1 = Monday.
               *
               * @sample {highcharts} highcharts/xaxis/startofweek-monday/
               *         Monday by default
               * @sample {highcharts} highcharts/xaxis/startofweek-sunday/
               *         Sunday
               * @sample {highstock} stock/xaxis/startofweek-1
               *         Monday by default
               * @sample {highstock} stock/xaxis/startofweek-0
               *         Sunday
               *
               * @product highcharts highstock gantt
               */
              startOfWeek: 1,
              /**
               * Whether to force the axis to start on a tick. Use this option with
               * the `minPadding` option to control the axis start.
               *
               * @productdesc {highstock}
               * In Highcharts Stock, `startOnTick` is always `false` when
               * the navigator is enabled, to prevent jumpy scrolling.
               *
               * @sample {highcharts} highcharts/xaxis/startontick-false/
               *         False by default
               * @sample {highcharts} highcharts/xaxis/startontick-true/
               *         True
               *
               * @since 1.2.0
               */
              startOnTick: false,
              /**
               * The amount of ticks to draw on the axis. This opens up for aligning
               * the ticks of multiple charts or panes within a chart. This option
               * overrides the `tickPixelInterval` option.
               *
               * This option only has an effect on linear axes. Datetime, logarithmic
               * or category axes are not affected.
               *
               * @sample {highcharts} highcharts/yaxis/tickamount/
               *         8 ticks on Y axis
               * @sample {highstock} highcharts/yaxis/tickamount/
               *         8 ticks on Y axis
               *
               * @type      {number}
               * @since     4.1.0
               * @product   highcharts highstock gantt
               * @apioption xAxis.tickAmount
               */
              /**
               * The interval of the tick marks in axis units. When `undefined`, the
               * tick interval is computed to approximately follow the
               * [tickPixelInterval](#xAxis.tickPixelInterval) on linear and datetime
               * axes. On categorized axes, a `undefined` tickInterval will default to
               * 1, one category. Note that datetime axes are based on milliseconds,
               * so for example an interval of one day is expressed as
               * `24 * 3600 * 1000`.
               *
               * On logarithmic axes, the tickInterval is based on powers, so a
               * tickInterval of 1 means one tick on each of 0.1, 1, 10, 100 etc. A
               * tickInterval of 2 means a tick of 0.1, 10, 1000 etc. A tickInterval
               * of 0.2 puts a tick on 0.1, 0.2, 0.4, 0.6, 0.8, 1, 2, 4, 6, 8, 10, 20,
               * 40 etc.
               *
               *
               * If the tickInterval is too dense for labels to be drawn, Highcharts
               * may remove ticks.
               *
               * If the chart has multiple axes, the [alignTicks](#chart.alignTicks)
               * option may interfere with the `tickInterval` setting.
               *
               * @see [tickPixelInterval](#xAxis.tickPixelInterval)
               * @see [tickPositions](#xAxis.tickPositions)
               * @see [tickPositioner](#xAxis.tickPositioner)
               *
               * @sample {highcharts} highcharts/xaxis/tickinterval-5/
               *         Tick interval of 5 on a linear axis
               * @sample {highstock} stock/xaxis/tickinterval/
               *         Tick interval of 0.01 on Y axis
               *
               * @type      {number}
               * @apioption xAxis.tickInterval
               */
              /**
               * The pixel length of the main tick marks.
               *
               * @sample {highcharts} highcharts/xaxis/ticklength/
               *         20 px tick length on the X axis
               * @sample {highstock} stock/xaxis/ticks/
               *         Formatted ticks on X axis
               */
              tickLength: 10,
              /**
               * If tickInterval is `null` this option sets the approximate pixel
               * interval of the tick marks. Not applicable to categorized axis.
               *
               * The tick interval is also influenced by the [minTickInterval](
               * #xAxis.minTickInterval) option, that, by default prevents ticks from
               * being denser than the data points.
               *
               * @see [tickInterval](#xAxis.tickInterval)
               * @see [tickPositioner](#xAxis.tickPositioner)
               * @see [tickPositions](#xAxis.tickPositions)
               *
               * @sample {highcharts} highcharts/xaxis/tickpixelinterval-50/
               *         50 px on X axis
               * @sample {highstock} stock/xaxis/tickpixelinterval/
               *         200 px on X axis
               */
              tickPixelInterval: 100,
              /**
               * For categorized axes only. If `on` the tick mark is placed in the
               * center of the category, if `between` the tick mark is placed between
               * categories. The default is `between` if the `tickInterval` is 1, else
               * `on`.
               *
               * @sample {highcharts} highcharts/xaxis/tickmarkplacement-between/
               *         "between" by default
               * @sample {highcharts} highcharts/xaxis/tickmarkplacement-on/
               *         "on"
               *
               * @product    highcharts gantt
               * @validvalue ["on", "between"]
               */
              tickmarkPlacement: "between",
              /**
               * The position of the major tick marks relative to the axis line.
               * Can be one of `inside` and `outside`.
               *
               * @sample {highcharts} highcharts/xaxis/tickposition-outside/
               *         "outside" by default
               * @sample {highcharts} highcharts/xaxis/tickposition-inside/
               *         "inside"
               * @sample {highstock} stock/xaxis/ticks/
               *         Formatted ticks on X axis
               *
               * @validvalue ["inside", "outside"]
               */
              tickPosition: "outside",
              /**
               * A callback function returning array defining where the ticks are
               * laid out on the axis. This overrides the default behaviour of
               * [tickPixelInterval](#xAxis.tickPixelInterval) and [tickInterval](
               * #xAxis.tickInterval). The automatic tick positions are accessible
               * through `this.tickPositions` and can be modified by the callback.
               *
               * @see [tickPositions](#xAxis.tickPositions)
               *
               * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
               *         Demo of tickPositions and tickPositioner
               * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
               *         Demo of tickPositions and tickPositioner
               *
               * @type      {Highcharts.AxisTickPositionerCallbackFunction}
               * @apioption xAxis.tickPositioner
               */
              /**
               * An array defining where the ticks are laid out on the axis. This
               * overrides the default behaviour of [tickPixelInterval](
               * #xAxis.tickPixelInterval) and [tickInterval](#xAxis.tickInterval).
               *
               * @see [tickPositioner](#xAxis.tickPositioner)
               *
               * @sample {highcharts} highcharts/xaxis/tickpositions-tickpositioner/
               *         Demo of tickPositions and tickPositioner
               * @sample {highstock} highcharts/xaxis/tickpositions-tickpositioner/
               *         Demo of tickPositions and tickPositioner
               *
               * @type      {Array<number>}
               * @apioption xAxis.tickPositions
               */
              /**
               * The pixel width of the major tick marks. Defaults to 0 on category
               * axes, otherwise 1.
               *
               * In styled mode, the stroke width is given in the `.highcharts-tick`
               * class, but in order for the element to be generated on category axes,
               * the option must be explicitly set to 1.
               *
               * @sample {highcharts} highcharts/xaxis/tickwidth/
               *         10 px width
               * @sample {highcharts} highcharts/css/axis-grid/
               *         Styled mode
               * @sample {highstock} stock/xaxis/ticks/
               *         Formatted ticks on X axis
               * @sample {highstock} highcharts/css/axis-grid/
               *         Styled mode
               *
               * @type      {undefined|number}
               * @default   {highstock} 1
               * @default   {highmaps} 0
               * @apioption xAxis.tickWidth
               */
              /**
               * The axis title, showing next to the axis line.
               *
               * @productdesc {highmaps}
               * In Highmaps, the axis is hidden by default, but adding an axis title
               * is still possible. X axis and Y axis titles will appear at the bottom
               * and left by default.
               */
              title: {
                /**
                 * Alignment of the title relative to the axis values. Possible
                 * values are "low", "middle" or "high".
                 *
                 * @sample {highcharts} highcharts/xaxis/title-align-low/
                 *         "low"
                 * @sample {highcharts} highcharts/xaxis/title-align-center/
                 *         "middle" by default
                 * @sample {highcharts} highcharts/xaxis/title-align-high/
                 *         "high"
                 * @sample {highcharts} highcharts/yaxis/title-offset/
                 *         Place the Y axis title on top of the axis
                 * @sample {highstock} stock/xaxis/title-align/
                 *         Aligned to "high" value
                 *
                 * @type {Highcharts.AxisTitleAlignValue}
                 */
                align: "middle",
                /**
                 * Deprecated. Set the `text` to `undefined` to disable the title.
                 *
                 * @deprecated
                 * @type      {boolean}
                 * @product   highcharts
                 * @apioption xAxis.title.enabled
                 */
                /**
                 * The pixel distance between the axis labels or line and the title.
                 * Defaults to 0 for horizontal axes, 10 for vertical
                 *
                 * @sample {highcharts} highcharts/xaxis/title-margin/
                 *         Y axis title margin of 60
                 *
                 * @type      {number}
                 * @apioption xAxis.title.margin
                 */
                /**
                 * The distance of the axis title from the axis line. By default,
                 * this distance is computed from the offset width of the labels,
                 * the labels' distance from the axis and the title's margin.
                 * However when the offset option is set, it overrides all this.
                 *
                 * @sample {highcharts} highcharts/yaxis/title-offset/
                 *         Place the axis title on top of the axis
                 * @sample {highstock} highcharts/yaxis/title-offset/
                 *         Place the axis title on top of the Y axis
                 *
                 * @type      {number}
                 * @since     2.2.0
                 * @apioption xAxis.title.offset
                 */
                /**
                 * Whether to reserve space for the title when laying out the axis.
                 *
                 * @type      {boolean}
                 * @default   true
                 * @since     5.0.11
                 * @product   highcharts highstock gantt
                 * @apioption xAxis.title.reserveSpace
                 */
                /**
                 * The rotation of the text in degrees. 0 is horizontal, 270 is
                 * vertical reading from bottom to top.
                 *
                 * @sample {highcharts} highcharts/yaxis/title-offset/
                 *         Horizontal
                 */
                rotation: 0,
                /**
                 * The actual text of the axis title. It can contain basic HTML tags
                 * like `b`, `i` and `span` with style.
                 *
                 * @sample {highcharts} highcharts/xaxis/title-text/
                 *         Custom HTML
                 * @sample {highstock} stock/xaxis/title-text/
                 *         Titles for both axes
                 *
                 * @type      {string|null}
                 * @apioption xAxis.title.text
                 */
                /**
                 * Alignment of the text, can be `"left"`, `"right"` or `"center"`.
                 * Default alignment depends on the
                 * [title.align](xAxis.title.align):
                 *
                 * Horizontal axes:
                 * - for `align` = `"low"`, `textAlign` is set to `left`
                 * - for `align` = `"middle"`, `textAlign` is set to `center`
                 * - for `align` = `"high"`, `textAlign` is set to `right`
                 *
                 * Vertical axes:
                 * - for `align` = `"low"` and `opposite` = `true`, `textAlign` is
                 *   set to `right`
                 * - for `align` = `"low"` and `opposite` = `false`, `textAlign` is
                 *   set to `left`
                 * - for `align` = `"middle"`, `textAlign` is set to `center`
                 * - for `align` = `"high"` and `opposite` = `true` `textAlign` is
                 *   set to `left`
                 * - for `align` = `"high"` and `opposite` = `false` `textAlign` is
                 *   set to `right`
                 *
                 * @type      {Highcharts.AlignValue}
                 * @apioption xAxis.title.textAlign
                 */
                /**
                 * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
                 * to render the axis title.
                 *
                 * @product   highcharts highstock gantt
                 */
                useHTML: false,
                /**
                 * Horizontal pixel offset of the title position.
                 *
                 * @since     4.1.6
                 * @product   highcharts highstock gantt
                 */
                x: 0,
                /**
                 * Vertical pixel offset of the title position.
                 *
                 * @product   highcharts highstock gantt
                 */
                y: 0,
                /**
                 * CSS styles for the title. If the title text is longer than the
                 * axis length, it will wrap to multiple lines by default. This can
                 * be customized by setting `textOverflow: 'ellipsis'`, by
                 * setting a specific `width` or by setting `whiteSpace: 'nowrap'`.
                 *
                 * In styled mode, the stroke width is given in the
                 * `.highcharts-axis-title` class.
                 *
                 * @sample {highcharts} highcharts/xaxis/title-style/
                 *         Red
                 * @sample {highcharts} highcharts/css/axis/
                 *         Styled mode
                 *
                 * @type    {Highcharts.CSSObject}
                 */
                style: {
                  /** @internal */
                  color: "#666666"
                  /* Palette.neutralColor60 */
                }
              },
              /**
               * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`
               * or `category`. In a datetime axis, the numbers are given in
               * milliseconds, and tick marks are placed on appropriate values like
               * full hours or days. In a category axis, the
               * [point names](#series.line.data.name) of the chart's series are used
               * for categories, if not a [categories](#xAxis.categories) array is
               * defined.
               *
               * @sample {highcharts} highcharts/xaxis/type-linear/
               *         Linear
               * @sample {highcharts} highcharts/yaxis/type-log/
               *         Logarithmic
               * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
               *         Logarithmic with minor grid lines
               * @sample {highcharts} highcharts/xaxis/type-log-both/
               *         Logarithmic on two axes
               * @sample {highcharts} highcharts/yaxis/type-log-negative/
               *         Logarithmic with extension to emulate negative values
               *
               * @type    {Highcharts.AxisTypeValue}
               * @product highcharts gantt
               */
              type: "linear",
              /**
               * If there are multiple axes on the same side of the chart, the pixel
               * margin between the axes. Defaults to 0 on vertical axes, 15 on
               * horizontal axes.
               *
               * @type      {number}
               * @since     7.0.3
               * @apioption xAxis.margin
               */
              /**
               * Applies only when the axis `type` is `category`. When `uniqueNames`
               * is true, points are placed on the X axis according to their names.
               * If the same point name is repeated in the same or another series,
               * the point is placed on the same X position as other points of the
               * same name. When `uniqueNames` is false, the points are laid out in
               * increasing X positions regardless of their names, and the X axis
               * category will take the name of the last point in each position.
               *
               * @sample {highcharts} highcharts/xaxis/uniquenames-true/
               *         True by default
               * @sample {highcharts} highcharts/xaxis/uniquenames-false/
               *         False
               *
               * @since     4.2.7
               * @product   highcharts gantt
               */
              uniqueNames: true,
              /**
               * Datetime axis only. An array determining what time intervals the
               * ticks are allowed to fall on. Each array item is an array where the
               * first value is the time unit and the second value another array of
               * allowed multiples.
               *
               * Defaults to:
               * ```js
               * units: [[
               *     'millisecond', // unit name
               *     [1, 2, 5, 10, 20, 25, 50, 100, 200, 500] // allowed multiples
               * ], [
               *     'second',
               *     [1, 2, 5, 10, 15, 30]
               * ], [
               *     'minute',
               *     [1, 2, 5, 10, 15, 30]
               * ], [
               *     'hour',
               *     [1, 2, 3, 4, 6, 8, 12]
               * ], [
               *     'day',
               *     [1, 2]
               * ], [
               *     'week',
               *     [1, 2]
               * ], [
               *     'month',
               *     [1, 2, 3, 4, 6]
               * ], [
               *     'year',
               *     null
               * ]]
               * ```
               *
               * @type      {Array<Array<string,(Array<number>|null)>>}
               * @product   highcharts highstock gantt
               * @apioption xAxis.units
               */
              /**
               * Whether axis, including axis title, line, ticks and labels, should
               * be visible.
               *
               * @since     4.1.9
               * @product   highcharts highstock gantt
               */
              visible: true,
              /**
               * Color of the minor, secondary grid lines.
               *
               * In styled mode, the stroke width is given in the
               * `.highcharts-minor-grid-line` class.
               *
               * @sample {highcharts} highcharts/yaxis/minorgridlinecolor/
               *         Bright grey lines from Y axis
               * @sample {highcharts|highstock} highcharts/css/axis-grid/
               *         Styled mode
               * @sample {highstock} stock/xaxis/minorgridlinecolor/
               *         Bright grey lines from Y axis
               *
               * @type    {Highcharts.ColorType}
               * @default #f2f2f2
               */
              minorGridLineColor: "#f2f2f2",
              /**
               * Width of the minor, secondary grid lines.
               *
               * In styled mode, the stroke width is given in the
               * `.highcharts-grid-line` class.
               *
               * @sample {highcharts} highcharts/yaxis/minorgridlinewidth/
               *         2px lines from Y axis
               * @sample {highcharts|highstock} highcharts/css/axis-grid/
               *         Styled mode
               * @sample {highstock} stock/xaxis/minorgridlinewidth/
               *         2px lines from Y axis
               */
              minorGridLineWidth: 1,
              /**
               * Color for the minor tick marks.
               *
               * @sample {highcharts} highcharts/yaxis/minortickcolor/
               *         Black tick marks on Y axis
               * @sample {highstock} stock/xaxis/minorticks/
               *         Black tick marks on Y axis
               *
               * @type    {Highcharts.ColorType}
               * @default #999999
               */
              minorTickColor: "#999999",
              /**
               * The color of the line marking the axis itself.
               *
               * In styled mode, the line stroke is given in the
               * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
               *
               * @productdesc {highmaps}
               * In Highmaps, the axis line is hidden by default, because the axis is
               * not visible by default.
               *
               * @sample {highcharts} highcharts/yaxis/linecolor/
               *         A red line on Y axis
               * @sample {highcharts|highstock} highcharts/css/axis/
               *         Axes in styled mode
               * @sample {highstock} stock/xaxis/linecolor/
               *         A red line on X axis
               *
               * @type    {Highcharts.ColorType}
               * @default #ccd6eb
               */
              lineColor: "#ccd6eb",
              /**
               * The width of the line marking the axis itself.
               *
               * In styled mode, the stroke width is given in the
               * `.highcharts-axis-line` or `.highcharts-xaxis-line` class.
               *
               * @sample {highcharts} highcharts/yaxis/linecolor/
               *         A 1px line on Y axis
               * @sample {highcharts|highstock} highcharts/css/axis/
               *         Axes in styled mode
               * @sample {highstock} stock/xaxis/linewidth/
               *         A 2px line on X axis
               *
               * @default {highcharts|highstock} 1
               * @default {highmaps} 0
               */
              lineWidth: 1,
              /**
               * Color of the grid lines extending the ticks across the plot area.
               *
               * In styled mode, the stroke is given in the `.highcharts-grid-line`
               * class.
               *
               * @productdesc {highmaps}
               * In Highmaps, the grid lines are hidden by default.
               *
               * @sample {highcharts} highcharts/yaxis/gridlinecolor/
               *         Green lines
               * @sample {highcharts|highstock} highcharts/css/axis-grid/
               *         Styled mode
               * @sample {highstock} stock/xaxis/gridlinecolor/
               *         Green lines
               *
               * @type    {Highcharts.ColorType}
               * @default #e6e6e6
               */
              gridLineColor: "#e6e6e6",
              /**
               * The width of the grid lines extending the ticks across the plot area.
               * Defaults to 1 on the Y axis and 0 on the X axis, except for 3d
               * charts.
               *
               * In styled mode, the stroke width is given in the
               * `.highcharts-grid-line` class.
               *
               * @sample {highcharts} highcharts/yaxis/gridlinewidth/
               *         2px lines
               * @sample {highcharts|highstock} highcharts/css/axis-grid/
               *         Styled mode
               * @sample {highstock} stock/xaxis/gridlinewidth/
               *         2px lines
               *
               * @type      {number}
               * @apioption xAxis.gridLineWidth
               */
              gridLineWidth: void 0,
              /**
               * The height as the vertical axis. If it's a number, it is
               * interpreted as pixels.
               *
               * Since Highcharts 2: If it's a percentage string, it is interpreted
               * as percentages of the total plot height.
               *
               * @type      {number|string}
               * @product   highcharts highstock
               * @apioption xAxis.height
               */
              /**
               * The width as the horizontal axis. If it's a number, it is interpreted
               * as pixels.
               *
               * Since Highcharts v5.0.13: If it's a percentage string, it is
               * interpreted as percentages of the total plot width.
               *
               * @type      {number|string}
               * @product   highcharts highstock
               * @apioption xAxis.width
               */
              /**
               * Color for the main tick marks.
               *
               * In styled mode, the stroke is given in the `.highcharts-tick`
               * class.
               *
               * @sample {highcharts} highcharts/xaxis/tickcolor/
               *         Red ticks on X axis
               * @sample {highcharts|highstock} highcharts/css/axis-grid/
               *         Styled mode
               * @sample {highstock} stock/xaxis/ticks/
               *         Formatted ticks on X axis
               *
               * @type    {Highcharts.ColorType}
               * @default #ccd6eb
               */
              tickColor: "#ccd6eb"
              /* Palette.highlightColor20 */
              // tickWidth: 1
            };
            AxisDefaults2.defaultYAxisOptions = {
              /**
               * The type of axis. Can be one of `linear`, `logarithmic`, `datetime`,
               * `category` or `treegrid`. Defaults to `treegrid` for Gantt charts,
               * `linear` for other chart types.
               *
               * In a datetime axis, the numbers are given in milliseconds, and tick
               * marks are placed on appropriate values, like full hours or days. In a
               * category or treegrid axis, the [point names](#series.line.data.name)
               * of the chart's series are used for categories, if a
               * [categories](#xAxis.categories) array is not defined.
               *
               * @sample {highcharts} highcharts/yaxis/type-log-minorgrid/
               *         Logarithmic with minor grid lines
               * @sample {highcharts} highcharts/yaxis/type-log-negative/
               *         Logarithmic with extension to emulate negative values
               * @sample {gantt} gantt/treegrid-axis/demo
               *         Treegrid axis
               *
               * @type      {Highcharts.AxisTypeValue}
               * @default   {highcharts} linear
               * @default   {gantt} treegrid
               * @product   highcharts gantt
               * @apioption yAxis.type
               */
              /**
               * The height of the Y axis. If it's a number, it is interpreted as
               * pixels.
               *
               * Since Highcharts 2: If it's a percentage string, it is interpreted as
               * percentages of the total plot height.
               *
               * @see [yAxis.top](#yAxis.top)
               *
               * @sample {highstock} stock/demo/candlestick-and-volume/
               *         Percentage height panes
               *
               * @type      {number|string}
               * @product   highcharts highstock
               * @apioption yAxis.height
               */
              /**
               * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
               * to represent the maximum value of the Y axis.
               *
               * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
               *         Min and max colors
               *
               * @type      {Highcharts.ColorType}
               * @default   #003399
               * @since     4.0
               * @product   highcharts
               * @apioption yAxis.maxColor
               */
              /**
               * Solid gauge only. Unless [stops](#yAxis.stops) are set, the color
               * to represent the minimum value of the Y axis.
               *
               * @sample {highcharts} highcharts/yaxis/mincolor-maxcolor/
               *         Min and max color
               *
               * @type      {Highcharts.ColorType}
               * @default   #e6ebf5
               * @since     4.0
               * @product   highcharts
               * @apioption yAxis.minColor
               */
              /**
               * Whether to reverse the axis so that the highest number is closest
               * to the origin.
               *
               * @sample {highcharts} highcharts/yaxis/reversed/
               *         Reversed Y axis
               * @sample {highstock} stock/xaxis/reversed/
               *         Reversed Y axis
               *
               * @type      {boolean}
               * @default   {highcharts} false
               * @default   {highstock} false
               * @default   {highmaps} true
               * @default   {gantt} true
               * @apioption yAxis.reversed
               */
              /**
               * If `true`, the first series in a stack will be drawn on top in a
               * positive, non-reversed Y axis. If `false`, the first series is in
               * the base of the stack.
               *
               * @sample {highcharts} highcharts/yaxis/reversedstacks-false/
               *         Non-reversed stacks
               * @sample {highstock} highcharts/yaxis/reversedstacks-false/
               *         Non-reversed stacks
               *
               * @type      {boolean}
               * @default   true
               * @since     3.0.10
               * @product   highcharts highstock
               * @apioption yAxis.reversedStacks
               */
              reversedStacks: true,
              /**
               * Solid gauge series only. Color stops for the solid gauge. Use this
               * in cases where a linear gradient between a `minColor` and `maxColor`
               * is not sufficient. The stops is an array of tuples, where the first
               * item is a float between 0 and 1 assigning the relative position in
               * the gradient, and the second item is the color.
               *
               * For solid gauges, the Y axis also inherits the concept of
               * [data classes](https://api.highcharts.com/highmaps#colorAxis.dataClasses)
               * from the Highmaps color axis.
               *
               * @sample {highcharts} highcharts/demo/gauge-solid/
               *         Gauge with stops
               *
               * @see [minColor](#yAxis.minColor)
               * @see [maxColor](#yAxis.maxColor)
               *
               * @type      {Array<Array<number,Highcharts.ColorType>>}
               * @since     4.0
               * @product   highcharts
               * @apioption yAxis.stops
               */
              /**
               * The pixel width of the major tick marks.
               *
               * @sample {highcharts} highcharts/xaxis/tickwidth/ 10 px width
               * @sample {highstock} stock/xaxis/ticks/ Formatted ticks on X axis
               *
               * @type      {number}
               * @default   0
               * @product   highcharts highstock gantt
               * @apioption yAxis.tickWidth
               */
              /**
               * Whether to force the axis to end on a tick. Use this option with
               * the `maxPadding` option to control the axis end.
               *
               * This option is always disabled, when panning type is
               * either `y` or `xy`.
               *
               * @see [type](#chart.panning.type)
               *
               *
               * @sample {highcharts} highcharts/yaxis/endontick/
               *         True by default
               * @sample {highcharts} highcharts/yaxis/endontick-false/
               *         False
               * @sample {highstock} stock/demo/basic-line/
               *         True by default
               * @sample {highstock} stock/xaxis/endontick/
               *         False for Y axis
               *
               * @since 1.2.0
               */
              endOnTick: true,
              /**
               * Padding of the max value relative to the length of the axis. A
               * padding of 0.05 will make a 100px axis 5px longer. This is useful
               * when you don't want the highest data value to appear on the edge
               * of the plot area. When the axis' `max` option is set or a max extreme
               * is set using `axis.setExtremes()`, the maxPadding will be ignored.
               *
               * Also the `softThreshold` option takes precedence over `maxPadding`,
               * so if the data is tangent to the threshold, `maxPadding` may not
               * apply unless `softThreshold` is set to false.
               *
               * @sample {highcharts} highcharts/yaxis/maxpadding-02/
               *         Max padding of 0.2
               * @sample {highstock} stock/xaxis/minpadding-maxpadding/
               *         Greater min- and maxPadding
               *
               * @since   1.2.0
               * @product highcharts highstock gantt
               */
              maxPadding: 0.05,
              /**
               * Padding of the min value relative to the length of the axis. A
               * padding of 0.05 will make a 100px axis 5px longer. This is useful
               * when you don't want the lowest data value to appear on the edge
               * of the plot area. When the axis' `min` option is set or a max extreme
               * is set using `axis.setExtremes()`, the maxPadding will be ignored.
               *
               * Also the `softThreshold` option takes precedence over `minPadding`,
               * so if the data is tangent to the threshold, `minPadding` may not
               * apply unless `softThreshold` is set to false.
               *
               * @sample {highcharts} highcharts/yaxis/minpadding/
               *         Min padding of 0.2
               * @sample {highstock} stock/xaxis/minpadding-maxpadding/
               *         Greater min- and maxPadding
               *
               * @since   1.2.0
               * @product highcharts highstock gantt
               */
              minPadding: 0.05,
              /**
               * @productdesc {highstock}
               * In Highcharts Stock 1.x, the Y axis was placed
               * on the left side by default.
               *
               * @sample {highcharts} highcharts/yaxis/opposite/
               *         Secondary Y axis opposite
               * @sample {highstock} stock/xaxis/opposite/
               *         Y axis on left side
               *
               * @type      {boolean}
               * @default   {highstock} true
               * @default   {highcharts} false
               * @product   highstock highcharts gantt
               * @apioption yAxis.opposite
               */
              /**
               * @see [tickInterval](#xAxis.tickInterval)
               * @see [tickPositioner](#xAxis.tickPositioner)
               * @see [tickPositions](#xAxis.tickPositions)
               */
              tickPixelInterval: 72,
              /**
               * Whether to show the last tick label.
               *
               * @productdesc {highcharts|gantt}
               * Defaults to `true` on cartesian charts, and `false` on polar charts.
               *
               * @productdesc {highstock}
               * Defaults to `true` for categorized yAxis and `false` for other types
               * of yAxis.
               *
               * @default undefined
               */
              showLastLabel: true,
              /**
               * @extends xAxis.labels
               */
              labels: {
                /**
                 * Angular gauges and solid gauges only.
                 * The label's pixel distance from the perimeter of the plot area.
                 *
                 * Since v7.1.2: If it's a percentage string, it is interpreted the
                 * same as [series.radius](#plotOptions.gauge.radius), so label can be
                 * aligned under the gauge's shape.
                 *
                 * @sample {highcharts} highcharts/yaxis/labels-distance/
                 *         Labels centered under the arc
                 *
                 * @type      {number|string}
                 * @default   -25
                 * @product   highcharts
                 * @apioption yAxis.labels.distance
                 */
                /**
                 * The y position offset of all labels relative to the tick
                 * positions on the axis. For polar and radial axis consider the use
                 * of the [distance](#yAxis.labels.distance) option.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-x/
                 *         Y axis labels placed on grid lines
                 *
                 * @type      {number}
                 * @default   {highcharts} 3
                 * @default   {highstock} -2
                 * @default   {highmaps} 3
                 * @apioption yAxis.labels.y
                 */
                /**
                 * What part of the string the given position is anchored to. Can
                 * be one of `"left"`, `"center"` or `"right"`. The exact position
                 * also depends on the `labels.x` setting.
                 *
                 * Angular gauges and solid gauges defaults to `"center"`.
                 * Solid gauges with two labels have additional option `"auto"`
                 * for automatic horizontal and vertical alignment.
                 *
                 * @see [yAxis.labels.distance](#yAxis.labels.distance)
                 *
                 * @sample {highcharts} highcharts/yaxis/labels-align-left/
                 *         Left
                 * @sample {highcharts} highcharts/series-solidgauge/labels-auto-aligned/
                 *         Solid gauge labels auto aligned
                 *
                 * @type       {Highcharts.AlignValue}
                 * @default    {highstock} right
                 * @apioption  yAxis.labels.align
                 */
                /**
                 * The x position offset of all labels relative to the tick
                 * positions on the axis. Defaults to -15 for left axis, 15 for
                 * right axis.
                 *
                 * @sample {highcharts} highcharts/xaxis/labels-x/
                 *         Y axis labels placed on grid lines
                 */
                x: -8
              },
              /**
               * @productdesc {highmaps}
               * In Highmaps, the axis line is hidden by default, because the axis is
               * not visible by default.
               *
               * @type      {Highcharts.ColorType}
               * @apioption yAxis.lineColor
               */
              /**
               * @sample {highcharts} highcharts/yaxis/max-200/
               *         Y axis max of 200
               * @sample {highcharts} highcharts/yaxis/max-logarithmic/
               *         Y axis max on logarithmic axis
               * @sample {highstock} stock/yaxis/min-max/
               *         Fixed min and max on Y axis
               *
               * @apioption yAxis.max
               */
              /**
               * @sample {highcharts} highcharts/yaxis/min-startontick-false/
               *         -50 with startOnTick to false
               * @sample {highcharts} highcharts/yaxis/min-startontick-true/
               *         -50 with startOnTick true by default
               * @sample {highstock} stock/yaxis/min-max/
               *         Fixed min and max on Y axis
               *
               * @apioption yAxis.min
               */
              /**
               * An optional scrollbar to display on the Y axis in response to
               * limiting the minimum an maximum of the axis values.
               *
               * In styled mode, all the presentational options for the scrollbar
               * are replaced by the classes `.highcharts-scrollbar-thumb`,
               * `.highcharts-scrollbar-arrow`, `.highcharts-scrollbar-button`,
               * `.highcharts-scrollbar-rifles` and `.highcharts-scrollbar-track`.
               *
               * @sample {highstock} stock/yaxis/scrollbar/
               *         Scrollbar on the Y axis
               *
               * @extends   scrollbar
               * @since     4.2.6
               * @product   highstock
               * @excluding height
               * @apioption yAxis.scrollbar
               */
              /**
               * Enable the scrollbar on the Y axis.
               *
               * @sample {highstock} stock/yaxis/scrollbar/
               *         Enabled on Y axis
               *
               * @type      {boolean}
               * @default   false
               * @since     4.2.6
               * @product   highstock
               * @apioption yAxis.scrollbar.enabled
               */
              /**
               * Pixel margin between the scrollbar and the axis elements.
               *
               * @type      {number}
               * @default   10
               * @since     4.2.6
               * @product   highstock
               * @apioption yAxis.scrollbar.margin
               */
              /* eslint-disable highcharts/doclet-apioption-last */
              /**
               * Defines the position of the scrollbar. By default, it is positioned
               * on the opposite of the main axis (right side of the chart).
               * However, in the case of RTL languages could be set to `false`
               * which positions the scrollbar on the left.
               *
               * Works only for vertical axes.
               * This means yAxis in a non-inverted chart and xAxis in the inverted.
               *
               * @sample stock/yaxis/scrollbar-opposite/
               *         A scrollbar not on the opposite side
               *
               * @type      {boolean}
               * @default   true
               * @since 9.3.0
               *
               * @apioption yAxis.scrollbar.opposite
               * @apioption xAxis.scrollbar.opposite
               *
               */
              /* eslint-enable highcharts/doclet-apioption-last */
              /**
               * Whether to show the scrollbar when it is fully zoomed out at max
               * range. Setting it to `false` on the Y axis makes the scrollbar stay
               * hidden until the user zooms in, like common in browsers.
               *
               * @type      {boolean}
               * @default   true
               * @since     4.2.6
               * @product   highstock
               * @apioption yAxis.scrollbar.showFull
               */
              /**
               * The width of a vertical scrollbar or height of a horizontal
               * scrollbar. Defaults to 20 on touch devices.
               *
               * @type      {number}
               * @default   14
               * @since     4.2.6
               * @product   highstock
               * @apioption yAxis.scrollbar.size
               */
              /**
               * Z index of the scrollbar elements.
               *
               * @type      {number}
               * @default   3
               * @since     4.2.6
               * @product   highstock
               * @apioption yAxis.scrollbar.zIndex
               */
              /**
               * A soft maximum for the axis. If the series data maximum is less
               * than this, the axis will stay at this maximum, but if the series
               * data maximum is higher, the axis will flex to show all data.
               *
               * **Note**: The [series.softThreshold](
               * #plotOptions.series.softThreshold) option takes precedence over this
               * option.
               *
               * @sample highcharts/yaxis/softmin-softmax/
               *         Soft min and max
               *
               * @type      {number}
               * @since     5.0.1
               * @product   highcharts highstock gantt
               * @apioption yAxis.softMax
               */
              /**
               * A soft minimum for the axis. If the series data minimum is greater
               * than this, the axis will stay at this minimum, but if the series
               * data minimum is lower, the axis will flex to show all data.
               *
               * **Note**: The [series.softThreshold](
               * #plotOptions.series.softThreshold) option takes precedence over this
               * option.
               *
               * @sample highcharts/yaxis/softmin-softmax/
               *         Soft min and max
               *
               * @type      {number}
               * @since     5.0.1
               * @product   highcharts highstock gantt
               * @apioption yAxis.softMin
               */
              /**
               * Defines the horizontal alignment of the stack total label. Can be one
               * of `"left"`, `"center"` or `"right"`. The default value is calculated
               * at runtime and depends on orientation and whether the stack is
               * positive or negative.
               *
               * @sample {highcharts} highcharts/yaxis/stacklabels-align-left/
               *         Aligned to the left
               * @sample {highcharts} highcharts/yaxis/stacklabels-align-center/
               *         Aligned in center
               * @sample {highcharts} highcharts/yaxis/stacklabels-align-right/
               *         Aligned to the right
               *
               * @type      {Highcharts.AlignValue}
               * @since     2.1.5
               * @product   highcharts
               * @apioption yAxis.stackLabels.align
               */
              /**
               * A format string for the data label. Available variables are the same
               * as for `formatter`.
               *
               * @type      {string}
               * @default   {total}
               * @since     3.0.2
               * @product   highcharts highstock
               * @apioption yAxis.stackLabels.format
               */
              /**
               * Rotation of the labels in degrees.
               *
               * @sample {highcharts} highcharts/yaxis/stacklabels-rotation/
               *         Labels rotated 45°
               *
               * @type      {number}
               * @default   0
               * @since     2.1.5
               * @product   highcharts
               * @apioption yAxis.stackLabels.rotation
               */
              /**
               * The text alignment for the label. While `align` determines where the
               * texts anchor point is placed with regards to the stack, `textAlign`
               * determines how the text is aligned against its anchor point. Possible
               * values are `"left"`, `"center"` and `"right"`. The default value is
               * calculated at runtime and depends on orientation and whether the
               * stack is positive or negative.
               *
               * @sample {highcharts} highcharts/yaxis/stacklabels-textalign-left/
               *         Label in center position but text-aligned left
               *
               * @type      {Highcharts.AlignValue}
               * @since     2.1.5
               * @product   highcharts
               * @apioption yAxis.stackLabels.textAlign
               */
              /**
               * Whether to [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
               * to render the labels.
               *
               * @type      {boolean}
               * @default   false
               * @since     3.0
               * @product   highcharts highstock
               * @apioption yAxis.stackLabels.useHTML
               */
              /**
               * Defines the vertical alignment of the stack total label. Can be one
               * of `"top"`, `"middle"` or `"bottom"`. The default value is calculated
               * at runtime and depends on orientation and whether the stack is
               * positive or negative.
               *
               * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-top/
               *         Vertically aligned top
               * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-middle/
               *         Vertically aligned middle
               * @sample {highcharts} highcharts/yaxis/stacklabels-verticalalign-bottom/
               *         Vertically aligned bottom
               *
               * @type      {Highcharts.VerticalAlignValue}
               * @since     2.1.5
               * @product   highcharts
               * @apioption yAxis.stackLabels.verticalAlign
               */
              /**
               * The x position offset of the label relative to the left of the
               * stacked bar. The default value is calculated at runtime and depends
               * on orientation and whether the stack is positive or negative.
               *
               * @sample {highcharts} highcharts/yaxis/stacklabels-x/
               *         Stack total labels with x offset
               *
               * @type      {number}
               * @since     2.1.5
               * @product   highcharts
               * @apioption yAxis.stackLabels.x
               */
              /**
               * The y position offset of the label relative to the tick position
               * on the axis. The default value is calculated at runtime and depends
               * on orientation and whether the stack is positive or negative.
               *
               * @sample {highcharts} highcharts/yaxis/stacklabels-y/
               *         Stack total labels with y offset
               *
               * @type      {number}
               * @since     2.1.5
               * @product   highcharts
               * @apioption yAxis.stackLabels.y
               */
              /**
               * Whether to force the axis to start on a tick. Use this option with
               * the `maxPadding` option to control the axis start.
               *
               * This option is always disabled, when panning type is
               * either `y` or `xy`.
               *
               * @see [type](#chart.panning.type)
               *
               * @sample {highcharts} highcharts/xaxis/startontick-false/
               *         False by default
               * @sample {highcharts} highcharts/xaxis/startontick-true/
               *         True
               * @sample {highstock} stock/xaxis/endontick/
               *         False for Y axis
               *
               * @since   1.2.0
               * @product highcharts highstock gantt
               */
              startOnTick: true,
              title: {
                /**
                 * The pixel distance between the axis labels and the title.
                 * Positive values are outside the axis line, negative are inside.
                 *
                 * @sample {highcharts} highcharts/xaxis/title-margin/
                 *         Y axis title margin of 60
                 *
                 * @type      {number}
                 * @default   40
                 * @apioption yAxis.title.margin
                 */
                /**
                 * The rotation of the text in degrees. 0 is horizontal, 270 is
                 * vertical reading from bottom to top.
                 *
                 * @sample {highcharts} highcharts/yaxis/title-offset/
                 *         Horizontal
                 */
                rotation: 270,
                /**
                 * The actual text of the axis title. Horizontal texts can contain
                 * HTML, but rotated texts are painted using vector techniques and
                 * must be clean text. The Y axis title is disabled by setting the
                 * `text` option to `undefined`.
                 *
                 * @sample {highcharts} highcharts/xaxis/title-text/
                 *         Custom HTML
                 *
                 * @type    {string|null}
                 * @default {highcharts} Values
                 * @default {highstock} undefined
                 * @product highcharts highstock gantt
                 */
                text: "Values"
              },
              /**
               * The top position of the Y axis. If it's a number, it is interpreted
               * as pixel position relative to the chart.
               *
               * Since Highcharts 2: If it's a percentage string, it is interpreted as
               * percentages of the plot height, offset from plot area top.
               *
               * @see [yAxis.height](#yAxis.height)
               *
               * @sample {highstock} stock/demo/candlestick-and-volume/
               *         Percentage height panes
               *
               * @type      {number|string}
               * @product   highcharts highstock
               * @apioption yAxis.top
               */
              /**
               * The stack labels show the total value for each bar in a stacked
               * column or bar chart. The label will be placed on top of positive
               * columns and below negative columns. In case of an inverted column
               * chart or a bar chart the label is placed to the right of positive
               * bars and to the left of negative bars.
               *
               * @product highcharts
               */
              stackLabels: {
                /**
                 * Enable or disable the initial animation when a series is
                 * displayed for the `stackLabels`. The animation can also be set as
                 * a configuration object. Please note that this option only
                 * applies to the initial animation.
                 * For other animations, see [chart.animation](#chart.animation)
                 * and the animation parameter under the API methods.
                 * The following properties are supported:
                 *
                 * - `defer`: The animation delay time in milliseconds.
                 *
                 * @sample {highcharts} highcharts/plotoptions/animation-defer/
                 *          Animation defer settings
                 * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 * @since 8.2.0
                 * @apioption yAxis.stackLabels.animation
                 */
                animation: {},
                /**
                 * The animation delay time in milliseconds.
                 * Set to `0` renders stackLabel immediately.
                 * As `undefined` inherits defer time from the [series.animation.defer](#plotOptions.series.animation.defer).
                 *
                 * @type      {number}
                 * @since 8.2.0
                 * @apioption yAxis.stackLabels.animation.defer
                 */
                /**
                 * Allow the stack labels to overlap.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-allowoverlap-false/
                 *         Default false
                 *
                 * @since   5.0.13
                 * @product highcharts
                 */
                allowOverlap: false,
                /**
                 * The background color or gradient for the stack label.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-box/
                 *          Stack labels box options
                 * @type      {Highcharts.ColorType}
                 * @since 8.1.0
                 * @apioption yAxis.stackLabels.backgroundColor
                 */
                /**
                 * The border color for the stack label. Defaults to `undefined`.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-box/
                 *          Stack labels box options
                 * @type      {Highcharts.ColorType}
                 * @since 8.1.0
                 * @apioption yAxis.stackLabels.borderColor
                 */
                /**
                 * The border radius in pixels for the stack label.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-box/
                 *          Stack labels box options
                 * @type      {number}
                 * @default   0
                 * @since 8.1.0
                 * @apioption yAxis.stackLabels.borderRadius
                 */
                /**
                 * The border width in pixels for the stack label.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-box/
                 *          Stack labels box options
                 * @type      {number}
                 * @default   0
                 * @since 8.1.0
                 * @apioption yAxis.stackLabels.borderWidth
                 */
                /**
                 * Enable or disable the stack total labels.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-enabled/
                 *         Enabled stack total labels
                 * @sample {highcharts} highcharts/yaxis/stacklabels-enabled-waterfall/
                 *         Enabled stack labels in waterfall chart
                 *
                 * @since   2.1.5
                 * @product highcharts
                 */
                enabled: false,
                /**
                 * Whether to hide stack labels that are outside the plot area.
                 * By default, the stack label is moved
                 * inside the plot area according to the
                 * [overflow](/highcharts/#yAxis/stackLabels/overflow)
                 * option.
                 *
                 * @type  {boolean}
                 * @since 7.1.3
                 */
                crop: true,
                /**
                 * How to handle stack total labels that flow outside the plot area.
                 * The default is set to `"justify"`,
                 * which aligns them inside the plot area.
                 * For columns and bars, this means it will be moved inside the bar.
                 * To display stack labels outside the plot area,
                 * set `crop` to `false` and `overflow` to `"allow"`.
                 *
                 * @sample highcharts/yaxis/stacklabels-overflow/
                 *         Stack labels flows outside the plot area.
                 *
                 * @type  {Highcharts.DataLabelsOverflowValue}
                 * @since 7.1.3
                 */
                overflow: "justify",
                /* eslint-disable valid-jsdoc */
                /**
                 * Callback JavaScript function to format the label. The value is
                 * given by `this.total`.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-formatter/
                 *         Added units to stack total value
                 *
                 * @type    {Highcharts.FormatterCallbackFunction<Highcharts.StackItemObject>}
                 * @since   2.1.5
                 * @product highcharts
                 */
                formatter: function() {
                  var numberFormatter = this.axis.chart.numberFormatter;
                  return numberFormatter(this.total || 0, -1);
                },
                /**
                 * CSS styles for the label.
                 *
                 * In styled mode, the styles are set in the
                 * `.highcharts-stack-label` class.
                 *
                 * @sample {highcharts} highcharts/yaxis/stacklabels-style/
                 *         Red stack total labels
                 *
                 * @type    {Highcharts.CSSObject}
                 * @since   2.1.5
                 * @product highcharts
                 */
                style: {
                  /** @internal */
                  color: "#000000",
                  /** @internal */
                  fontSize: "11px",
                  /** @internal */
                  fontWeight: "bold",
                  /** @internal */
                  textOutline: "1px contrast"
                }
              },
              gridLineWidth: 1,
              lineWidth: 0
              // tickWidth: 0
            };
            AxisDefaults2.defaultLeftAxisOptions = {
              labels: {
                x: -15
              },
              title: {
                rotation: 270
              }
            };
            AxisDefaults2.defaultRightAxisOptions = {
              labels: {
                x: 15
              },
              title: {
                rotation: 90
              }
            };
            AxisDefaults2.defaultBottomAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
                // overflow: undefined,
                // staggerLines: null
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
            AxisDefaults2.defaultTopAxisOptions = {
              labels: {
                autoRotation: [-45],
                x: 0
                // overflow: undefined
                // staggerLines: null
              },
              margin: 15,
              title: {
                rotation: 0
              }
            };
          })(AxisDefaults || (AxisDefaults = {}));
          return AxisDefaults;
        });
        _registerModule(_modules, "Core/Foundation.js", [_modules["Core/Utilities.js"]], function(U) {
          var addEvent = U.addEvent, isFunction = U.isFunction, objectEach = U.objectEach, removeEvent = U.removeEvent;
          var Foundation;
          (function(Foundation2) {
            function registerEventOptions(component, options) {
              component.eventOptions = component.eventOptions || {};
              objectEach(options.events, function(event, eventType) {
                if (component.eventOptions[eventType] !== event) {
                  if (component.eventOptions[eventType]) {
                    removeEvent(component, eventType, component.eventOptions[eventType]);
                    delete component.eventOptions[eventType];
                  }
                  if (isFunction(event)) {
                    component.eventOptions[eventType] = event;
                    addEvent(component, eventType, event);
                  }
                }
              });
            }
            Foundation2.registerEventOptions = registerEventOptions;
          })(Foundation || (Foundation = {}));
          return Foundation;
        });
        _registerModule(_modules, "Core/Axis/Tick.js", [_modules["Core/FormatUtilities.js"], _modules["Core/Globals.js"], _modules["Core/Utilities.js"]], function(F, H, U) {
          var deg2rad = H.deg2rad;
          var clamp = U.clamp, correctFloat = U.correctFloat, defined = U.defined, destroyObjectProperties = U.destroyObjectProperties, extend2 = U.extend, fireEvent = U.fireEvent, isNumber = U.isNumber, merge = U.merge, objectEach = U.objectEach, pick = U.pick;
          var Tick = (
            /** @class */
            function() {
              function Tick2(axis, pos, type, noLabel, parameters) {
                this.isNew = true;
                this.isNewLabel = true;
                this.axis = axis;
                this.pos = pos;
                this.type = type || "";
                this.parameters = parameters || {};
                this.tickmarkOffset = this.parameters.tickmarkOffset;
                this.options = this.parameters.options;
                fireEvent(this, "init");
                if (!type && !noLabel) {
                  this.addLabel();
                }
              }
              Tick2.prototype.addLabel = function() {
                var tick = this, axis = tick.axis, options = axis.options, chart = axis.chart, categories = axis.categories, log = axis.logarithmic, names = axis.names, pos = tick.pos, labelOptions = pick(
                  tick.options && tick.options.labels,
                  options.labels
                ), tickPositions = axis.tickPositions, isFirst = pos === tickPositions[0], isLast = pos === tickPositions[tickPositions.length - 1], animateLabels = (!labelOptions.step || labelOptions.step === 1) && axis.tickInterval === 1, tickPositionInfo = tickPositions.info;
                var label = tick.label, dateTimeLabelFormat, dateTimeLabelFormats, i;
                var value = this.parameters.category || (categories ? pick(
                  categories[pos],
                  names[pos],
                  pos
                ) : pos);
                if (log && isNumber(value)) {
                  value = correctFloat(log.lin2log(value));
                }
                if (axis.dateTime) {
                  if (tickPositionInfo) {
                    dateTimeLabelFormats = chart.time.resolveDTLFormat(options.dateTimeLabelFormats[!options.grid && tickPositionInfo.higherRanks[pos] || tickPositionInfo.unitName]);
                    dateTimeLabelFormat = dateTimeLabelFormats.main;
                  } else if (isNumber(value)) {
                    dateTimeLabelFormat = axis.dateTime.getXDateFormat(value, options.dateTimeLabelFormats || {});
                  }
                }
                tick.isFirst = isFirst;
                tick.isLast = isLast;
                var ctx = {
                  axis,
                  chart,
                  dateTimeLabelFormat,
                  isFirst,
                  isLast,
                  pos,
                  tick,
                  tickPositionInfo,
                  value
                };
                fireEvent(this, "labelFormat", ctx);
                var labelFormatter = function(ctx2) {
                  if (labelOptions.formatter) {
                    return labelOptions.formatter.call(
                      ctx2,
                      ctx2
                    );
                  }
                  if (labelOptions.format) {
                    ctx2.text = axis.defaultLabelFormatter.call(ctx2, ctx2);
                    return F.format(labelOptions.format, ctx2, chart);
                  }
                  return axis.defaultLabelFormatter.call(ctx2, ctx2);
                };
                var str = labelFormatter.call(
                  ctx,
                  ctx
                );
                var list = dateTimeLabelFormats && dateTimeLabelFormats.list;
                if (list) {
                  tick.shortenLabel = function() {
                    for (i = 0; i < list.length; i++) {
                      extend2(ctx, { dateTimeLabelFormat: list[i] });
                      label.attr({
                        text: labelFormatter.call(ctx, ctx)
                      });
                      if (label.getBBox().width < axis.getSlotWidth(tick) - 2 * labelOptions.padding) {
                        return;
                      }
                    }
                    label.attr({
                      text: ""
                    });
                  };
                } else {
                  tick.shortenLabel = void 0;
                }
                if (animateLabels && axis._addedPlotLB) {
                  tick.moveLabel(str, labelOptions);
                }
                if (!defined(label) && !tick.movedLabel) {
                  tick.label = label = tick.createLabel({ x: 0, y: 0 }, str, labelOptions);
                  tick.rotation = 0;
                } else if (label && label.textStr !== str && !animateLabels) {
                  if (label.textWidth && !labelOptions.style.width && !label.styles.width) {
                    label.css({ width: null });
                  }
                  label.attr({ text: str });
                  label.textPxLength = label.getBBox().width;
                }
              };
              Tick2.prototype.createLabel = function(xy, str, labelOptions) {
                var axis = this.axis, chart = axis.chart, label = defined(str) && labelOptions.enabled ? chart.renderer.text(
                  str,
                  xy.x,
                  xy.y,
                  labelOptions.useHTML
                ).add(axis.labelGroup) : null;
                if (label) {
                  if (!chart.styledMode) {
                    label.css(merge(labelOptions.style));
                  }
                  label.textPxLength = label.getBBox().width;
                }
                return label;
              };
              Tick2.prototype.destroy = function() {
                destroyObjectProperties(this, this.axis);
              };
              Tick2.prototype.getPosition = function(horiz, tickPos, tickmarkOffset, old) {
                var axis = this.axis, chart = axis.chart, cHeight = old && chart.oldChartHeight || chart.chartHeight, pos = {
                  x: horiz ? correctFloat(axis.translate(
                    tickPos + tickmarkOffset,
                    void 0,
                    void 0,
                    old
                  ) + axis.transB) : axis.left + axis.offset + (axis.opposite ? (old && chart.oldChartWidth || chart.chartWidth) - axis.right - axis.left : 0),
                  y: horiz ? cHeight - axis.bottom + axis.offset - (axis.opposite ? axis.height : 0) : correctFloat(cHeight - axis.translate(
                    tickPos + tickmarkOffset,
                    void 0,
                    void 0,
                    old
                  ) - axis.transB)
                };
                pos.y = clamp(pos.y, -1e5, 1e5);
                fireEvent(this, "afterGetPosition", { pos });
                return pos;
              };
              Tick2.prototype.getLabelPosition = function(x, y, label, horiz, labelOptions, tickmarkOffset, index, step) {
                var axis = this.axis, transA = axis.transA, reversed = (
                  // #7911
                  axis.isLinked && axis.linkedParent ? axis.linkedParent.reversed : axis.reversed
                ), staggerLines = axis.staggerLines, rotCorr = axis.tickRotCorr || {
                  x: 0,
                  y: 0
                }, labelOffsetCorrection = !horiz && !axis.reserveSpaceDefault ? -axis.labelOffset * (axis.labelAlign === "center" ? 0.5 : 1) : 0, pos = {};
                var yOffset, line;
                if (axis.side === 0) {
                  yOffset = label.rotation ? -8 : -label.getBBox().height;
                } else if (axis.side === 2) {
                  yOffset = rotCorr.y + 8;
                } else {
                  yOffset = Math.cos(label.rotation * deg2rad) * (rotCorr.y - label.getBBox(false, 0).height / 2);
                }
                if (defined(labelOptions.y)) {
                  yOffset = axis.side === 0 && axis.horiz ? labelOptions.y + yOffset : labelOptions.y;
                }
                x = x + labelOptions.x + labelOffsetCorrection + rotCorr.x - (tickmarkOffset && horiz ? tickmarkOffset * transA * (reversed ? -1 : 1) : 0);
                y = y + yOffset - (tickmarkOffset && !horiz ? tickmarkOffset * transA * (reversed ? 1 : -1) : 0);
                if (staggerLines) {
                  line = index / (step || 1) % staggerLines;
                  if (axis.opposite) {
                    line = staggerLines - line - 1;
                  }
                  y += line * (axis.labelOffset / staggerLines);
                }
                pos.x = x;
                pos.y = Math.round(y);
                fireEvent(this, "afterGetLabelPosition", { pos, tickmarkOffset, index });
                return pos;
              };
              Tick2.prototype.getLabelSize = function() {
                return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
              };
              Tick2.prototype.getMarkPath = function(x, y, tickLength, tickWidth, horiz, renderer) {
                return renderer.crispLine([[
                  "M",
                  x,
                  y
                ], [
                  "L",
                  x + (horiz ? 0 : -tickLength),
                  y + (horiz ? tickLength : 0)
                ]], tickWidth);
              };
              Tick2.prototype.handleOverflow = function(xy) {
                var tick = this, axis = this.axis, labelOptions = axis.options.labels, pxPos = xy.x, chartWidth = axis.chart.chartWidth, spacing = axis.chart.spacing, leftBound = pick(
                  axis.labelLeft,
                  Math.min(
                    axis.pos,
                    spacing[3]
                  )
                ), rightBound = pick(
                  axis.labelRight,
                  Math.max(
                    !axis.isRadial ? axis.pos + axis.len : 0,
                    chartWidth - spacing[1]
                  )
                ), label = this.label, rotation = this.rotation, factor = {
                  left: 0,
                  center: 0.5,
                  right: 1
                }[axis.labelAlign || label.attr("align")], labelWidth = label.getBBox().width, slotWidth = axis.getSlotWidth(tick), xCorrection = factor, css = {};
                var modifiedSlotWidth = slotWidth, goRight = 1, leftPos, rightPos, textWidth;
                if (!rotation && labelOptions.overflow === "justify") {
                  leftPos = pxPos - factor * labelWidth;
                  rightPos = pxPos + (1 - factor) * labelWidth;
                  if (leftPos < leftBound) {
                    modifiedSlotWidth = xy.x + modifiedSlotWidth * (1 - factor) - leftBound;
                  } else if (rightPos > rightBound) {
                    modifiedSlotWidth = rightBound - xy.x + modifiedSlotWidth * factor;
                    goRight = -1;
                  }
                  modifiedSlotWidth = Math.min(slotWidth, modifiedSlotWidth);
                  if (modifiedSlotWidth < slotWidth && axis.labelAlign === "center") {
                    xy.x += goRight * (slotWidth - modifiedSlotWidth - xCorrection * (slotWidth - Math.min(labelWidth, modifiedSlotWidth)));
                  }
                  if (labelWidth > modifiedSlotWidth || axis.autoRotation && (label.styles || {}).width) {
                    textWidth = modifiedSlotWidth;
                  }
                } else if (rotation < 0 && pxPos - factor * labelWidth < leftBound) {
                  textWidth = Math.round(pxPos / Math.cos(rotation * deg2rad) - leftBound);
                } else if (rotation > 0 && pxPos + factor * labelWidth > rightBound) {
                  textWidth = Math.round((chartWidth - pxPos) / Math.cos(rotation * deg2rad));
                }
                if (textWidth) {
                  if (tick.shortenLabel) {
                    tick.shortenLabel();
                  } else {
                    css.width = Math.floor(textWidth) + "px";
                    if (!(labelOptions.style || {}).textOverflow) {
                      css.textOverflow = "ellipsis";
                    }
                    label.css(css);
                  }
                }
              };
              Tick2.prototype.moveLabel = function(str, labelOptions) {
                var tick = this, label = tick.label, axis = tick.axis, reversed = axis.reversed;
                var moved = false, labelPos, xPos, yPos;
                if (label && label.textStr === str) {
                  tick.movedLabel = label;
                  moved = true;
                  delete tick.label;
                } else {
                  objectEach(axis.ticks, function(currentTick) {
                    if (!moved && !currentTick.isNew && currentTick !== tick && currentTick.label && currentTick.label.textStr === str) {
                      tick.movedLabel = currentTick.label;
                      moved = true;
                      currentTick.labelPos = tick.movedLabel.xy;
                      delete currentTick.label;
                    }
                  });
                }
                if (!moved && (tick.labelPos || label)) {
                  labelPos = tick.labelPos || label.xy;
                  xPos = axis.horiz ? reversed ? 0 : axis.width + axis.left : labelPos.x;
                  yPos = axis.horiz ? labelPos.y : reversed ? axis.width + axis.left : 0;
                  tick.movedLabel = tick.createLabel({ x: xPos, y: yPos }, str, labelOptions);
                  if (tick.movedLabel) {
                    tick.movedLabel.attr({ opacity: 0 });
                  }
                }
              };
              Tick2.prototype.render = function(index, old, opacity) {
                var tick = this, axis = tick.axis, horiz = axis.horiz, pos = tick.pos, tickmarkOffset = pick(
                  tick.tickmarkOffset,
                  axis.tickmarkOffset
                ), xy = tick.getPosition(
                  horiz,
                  pos,
                  tickmarkOffset,
                  old
                ), x = xy.x, y = xy.y, reverseCrisp = horiz && x === axis.pos + axis.len || !horiz && y === axis.pos ? -1 : 1;
                var labelOpacity = pick(
                  opacity,
                  tick.label && tick.label.newOpacity,
                  // #15528
                  1
                );
                opacity = pick(opacity, 1);
                this.isActive = true;
                this.renderGridLine(old, opacity, reverseCrisp);
                this.renderMark(xy, opacity, reverseCrisp);
                this.renderLabel(xy, old, labelOpacity, index);
                tick.isNew = false;
                fireEvent(this, "afterRender");
              };
              Tick2.prototype.renderGridLine = function(old, opacity, reverseCrisp) {
                var tick = this, axis = tick.axis, options = axis.options, attribs = {}, pos = tick.pos, type = tick.type, tickmarkOffset = pick(
                  tick.tickmarkOffset,
                  axis.tickmarkOffset
                ), renderer = axis.chart.renderer;
                var gridLine = tick.gridLine, gridLinePath, gridLineWidth = options.gridLineWidth, gridLineColor = options.gridLineColor, dashStyle = options.gridLineDashStyle;
                if (tick.type === "minor") {
                  gridLineWidth = options.minorGridLineWidth;
                  gridLineColor = options.minorGridLineColor;
                  dashStyle = options.minorGridLineDashStyle;
                }
                if (!gridLine) {
                  if (!axis.chart.styledMode) {
                    attribs.stroke = gridLineColor;
                    attribs["stroke-width"] = gridLineWidth || 0;
                    attribs.dashstyle = dashStyle;
                  }
                  if (!type) {
                    attribs.zIndex = 1;
                  }
                  if (old) {
                    opacity = 0;
                  }
                  tick.gridLine = gridLine = renderer.path().attr(attribs).addClass("highcharts-" + (type ? type + "-" : "") + "grid-line").add(axis.gridGroup);
                }
                if (gridLine) {
                  gridLinePath = axis.getPlotLinePath({
                    value: pos + tickmarkOffset,
                    lineWidth: gridLine.strokeWidth() * reverseCrisp,
                    force: "pass",
                    old,
                    acrossPanes: false
                    // #18025
                  });
                  if (gridLinePath) {
                    gridLine[old || tick.isNew ? "attr" : "animate"]({
                      d: gridLinePath,
                      opacity
                    });
                  }
                }
              };
              Tick2.prototype.renderMark = function(xy, opacity, reverseCrisp) {
                var tick = this, axis = tick.axis, options = axis.options, renderer = axis.chart.renderer, type = tick.type, tickSize = axis.tickSize(type ? type + "Tick" : "tick"), x = xy.x, y = xy.y, tickWidth = pick(options[type !== "minor" ? "tickWidth" : "minorTickWidth"], !type && axis.isXAxis ? 1 : 0), tickColor = options[type !== "minor" ? "tickColor" : "minorTickColor"];
                var mark = tick.mark;
                var isNewMark = !mark;
                if (tickSize) {
                  if (axis.opposite) {
                    tickSize[0] = -tickSize[0];
                  }
                  if (!mark) {
                    tick.mark = mark = renderer.path().addClass("highcharts-" + (type ? type + "-" : "") + "tick").add(axis.axisGroup);
                    if (!axis.chart.styledMode) {
                      mark.attr({
                        stroke: tickColor,
                        "stroke-width": tickWidth
                      });
                    }
                  }
                  mark[isNewMark ? "attr" : "animate"]({
                    d: tick.getMarkPath(x, y, tickSize[0], mark.strokeWidth() * reverseCrisp, axis.horiz, renderer),
                    opacity
                  });
                }
              };
              Tick2.prototype.renderLabel = function(xy, old, opacity, index) {
                var tick = this, axis = tick.axis, horiz = axis.horiz, options = axis.options, label = tick.label, labelOptions = options.labels, step = labelOptions.step, tickmarkOffset = pick(
                  tick.tickmarkOffset,
                  axis.tickmarkOffset
                ), x = xy.x, y = xy.y;
                var show = true;
                if (label && isNumber(x)) {
                  label.xy = xy = tick.getLabelPosition(x, y, label, horiz, labelOptions, tickmarkOffset, index, step);
                  if (tick.isFirst && !tick.isLast && !options.showFirstLabel || tick.isLast && !tick.isFirst && !options.showLastLabel) {
                    show = false;
                  } else if (horiz && !labelOptions.step && !labelOptions.rotation && !old && opacity !== 0) {
                    tick.handleOverflow(xy);
                  }
                  if (step && index % step) {
                    show = false;
                  }
                  if (show && isNumber(xy.y)) {
                    xy.opacity = opacity;
                    label[tick.isNewLabel ? "attr" : "animate"](xy).show(true);
                    tick.isNewLabel = false;
                  } else {
                    label.hide();
                    tick.isNewLabel = true;
                  }
                }
              };
              Tick2.prototype.replaceMovedLabel = function() {
                var tick = this, label = tick.label, axis = tick.axis, reversed = axis.reversed;
                var x, y;
                if (label && !tick.isNew) {
                  x = axis.horiz ? reversed ? axis.left : axis.width + axis.left : label.xy.x;
                  y = axis.horiz ? label.xy.y : reversed ? axis.width + axis.top : axis.top;
                  label.animate({ x, y, opacity: 0 }, void 0, label.destroy);
                  delete tick.label;
                }
                axis.isDirty = true;
                tick.label = tick.movedLabel;
                delete tick.movedLabel;
              };
              return Tick2;
            }()
          );
          "";
          return Tick;
        });
        _registerModule(_modules, "Core/Axis/Axis.js", [_modules["Core/Animation/AnimationUtilities.js"], _modules["Core/Axis/AxisDefaults.js"], _modules["Core/Color/Color.js"], _modules["Core/Defaults.js"], _modules["Core/Foundation.js"], _modules["Core/Globals.js"], _modules["Core/Axis/Tick.js"], _modules["Core/Utilities.js"]], function(A, AxisDefaults, Color2, D, F, H, Tick, U) {
          var animObject = A.animObject;
          var defaultOptions = D.defaultOptions;
          var registerEventOptions = F.registerEventOptions;
          var deg2rad = H.deg2rad;
          var arrayMax = U.arrayMax, arrayMin = U.arrayMin, clamp = U.clamp, correctFloat = U.correctFloat, defined = U.defined, destroyObjectProperties = U.destroyObjectProperties, erase = U.erase, error = U.error, extend2 = U.extend, fireEvent = U.fireEvent, isArray = U.isArray, isNumber = U.isNumber, isString = U.isString, merge = U.merge, normalizeTickInterval = U.normalizeTickInterval, objectEach = U.objectEach, pick = U.pick, relativeLength = U.relativeLength, removeEvent = U.removeEvent, splat = U.splat, syncTimeout = U.syncTimeout;
          var getNormalizedTickInterval = function(axis, tickInterval) {
            return normalizeTickInterval(
              tickInterval,
              void 0,
              void 0,
              pick(
                axis.options.allowDecimals,
                // If the tick interval is greather than 0.5, avoid decimals, as
                // linear axes are often used to render discrete values (#3363). If
                // a tick amount is set, allow decimals by default, as it increases
                // the chances for a good fit.
                tickInterval < 0.5 || axis.tickAmount !== void 0
              ),
              !!axis.tickAmount
            );
          };
          var Axis = (
            /** @class */
            function() {
              function Axis2(chart, userOptions) {
                this.alternateBands = void 0;
                this.bottom = void 0;
                this.chart = void 0;
                this.closestPointRange = void 0;
                this.coll = void 0;
                this.eventOptions = void 0;
                this.hasNames = void 0;
                this.hasVisibleSeries = void 0;
                this.height = void 0;
                this.isLinked = void 0;
                this.labelEdge = void 0;
                this.labelFormatter = void 0;
                this.left = void 0;
                this.len = void 0;
                this.max = void 0;
                this.maxLabelLength = void 0;
                this.min = void 0;
                this.minorTickInterval = void 0;
                this.minorTicks = void 0;
                this.minPixelPadding = void 0;
                this.names = void 0;
                this.offset = void 0;
                this.options = void 0;
                this.overlap = void 0;
                this.paddedTicks = void 0;
                this.plotLinesAndBands = void 0;
                this.plotLinesAndBandsGroups = void 0;
                this.pointRange = void 0;
                this.pointRangePadding = void 0;
                this.pos = void 0;
                this.positiveValuesOnly = void 0;
                this.right = void 0;
                this.series = void 0;
                this.side = void 0;
                this.tickAmount = void 0;
                this.tickInterval = void 0;
                this.tickmarkOffset = void 0;
                this.tickPositions = void 0;
                this.tickRotCorr = void 0;
                this.ticks = void 0;
                this.top = void 0;
                this.transA = void 0;
                this.transB = void 0;
                this.translationSlope = void 0;
                this.userOptions = void 0;
                this.visible = void 0;
                this.width = void 0;
                this.zoomEnabled = void 0;
                this.init(chart, userOptions);
              }
              Axis2.prototype.init = function(chart, userOptions) {
                var isXAxis = userOptions.isX, axis = this;
                axis.chart = chart;
                axis.horiz = chart.inverted && !axis.isZAxis ? !isXAxis : isXAxis;
                axis.isXAxis = isXAxis;
                axis.coll = axis.coll || (isXAxis ? "xAxis" : "yAxis");
                fireEvent(this, "init", { userOptions });
                axis.opposite = pick(userOptions.opposite, axis.opposite);
                axis.side = pick(
                  userOptions.side,
                  axis.side,
                  axis.horiz ? axis.opposite ? 0 : 2 : (
                    // top : bottom
                    axis.opposite ? 1 : 3
                  )
                  // right : left
                );
                axis.setOptions(userOptions);
                var options = this.options, labelsOptions = options.labels, type = options.type;
                axis.userOptions = userOptions;
                axis.minPixelPadding = 0;
                axis.reversed = pick(options.reversed, axis.reversed);
                axis.visible = options.visible;
                axis.zoomEnabled = options.zoomEnabled;
                axis.hasNames = type === "category" || options.categories === true;
                axis.categories = options.categories || (axis.hasNames ? [] : void 0);
                if (!axis.names) {
                  axis.names = [];
                  axis.names.keys = {};
                }
                axis.plotLinesAndBandsGroups = {};
                axis.positiveValuesOnly = !!axis.logarithmic;
                axis.isLinked = defined(options.linkedTo);
                axis.ticks = {};
                axis.labelEdge = [];
                axis.minorTicks = {};
                axis.plotLinesAndBands = [];
                axis.alternateBands = {};
                axis.len = 0;
                axis.minRange = axis.userMinRange = options.minRange || options.maxZoom;
                axis.range = options.range;
                axis.offset = options.offset || 0;
                axis.max = null;
                axis.min = null;
                var crosshair = pick(
                  options.crosshair,
                  splat(chart.options.tooltip.crosshairs)[isXAxis ? 0 : 1]
                );
                axis.crosshair = crosshair === true ? {} : crosshair;
                if (chart.axes.indexOf(axis) === -1) {
                  if (isXAxis) {
                    chart.axes.splice(chart.xAxis.length, 0, axis);
                  } else {
                    chart.axes.push(axis);
                  }
                  chart[axis.coll].push(axis);
                }
                axis.series = axis.series || [];
                if (chart.inverted && !axis.isZAxis && isXAxis && typeof axis.reversed === "undefined") {
                  axis.reversed = true;
                }
                axis.labelRotation = isNumber(labelsOptions.rotation) ? labelsOptions.rotation : void 0;
                registerEventOptions(axis, options);
                fireEvent(this, "afterInit");
              };
              Axis2.prototype.setOptions = function(userOptions) {
                this.options = merge(AxisDefaults.defaultXAxisOptions, this.coll === "yAxis" && AxisDefaults.defaultYAxisOptions, [
                  AxisDefaults.defaultTopAxisOptions,
                  AxisDefaults.defaultRightAxisOptions,
                  AxisDefaults.defaultBottomAxisOptions,
                  AxisDefaults.defaultLeftAxisOptions
                ][this.side], merge(
                  // if set in setOptions (#1053):
                  defaultOptions[this.coll],
                  userOptions
                ));
                fireEvent(this, "afterSetOptions", { userOptions });
              };
              Axis2.prototype.defaultLabelFormatter = function(ctx) {
                var axis = this.axis, chart = this.chart, numberFormatter = chart.numberFormatter, value = isNumber(this.value) ? this.value : NaN, time = axis.chart.time, categories = axis.categories, dateTimeLabelFormat = this.dateTimeLabelFormat, lang = defaultOptions.lang, numericSymbols = lang.numericSymbols, numSymMagnitude = lang.numericSymbolMagnitude || 1e3, numericSymbolDetector = axis.logarithmic ? Math.abs(value) : axis.tickInterval;
                var i = numericSymbols && numericSymbols.length, multi, ret;
                if (categories) {
                  ret = "".concat(this.value);
                } else if (dateTimeLabelFormat) {
                  ret = time.dateFormat(dateTimeLabelFormat, value);
                } else if (i && numericSymbolDetector >= 1e3) {
                  while (i-- && typeof ret === "undefined") {
                    multi = Math.pow(numSymMagnitude, i + 1);
                    if (
                      // Only accept a numeric symbol when the distance is more
                      // than a full unit. So for example if the symbol is k, we
                      // don't accept numbers like 0.5k.
                      numericSymbolDetector >= multi && // Accept one decimal before the symbol. Accepts 0.5k but
                      // not 0.25k. How does this work with the previous?
                      value * 10 % multi === 0 && numericSymbols[i] !== null && value !== 0
                    ) {
                      ret = numberFormatter(value / multi, -1) + numericSymbols[i];
                    }
                  }
                }
                if (typeof ret === "undefined") {
                  if (Math.abs(value) >= 1e4) {
                    ret = numberFormatter(value, -1);
                  } else {
                    ret = numberFormatter(value, -1, void 0, "");
                  }
                }
                return ret;
              };
              Axis2.prototype.getSeriesExtremes = function() {
                var axis = this, chart = axis.chart;
                var xExtremes;
                fireEvent(this, "getSeriesExtremes", null, function() {
                  axis.hasVisibleSeries = false;
                  axis.dataMin = axis.dataMax = axis.threshold = null;
                  axis.softThreshold = !axis.isXAxis;
                  axis.series.forEach(function(series) {
                    if (series.visible || !chart.options.chart.ignoreHiddenSeries) {
                      var seriesOptions = series.options;
                      var xData = void 0, threshold = seriesOptions.threshold, seriesDataMin = void 0, seriesDataMax = void 0;
                      axis.hasVisibleSeries = true;
                      if (axis.positiveValuesOnly && threshold <= 0) {
                        threshold = null;
                      }
                      if (axis.isXAxis) {
                        xData = series.xData;
                        if (xData.length) {
                          xData = axis.logarithmic ? xData.filter(axis.validatePositiveValue) : xData;
                          xExtremes = series.getXExtremes(xData);
                          seriesDataMin = xExtremes.min;
                          seriesDataMax = xExtremes.max;
                          if (!isNumber(seriesDataMin) && // #5010:
                          !(seriesDataMin instanceof Date)) {
                            xData = xData.filter(isNumber);
                            xExtremes = series.getXExtremes(xData);
                            seriesDataMin = xExtremes.min;
                            seriesDataMax = xExtremes.max;
                          }
                          if (xData.length) {
                            axis.dataMin = Math.min(pick(axis.dataMin, seriesDataMin), seriesDataMin);
                            axis.dataMax = Math.max(pick(axis.dataMax, seriesDataMax), seriesDataMax);
                          }
                        }
                      } else {
                        var dataExtremes = series.applyExtremes();
                        if (isNumber(dataExtremes.dataMin)) {
                          seriesDataMin = dataExtremes.dataMin;
                          axis.dataMin = Math.min(pick(axis.dataMin, seriesDataMin), seriesDataMin);
                        }
                        if (isNumber(dataExtremes.dataMax)) {
                          seriesDataMax = dataExtremes.dataMax;
                          axis.dataMax = Math.max(pick(axis.dataMax, seriesDataMax), seriesDataMax);
                        }
                        if (defined(threshold)) {
                          axis.threshold = threshold;
                        }
                        if (!seriesOptions.softThreshold || axis.positiveValuesOnly) {
                          axis.softThreshold = false;
                        }
                      }
                    }
                  });
                });
                fireEvent(this, "afterGetSeriesExtremes");
              };
              Axis2.prototype.translate = function(val, backwards, cvsCoord, old, handleLog, pointPlacement) {
                var axis = this.linkedParent || this, localMin = old && axis.old ? axis.old.min : axis.min;
                if (!isNumber(localMin)) {
                  return NaN;
                }
                var minPixelPadding = axis.minPixelPadding, doPostTranslate = (axis.isOrdinal || axis.brokenAxis && axis.brokenAxis.hasBreaks || axis.logarithmic && handleLog) && axis.lin2val;
                var sign = 1, cvsOffset = 0, localA = old && axis.old ? axis.old.transA : axis.transA, returnValue = 0;
                if (!localA) {
                  localA = axis.transA;
                }
                if (cvsCoord) {
                  sign *= -1;
                  cvsOffset = axis.len;
                }
                if (axis.reversed) {
                  sign *= -1;
                  cvsOffset -= sign * (axis.sector || axis.len);
                }
                if (backwards) {
                  val = val * sign + cvsOffset;
                  val -= minPixelPadding;
                  returnValue = val / localA + localMin;
                  if (doPostTranslate) {
                    returnValue = axis.lin2val(returnValue);
                  }
                } else {
                  if (doPostTranslate) {
                    val = axis.val2lin(val);
                  }
                  var value = sign * (val - localMin) * localA;
                  returnValue = (!axis.isRadial ? correctFloat(value) : value) + cvsOffset + sign * minPixelPadding + (isNumber(pointPlacement) ? localA * pointPlacement : 0);
                }
                return returnValue;
              };
              Axis2.prototype.toPixels = function(value, paneCoordinates) {
                return this.translate(value, false, !this.horiz, void 0, true) + (paneCoordinates ? 0 : this.pos);
              };
              Axis2.prototype.toValue = function(pixel, paneCoordinates) {
                return this.translate(pixel - (paneCoordinates ? 0 : this.pos), true, !this.horiz, void 0, true);
              };
              Axis2.prototype.getPlotLinePath = function(options) {
                var axis = this, chart = axis.chart, axisLeft = axis.left, axisTop = axis.top, old = options.old, value = options.value, lineWidth = options.lineWidth, cHeight = old && chart.oldChartHeight || chart.chartHeight, cWidth = old && chart.oldChartWidth || chart.chartWidth, transB = axis.transB;
                var translatedValue = options.translatedValue, force = options.force, x1, y1, x2, y2, skip;
                function between(x, a, b) {
                  if (force !== "pass" && (x < a || x > b)) {
                    if (force) {
                      x = clamp(x, a, b);
                    } else {
                      skip = true;
                    }
                  }
                  return x;
                }
                var evt = {
                  value,
                  lineWidth,
                  old,
                  force,
                  acrossPanes: options.acrossPanes,
                  translatedValue
                };
                fireEvent(this, "getPlotLinePath", evt, function(e) {
                  translatedValue = pick(translatedValue, axis.translate(value, void 0, void 0, old));
                  translatedValue = clamp(translatedValue, -1e5, 1e5);
                  x1 = x2 = Math.round(translatedValue + transB);
                  y1 = y2 = Math.round(cHeight - translatedValue - transB);
                  if (!isNumber(translatedValue)) {
                    skip = true;
                    force = false;
                  } else if (axis.horiz) {
                    y1 = axisTop;
                    y2 = cHeight - axis.bottom;
                    x1 = x2 = between(x1, axisLeft, axisLeft + axis.width);
                  } else {
                    x1 = axisLeft;
                    x2 = cWidth - axis.right;
                    y1 = y2 = between(y1, axisTop, axisTop + axis.height);
                  }
                  e.path = skip && !force ? null : chart.renderer.crispLine([["M", x1, y1], ["L", x2, y2]], lineWidth || 1);
                });
                return evt.path;
              };
              Axis2.prototype.getLinearTickPositions = function(tickInterval, min2, max2) {
                var roundedMin = correctFloat(Math.floor(min2 / tickInterval) * tickInterval), roundedMax = correctFloat(Math.ceil(max2 / tickInterval) * tickInterval), tickPositions = [];
                var pos, lastPos, precision;
                if (correctFloat(roundedMin + tickInterval) === roundedMin) {
                  precision = 20;
                }
                if (this.single) {
                  return [min2];
                }
                pos = roundedMin;
                while (pos <= roundedMax) {
                  tickPositions.push(pos);
                  pos = correctFloat(pos + tickInterval, precision);
                  if (pos === lastPos) {
                    break;
                  }
                  lastPos = pos;
                }
                return tickPositions;
              };
              Axis2.prototype.getMinorTickInterval = function() {
                var options = this.options;
                if (options.minorTicks === true) {
                  return pick(options.minorTickInterval, "auto");
                }
                if (options.minorTicks === false) {
                  return null;
                }
                return options.minorTickInterval;
              };
              Axis2.prototype.getMinorTickPositions = function() {
                var axis = this, options = axis.options, tickPositions = axis.tickPositions, minorTickInterval = axis.minorTickInterval, pointRangePadding = axis.pointRangePadding || 0, min2 = axis.min - pointRangePadding, max2 = axis.max + pointRangePadding, range = max2 - min2;
                var minorTickPositions = [], pos;
                if (range && range / minorTickInterval < axis.len / 3) {
                  var logarithmic_1 = axis.logarithmic;
                  if (logarithmic_1) {
                    this.paddedTicks.forEach(function(_pos, i, paddedTicks) {
                      if (i) {
                        minorTickPositions.push.apply(minorTickPositions, logarithmic_1.getLogTickPositions(minorTickInterval, paddedTicks[i - 1], paddedTicks[i], true));
                      }
                    });
                  } else if (axis.dateTime && this.getMinorTickInterval() === "auto") {
                    minorTickPositions = minorTickPositions.concat(axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(minorTickInterval), min2, max2, options.startOfWeek));
                  } else {
                    for (pos = min2 + (tickPositions[0] - min2) % minorTickInterval; pos <= max2; pos += minorTickInterval) {
                      if (pos === minorTickPositions[0]) {
                        break;
                      }
                      minorTickPositions.push(pos);
                    }
                  }
                }
                if (minorTickPositions.length !== 0) {
                  axis.trimTicks(minorTickPositions);
                }
                return minorTickPositions;
              };
              Axis2.prototype.adjustForMinRange = function() {
                var axis = this, options = axis.options, log = axis.logarithmic;
                var min2 = axis.min, max2 = axis.max, zoomOffset, spaceAvailable, closestDataRange = 0, i, distance, xData, loopLength, minArgs, maxArgs, minRange;
                if (axis.isXAxis && typeof axis.minRange === "undefined" && !log) {
                  if (defined(options.min) || defined(options.max) || defined(options.floor) || defined(options.ceiling)) {
                    axis.minRange = null;
                  } else {
                    axis.series.forEach(function(series) {
                      xData = series.xData;
                      loopLength = series.xIncrement ? 1 : xData.length - 1;
                      if (xData.length > 1) {
                        for (i = loopLength; i > 0; i--) {
                          distance = xData[i] - xData[i - 1];
                          if (!closestDataRange || distance < closestDataRange) {
                            closestDataRange = distance;
                          }
                        }
                      }
                    });
                    axis.minRange = Math.min(closestDataRange * 5, axis.dataMax - axis.dataMin);
                  }
                }
                if (max2 - min2 < axis.minRange) {
                  spaceAvailable = axis.dataMax - axis.dataMin >= axis.minRange;
                  minRange = axis.minRange;
                  zoomOffset = (minRange - max2 + min2) / 2;
                  minArgs = [
                    min2 - zoomOffset,
                    pick(options.min, min2 - zoomOffset)
                  ];
                  if (spaceAvailable) {
                    minArgs[2] = axis.logarithmic ? axis.logarithmic.log2lin(axis.dataMin) : axis.dataMin;
                  }
                  min2 = arrayMax(minArgs);
                  maxArgs = [
                    min2 + minRange,
                    pick(options.max, min2 + minRange)
                  ];
                  if (spaceAvailable) {
                    maxArgs[2] = log ? log.log2lin(axis.dataMax) : axis.dataMax;
                  }
                  max2 = arrayMin(maxArgs);
                  if (max2 - min2 < minRange) {
                    minArgs[0] = max2 - minRange;
                    minArgs[1] = pick(options.min, max2 - minRange);
                    min2 = arrayMax(minArgs);
                  }
                }
                axis.min = min2;
                axis.max = max2;
              };
              Axis2.prototype.getClosest = function() {
                var ret;
                if (this.categories) {
                  ret = 1;
                } else {
                  this.series.forEach(function(series) {
                    var seriesClosest = series.closestPointRange, visible = series.visible || !series.chart.options.chart.ignoreHiddenSeries;
                    if (!series.noSharedTooltip && defined(seriesClosest) && visible) {
                      ret = defined(ret) ? Math.min(ret, seriesClosest) : seriesClosest;
                    }
                  });
                }
                return ret;
              };
              Axis2.prototype.nameToX = function(point) {
                var explicitCategories = isArray(this.options.categories), names = explicitCategories ? this.categories : this.names;
                var nameX = point.options.x, x;
                point.series.requireSorting = false;
                if (!defined(nameX)) {
                  nameX = this.options.uniqueNames && names ? explicitCategories ? names.indexOf(point.name) : pick(names.keys[point.name], -1) : point.series.autoIncrement();
                }
                if (nameX === -1) {
                  if (!explicitCategories && names) {
                    x = names.length;
                  }
                } else {
                  x = nameX;
                }
                if (typeof x !== "undefined") {
                  this.names[x] = point.name;
                  this.names.keys[point.name] = x;
                } else if (point.x) {
                  x = point.x;
                }
                return x;
              };
              Axis2.prototype.updateNames = function() {
                var axis = this, names = this.names, i = names.length;
                if (i > 0) {
                  Object.keys(names.keys).forEach(function(key) {
                    delete names.keys[key];
                  });
                  names.length = 0;
                  this.minRange = this.userMinRange;
                  (this.series || []).forEach(function(series) {
                    series.xIncrement = null;
                    if (!series.points || series.isDirtyData) {
                      axis.max = Math.max(axis.max, series.xData.length - 1);
                      series.processData();
                      series.generatePoints();
                    }
                    series.data.forEach(function(point, i2) {
                      var x;
                      if (point && point.options && typeof point.name !== "undefined") {
                        x = axis.nameToX(point);
                        if (typeof x !== "undefined" && x !== point.x) {
                          point.x = x;
                          series.xData[i2] = x;
                        }
                      }
                    });
                  });
                }
              };
              Axis2.prototype.setAxisTranslation = function() {
                var axis = this, range = axis.max - axis.min, linkedParent = axis.linkedParent, hasCategories = !!axis.categories, isXAxis = axis.isXAxis;
                var pointRange = axis.axisPointRange || 0, closestPointRange, minPointOffset = 0, pointRangePadding = 0, ordinalCorrection, transA = axis.transA;
                if (isXAxis || hasCategories || pointRange) {
                  closestPointRange = axis.getClosest();
                  if (linkedParent) {
                    minPointOffset = linkedParent.minPointOffset;
                    pointRangePadding = linkedParent.pointRangePadding;
                  } else {
                    axis.series.forEach(function(series) {
                      var seriesPointRange = hasCategories ? 1 : isXAxis ? pick(
                        series.options.pointRange,
                        closestPointRange,
                        0
                      ) : axis.axisPointRange || 0, pointPlacement = series.options.pointPlacement;
                      pointRange = Math.max(pointRange, seriesPointRange);
                      if (!axis.single || hasCategories) {
                        var isPointPlacementAxis = series.is("xrange") ? !isXAxis : isXAxis;
                        minPointOffset = Math.max(minPointOffset, isPointPlacementAxis && isString(pointPlacement) ? 0 : seriesPointRange / 2);
                        pointRangePadding = Math.max(pointRangePadding, isPointPlacementAxis && pointPlacement === "on" ? 0 : seriesPointRange);
                      }
                    });
                  }
                  ordinalCorrection = axis.ordinal && axis.ordinal.slope && closestPointRange ? axis.ordinal.slope / closestPointRange : 1;
                  axis.minPointOffset = minPointOffset = minPointOffset * ordinalCorrection;
                  axis.pointRangePadding = pointRangePadding = pointRangePadding * ordinalCorrection;
                  axis.pointRange = Math.min(pointRange, axis.single && hasCategories ? 1 : range);
                  if (isXAxis) {
                    axis.closestPointRange = closestPointRange;
                  }
                }
                axis.translationSlope = axis.transA = transA = axis.staticScale || axis.len / (range + pointRangePadding || 1);
                axis.transB = axis.horiz ? axis.left : axis.bottom;
                axis.minPixelPadding = transA * minPointOffset;
                fireEvent(this, "afterSetAxisTranslation");
              };
              Axis2.prototype.minFromRange = function() {
                var axis = this;
                return axis.max - axis.range;
              };
              Axis2.prototype.setTickInterval = function(secondPass) {
                var axis = this, chart = axis.chart, log = axis.logarithmic, options = axis.options, isXAxis = axis.isXAxis, isLinked = axis.isLinked, tickPixelIntervalOption = options.tickPixelInterval, categories = axis.categories, softThreshold = axis.softThreshold;
                var maxPadding = options.maxPadding, minPadding = options.minPadding, length, linkedParentExtremes, tickIntervalOption = isNumber(options.tickInterval) && options.tickInterval >= 0 ? options.tickInterval : void 0, threshold = isNumber(axis.threshold) ? axis.threshold : null, thresholdMin, thresholdMax, hardMin, hardMax;
                if (!axis.dateTime && !categories && !isLinked) {
                  this.getTickAmount();
                }
                hardMin = pick(axis.userMin, options.min);
                hardMax = pick(axis.userMax, options.max);
                if (isLinked) {
                  axis.linkedParent = chart[axis.coll][options.linkedTo];
                  linkedParentExtremes = axis.linkedParent.getExtremes();
                  axis.min = pick(linkedParentExtremes.min, linkedParentExtremes.dataMin);
                  axis.max = pick(linkedParentExtremes.max, linkedParentExtremes.dataMax);
                  if (options.type !== axis.linkedParent.options.type) {
                    error(11, 1, chart);
                  }
                } else {
                  if (softThreshold && defined(threshold)) {
                    if (axis.dataMin >= threshold) {
                      thresholdMin = threshold;
                      minPadding = 0;
                    } else if (axis.dataMax <= threshold) {
                      thresholdMax = threshold;
                      maxPadding = 0;
                    }
                  }
                  axis.min = pick(hardMin, thresholdMin, axis.dataMin);
                  axis.max = pick(hardMax, thresholdMax, axis.dataMax);
                }
                if (log) {
                  if (axis.positiveValuesOnly && !secondPass && Math.min(axis.min, pick(axis.dataMin, axis.min)) <= 0) {
                    error(10, 1, chart);
                  }
                  axis.min = correctFloat(log.log2lin(axis.min), 16);
                  axis.max = correctFloat(log.log2lin(axis.max), 16);
                }
                if (axis.range && defined(axis.max)) {
                  axis.userMin = axis.min = hardMin = Math.max(axis.dataMin, axis.minFromRange());
                  axis.userMax = hardMax = axis.max;
                  axis.range = null;
                }
                fireEvent(axis, "foundExtremes");
                if (axis.beforePadding) {
                  axis.beforePadding();
                }
                axis.adjustForMinRange();
                if (!categories && !axis.axisPointRange && !(axis.stacking && axis.stacking.usePercentage) && !isLinked && defined(axis.min) && defined(axis.max)) {
                  length = axis.max - axis.min;
                  if (length) {
                    if (!defined(hardMin) && minPadding) {
                      axis.min -= length * minPadding;
                    }
                    if (!defined(hardMax) && maxPadding) {
                      axis.max += length * maxPadding;
                    }
                  }
                }
                if (!isNumber(axis.userMin)) {
                  if (isNumber(options.softMin) && options.softMin < axis.min) {
                    axis.min = hardMin = options.softMin;
                  }
                  if (isNumber(options.floor)) {
                    axis.min = Math.max(axis.min, options.floor);
                  }
                }
                if (!isNumber(axis.userMax)) {
                  if (isNumber(options.softMax) && options.softMax > axis.max) {
                    axis.max = hardMax = options.softMax;
                  }
                  if (isNumber(options.ceiling)) {
                    axis.max = Math.min(axis.max, options.ceiling);
                  }
                }
                if (softThreshold && defined(axis.dataMin)) {
                  threshold = threshold || 0;
                  if (!defined(hardMin) && axis.min < threshold && axis.dataMin >= threshold) {
                    axis.min = axis.options.minRange ? Math.min(threshold, axis.max - axis.minRange) : threshold;
                  } else if (!defined(hardMax) && axis.max > threshold && axis.dataMax <= threshold) {
                    axis.max = axis.options.minRange ? Math.max(threshold, axis.min + axis.minRange) : threshold;
                  }
                }
                if (isNumber(axis.min) && isNumber(axis.max) && !this.chart.polar && axis.min > axis.max) {
                  if (defined(axis.options.min)) {
                    axis.max = axis.min;
                  } else if (defined(axis.options.max)) {
                    axis.min = axis.max;
                  }
                }
                if (axis.min === axis.max || typeof axis.min === "undefined" || typeof axis.max === "undefined") {
                  axis.tickInterval = 1;
                } else if (isLinked && axis.linkedParent && !tickIntervalOption && tickPixelIntervalOption === axis.linkedParent.options.tickPixelInterval) {
                  axis.tickInterval = tickIntervalOption = axis.linkedParent.tickInterval;
                } else {
                  axis.tickInterval = pick(
                    tickIntervalOption,
                    this.tickAmount ? (axis.max - axis.min) / Math.max(this.tickAmount - 1, 1) : void 0,
                    // For categoried axis, 1 is default, for linear axis use
                    // tickPix
                    categories ? 1 : (
                      // don't let it be more than the data range
                      (axis.max - axis.min) * tickPixelIntervalOption / Math.max(axis.len, tickPixelIntervalOption)
                    )
                  );
                }
                if (isXAxis && !secondPass) {
                  var hasExtremesChanged_1 = axis.min !== (axis.old && axis.old.min) || axis.max !== (axis.old && axis.old.max);
                  axis.series.forEach(function(series) {
                    series.forceCrop = series.forceCropping && series.forceCropping();
                    series.processData(hasExtremesChanged_1);
                  });
                  fireEvent(this, "postProcessData", { hasExtremesChanged: hasExtremesChanged_1 });
                }
                axis.setAxisTranslation();
                fireEvent(this, "initialAxisTranslation");
                if (axis.pointRange && !tickIntervalOption) {
                  axis.tickInterval = Math.max(axis.pointRange, axis.tickInterval);
                }
                var minTickInterval = pick(
                  options.minTickInterval,
                  // In datetime axes, don't go below the data interval, except when
                  // there are scatter-like series involved (#13369).
                  axis.dateTime && !axis.series.some(function(s) {
                    return s.noSharedTooltip;
                  }) ? axis.closestPointRange : 0
                );
                if (!tickIntervalOption && axis.tickInterval < minTickInterval) {
                  axis.tickInterval = minTickInterval;
                }
                if (!axis.dateTime && !axis.logarithmic && !tickIntervalOption) {
                  axis.tickInterval = getNormalizedTickInterval(axis, axis.tickInterval);
                }
                if (!this.tickAmount) {
                  axis.tickInterval = axis.unsquish();
                }
                this.setTickPositions();
              };
              Axis2.prototype.setTickPositions = function() {
                var axis = this, options = this.options, tickPositionsOption = options.tickPositions, tickPositioner = options.tickPositioner, minorTickIntervalOption = this.getMinorTickInterval(), hasVerticalPanning = this.hasVerticalPanning(), isColorAxis = this.coll === "colorAxis", startOnTick = (isColorAxis || !hasVerticalPanning) && options.startOnTick, endOnTick = (isColorAxis || !hasVerticalPanning) && options.endOnTick;
                var tickPositions = [], tickPositionerResult;
                this.tickmarkOffset = this.categories && options.tickmarkPlacement === "between" && this.tickInterval === 1 ? 0.5 : 0;
                this.minorTickInterval = minorTickIntervalOption === "auto" && this.tickInterval ? this.tickInterval / 5 : minorTickIntervalOption;
                this.single = this.min === this.max && defined(this.min) && !this.tickAmount && // Data is on integer (#6563)
                (parseInt(this.min, 10) === this.min || // Between integers and decimals are not allowed (#6274)
                options.allowDecimals !== false);
                if (tickPositionsOption) {
                  tickPositions = tickPositionsOption.slice();
                } else if (isNumber(this.min) && isNumber(this.max)) {
                  if ((!axis.ordinal || !axis.ordinal.positions) && (this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) {
                    tickPositions = [this.min, this.max];
                    error(19, false, this.chart);
                  } else if (axis.dateTime) {
                    tickPositions = axis.getTimeTicks(axis.dateTime.normalizeTimeTickInterval(this.tickInterval, options.units), this.min, this.max, options.startOfWeek, axis.ordinal && axis.ordinal.positions, this.closestPointRange, true);
                  } else if (axis.logarithmic) {
                    tickPositions = axis.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
                  } else {
                    var startingTickInterval = this.tickInterval;
                    var adjustedTickInterval = startingTickInterval;
                    while (adjustedTickInterval <= startingTickInterval * 2) {
                      tickPositions = this.getLinearTickPositions(this.tickInterval, this.min, this.max);
                      if (this.tickAmount && tickPositions.length > this.tickAmount) {
                        this.tickInterval = getNormalizedTickInterval(this, adjustedTickInterval *= 1.1);
                      } else {
                        break;
                      }
                    }
                  }
                  if (tickPositions.length > this.len) {
                    tickPositions = [
                      tickPositions[0],
                      tickPositions[tickPositions.length - 1]
                    ];
                    if (tickPositions[0] === tickPositions[1]) {
                      tickPositions.length = 1;
                    }
                  }
                  if (tickPositioner) {
                    this.tickPositions = tickPositions;
                    tickPositionerResult = tickPositioner.apply(axis, [this.min, this.max]);
                    if (tickPositionerResult) {
                      tickPositions = tickPositionerResult;
                    }
                  }
                }
                this.tickPositions = tickPositions;
                this.paddedTicks = tickPositions.slice(0);
                this.trimTicks(tickPositions, startOnTick, endOnTick);
                if (!this.isLinked && isNumber(this.min) && isNumber(this.max)) {
                  if (this.single && tickPositions.length < 2 && !this.categories && !this.series.some(function(s) {
                    return s.is("heatmap") && s.options.pointPlacement === "between";
                  })) {
                    this.min -= 0.5;
                    this.max += 0.5;
                  }
                  if (!tickPositionsOption && !tickPositionerResult) {
                    this.adjustTickAmount();
                  }
                }
                fireEvent(this, "afterSetTickPositions");
              };
              Axis2.prototype.trimTicks = function(tickPositions, startOnTick, endOnTick) {
                var roundedMin = tickPositions[0], roundedMax = tickPositions[tickPositions.length - 1], minPointOffset = !this.isOrdinal && this.minPointOffset || 0;
                fireEvent(this, "trimTicks");
                if (!this.isLinked) {
                  if (startOnTick && roundedMin !== -Infinity) {
                    this.min = roundedMin;
                  } else {
                    while (this.min - minPointOffset > tickPositions[0]) {
                      tickPositions.shift();
                    }
                  }
                  if (endOnTick) {
                    this.max = roundedMax;
                  } else {
                    while (this.max + minPointOffset < tickPositions[tickPositions.length - 1]) {
                      tickPositions.pop();
                    }
                  }
                  if (tickPositions.length === 0 && defined(roundedMin) && !this.options.tickPositions) {
                    tickPositions.push((roundedMax + roundedMin) / 2);
                  }
                }
              };
              Axis2.prototype.alignToOthers = function() {
                var axis = this, alignedAxes = [this], options = axis.options, alignThresholds = this.coll === "yAxis" && this.chart.options.chart.alignThresholds, thresholdAlignments = [];
                var hasOther;
                axis.thresholdAlignment = void 0;
                if (
                  // Only if alignTicks or alignThresholds is true
                  (this.chart.options.chart.alignTicks !== false && options.alignTicks || alignThresholds) && // Disabled when startOnTick or endOnTick are false (#7604)
                  options.startOnTick !== false && options.endOnTick !== false && // Don't try to align ticks on a log axis, they are not evenly
                  // spaced (#6021)
                  !axis.logarithmic
                ) {
                  var getKey_1 = function(axis2) {
                    var horiz = axis2.horiz, options2 = axis2.options;
                    return [
                      horiz ? options2.left : options2.top,
                      options2.width,
                      options2.height,
                      options2.pane
                    ].join(",");
                  };
                  var thisKey_1 = getKey_1(this);
                  this.chart[this.coll].forEach(function(otherAxis) {
                    var series = otherAxis.series;
                    if (
                      // #4442
                      series.length && series.some(function(s) {
                        return s.visible;
                      }) && otherAxis !== axis && getKey_1(otherAxis) === thisKey_1
                    ) {
                      hasOther = true;
                      alignedAxes.push(otherAxis);
                    }
                  });
                }
                if (hasOther && alignThresholds) {
                  alignedAxes.forEach(function(otherAxis) {
                    var threshAlign = otherAxis.getThresholdAlignment(axis);
                    if (isNumber(threshAlign)) {
                      thresholdAlignments.push(threshAlign);
                    }
                  });
                  var thresholdAlignment_1 = thresholdAlignments.length > 1 ? thresholdAlignments.reduce(function(sum2, n) {
                    return sum2 += n;
                  }, 0) / thresholdAlignments.length : void 0;
                  alignedAxes.forEach(function(axis2) {
                    axis2.thresholdAlignment = thresholdAlignment_1;
                  });
                }
                return hasOther;
              };
              Axis2.prototype.getThresholdAlignment = function(callerAxis) {
                if (!isNumber(this.dataMin) || this !== callerAxis && this.series.some(function(s) {
                  return s.isDirty || s.isDirtyData;
                })) {
                  this.getSeriesExtremes();
                }
                if (isNumber(this.threshold)) {
                  var thresholdAlignment = clamp((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1);
                  if (this.options.reversed) {
                    thresholdAlignment = 1 - thresholdAlignment;
                  }
                  return thresholdAlignment;
                }
              };
              Axis2.prototype.getTickAmount = function() {
                var axis = this, options = this.options, tickPixelInterval = options.tickPixelInterval;
                var tickAmount = options.tickAmount;
                if (!defined(options.tickInterval) && !tickAmount && this.len < tickPixelInterval && !this.isRadial && !axis.logarithmic && options.startOnTick && options.endOnTick) {
                  tickAmount = 2;
                }
                if (!tickAmount && this.alignToOthers()) {
                  tickAmount = Math.ceil(this.len / tickPixelInterval) + 1;
                }
                if (tickAmount < 4) {
                  this.finalTickAmt = tickAmount;
                  tickAmount = 5;
                }
                this.tickAmount = tickAmount;
              };
              Axis2.prototype.adjustTickAmount = function() {
                var axis = this, finalTickAmt = axis.finalTickAmt, max2 = axis.max, min2 = axis.min, options = axis.options, tickPositions = axis.tickPositions, tickAmount = axis.tickAmount, thresholdAlignment = axis.thresholdAlignment, currentTickAmount = tickPositions && tickPositions.length, threshold = pick(
                  axis.threshold,
                  axis.softThreshold ? 0 : null
                );
                var len, i, tickInterval = axis.tickInterval, thresholdTickIndex;
                var append = function() {
                  return tickPositions.push(correctFloat(tickPositions[tickPositions.length - 1] + tickInterval));
                }, prepend = function() {
                  return tickPositions.unshift(correctFloat(tickPositions[0] - tickInterval));
                };
                if (isNumber(thresholdAlignment)) {
                  thresholdTickIndex = thresholdAlignment < 0.5 ? Math.ceil(thresholdAlignment * (tickAmount - 1)) : Math.floor(thresholdAlignment * (tickAmount - 1));
                  if (options.reversed) {
                    thresholdTickIndex = tickAmount - 1 - thresholdTickIndex;
                  }
                }
                if (axis.hasData() && isNumber(min2) && isNumber(max2)) {
                  var adjustExtremes = function() {
                    axis.transA *= (currentTickAmount - 1) / (tickAmount - 1);
                    axis.min = options.startOnTick ? tickPositions[0] : Math.min(min2, tickPositions[0]);
                    axis.max = options.endOnTick ? tickPositions[tickPositions.length - 1] : Math.max(max2, tickPositions[tickPositions.length - 1]);
                  };
                  if (isNumber(thresholdTickIndex) && isNumber(axis.threshold)) {
                    while (tickPositions[thresholdTickIndex] !== threshold || tickPositions.length !== tickAmount || tickPositions[0] > min2 || tickPositions[tickPositions.length - 1] < max2) {
                      tickPositions.length = 0;
                      tickPositions.push(axis.threshold);
                      while (tickPositions.length < tickAmount) {
                        if (
                          // Start by prepending positions until the threshold
                          // is at the required index...
                          tickPositions[thresholdTickIndex] === void 0 || tickPositions[thresholdTickIndex] > axis.threshold
                        ) {
                          prepend();
                        } else {
                          append();
                        }
                      }
                      if (tickInterval > axis.tickInterval * 8) {
                        break;
                      }
                      tickInterval *= 2;
                    }
                    adjustExtremes();
                  } else if (currentTickAmount < tickAmount) {
                    while (tickPositions.length < tickAmount) {
                      if (tickPositions.length % 2 || min2 === threshold) {
                        append();
                      } else {
                        prepend();
                      }
                    }
                    adjustExtremes();
                  }
                  if (defined(finalTickAmt)) {
                    i = len = tickPositions.length;
                    while (i--) {
                      if (
                        // Remove every other tick
                        finalTickAmt === 3 && i % 2 === 1 || // Remove all but first and last
                        finalTickAmt <= 2 && i > 0 && i < len - 1
                      ) {
                        tickPositions.splice(i, 1);
                      }
                    }
                    axis.finalTickAmt = void 0;
                  }
                }
              };
              Axis2.prototype.setScale = function() {
                var axis = this;
                var isDirtyData = false, isXAxisDirty = false;
                axis.series.forEach(function(series) {
                  isDirtyData = isDirtyData || series.isDirtyData || series.isDirty;
                  isXAxisDirty = isXAxisDirty || series.xAxis && series.xAxis.isDirty || false;
                });
                axis.setAxisSize();
                var isDirtyAxisLength = axis.len !== (axis.old && axis.old.len);
                if (isDirtyAxisLength || isDirtyData || isXAxisDirty || axis.isLinked || axis.forceRedraw || axis.userMin !== (axis.old && axis.old.userMin) || axis.userMax !== (axis.old && axis.old.userMax) || axis.alignToOthers()) {
                  if (axis.stacking) {
                    axis.stacking.resetStacks();
                    axis.stacking.buildStacks();
                  }
                  axis.forceRedraw = false;
                  axis.getSeriesExtremes();
                  axis.setTickInterval();
                  if (!axis.isDirty) {
                    axis.isDirty = isDirtyAxisLength || axis.min !== (axis.old && axis.old.min) || axis.max !== (axis.old && axis.old.max);
                  }
                } else if (axis.stacking) {
                  axis.stacking.cleanStacks();
                }
                if (isDirtyData && axis.panningState) {
                  axis.panningState.isDirty = true;
                }
                fireEvent(this, "afterSetScale");
              };
              Axis2.prototype.setExtremes = function(newMin, newMax, redraw, animation, eventArguments) {
                var axis = this, chart = axis.chart;
                redraw = pick(redraw, true);
                axis.series.forEach(function(serie) {
                  delete serie.kdTree;
                });
                eventArguments = extend2(eventArguments, {
                  min: newMin,
                  max: newMax
                });
                fireEvent(axis, "setExtremes", eventArguments, function() {
                  axis.userMin = newMin;
                  axis.userMax = newMax;
                  axis.eventArgs = eventArguments;
                  if (redraw) {
                    chart.redraw(animation);
                  }
                });
              };
              Axis2.prototype.zoom = function(newMin, newMax) {
                var axis = this, dataMin = this.dataMin, dataMax = this.dataMax, options = this.options, min2 = Math.min(
                  dataMin,
                  pick(
                    options.min,
                    dataMin
                  )
                ), max2 = Math.max(
                  dataMax,
                  pick(
                    options.max,
                    dataMax
                  )
                ), evt = {
                  newMin,
                  newMax
                };
                fireEvent(this, "zoom", evt, function(e) {
                  var newMin2 = e.newMin, newMax2 = e.newMax;
                  if (newMin2 !== axis.min || newMax2 !== axis.max) {
                    if (!axis.allowZoomOutside) {
                      if (defined(dataMin)) {
                        if (newMin2 < min2) {
                          newMin2 = min2;
                        }
                        if (newMin2 > max2) {
                          newMin2 = max2;
                        }
                      }
                      if (defined(dataMax)) {
                        if (newMax2 < min2) {
                          newMax2 = min2;
                        }
                        if (newMax2 > max2) {
                          newMax2 = max2;
                        }
                      }
                    }
                    axis.displayBtn = typeof newMin2 !== "undefined" || typeof newMax2 !== "undefined";
                    axis.setExtremes(newMin2, newMax2, false, void 0, { trigger: "zoom" });
                  }
                  e.zoomed = true;
                });
                return evt.zoomed;
              };
              Axis2.prototype.setAxisSize = function() {
                var chart = this.chart, options = this.options, offsets = options.offsets || [0, 0, 0, 0], horiz = this.horiz, width = this.width = Math.round(relativeLength(
                  pick(
                    options.width,
                    chart.plotWidth - offsets[3] + offsets[1]
                  ),
                  chart.plotWidth
                )), height = this.height = Math.round(relativeLength(
                  pick(
                    options.height,
                    chart.plotHeight - offsets[0] + offsets[2]
                  ),
                  chart.plotHeight
                )), top = this.top = Math.round(relativeLength(
                  pick(
                    options.top,
                    chart.plotTop + offsets[0]
                  ),
                  chart.plotHeight,
                  chart.plotTop
                )), left = this.left = Math.round(relativeLength(
                  pick(
                    options.left,
                    chart.plotLeft + offsets[3]
                  ),
                  chart.plotWidth,
                  chart.plotLeft
                ));
                this.bottom = chart.chartHeight - height - top;
                this.right = chart.chartWidth - width - left;
                this.len = Math.max(horiz ? width : height, 0);
                this.pos = horiz ? left : top;
              };
              Axis2.prototype.getExtremes = function() {
                var axis = this, log = axis.logarithmic;
                return {
                  min: log ? correctFloat(log.lin2log(axis.min)) : axis.min,
                  max: log ? correctFloat(log.lin2log(axis.max)) : axis.max,
                  dataMin: axis.dataMin,
                  dataMax: axis.dataMax,
                  userMin: axis.userMin,
                  userMax: axis.userMax
                };
              };
              Axis2.prototype.getThreshold = function(threshold) {
                var axis = this, log = axis.logarithmic, realMin = log ? log.lin2log(axis.min) : axis.min, realMax = log ? log.lin2log(axis.max) : axis.max;
                if (threshold === null || threshold === -Infinity) {
                  threshold = realMin;
                } else if (threshold === Infinity) {
                  threshold = realMax;
                } else if (realMin > threshold) {
                  threshold = realMin;
                } else if (realMax < threshold) {
                  threshold = realMax;
                }
                return axis.translate(threshold, 0, 1, 0, 1);
              };
              Axis2.prototype.autoLabelAlign = function(rotation) {
                var angle = (pick(rotation, 0) - this.side * 90 + 720) % 360, evt = { align: "center" };
                fireEvent(this, "autoLabelAlign", evt, function(e) {
                  if (angle > 15 && angle < 165) {
                    e.align = "right";
                  } else if (angle > 195 && angle < 345) {
                    e.align = "left";
                  }
                });
                return evt.align;
              };
              Axis2.prototype.tickSize = function(prefix) {
                var options = this.options, tickWidth = pick(
                  options[prefix === "tick" ? "tickWidth" : "minorTickWidth"],
                  // Default to 1 on linear and datetime X axes
                  prefix === "tick" && this.isXAxis && !this.categories ? 1 : 0
                );
                var tickLength = options[prefix === "tick" ? "tickLength" : "minorTickLength"], tickSize;
                if (tickWidth && tickLength) {
                  if (options[prefix + "Position"] === "inside") {
                    tickLength = -tickLength;
                  }
                  tickSize = [tickLength, tickWidth];
                }
                var e = { tickSize };
                fireEvent(this, "afterTickSize", e);
                return e.tickSize;
              };
              Axis2.prototype.labelMetrics = function() {
                var index = this.tickPositions && this.tickPositions[0] || 0;
                return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[index] && this.ticks[index].label);
              };
              Axis2.prototype.unsquish = function() {
                var labelOptions = this.options.labels, horiz = this.horiz, tickInterval = this.tickInterval, slotSize = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / tickInterval), rotationOption = labelOptions.rotation, labelMetrics = this.labelMetrics(), range = Math.max(this.max - this.min, 0), getStep = function(spaceNeeded) {
                  var step2 = spaceNeeded / (slotSize || 1);
                  step2 = step2 > 1 ? Math.ceil(step2) : 1;
                  if (step2 * tickInterval > range && spaceNeeded !== Infinity && slotSize !== Infinity && range) {
                    step2 = Math.ceil(range / tickInterval);
                  }
                  return correctFloat(step2 * tickInterval);
                };
                var newTickInterval = tickInterval, rotation, bestScore = Number.MAX_VALUE, autoRotation;
                if (horiz) {
                  if (!labelOptions.staggerLines) {
                    if (isNumber(rotationOption)) {
                      autoRotation = [rotationOption];
                    } else if (slotSize < labelOptions.autoRotationLimit) {
                      autoRotation = labelOptions.autoRotation;
                    }
                  }
                  if (autoRotation) {
                    var step = void 0, score = void 0;
                    for (var _i = 0, autoRotation_1 = autoRotation; _i < autoRotation_1.length; _i++) {
                      var rot = autoRotation_1[_i];
                      if (rot === rotationOption || rot && rot >= -90 && rot <= 90) {
                        step = getStep(Math.abs(labelMetrics.h / Math.sin(deg2rad * rot)));
                        score = step + Math.abs(rot / 360);
                        if (score < bestScore) {
                          bestScore = score;
                          rotation = rot;
                          newTickInterval = step;
                        }
                      }
                    }
                  }
                } else {
                  newTickInterval = getStep(labelMetrics.h);
                }
                this.autoRotation = autoRotation;
                this.labelRotation = pick(rotation, isNumber(rotationOption) ? rotationOption : 0);
                return labelOptions.step ? tickInterval : newTickInterval;
              };
              Axis2.prototype.getSlotWidth = function(tick) {
                var chart = this.chart, horiz = this.horiz, labelOptions = this.options.labels, slotCount = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), marginLeft = chart.margin[3];
                if (tick && isNumber(tick.slotWidth)) {
                  return tick.slotWidth;
                }
                if (horiz && labelOptions.step < 2) {
                  if (labelOptions.rotation) {
                    return 0;
                  }
                  return (this.staggerLines || 1) * this.len / slotCount;
                }
                if (!horiz) {
                  var cssWidth = labelOptions.style.width;
                  if (cssWidth !== void 0) {
                    return parseInt(String(cssWidth), 10);
                  }
                  if (marginLeft) {
                    return marginLeft - chart.spacing[3];
                  }
                }
                return chart.chartWidth * 0.33;
              };
              Axis2.prototype.renderUnsquish = function() {
                var chart = this.chart, renderer = chart.renderer, tickPositions = this.tickPositions, ticks = this.ticks, labelOptions = this.options.labels, labelStyleOptions = labelOptions.style, horiz = this.horiz, slotWidth = this.getSlotWidth(), innerWidth = Math.max(
                  1,
                  Math.round(slotWidth - 2 * labelOptions.padding)
                ), attr = {}, labelMetrics = this.labelMetrics(), textOverflowOption = labelStyleOptions.textOverflow;
                var commonWidth, commonTextOverflow, maxLabelLength = 0, label, i, pos;
                if (!isString(labelOptions.rotation)) {
                  attr.rotation = labelOptions.rotation || 0;
                }
                tickPositions.forEach(function(tickPosition) {
                  var tick = ticks[tickPosition];
                  if (tick.movedLabel) {
                    tick.replaceMovedLabel();
                  }
                  if (tick && tick.label && tick.label.textPxLength > maxLabelLength) {
                    maxLabelLength = tick.label.textPxLength;
                  }
                });
                this.maxLabelLength = maxLabelLength;
                if (this.autoRotation) {
                  if (maxLabelLength > innerWidth && maxLabelLength > labelMetrics.h) {
                    attr.rotation = this.labelRotation;
                  } else {
                    this.labelRotation = 0;
                  }
                } else if (slotWidth) {
                  commonWidth = innerWidth;
                  if (!textOverflowOption) {
                    commonTextOverflow = "clip";
                    i = tickPositions.length;
                    while (!horiz && i--) {
                      pos = tickPositions[i];
                      label = ticks[pos].label;
                      if (label) {
                        if (label.styles && label.styles.textOverflow === "ellipsis") {
                          label.css({ textOverflow: "clip" });
                        } else if (label.textPxLength > slotWidth) {
                          label.css({ width: slotWidth + "px" });
                        }
                        if (label.getBBox().height > this.len / tickPositions.length - (labelMetrics.h - labelMetrics.f)) {
                          label.specificTextOverflow = "ellipsis";
                        }
                      }
                    }
                  }
                }
                if (attr.rotation) {
                  commonWidth = maxLabelLength > chart.chartHeight * 0.5 ? chart.chartHeight * 0.33 : maxLabelLength;
                  if (!textOverflowOption) {
                    commonTextOverflow = "ellipsis";
                  }
                }
                this.labelAlign = labelOptions.align || this.autoLabelAlign(this.labelRotation);
                if (this.labelAlign) {
                  attr.align = this.labelAlign;
                }
                tickPositions.forEach(function(pos2) {
                  var tick = ticks[pos2], label2 = tick && tick.label, widthOption = labelStyleOptions.width, css = {};
                  if (label2) {
                    label2.attr(attr);
                    if (tick.shortenLabel) {
                      tick.shortenLabel();
                    } else if (commonWidth && !widthOption && // Setting width in this case messes with the bounding box
                    // (#7975)
                    labelStyleOptions.whiteSpace !== "nowrap" && // Speed optimizing, #7656
                    (commonWidth < label2.textPxLength || // Resetting CSS, #4928
                    label2.element.tagName === "SPAN")) {
                      css.width = commonWidth + "px";
                      if (!textOverflowOption) {
                        css.textOverflow = label2.specificTextOverflow || commonTextOverflow;
                      }
                      label2.css(css);
                    } else if (label2.styles && label2.styles.width && !css.width && !widthOption) {
                      label2.css({ width: null });
                    }
                    delete label2.specificTextOverflow;
                    tick.rotation = attr.rotation;
                  }
                }, this);
                this.tickRotCorr = renderer.rotCorr(labelMetrics.b, this.labelRotation || 0, this.side !== 0);
              };
              Axis2.prototype.hasData = function() {
                return this.series.some(function(s) {
                  return s.hasData();
                }) || this.options.showEmpty && defined(this.min) && defined(this.max);
              };
              Axis2.prototype.addTitle = function(display) {
                var axis = this, renderer = axis.chart.renderer, horiz = axis.horiz, opposite = axis.opposite, options = axis.options, axisTitleOptions = options.title, styledMode = axis.chart.styledMode;
                var textAlign;
                if (!axis.axisTitle) {
                  textAlign = axisTitleOptions.textAlign;
                  if (!textAlign) {
                    textAlign = (horiz ? {
                      low: "left",
                      middle: "center",
                      high: "right"
                    } : {
                      low: opposite ? "right" : "left",
                      middle: "center",
                      high: opposite ? "left" : "right"
                    })[axisTitleOptions.align];
                  }
                  axis.axisTitle = renderer.text(axisTitleOptions.text || "", 0, 0, axisTitleOptions.useHTML).attr({
                    zIndex: 7,
                    rotation: axisTitleOptions.rotation,
                    align: textAlign
                  }).addClass("highcharts-axis-title");
                  if (!styledMode) {
                    axis.axisTitle.css(merge(axisTitleOptions.style));
                  }
                  axis.axisTitle.add(axis.axisGroup);
                  axis.axisTitle.isNew = true;
                }
                if (!styledMode && !axisTitleOptions.style.width && !axis.isRadial) {
                  axis.axisTitle.css({
                    width: axis.len + "px"
                  });
                }
                axis.axisTitle[display ? "show" : "hide"](display);
              };
              Axis2.prototype.generateTick = function(pos) {
                var axis = this, ticks = axis.ticks;
                if (!ticks[pos]) {
                  ticks[pos] = new Tick(axis, pos);
                } else {
                  ticks[pos].addLabel();
                }
              };
              Axis2.prototype.getOffset = function() {
                var _this = this;
                var axis = this, chart = axis.chart, horiz = axis.horiz, options = axis.options, side = axis.side, ticks = axis.ticks, tickPositions = axis.tickPositions, coll = axis.coll, axisParent = axis.axisParent, renderer = chart.renderer, invertedSide = chart.inverted && !axis.isZAxis ? [1, 0, 3, 2][side] : side, hasData = axis.hasData(), axisTitleOptions = options.title, labelOptions = options.labels, axisOffset = chart.axisOffset, clipOffset = chart.clipOffset, directionFactor = [-1, 1, 1, -1][side], className = options.className;
                var showAxis, titleOffset = 0, titleOffsetOption, titleMargin = 0, labelOffset = 0, labelOffsetPadded, lineHeightCorrection;
                axis.showAxis = showAxis = hasData || options.showEmpty;
                axis.staggerLines = axis.horiz && labelOptions.staggerLines || void 0;
                if (!axis.axisGroup) {
                  var createGroup = function(name, suffix, zIndex) {
                    return renderer.g(name).attr({ zIndex }).addClass("highcharts-".concat(coll.toLowerCase()).concat(suffix, " ") + (_this.isRadial ? "highcharts-radial-axis".concat(suffix, " ") : "") + (className || "")).add(axisParent);
                  };
                  axis.gridGroup = createGroup("grid", "-grid", options.gridZIndex);
                  axis.axisGroup = createGroup("axis", "", options.zIndex);
                  axis.labelGroup = createGroup("axis-labels", "-labels", labelOptions.zIndex);
                }
                if (hasData || axis.isLinked) {
                  tickPositions.forEach(function(pos) {
                    axis.generateTick(pos);
                  });
                  axis.renderUnsquish();
                  axis.reserveSpaceDefault = side === 0 || side === 2 || { 1: "left", 3: "right" }[side] === axis.labelAlign;
                  if (pick(labelOptions.reserveSpace, axis.labelAlign === "center" ? true : null, axis.reserveSpaceDefault)) {
                    tickPositions.forEach(function(pos) {
                      labelOffset = Math.max(ticks[pos].getLabelSize(), labelOffset);
                    });
                  }
                  if (axis.staggerLines) {
                    labelOffset *= axis.staggerLines;
                  }
                  axis.labelOffset = labelOffset * (axis.opposite ? -1 : 1);
                } else {
                  objectEach(ticks, function(tick, n) {
                    tick.destroy();
                    delete ticks[n];
                  });
                }
                if (axisTitleOptions && axisTitleOptions.text && axisTitleOptions.enabled !== false) {
                  axis.addTitle(showAxis);
                  if (showAxis && axisTitleOptions.reserveSpace !== false) {
                    axis.titleOffset = titleOffset = axis.axisTitle.getBBox()[horiz ? "height" : "width"];
                    titleOffsetOption = axisTitleOptions.offset;
                    titleMargin = defined(titleOffsetOption) ? 0 : pick(axisTitleOptions.margin, horiz ? 5 : 10);
                  }
                }
                axis.renderLine();
                axis.offset = directionFactor * pick(options.offset, axisOffset[side] ? axisOffset[side] + (options.margin || 0) : 0);
                axis.tickRotCorr = axis.tickRotCorr || { x: 0, y: 0 };
                if (side === 0) {
                  lineHeightCorrection = -axis.labelMetrics().h;
                } else if (side === 2) {
                  lineHeightCorrection = axis.tickRotCorr.y;
                } else {
                  lineHeightCorrection = 0;
                }
                labelOffsetPadded = Math.abs(labelOffset) + titleMargin;
                if (labelOffset) {
                  labelOffsetPadded -= lineHeightCorrection;
                  labelOffsetPadded += directionFactor * (horiz ? pick(labelOptions.y, axis.tickRotCorr.y + directionFactor * 8) : labelOptions.x);
                }
                axis.axisTitleMargin = pick(titleOffsetOption, labelOffsetPadded);
                if (axis.getMaxLabelDimensions) {
                  axis.maxLabelDimensions = axis.getMaxLabelDimensions(ticks, tickPositions);
                }
                if (coll !== "colorAxis") {
                  var tickSize = this.tickSize("tick");
                  axisOffset[side] = Math.max(
                    axisOffset[side],
                    (axis.axisTitleMargin || 0) + titleOffset + directionFactor * axis.offset,
                    labelOffsetPadded,
                    // #3027
                    tickPositions && tickPositions.length && tickSize ? tickSize[0] + directionFactor * axis.offset : 0
                    // #4866
                  );
                  var clip = !axis.axisLine || options.offset ? 0 : (
                    // #4308, #4371:
                    Math.floor(axis.axisLine.strokeWidth() / 2) * 2
                  );
                  clipOffset[invertedSide] = Math.max(clipOffset[invertedSide], clip);
                }
                fireEvent(this, "afterGetOffset");
              };
              Axis2.prototype.getLinePath = function(lineWidth) {
                var chart = this.chart, opposite = this.opposite, offset = this.offset, horiz = this.horiz, lineLeft = this.left + (opposite ? this.width : 0) + offset, lineTop = chart.chartHeight - this.bottom - (opposite ? this.height : 0) + offset;
                if (opposite) {
                  lineWidth *= -1;
                }
                return chart.renderer.crispLine([
                  [
                    "M",
                    horiz ? this.left : lineLeft,
                    horiz ? lineTop : this.top
                  ],
                  [
                    "L",
                    horiz ? chart.chartWidth - this.right : lineLeft,
                    horiz ? lineTop : chart.chartHeight - this.bottom
                  ]
                ], lineWidth);
              };
              Axis2.prototype.renderLine = function() {
                if (!this.axisLine) {
                  this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup);
                  if (!this.chart.styledMode) {
                    this.axisLine.attr({
                      stroke: this.options.lineColor,
                      "stroke-width": this.options.lineWidth,
                      zIndex: 7
                    });
                  }
                }
              };
              Axis2.prototype.getTitlePosition = function() {
                var horiz = this.horiz, axisLeft = this.left, axisTop = this.top, axisLength = this.len, axisTitleOptions = this.options.title, margin = horiz ? axisLeft : axisTop, opposite = this.opposite, offset = this.offset, xOption = axisTitleOptions.x, yOption = axisTitleOptions.y, axisTitle = this.axisTitle, fontMetrics = this.chart.renderer.fontMetrics(
                  axisTitleOptions.style.fontSize,
                  axisTitle
                ), textHeightOvershoot = axisTitle ? Math.max(axisTitle.getBBox(false, 0).height - fontMetrics.h - 1, 0) : 0, alongAxis = {
                  low: margin + (horiz ? 0 : axisLength),
                  middle: margin + axisLength / 2,
                  high: margin + (horiz ? axisLength : 0)
                }[axisTitleOptions.align], offAxis = (horiz ? axisTop + this.height : axisLeft) + (horiz ? 1 : -1) * // horizontal axis reverses the margin
                (opposite ? -1 : 1) * // so does opposite axes
                (this.axisTitleMargin || 0) + [
                  -textHeightOvershoot,
                  textHeightOvershoot,
                  fontMetrics.f,
                  -textHeightOvershoot
                  // left
                ][this.side], titlePosition = {
                  x: horiz ? alongAxis + xOption : offAxis + (opposite ? this.width : 0) + offset + xOption,
                  y: horiz ? offAxis + yOption - (opposite ? this.height : 0) + offset : alongAxis + yOption
                };
                fireEvent(this, "afterGetTitlePosition", { titlePosition });
                return titlePosition;
              };
              Axis2.prototype.renderMinorTick = function(pos, slideIn) {
                var axis = this;
                var minorTicks = axis.minorTicks;
                if (!minorTicks[pos]) {
                  minorTicks[pos] = new Tick(axis, pos, "minor");
                }
                if (slideIn && minorTicks[pos].isNew) {
                  minorTicks[pos].render(null, true);
                }
                minorTicks[pos].render(null, false, 1);
              };
              Axis2.prototype.renderTick = function(pos, i, slideIn) {
                var axis = this, isLinked = axis.isLinked, ticks = axis.ticks;
                if (!isLinked || pos >= axis.min && pos <= axis.max || axis.grid && axis.grid.isColumn) {
                  if (!ticks[pos]) {
                    ticks[pos] = new Tick(axis, pos);
                  }
                  if (slideIn && ticks[pos].isNew) {
                    ticks[pos].render(i, true, -1);
                  }
                  ticks[pos].render(i);
                }
              };
              Axis2.prototype.render = function() {
                var axis = this, chart = axis.chart, log = axis.logarithmic, renderer = chart.renderer, options = axis.options, isLinked = axis.isLinked, tickPositions = axis.tickPositions, axisTitle = axis.axisTitle, ticks = axis.ticks, minorTicks = axis.minorTicks, alternateBands = axis.alternateBands, stackLabelOptions = options.stackLabels, alternateGridColor = options.alternateGridColor, tickmarkOffset = axis.tickmarkOffset, axisLine = axis.axisLine, showAxis = axis.showAxis, animation = animObject(renderer.globalAnimation);
                var from, to;
                axis.labelEdge.length = 0;
                axis.overlap = false;
                [ticks, minorTicks, alternateBands].forEach(function(coll) {
                  objectEach(coll, function(tick) {
                    tick.isActive = false;
                  });
                });
                if (axis.hasData() || isLinked) {
                  var slideInTicks_1 = axis.chart.hasRendered && axis.old && isNumber(axis.old.min);
                  if (axis.minorTickInterval && !axis.categories) {
                    axis.getMinorTickPositions().forEach(function(pos) {
                      axis.renderMinorTick(pos, slideInTicks_1);
                    });
                  }
                  if (tickPositions.length) {
                    tickPositions.forEach(function(pos, i) {
                      axis.renderTick(pos, i, slideInTicks_1);
                    });
                    if (tickmarkOffset && (axis.min === 0 || axis.single)) {
                      if (!ticks[-1]) {
                        ticks[-1] = new Tick(axis, -1, null, true);
                      }
                      ticks[-1].render(-1);
                    }
                  }
                  if (alternateGridColor) {
                    tickPositions.forEach(function(pos, i) {
                      to = typeof tickPositions[i + 1] !== "undefined" ? tickPositions[i + 1] + tickmarkOffset : axis.max - tickmarkOffset;
                      if (i % 2 === 0 && pos < axis.max && to <= axis.max + (chart.polar ? -tickmarkOffset : tickmarkOffset)) {
                        if (!alternateBands[pos]) {
                          alternateBands[pos] = new H.PlotLineOrBand(axis);
                        }
                        from = pos + tickmarkOffset;
                        alternateBands[pos].options = {
                          from: log ? log.lin2log(from) : from,
                          to: log ? log.lin2log(to) : to,
                          color: alternateGridColor,
                          className: "highcharts-alternate-grid"
                        };
                        alternateBands[pos].render();
                        alternateBands[pos].isActive = true;
                      }
                    });
                  }
                  if (!axis._addedPlotLB) {
                    axis._addedPlotLB = true;
                    (options.plotLines || []).concat(options.plotBands || []).forEach(function(plotLineOptions) {
                      axis.addPlotBandOrLine(plotLineOptions);
                    });
                  }
                }
                [ticks, minorTicks, alternateBands].forEach(function(coll) {
                  var forDestruction = [], delay = animation.duration, destroyInactiveItems = function() {
                    var i = forDestruction.length;
                    while (i--) {
                      if (coll[forDestruction[i]] && !coll[forDestruction[i]].isActive) {
                        coll[forDestruction[i]].destroy();
                        delete coll[forDestruction[i]];
                      }
                    }
                  };
                  objectEach(coll, function(tick, pos) {
                    if (!tick.isActive) {
                      tick.render(pos, false, 0);
                      tick.isActive = false;
                      forDestruction.push(pos);
                    }
                  });
                  syncTimeout(destroyInactiveItems, coll === alternateBands || !chart.hasRendered || !delay ? 0 : delay);
                });
                if (axisLine) {
                  axisLine[axisLine.isPlaced ? "animate" : "attr"]({
                    d: this.getLinePath(axisLine.strokeWidth())
                  });
                  axisLine.isPlaced = true;
                  axisLine[showAxis ? "show" : "hide"](showAxis);
                }
                if (axisTitle && showAxis) {
                  var titleXy = axis.getTitlePosition();
                  axisTitle[axisTitle.isNew ? "attr" : "animate"](titleXy);
                  axisTitle.isNew = false;
                }
                if (stackLabelOptions && stackLabelOptions.enabled && axis.stacking) {
                  axis.stacking.renderStackTotals();
                }
                axis.old = {
                  len: axis.len,
                  max: axis.max,
                  min: axis.min,
                  transA: axis.transA,
                  userMax: axis.userMax,
                  userMin: axis.userMin
                };
                axis.isDirty = false;
                fireEvent(this, "afterRender");
              };
              Axis2.prototype.redraw = function() {
                if (this.visible) {
                  this.render();
                  this.plotLinesAndBands.forEach(function(plotLine) {
                    plotLine.render();
                  });
                }
                this.series.forEach(function(series) {
                  series.isDirty = true;
                });
              };
              Axis2.prototype.getKeepProps = function() {
                return this.keepProps || Axis2.keepProps;
              };
              Axis2.prototype.destroy = function(keepEvents) {
                var axis = this, plotLinesAndBands = axis.plotLinesAndBands, eventOptions = this.eventOptions;
                fireEvent(this, "destroy", { keepEvents });
                if (!keepEvents) {
                  removeEvent(axis);
                }
                [axis.ticks, axis.minorTicks, axis.alternateBands].forEach(function(coll) {
                  destroyObjectProperties(coll);
                });
                if (plotLinesAndBands) {
                  var i = plotLinesAndBands.length;
                  while (i--) {
                    plotLinesAndBands[i].destroy();
                  }
                }
                [
                  "axisLine",
                  "axisTitle",
                  "axisGroup",
                  "gridGroup",
                  "labelGroup",
                  "cross",
                  "scrollbar"
                ].forEach(function(prop) {
                  if (axis[prop]) {
                    axis[prop] = axis[prop].destroy();
                  }
                });
                for (var plotGroup in axis.plotLinesAndBandsGroups) {
                  axis.plotLinesAndBandsGroups[plotGroup] = axis.plotLinesAndBandsGroups[plotGroup].destroy();
                }
                objectEach(axis, function(val, key) {
                  if (axis.getKeepProps().indexOf(key) === -1) {
                    delete axis[key];
                  }
                });
                this.eventOptions = eventOptions;
              };
              Axis2.prototype.drawCrosshair = function(e, point) {
                var options = this.crosshair, snap = pick(
                  options && options.snap,
                  true
                ), chart = this.chart;
                var path, pos, categorized, graphic = this.cross, crossOptions;
                fireEvent(this, "drawCrosshair", { e, point });
                if (!e) {
                  e = this.cross && this.cross.e;
                }
                if (
                  // Disabled in options
                  !options || // Snap
                  (defined(point) || !snap) === false
                ) {
                  this.hideCrosshair();
                } else {
                  if (!snap) {
                    pos = e && (this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos);
                  } else if (defined(point)) {
                    pos = pick(this.coll !== "colorAxis" ? point.crosshairPos : (
                      // 3D axis extension
                      null
                    ), this.isXAxis ? point.plotX : this.len - point.plotY);
                  }
                  if (defined(pos)) {
                    crossOptions = {
                      // value, only used on radial
                      value: point && (this.isXAxis ? point.x : pick(point.stackY, point.y)),
                      translatedValue: pos
                    };
                    if (chart.polar) {
                      extend2(crossOptions, {
                        isCrosshair: true,
                        chartX: e && e.chartX,
                        chartY: e && e.chartY,
                        point
                      });
                    }
                    path = this.getPlotLinePath(crossOptions) || null;
                  }
                  if (!defined(path)) {
                    this.hideCrosshair();
                    return;
                  }
                  categorized = this.categories && !this.isRadial;
                  if (!graphic) {
                    this.cross = graphic = chart.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (categorized ? "category " : "thin ") + (options.className || "")).attr({
                      zIndex: pick(options.zIndex, 2)
                    }).add();
                    if (!chart.styledMode) {
                      graphic.attr({
                        stroke: options.color || (categorized ? Color2.parse(
                          "#ccd6eb"
                          /* Palette.highlightColor20 */
                        ).setOpacity(0.25).get() : "#cccccc"),
                        "stroke-width": pick(options.width, 1)
                      }).css({
                        "pointer-events": "none"
                      });
                      if (options.dashStyle) {
                        graphic.attr({
                          dashstyle: options.dashStyle
                        });
                      }
                    }
                  }
                  graphic.show().attr({
                    d: path
                  });
                  if (categorized && !options.width) {
                    graphic.attr({
                      "stroke-width": this.transA
                    });
                  }
                  this.cross.e = e;
                }
                fireEvent(this, "afterDrawCrosshair", { e, point });
              };
              Axis2.prototype.hideCrosshair = function() {
                if (this.cross) {
                  this.cross.hide();
                }
                fireEvent(this, "afterHideCrosshair");
              };
              Axis2.prototype.hasVerticalPanning = function() {
                var panningOptions = this.chart.options.chart.panning;
                return Boolean(panningOptions && panningOptions.enabled && // #14624
                /y/.test(panningOptions.type));
              };
              Axis2.prototype.validatePositiveValue = function(value) {
                return isNumber(value) && value > 0;
              };
              Axis2.prototype.update = function(options, redraw) {
                var chart = this.chart;
                options = merge(this.userOptions, options);
                this.destroy(true);
                this.init(chart, options);
                chart.isDirtyBox = true;
                if (pick(redraw, true)) {
                  chart.redraw();
                }
              };
              Axis2.prototype.remove = function(redraw) {
                var chart = this.chart, key = this.coll, axisSeries = this.series;
                var i = axisSeries.length;
                while (i--) {
                  if (axisSeries[i]) {
                    axisSeries[i].remove(false);
                  }
                }
                erase(chart.axes, this);
                erase(chart[key], this);
                chart[key].forEach(function(axis, i2) {
                  axis.options.index = axis.userOptions.index = i2;
                });
                this.destroy();
                chart.isDirtyBox = true;
                if (pick(redraw, true)) {
                  chart.redraw();
                }
              };
              Axis2.prototype.setTitle = function(titleOptions, redraw) {
                this.update({ title: titleOptions }, redraw);
              };
              Axis2.prototype.setCategories = function(categories, redraw) {
                this.update({ categories }, redraw);
              };
              Axis2.defaultOptions = AxisDefaults.defaultXAxisOptions;
              Axis2.keepProps = [
                "extKey",
                "hcEvents",
                "names",
                "series",
                "userMax",
                "userMin"
              ];
              return Axis2;
            }()
          );
          "";
          return Axis;
        });
        _registerModule(_modules, "Core/Axis/DateTimeAxis.js", [_modules["Core/Utilities.js"]], function(U) {
          var addEvent = U.addEvent, getMagnitude = U.getMagnitude, normalizeTickInterval = U.normalizeTickInterval, timeUnits = U.timeUnits;
          var DateTimeAxis;
          (function(DateTimeAxis2) {
            var composedClasses = [];
            function compose(AxisClass) {
              if (composedClasses.indexOf(AxisClass) === -1) {
                composedClasses.push(AxisClass);
                AxisClass.keepProps.push("dateTime");
                var axisProto = AxisClass.prototype;
                axisProto.getTimeTicks = getTimeTicks;
                addEvent(AxisClass, "init", onInit);
              }
              return AxisClass;
            }
            DateTimeAxis2.compose = compose;
            function getTimeTicks() {
              return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
            }
            function onInit(e) {
              var axis = this;
              var options = e.userOptions;
              if (options.type !== "datetime") {
                axis.dateTime = void 0;
                return;
              }
              if (!axis.dateTime) {
                axis.dateTime = new Additions(axis);
              }
            }
            var Additions = (
              /** @class */
              function() {
                function Additions2(axis) {
                  this.axis = axis;
                }
                Additions2.prototype.normalizeTimeTickInterval = function(tickInterval, unitsOption) {
                  var units = unitsOption || [
                    [
                      // unit name
                      "millisecond",
                      // allowed multiples
                      [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]
                    ],
                    [
                      "second",
                      [1, 2, 5, 10, 15, 30]
                    ],
                    [
                      "minute",
                      [1, 2, 5, 10, 15, 30]
                    ],
                    [
                      "hour",
                      [1, 2, 3, 4, 6, 8, 12]
                    ],
                    [
                      "day",
                      [1, 2]
                    ],
                    [
                      "week",
                      [1, 2]
                    ],
                    [
                      "month",
                      [1, 2, 3, 4, 6]
                    ],
                    [
                      "year",
                      null
                    ]
                  ];
                  var unit = units[units.length - 1], interval2 = timeUnits[unit[0]], multiples = unit[1], i;
                  for (i = 0; i < units.length; i++) {
                    unit = units[i];
                    interval2 = timeUnits[unit[0]];
                    multiples = unit[1];
                    if (units[i + 1]) {
                      var lessThan = (interval2 * multiples[multiples.length - 1] + timeUnits[units[i + 1][0]]) / 2;
                      if (tickInterval <= lessThan) {
                        break;
                      }
                    }
                  }
                  if (interval2 === timeUnits.year && tickInterval < 5 * interval2) {
                    multiples = [1, 2, 5];
                  }
                  var count = normalizeTickInterval(
                    tickInterval / interval2,
                    multiples,
                    unit[0] === "year" ? (
                      // #1913, #2360
                      Math.max(getMagnitude(tickInterval / interval2), 1)
                    ) : 1
                  );
                  return {
                    unitRange: interval2,
                    count,
                    unitName: unit[0]
                  };
                };
                Additions2.prototype.getXDateFormat = function(x, dateTimeLabelFormats) {
                  var axis = this.axis, time = axis.chart.time;
                  return axis.closestPointRange ? time.getDateFormat(axis.closestPointRange, x, axis.options.startOfWeek, dateTimeLabelFormats) || // #2546, 2581
                  time.resolveDTLFormat(dateTimeLabelFormats.year).main : time.resolveDTLFormat(dateTimeLabelFormats.day).main;
                };
                return Additions2;
              }()
            );
            DateTimeAxis2.Additions = Additions;
          })(DateTimeAxis || (DateTimeAxis = {}));
          return DateTimeAxis;
        });
        _registerModule(_modules, "Core/Axis/LogarithmicAxis.js", [_modules["Core/Utilities.js"]], function(U) {
          var addEvent = U.addEvent, getMagnitude = U.getMagnitude, normalizeTickInterval = U.normalizeTickInterval, pick = U.pick;
          var LogarithmicAxis;
          (function(LogarithmicAxis2) {
            var composedClasses = [];
            function compose(AxisClass) {
              if (composedClasses.indexOf(AxisClass) === -1) {
                composedClasses.push(AxisClass);
                AxisClass.keepProps.push("logarithmic");
                addEvent(AxisClass, "init", onInit);
                addEvent(AxisClass, "afterInit", onAfterInit);
              }
              return AxisClass;
            }
            LogarithmicAxis2.compose = compose;
            function onInit(e) {
              var axis = this;
              var options = e.userOptions;
              var logarithmic = axis.logarithmic;
              if (options.type !== "logarithmic") {
                axis.logarithmic = void 0;
              } else {
                if (!logarithmic) {
                  logarithmic = axis.logarithmic = new Additions(axis);
                }
              }
            }
            function onAfterInit() {
              var axis = this;
              var log = axis.logarithmic;
              if (log) {
                axis.lin2val = function(num) {
                  return log.lin2log(num);
                };
                axis.val2lin = function(num) {
                  return log.log2lin(num);
                };
              }
            }
            var Additions = (
              /** @class */
              function() {
                function Additions2(axis) {
                  this.axis = axis;
                }
                Additions2.prototype.getLogTickPositions = function(interval2, min2, max2, minor) {
                  var log = this;
                  var axis = log.axis;
                  var axisLength = axis.len;
                  var options = axis.options;
                  var positions = [];
                  if (!minor) {
                    log.minorAutoInterval = void 0;
                  }
                  if (interval2 >= 0.5) {
                    interval2 = Math.round(interval2);
                    positions = axis.getLinearTickPositions(interval2, min2, max2);
                  } else if (interval2 >= 0.08) {
                    var roundedMin = Math.floor(min2);
                    var intermediate = void 0, i = void 0, j = void 0, len = void 0, pos = void 0, lastPos = void 0, break2 = void 0;
                    if (interval2 > 0.3) {
                      intermediate = [1, 2, 4];
                    } else if (interval2 > 0.15) {
                      intermediate = [1, 2, 4, 6, 8];
                    } else {
                      intermediate = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                    }
                    for (i = roundedMin; i < max2 + 1 && !break2; i++) {
                      len = intermediate.length;
                      for (j = 0; j < len && !break2; j++) {
                        pos = log.log2lin(log.lin2log(i) * intermediate[j]);
                        if (pos > min2 && (!minor || lastPos <= max2) && typeof lastPos !== "undefined") {
                          positions.push(lastPos);
                        }
                        if (lastPos > max2) {
                          break2 = true;
                        }
                        lastPos = pos;
                      }
                    }
                  } else {
                    var realMin = log.lin2log(min2), realMax = log.lin2log(max2), tickIntervalOption = minor ? axis.getMinorTickInterval() : options.tickInterval, filteredTickIntervalOption = tickIntervalOption === "auto" ? null : tickIntervalOption, tickPixelIntervalOption = options.tickPixelInterval / (minor ? 5 : 1), totalPixelLength = minor ? axisLength / axis.tickPositions.length : axisLength;
                    interval2 = pick(filteredTickIntervalOption, log.minorAutoInterval, (realMax - realMin) * tickPixelIntervalOption / (totalPixelLength || 1));
                    interval2 = normalizeTickInterval(interval2);
                    positions = axis.getLinearTickPositions(interval2, realMin, realMax).map(log.log2lin);
                    if (!minor) {
                      log.minorAutoInterval = interval2 / 5;
                    }
                  }
                  if (!minor) {
                    axis.tickInterval = interval2;
                  }
                  return positions;
                };
                Additions2.prototype.lin2log = function(num) {
                  return Math.pow(10, num);
                };
                Additions2.prototype.log2lin = function(num) {
                  return Math.log(num) / Math.LN10;
                };
                return Additions2;
              }()
            );
            LogarithmicAxis2.Additions = Additions;
          })(LogarithmicAxis || (LogarithmicAxis = {}));
          return LogarithmicAxis;
        });
        _registerModule(_modules, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [_modules["Core/Utilities.js"]], function(U) {
          var erase = U.erase, extend2 = U.extend, isNumber = U.isNumber;
          var PlotLineOrBandAxis;
          (function(PlotLineOrBandAxis2) {
            var composedClasses = [];
            var PlotLineOrBandClass;
            function compose(PlotLineOrBandType, AxisClass) {
              if (!PlotLineOrBandClass) {
                PlotLineOrBandClass = PlotLineOrBandType;
              }
              if (composedClasses.indexOf(AxisClass) === -1) {
                composedClasses.push(AxisClass);
                extend2(AxisClass.prototype, Additions.prototype);
              }
              return AxisClass;
            }
            PlotLineOrBandAxis2.compose = compose;
            var Additions = (
              /** @class */
              function() {
                function Additions2() {
                }
                Additions2.prototype.getPlotBandPath = function(from, to, options) {
                  if (options === void 0) {
                    options = this.options;
                  }
                  var toPath = this.getPlotLinePath({
                    value: to,
                    force: true,
                    acrossPanes: options.acrossPanes
                  }), result = [], horiz = this.horiz, outside = !isNumber(this.min) || !isNumber(this.max) || from < this.min && to < this.min || from > this.max && to > this.max;
                  var path = this.getPlotLinePath({
                    value: from,
                    force: true,
                    acrossPanes: options.acrossPanes
                  }), i, plus = 1, isFlat;
                  if (path && toPath) {
                    if (outside) {
                      isFlat = path.toString() === toPath.toString();
                      plus = 0;
                    }
                    for (i = 0; i < path.length; i += 2) {
                      var pathStart = path[i], pathEnd = path[i + 1], toPathStart = toPath[i], toPathEnd = toPath[i + 1];
                      if ((pathStart[0] === "M" || pathStart[0] === "L") && (pathEnd[0] === "M" || pathEnd[0] === "L") && (toPathStart[0] === "M" || toPathStart[0] === "L") && (toPathEnd[0] === "M" || toPathEnd[0] === "L")) {
                        if (horiz && toPathStart[1] === pathStart[1]) {
                          toPathStart[1] += plus;
                          toPathEnd[1] += plus;
                        } else if (!horiz && toPathStart[2] === pathStart[2]) {
                          toPathStart[2] += plus;
                          toPathEnd[2] += plus;
                        }
                        result.push(["M", pathStart[1], pathStart[2]], ["L", pathEnd[1], pathEnd[2]], ["L", toPathEnd[1], toPathEnd[2]], ["L", toPathStart[1], toPathStart[2]], ["Z"]);
                      }
                      result.isFlat = isFlat;
                    }
                  } else {
                    path = null;
                  }
                  return result;
                };
                Additions2.prototype.addPlotBand = function(options) {
                  return this.addPlotBandOrLine(options, "plotBands");
                };
                Additions2.prototype.addPlotLine = function(options) {
                  return this.addPlotBandOrLine(options, "plotLines");
                };
                Additions2.prototype.addPlotBandOrLine = function(options, coll) {
                  var _this = this;
                  var userOptions = this.userOptions;
                  var obj = new PlotLineOrBandClass(
                    this,
                    options
                  );
                  if (this.visible) {
                    obj = obj.render();
                  }
                  if (obj) {
                    if (!this._addedPlotLB) {
                      this._addedPlotLB = true;
                      (userOptions.plotLines || []).concat(userOptions.plotBands || []).forEach(function(plotLineOptions) {
                        _this.addPlotBandOrLine(plotLineOptions);
                      });
                    }
                    if (coll) {
                      var updatedOptions = userOptions[coll] || [];
                      updatedOptions.push(options);
                      userOptions[coll] = updatedOptions;
                    }
                    this.plotLinesAndBands.push(obj);
                  }
                  return obj;
                };
                Additions2.prototype.removePlotBandOrLine = function(id2) {
                  var plotLinesAndBands = this.plotLinesAndBands, options = this.options, userOptions = this.userOptions;
                  if (plotLinesAndBands) {
                    var i_1 = plotLinesAndBands.length;
                    while (i_1--) {
                      if (plotLinesAndBands[i_1].id === id2) {
                        plotLinesAndBands[i_1].destroy();
                      }
                    }
                    [
                      options.plotLines || [],
                      userOptions.plotLines || [],
                      options.plotBands || [],
                      userOptions.plotBands || []
                    ].forEach(function(arr) {
                      i_1 = arr.length;
                      while (i_1--) {
                        if ((arr[i_1] || {}).id === id2) {
                          erase(arr, arr[i_1]);
                        }
                      }
                    });
                  }
                };
                Additions2.prototype.removePlotBand = function(id2) {
                  this.removePlotBandOrLine(id2);
                };
                Additions2.prototype.removePlotLine = function(id2) {
                  this.removePlotBandOrLine(id2);
                };
                return Additions2;
              }()
            );
          })(PlotLineOrBandAxis || (PlotLineOrBandAxis = {}));
          return PlotLineOrBandAxis;
        });
        _registerModule(_modules, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [_modules["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], _modules["Core/Utilities.js"]], function(PlotLineOrBandAxis, U) {
          var arrayMax = U.arrayMax, arrayMin = U.arrayMin, defined = U.defined, destroyObjectProperties = U.destroyObjectProperties, erase = U.erase, fireEvent = U.fireEvent, merge = U.merge, objectEach = U.objectEach, pick = U.pick;
          var PlotLineOrBand = (
            /** @class */
            function() {
              function PlotLineOrBand2(axis, options) {
                this.axis = axis;
                if (options) {
                  this.options = options;
                  this.id = options.id;
                }
              }
              PlotLineOrBand2.compose = function(AxisClass) {
                return PlotLineOrBandAxis.compose(PlotLineOrBand2, AxisClass);
              };
              PlotLineOrBand2.prototype.render = function() {
                fireEvent(this, "render");
                var plotLine = this, axis = plotLine.axis, horiz = axis.horiz, log = axis.logarithmic, options = plotLine.options, color2 = options.color, zIndex = pick(options.zIndex, 0), events = options.events, groupAttribs = {}, renderer = axis.chart.renderer;
                var optionsLabel = options.label, label = plotLine.label, to = options.to, from = options.from, value = options.value, svgElem = plotLine.svgElem, path = [], group;
                var isBand = defined(from) && defined(to), isLine = defined(value), isNew = !svgElem, attribs = {
                  "class": "highcharts-plot-" + (isBand ? "band " : "line ") + (options.className || "")
                };
                var groupName = isBand ? "bands" : "lines";
                if (log) {
                  from = log.log2lin(from);
                  to = log.log2lin(to);
                  value = log.log2lin(value);
                }
                if (!axis.chart.styledMode) {
                  if (isLine) {
                    attribs.stroke = color2 || "#999999";
                    attribs["stroke-width"] = pick(options.width, 1);
                    if (options.dashStyle) {
                      attribs.dashstyle = options.dashStyle;
                    }
                  } else if (isBand) {
                    attribs.fill = color2 || "#e6ebf5";
                    if (options.borderWidth) {
                      attribs.stroke = options.borderColor;
                      attribs["stroke-width"] = options.borderWidth;
                    }
                  }
                }
                groupAttribs.zIndex = zIndex;
                groupName += "-" + zIndex;
                group = axis.plotLinesAndBandsGroups[groupName];
                if (!group) {
                  axis.plotLinesAndBandsGroups[groupName] = group = renderer.g("plot-" + groupName).attr(groupAttribs).add();
                }
                if (isNew) {
                  plotLine.svgElem = svgElem = renderer.path().attr(attribs).add(group);
                }
                if (isLine) {
                  path = axis.getPlotLinePath({
                    value,
                    lineWidth: svgElem.strokeWidth(),
                    acrossPanes: options.acrossPanes
                  });
                } else if (isBand) {
                  path = axis.getPlotBandPath(from, to, options);
                } else {
                  return;
                }
                if (!plotLine.eventsAdded && events) {
                  objectEach(events, function(event, eventType) {
                    svgElem.on(eventType, function(e) {
                      events[eventType].apply(plotLine, [e]);
                    });
                  });
                  plotLine.eventsAdded = true;
                }
                if ((isNew || !svgElem.d) && path && path.length) {
                  svgElem.attr({ d: path });
                } else if (svgElem) {
                  if (path) {
                    svgElem.show();
                    svgElem.animate({ d: path });
                  } else if (svgElem.d) {
                    svgElem.hide();
                    if (label) {
                      plotLine.label = label = label.destroy();
                    }
                  }
                }
                if (optionsLabel && (defined(optionsLabel.text) || defined(optionsLabel.formatter)) && path && path.length && axis.width > 0 && axis.height > 0 && !path.isFlat) {
                  optionsLabel = merge({
                    align: horiz && isBand && "center",
                    x: horiz ? !isBand && 4 : 10,
                    verticalAlign: !horiz && isBand && "middle",
                    y: horiz ? isBand ? 16 : 10 : isBand ? 6 : -4,
                    rotation: horiz && !isBand && 90
                  }, optionsLabel);
                  this.renderLabel(optionsLabel, path, isBand, zIndex);
                } else if (label) {
                  label.hide();
                }
                return plotLine;
              };
              PlotLineOrBand2.prototype.renderLabel = function(optionsLabel, path, isBand, zIndex) {
                var plotLine = this, axis = plotLine.axis, renderer = axis.chart.renderer;
                var label = plotLine.label;
                if (!label) {
                  plotLine.label = label = renderer.text(this.getLabelText(optionsLabel), 0, 0, optionsLabel.useHTML).attr({
                    align: optionsLabel.textAlign || optionsLabel.align,
                    rotation: optionsLabel.rotation,
                    "class": "highcharts-plot-" + (isBand ? "band" : "line") + "-label " + (optionsLabel.className || ""),
                    zIndex
                  }).add();
                  if (!axis.chart.styledMode) {
                    label.css(merge({
                      textOverflow: "ellipsis"
                    }, optionsLabel.style));
                  }
                }
                var xBounds = path.xBounds || [
                  path[0][1],
                  path[1][1],
                  isBand ? path[2][1] : path[0][1]
                ];
                var yBounds = path.yBounds || [
                  path[0][2],
                  path[1][2],
                  isBand ? path[2][2] : path[0][2]
                ];
                var x = arrayMin(xBounds);
                var y = arrayMin(yBounds);
                label.align(optionsLabel, false, {
                  x,
                  y,
                  width: arrayMax(xBounds) - x,
                  height: arrayMax(yBounds) - y
                });
                if (!label.alignValue || label.alignValue === "left") {
                  var width = optionsLabel.clip ? axis.width : axis.chart.chartWidth;
                  label.css({
                    width: (label.rotation === 90 ? axis.height - (label.alignAttr.y - axis.top) : width - (label.alignAttr.x - axis.left)) + "px"
                  });
                }
                label.show(true);
              };
              PlotLineOrBand2.prototype.getLabelText = function(optionsLabel) {
                return defined(optionsLabel.formatter) ? optionsLabel.formatter.call(this) : optionsLabel.text;
              };
              PlotLineOrBand2.prototype.destroy = function() {
                erase(this.axis.plotLinesAndBands, this);
                delete this.axis;
                destroyObjectProperties(this);
              };
              return PlotLineOrBand2;
            }()
          );
          "";
          "";
          return PlotLineOrBand;
        });
        _registerModule(_modules, "Core/Tooltip.js", [_modules["Core/FormatUtilities.js"], _modules["Core/Globals.js"], _modules["Core/Renderer/RendererUtilities.js"], _modules["Core/Renderer/RendererRegistry.js"], _modules["Core/Utilities.js"]], function(F, H, R, RendererRegistry, U) {
          var format3 = F.format;
          var doc = H.doc;
          var distribute = R.distribute;
          var addEvent = U.addEvent, clamp = U.clamp, css = U.css, defined = U.defined, discardElement = U.discardElement, extend2 = U.extend, fireEvent = U.fireEvent, isArray = U.isArray, isNumber = U.isNumber, isString = U.isString, merge = U.merge, pick = U.pick, splat = U.splat, syncTimeout = U.syncTimeout;
          var Tooltip = (
            /** @class */
            function() {
              function Tooltip2(chart, options) {
                this.allowShared = true;
                this.container = void 0;
                this.crosshairs = [];
                this.distance = 0;
                this.isHidden = true;
                this.isSticky = false;
                this.now = {};
                this.options = {};
                this.outside = false;
                this.chart = chart;
                this.init(chart, options);
              }
              Tooltip2.prototype.applyFilter = function() {
                var chart = this.chart;
                chart.renderer.definition({
                  tagName: "filter",
                  attributes: {
                    id: "drop-shadow-" + chart.index,
                    opacity: 0.5
                  },
                  children: [{
                    tagName: "feGaussianBlur",
                    attributes: {
                      "in": "SourceAlpha",
                      stdDeviation: 1
                    }
                  }, {
                    tagName: "feOffset",
                    attributes: {
                      dx: 1,
                      dy: 1
                    }
                  }, {
                    tagName: "feComponentTransfer",
                    children: [{
                      tagName: "feFuncA",
                      attributes: {
                        type: "linear",
                        slope: 0.3
                      }
                    }]
                  }, {
                    tagName: "feMerge",
                    children: [{
                      tagName: "feMergeNode"
                    }, {
                      tagName: "feMergeNode",
                      attributes: {
                        "in": "SourceGraphic"
                      }
                    }]
                  }]
                });
              };
              Tooltip2.prototype.bodyFormatter = function(items) {
                return items.map(function(item) {
                  var tooltipOptions = item.series.tooltipOptions;
                  return (tooltipOptions[(item.point.formatPrefix || "point") + "Formatter"] || item.point.tooltipFormatter).call(item.point, tooltipOptions[(item.point.formatPrefix || "point") + "Format"] || "");
                });
              };
              Tooltip2.prototype.cleanSplit = function(force) {
                this.chart.series.forEach(function(series) {
                  var tt = series && series.tt;
                  if (tt) {
                    if (!tt.isActive || force) {
                      series.tt = tt.destroy();
                    } else {
                      tt.isActive = false;
                    }
                  }
                });
              };
              Tooltip2.prototype.defaultFormatter = function(tooltip) {
                var items = this.points || splat(this);
                var s;
                s = [tooltip.tooltipFooterHeaderFormatter(items[0])];
                s = s.concat(tooltip.bodyFormatter(items));
                s.push(tooltip.tooltipFooterHeaderFormatter(items[0], true));
                return s;
              };
              Tooltip2.prototype.destroy = function() {
                if (this.label) {
                  this.label = this.label.destroy();
                }
                if (this.split && this.tt) {
                  this.cleanSplit(true);
                  this.tt = this.tt.destroy();
                }
                if (this.renderer) {
                  this.renderer = this.renderer.destroy();
                  discardElement(this.container);
                }
                U.clearTimeout(this.hideTimer);
                U.clearTimeout(this.tooltipTimeout);
              };
              Tooltip2.prototype.getAnchor = function(points, mouseEvent) {
                var chart = this.chart, pointer = chart.pointer, inverted = chart.inverted, plotTop = chart.plotTop, plotLeft = chart.plotLeft;
                var ret;
                points = splat(points);
                if (points[0].series && points[0].series.yAxis && !points[0].series.yAxis.options.reversedStacks) {
                  points = points.slice().reverse();
                }
                if (this.followPointer && mouseEvent) {
                  if (typeof mouseEvent.chartX === "undefined") {
                    mouseEvent = pointer.normalize(mouseEvent);
                  }
                  ret = [
                    mouseEvent.chartX - plotLeft,
                    mouseEvent.chartY - plotTop
                  ];
                } else if (points[0].tooltipPos) {
                  ret = points[0].tooltipPos;
                } else {
                  var chartX_1 = 0, chartY_1 = 0;
                  points.forEach(function(point) {
                    var pos = point.pos(true);
                    if (pos) {
                      chartX_1 += pos[0];
                      chartY_1 += pos[1];
                    }
                  });
                  chartX_1 /= points.length;
                  chartY_1 /= points.length;
                  if (this.shared && points.length > 1 && mouseEvent) {
                    if (inverted) {
                      chartX_1 = mouseEvent.chartX;
                    } else {
                      chartY_1 = mouseEvent.chartY;
                    }
                  }
                  ret = [chartX_1 - plotLeft, chartY_1 - plotTop];
                }
                return ret.map(Math.round);
              };
              Tooltip2.prototype.getClassName = function(point, isSplit, isHeader) {
                var options = this.options, series = point.series, seriesOptions = series.options;
                return [
                  options.className,
                  "highcharts-label",
                  isHeader && "highcharts-tooltip-header",
                  isSplit ? "highcharts-tooltip-box" : "highcharts-tooltip",
                  !isHeader && "highcharts-color-" + pick(point.colorIndex, series.colorIndex),
                  seriesOptions && seriesOptions.className
                ].filter(isString).join(" ");
              };
              Tooltip2.prototype.getLabel = function() {
                var tooltip = this, styledMode = this.chart.styledMode, options = this.options, doSplit = this.split && this.allowShared, pointerEvents = options.style.pointerEvents || (this.shouldStickOnContact() ? "auto" : "none");
                var container, renderer = this.chart.renderer;
                if (tooltip.label) {
                  var wasSplit = !tooltip.label.hasClass("highcharts-label");
                  if (doSplit && !wasSplit || !doSplit && wasSplit) {
                    tooltip.destroy();
                  }
                }
                if (!this.label) {
                  if (this.outside) {
                    var chartStyle = this.chart.options.chart.style, Renderer = RendererRegistry.getRendererType();
                    this.container = container = H.doc.createElement("div");
                    container.className = "highcharts-tooltip-container";
                    css(container, {
                      position: "absolute",
                      top: "1px",
                      pointerEvents,
                      zIndex: Math.max(this.options.style.zIndex || 0, (chartStyle && chartStyle.zIndex || 0) + 3)
                    });
                    H.doc.body.appendChild(container);
                    this.renderer = renderer = new Renderer(container, 0, 0, chartStyle, void 0, void 0, renderer.styledMode);
                  }
                  if (doSplit) {
                    this.label = renderer.g("tooltip");
                  } else {
                    this.label = renderer.label("", 0, 0, options.shape, void 0, void 0, options.useHTML, void 0, "tooltip").attr({
                      padding: options.padding,
                      r: options.borderRadius
                    });
                    if (!styledMode) {
                      this.label.attr({
                        fill: options.backgroundColor,
                        "stroke-width": options.borderWidth
                      }).css(options.style).css({ pointerEvents }).shadow(options.shadow);
                    }
                  }
                  if (styledMode && options.shadow) {
                    this.applyFilter();
                    this.label.attr({
                      filter: "url(#drop-shadow-" + this.chart.index + ")"
                    });
                  }
                  if (tooltip.outside && !tooltip.split) {
                    var label_1 = this.label;
                    var xSetter_1 = label_1.xSetter, ySetter_1 = label_1.ySetter;
                    label_1.xSetter = function(value) {
                      xSetter_1.call(label_1, tooltip.distance);
                      container.style.left = value + "px";
                    };
                    label_1.ySetter = function(value) {
                      ySetter_1.call(label_1, tooltip.distance);
                      container.style.top = value + "px";
                    };
                  }
                  this.label.attr({ zIndex: 8 }).add();
                }
                return this.label;
              };
              Tooltip2.prototype.getPosition = function(boxWidth, boxHeight, point) {
                var chart = this.chart, distance = this.distance, ret = {}, h3 = chart.inverted && point.h || 0, outside = this.outside, outerWidth = outside ? (
                  // substract distance to prevent scrollbars
                  doc.documentElement.clientWidth - 2 * distance
                ) : chart.chartWidth, outerHeight = outside ? Math.max(
                  doc.body.scrollHeight,
                  doc.documentElement.scrollHeight,
                  doc.body.offsetHeight,
                  doc.documentElement.offsetHeight,
                  doc.documentElement.clientHeight
                ) : chart.chartHeight, chartPosition = chart.pointer.getChartPosition(), scaleX = function(val) {
                  return (
                    // eslint-disable-line no-confusing-arrow
                    val * chartPosition.scaleX
                  );
                }, scaleY = function(val) {
                  return (
                    // eslint-disable-line no-confusing-arrow
                    val * chartPosition.scaleY
                  );
                }, buildDimensionArray = function(dim) {
                  var isX = dim === "x";
                  return [
                    dim,
                    isX ? outerWidth : outerHeight,
                    isX ? boxWidth : boxHeight
                  ].concat(outside ? [
                    // If we are using tooltip.outside, we need to scale the
                    // position to match scaling of the container in case there
                    // is a transform/zoom on the container. #11329
                    isX ? scaleX(boxWidth) : scaleY(boxHeight),
                    isX ? chartPosition.left - distance + scaleX(point.plotX + chart.plotLeft) : chartPosition.top - distance + scaleY(point.plotY + chart.plotTop),
                    0,
                    isX ? outerWidth : outerHeight
                  ] : [
                    // Not outside, no scaling is needed
                    isX ? boxWidth : boxHeight,
                    isX ? point.plotX + chart.plotLeft : point.plotY + chart.plotTop,
                    isX ? chart.plotLeft : chart.plotTop,
                    isX ? chart.plotLeft + chart.plotWidth : chart.plotTop + chart.plotHeight
                  ]);
                };
                var first = buildDimensionArray("y"), second = buildDimensionArray("x"), swapped;
                var flipped = !!point.negative;
                if (!chart.polar && chart.hoverSeries && chart.hoverSeries.yAxis && chart.hoverSeries.yAxis.reversed) {
                  flipped = !flipped;
                }
                var preferFarSide = !this.followPointer && pick(point.ttBelow, !chart.inverted === flipped), firstDimension = function(dim, outerSize, innerSize, scaledInnerSize, point2, min2, max2) {
                  var scaledDist = outside ? dim === "y" ? scaleY(distance) : scaleX(distance) : distance, scaleDiff = (innerSize - scaledInnerSize) / 2, roomLeft = scaledInnerSize < point2 - distance, roomRight = point2 + distance + scaledInnerSize < outerSize, alignedLeft = point2 - scaledDist - innerSize + scaleDiff, alignedRight = point2 + scaledDist - scaleDiff;
                  if (preferFarSide && roomRight) {
                    ret[dim] = alignedRight;
                  } else if (!preferFarSide && roomLeft) {
                    ret[dim] = alignedLeft;
                  } else if (roomLeft) {
                    ret[dim] = Math.min(max2 - scaledInnerSize, alignedLeft - h3 < 0 ? alignedLeft : alignedLeft - h3);
                  } else if (roomRight) {
                    ret[dim] = Math.max(min2, alignedRight + h3 + innerSize > outerSize ? alignedRight : alignedRight + h3);
                  } else {
                    return false;
                  }
                }, secondDimension = function(dim, outerSize, innerSize, scaledInnerSize, point2) {
                  var retVal;
                  if (point2 < distance || point2 > outerSize - distance) {
                    retVal = false;
                  } else if (point2 < innerSize / 2) {
                    ret[dim] = 1;
                  } else if (point2 > outerSize - scaledInnerSize / 2) {
                    ret[dim] = outerSize - scaledInnerSize - 2;
                  } else {
                    ret[dim] = point2 - innerSize / 2;
                  }
                  return retVal;
                }, swap = function(count) {
                  var temp = first;
                  first = second;
                  second = temp;
                  swapped = count;
                }, run = function() {
                  if (firstDimension.apply(0, first) !== false) {
                    if (secondDimension.apply(0, second) === false && !swapped) {
                      swap(true);
                      run();
                    }
                  } else if (!swapped) {
                    swap(true);
                    run();
                  } else {
                    ret.x = ret.y = 0;
                  }
                };
                if (chart.inverted || this.len > 1) {
                  swap();
                }
                run();
                return ret;
              };
              Tooltip2.prototype.hide = function(delay) {
                var tooltip = this;
                U.clearTimeout(this.hideTimer);
                delay = pick(delay, this.options.hideDelay);
                if (!this.isHidden) {
                  this.hideTimer = syncTimeout(function() {
                    tooltip.getLabel().fadeOut(delay ? void 0 : delay);
                    tooltip.isHidden = true;
                  }, delay);
                }
              };
              Tooltip2.prototype.init = function(chart, options) {
                this.chart = chart;
                this.options = options;
                this.crosshairs = [];
                this.now = { x: 0, y: 0 };
                this.isHidden = true;
                this.split = options.split && !chart.inverted && !chart.polar;
                this.shared = options.shared || this.split;
                this.outside = pick(options.outside, Boolean(chart.scrollablePixelsX || chart.scrollablePixelsY));
              };
              Tooltip2.prototype.shouldStickOnContact = function(pointerEvent) {
                return !!(!this.followPointer && this.options.stickOnContact && (!pointerEvent || this.chart.pointer.inClass(pointerEvent.target, "highcharts-tooltip")));
              };
              Tooltip2.prototype.move = function(x, y, anchorX, anchorY) {
                var tooltip = this, now2 = tooltip.now, animate = tooltip.options.animation !== false && !tooltip.isHidden && // When we get close to the target position, abort animation and
                // land on the right place (#3056)
                (Math.abs(x - now2.x) > 1 || Math.abs(y - now2.y) > 1), skipAnchor = tooltip.followPointer || tooltip.len > 1;
                extend2(now2, {
                  x: animate ? (2 * now2.x + x) / 3 : x,
                  y: animate ? (now2.y + y) / 2 : y,
                  anchorX: skipAnchor ? void 0 : animate ? (2 * now2.anchorX + anchorX) / 3 : anchorX,
                  anchorY: skipAnchor ? void 0 : animate ? (now2.anchorY + anchorY) / 2 : anchorY
                });
                tooltip.getLabel().attr(now2);
                tooltip.drawTracker();
                if (animate) {
                  U.clearTimeout(this.tooltipTimeout);
                  this.tooltipTimeout = setTimeout(function() {
                    if (tooltip) {
                      tooltip.move(x, y, anchorX, anchorY);
                    }
                  }, 32);
                }
              };
              Tooltip2.prototype.refresh = function(pointOrPoints, mouseEvent) {
                var tooltip = this, chart = this.chart, options = tooltip.options, pointer = chart.pointer, points = splat(pointOrPoints), point = points[0], pointConfig = [], formatter = options.formatter || tooltip.defaultFormatter, shared = tooltip.shared, styledMode = chart.styledMode;
                var textConfig = {};
                if (!options.enabled || !point.series) {
                  return;
                }
                U.clearTimeout(this.hideTimer);
                tooltip.allowShared = !(!isArray(pointOrPoints) && pointOrPoints.series && pointOrPoints.series.noSharedTooltip);
                tooltip.followPointer = !tooltip.split && point.series.tooltipOptions.followPointer;
                var anchor = tooltip.getAnchor(
                  pointOrPoints,
                  mouseEvent
                ), x = anchor[0], y = anchor[1];
                if (shared && tooltip.allowShared) {
                  pointer.applyInactiveState(points);
                  points.forEach(function(item) {
                    item.setState("hover");
                    pointConfig.push(item.getLabelConfig());
                  });
                  textConfig = {
                    x: point.category,
                    y: point.y
                  };
                  textConfig.points = pointConfig;
                } else {
                  textConfig = point.getLabelConfig();
                }
                this.len = pointConfig.length;
                var text = formatter.call(
                  textConfig,
                  tooltip
                );
                var currentSeries = point.series;
                this.distance = pick(currentSeries.tooltipOptions.distance, 16);
                if (text === false) {
                  this.hide();
                } else {
                  if (tooltip.split && tooltip.allowShared) {
                    this.renderSplit(text, points);
                  } else {
                    var checkX_1 = x;
                    var checkY_1 = y;
                    if (mouseEvent && pointer.isDirectTouch) {
                      checkX_1 = mouseEvent.chartX - chart.plotLeft;
                      checkY_1 = mouseEvent.chartY - chart.plotTop;
                    }
                    if (chart.polar || currentSeries.options.clip === false || points.some(function(p) {
                      return pointer.isDirectTouch || // ##17929
                      p.series.shouldShowTooltip(checkX_1, checkY_1);
                    })) {
                      var label = tooltip.getLabel();
                      if (!options.style.width || styledMode) {
                        label.css({
                          width: chart.spacingBox.width + "px"
                        });
                      }
                      label.attr({
                        text: text && text.join ? text.join("") : text
                      });
                      label.addClass(tooltip.getClassName(point), true);
                      if (!styledMode) {
                        label.attr({
                          stroke: options.borderColor || point.color || currentSeries.color || "#666666"
                        });
                      }
                      tooltip.updatePosition({
                        plotX: x,
                        plotY: y,
                        negative: point.negative,
                        ttBelow: point.ttBelow,
                        h: anchor[2] || 0
                      });
                    } else {
                      tooltip.hide();
                      return;
                    }
                  }
                  if (tooltip.isHidden && tooltip.label) {
                    tooltip.label.attr({
                      opacity: 1
                    }).show();
                  }
                  tooltip.isHidden = false;
                }
                fireEvent(this, "refresh");
              };
              Tooltip2.prototype.renderSplit = function(labels, points) {
                var tooltip = this;
                var chart = tooltip.chart, _a = tooltip.chart, chartWidth = _a.chartWidth, chartHeight = _a.chartHeight, plotHeight = _a.plotHeight, plotLeft = _a.plotLeft, plotTop = _a.plotTop, pointer = _a.pointer, _b = _a.scrollablePixelsY, scrollablePixelsY = _b === void 0 ? 0 : _b, scrollablePixelsX = _a.scrollablePixelsX, _c = _a.scrollingContainer, _d = _c === void 0 ? {
                  scrollLeft: 0,
                  scrollTop: 0
                } : _c, scrollLeft = _d.scrollLeft, scrollTop = _d.scrollTop, styledMode = _a.styledMode, distance = tooltip.distance, options = tooltip.options, positioner = tooltip.options.positioner;
                var bounds = tooltip.outside && typeof scrollablePixelsX !== "number" ? doc.documentElement.getBoundingClientRect() : {
                  left: scrollLeft,
                  right: scrollLeft + chartWidth,
                  top: scrollTop,
                  bottom: scrollTop + chartHeight
                };
                var tooltipLabel = tooltip.getLabel();
                var ren = this.renderer || chart.renderer;
                var headerTop = Boolean(chart.xAxis[0] && chart.xAxis[0].opposite);
                var _e = pointer.getChartPosition(), chartLeft = _e.left, chartTop = _e.top;
                var distributionBoxTop = plotTop + scrollTop;
                var headerHeight = 0;
                var adjustedPlotHeight = plotHeight - scrollablePixelsY;
                function getAnchor(point) {
                  var isHeader = point.isHeader, _a2 = point.plotX, plotX = _a2 === void 0 ? 0 : _a2, _b2 = point.plotY, plotY = _b2 === void 0 ? 0 : _b2, series = point.series;
                  var anchorX;
                  var anchorY;
                  if (isHeader) {
                    anchorX = plotLeft + plotX;
                    anchorY = plotTop + plotHeight / 2;
                  } else {
                    var xAxis = series.xAxis, yAxis = series.yAxis;
                    anchorX = xAxis.pos + clamp(plotX, -distance, xAxis.len + distance);
                    if (series.shouldShowTooltip(0, yAxis.pos - plotTop + plotY, {
                      ignoreX: true
                    })) {
                      anchorY = yAxis.pos + plotY;
                    }
                  }
                  anchorX = clamp(anchorX, bounds.left - distance, bounds.right + distance);
                  return { anchorX, anchorY };
                }
                function defaultPositioner(anchorX, anchorY, isHeader, boxWidth, alignedLeft) {
                  if (alignedLeft === void 0) {
                    alignedLeft = true;
                  }
                  var y2;
                  var x2;
                  if (isHeader) {
                    y2 = headerTop ? 0 : adjustedPlotHeight;
                    x2 = clamp(anchorX - boxWidth / 2, bounds.left, bounds.right - boxWidth - (tooltip.outside ? chartLeft : 0));
                  } else {
                    y2 = anchorY - distributionBoxTop;
                    x2 = alignedLeft ? anchorX - boxWidth - distance : anchorX + distance;
                    x2 = clamp(x2, alignedLeft ? x2 : bounds.left, bounds.right);
                  }
                  return { x: x2, y: y2 };
                }
                function updatePartialTooltip(partialTooltip, point, str) {
                  var tt = partialTooltip;
                  var isHeader = point.isHeader, series = point.series;
                  if (!tt) {
                    var attribs = {
                      padding: options.padding,
                      r: options.borderRadius
                    };
                    if (!styledMode) {
                      attribs.fill = options.backgroundColor;
                      attribs["stroke-width"] = options.borderWidth;
                    }
                    tt = ren.label("", 0, 0, options[isHeader ? "headerShape" : "shape"], void 0, void 0, options.useHTML).addClass(tooltip.getClassName(point, true, isHeader)).attr(attribs).add(tooltipLabel);
                  }
                  tt.isActive = true;
                  tt.attr({
                    text: str
                  });
                  if (!styledMode) {
                    tt.css(options.style).shadow(options.shadow).attr({
                      stroke: options.borderColor || point.color || series.color || "#333333"
                    });
                  }
                  return tt;
                }
                if (isString(labels)) {
                  labels = [false, labels];
                }
                var boxes = labels.slice(
                  0,
                  points.length + 1
                ).reduce(function(boxes2, str, i) {
                  if (str !== false && str !== "") {
                    var point = points[i - 1] || {
                      // Item 0 is the header. Instead of this, we could also
                      // use the crosshair label
                      isHeader: true,
                      plotX: points[0].plotX,
                      plotY: plotHeight,
                      series: {}
                    };
                    var isHeader = point.isHeader;
                    var owner = isHeader ? tooltip : point.series;
                    var tt = owner.tt = updatePartialTooltip(
                      owner.tt,
                      point,
                      str.toString()
                    );
                    var bBox = tt.getBBox();
                    var boxWidth = bBox.width + tt.strokeWidth();
                    if (isHeader) {
                      headerHeight = bBox.height;
                      adjustedPlotHeight += headerHeight;
                      if (headerTop) {
                        distributionBoxTop -= headerHeight;
                      }
                    }
                    var _a2 = getAnchor(point), anchorX = _a2.anchorX, anchorY = _a2.anchorY;
                    if (typeof anchorY === "number") {
                      var size = bBox.height + 1;
                      var boxPosition = positioner ? positioner.call(
                        tooltip,
                        boxWidth,
                        size,
                        point
                      ) : defaultPositioner(
                        anchorX,
                        anchorY,
                        isHeader,
                        boxWidth
                      );
                      boxes2.push({
                        // 0-align to the top, 1-align to the bottom
                        align: positioner ? 0 : void 0,
                        anchorX,
                        anchorY,
                        boxWidth,
                        point,
                        rank: pick(boxPosition.rank, isHeader ? 1 : 0),
                        size,
                        target: boxPosition.y,
                        tt,
                        x: boxPosition.x
                      });
                    } else {
                      tt.isActive = false;
                    }
                  }
                  return boxes2;
                }, []);
                if (!positioner && boxes.some(function(box) {
                  var outside2 = tooltip.outside;
                  var boxStart = (outside2 ? chartLeft : 0) + box.anchorX;
                  if (boxStart < bounds.left && boxStart + box.boxWidth < bounds.right) {
                    return true;
                  }
                  return boxStart < chartLeft - bounds.left + box.boxWidth && bounds.right - boxStart > boxStart;
                })) {
                  boxes = boxes.map(function(box) {
                    var _a2 = defaultPositioner(
                      box.anchorX,
                      box.anchorY,
                      box.point.isHeader,
                      box.boxWidth,
                      false
                    ), x2 = _a2.x, y2 = _a2.y;
                    return extend2(box, {
                      target: y2,
                      x: x2
                    });
                  });
                }
                tooltip.cleanSplit();
                distribute(boxes, adjustedPlotHeight);
                var boxExtremes = {
                  left: chartLeft,
                  right: chartLeft
                };
                boxes.forEach(function(box) {
                  var x2 = box.x, boxWidth = box.boxWidth, isHeader = box.isHeader;
                  if (!isHeader) {
                    if (tooltip.outside && chartLeft + x2 < boxExtremes.left) {
                      boxExtremes.left = chartLeft + x2;
                    }
                    if (!isHeader && tooltip.outside && boxExtremes.left + boxWidth > boxExtremes.right) {
                      boxExtremes.right = chartLeft + x2;
                    }
                  }
                });
                boxes.forEach(function(box) {
                  var x2 = box.x, anchorX = box.anchorX, anchorY = box.anchorY, pos = box.pos, isHeader = box.point.isHeader;
                  var attributes = {
                    visibility: typeof pos === "undefined" ? "hidden" : "inherit",
                    x: x2,
                    /* NOTE: y should equal pos to be consistent with !split
                         * tooltip,
                    but is currently relative to plotTop. Is left as is
                         * to avoid breaking change. Remove distributionBoxTop to make
                         * it consistent.
                         */
                    y: (pos || 0) + distributionBoxTop,
                    anchorX,
                    anchorY
                  };
                  if (tooltip.outside && x2 < anchorX) {
                    var offset = chartLeft - boxExtremes.left;
                    if (offset > 0) {
                      if (!isHeader) {
                        attributes.x = x2 + offset;
                        attributes.anchorX = anchorX + offset;
                      }
                      if (isHeader) {
                        attributes.x = (boxExtremes.right - boxExtremes.left) / 2;
                        attributes.anchorX = anchorX + offset;
                      }
                    }
                  }
                  box.tt.attr(attributes);
                });
                var container = tooltip.container, outside = tooltip.outside, renderer = tooltip.renderer;
                if (outside && container && renderer) {
                  var _f = tooltipLabel.getBBox(), width = _f.width, height = _f.height, x = _f.x, y = _f.y;
                  renderer.setSize(width + x, height + y, false);
                  container.style.left = boxExtremes.left + "px";
                  container.style.top = chartTop + "px";
                }
              };
              Tooltip2.prototype.drawTracker = function() {
                var tooltip = this;
                if (!this.shouldStickOnContact()) {
                  if (tooltip.tracker) {
                    tooltip.tracker.destroy();
                  }
                  return;
                }
                var chart = tooltip.chart;
                var label = tooltip.label;
                var points = tooltip.shared ? chart.hoverPoints : chart.hoverPoint;
                if (!label || !points) {
                  return;
                }
                var box = {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
                var anchorPos = this.getAnchor(points);
                var labelBBox = label.getBBox();
                anchorPos[0] += chart.plotLeft - label.translateX;
                anchorPos[1] += chart.plotTop - label.translateY;
                box.x = Math.min(0, anchorPos[0]);
                box.y = Math.min(0, anchorPos[1]);
                box.width = anchorPos[0] < 0 ? Math.max(Math.abs(anchorPos[0]), labelBBox.width - anchorPos[0]) : Math.max(Math.abs(anchorPos[0]), labelBBox.width);
                box.height = anchorPos[1] < 0 ? Math.max(Math.abs(anchorPos[1]), labelBBox.height - Math.abs(anchorPos[1])) : Math.max(Math.abs(anchorPos[1]), labelBBox.height);
                if (tooltip.tracker) {
                  tooltip.tracker.attr(box);
                } else {
                  tooltip.tracker = label.renderer.rect(box).addClass("highcharts-tracker").add(label);
                  if (!chart.styledMode) {
                    tooltip.tracker.attr({
                      fill: "rgba(0,0,0,0)"
                    });
                  }
                }
              };
              Tooltip2.prototype.styledModeFormat = function(formatString) {
                return formatString.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex} {series.options.className} {point.options.className}"');
              };
              Tooltip2.prototype.tooltipFooterHeaderFormatter = function(labelConfig, isFooter) {
                var series = labelConfig.series, tooltipOptions = series.tooltipOptions, xAxis = series.xAxis, dateTime = xAxis && xAxis.dateTime, e = {
                  isFooter,
                  labelConfig
                };
                var xDateFormat = tooltipOptions.xDateFormat, formatString = tooltipOptions[isFooter ? "footerFormat" : "headerFormat"];
                fireEvent(this, "headerFormatter", e, function(e2) {
                  if (dateTime && !xDateFormat && isNumber(labelConfig.key)) {
                    xDateFormat = dateTime.getXDateFormat(labelConfig.key, tooltipOptions.dateTimeLabelFormats);
                  }
                  if (dateTime && xDateFormat) {
                    (labelConfig.point && labelConfig.point.tooltipDateKeys || ["key"]).forEach(function(key) {
                      formatString = formatString.replace("{point." + key + "}", "{point." + key + ":" + xDateFormat + "}");
                    });
                  }
                  if (series.chart.styledMode) {
                    formatString = this.styledModeFormat(formatString);
                  }
                  e2.text = format3(formatString, {
                    point: labelConfig,
                    series
                  }, this.chart);
                });
                return e.text;
              };
              Tooltip2.prototype.update = function(options) {
                this.destroy();
                merge(true, this.chart.options.tooltip.userOptions, options);
                this.init(this.chart, merge(true, this.options, options));
              };
              Tooltip2.prototype.updatePosition = function(point) {
                var _a = this, chart = _a.chart, distance = _a.distance, options = _a.options, pointer = chart.pointer, label = this.getLabel(), _b = pointer.getChartPosition(), left = _b.left, top = _b.top, scaleX = _b.scaleX, scaleY = _b.scaleY, pos = (options.positioner || this.getPosition).call(
                  this,
                  label.width,
                  label.height,
                  point
                );
                var anchorX = (point.plotX || 0) + chart.plotLeft, anchorY = (point.plotY || 0) + chart.plotTop, pad2;
                if (this.outside) {
                  if (options.positioner) {
                    pos.x += left - distance;
                    pos.y += top - distance;
                  }
                  pad2 = options.borderWidth + 2 * distance;
                  this.renderer.setSize(label.width + pad2, label.height + pad2, false);
                  if (scaleX !== 1 || scaleY !== 1) {
                    css(this.container, {
                      transform: "scale(".concat(scaleX, ", ").concat(scaleY, ")")
                    });
                    anchorX *= scaleX;
                    anchorY *= scaleY;
                  }
                  anchorX += left - pos.x;
                  anchorY += top - pos.y;
                }
                this.move(
                  Math.round(pos.x),
                  Math.round(pos.y || 0),
                  // can be undefined (#3977)
                  anchorX,
                  anchorY
                );
              };
              return Tooltip2;
            }()
          );
          "";
          return Tooltip;
        });
        _registerModule(_modules, "Core/Series/Point.js", [_modules["Core/Renderer/HTML/AST.js"], _modules["Core/Animation/AnimationUtilities.js"], _modules["Core/Defaults.js"], _modules["Core/FormatUtilities.js"], _modules["Core/Utilities.js"]], function(AST, A, D, F, U) {
          var animObject = A.animObject;
          var defaultOptions = D.defaultOptions;
          var format3 = F.format;
          var addEvent = U.addEvent, defined = U.defined, erase = U.erase, extend2 = U.extend, fireEvent = U.fireEvent, getNestedProperty = U.getNestedProperty, isArray = U.isArray, isFunction = U.isFunction, isNumber = U.isNumber, isObject = U.isObject, merge = U.merge, objectEach = U.objectEach, pick = U.pick, syncTimeout = U.syncTimeout, removeEvent = U.removeEvent, uniqueKey = U.uniqueKey;
          var Point = (
            /** @class */
            function() {
              function Point2() {
                this.category = void 0;
                this.formatPrefix = "point";
                this.id = void 0;
                this.isNull = false;
                this.name = void 0;
                this.options = void 0;
                this.percentage = void 0;
                this.selected = false;
                this.series = void 0;
                this.shapeArgs = void 0;
                this.total = void 0;
                this.visible = true;
                this.x = void 0;
              }
              Point2.prototype.animateBeforeDestroy = function() {
                var point = this, animateParams = {
                  x: point.startXPos,
                  opacity: 0
                }, graphicalProps = point.getGraphicalProps();
                graphicalProps.singular.forEach(function(prop) {
                  var isDataLabel = prop === "dataLabel";
                  point[prop] = point[prop].animate(isDataLabel ? {
                    x: point[prop].startXPos,
                    y: point[prop].startYPos,
                    opacity: 0
                  } : animateParams);
                });
                graphicalProps.plural.forEach(function(plural) {
                  point[plural].forEach(function(item) {
                    if (item.element) {
                      item.animate(extend2({ x: point.startXPos }, item.startYPos ? {
                        x: item.startXPos,
                        y: item.startYPos
                      } : {}));
                    }
                  });
                });
              };
              Point2.prototype.applyOptions = function(options, x) {
                var point = this, series = point.series, pointValKey = series.options.pointValKey || series.pointValKey;
                options = Point2.prototype.optionsToObject.call(this, options);
                extend2(point, options);
                point.options = point.options ? extend2(point.options, options) : options;
                if (options.group) {
                  delete point.group;
                }
                if (options.dataLabels) {
                  delete point.dataLabels;
                }
                if (pointValKey) {
                  point.y = Point2.prototype.getNestedProperty.call(point, pointValKey);
                }
                point.isNull = this.isValid && !this.isValid();
                point.formatPrefix = point.isNull ? "null" : "point";
                if (point.selected) {
                  point.state = "select";
                }
                if ("name" in point && typeof x === "undefined" && series.xAxis && series.xAxis.hasNames) {
                  point.x = series.xAxis.nameToX(point);
                }
                if (typeof point.x === "undefined" && series) {
                  if (typeof x === "undefined") {
                    point.x = series.autoIncrement();
                  } else {
                    point.x = x;
                  }
                } else if (isNumber(options.x) && series.options.relativeXValue) {
                  point.x = series.autoIncrement(options.x);
                }
                return point;
              };
              Point2.prototype.destroy = function() {
                var point = this, series = point.series, chart = series.chart, dataSorting = series.options.dataSorting, hoverPoints = chart.hoverPoints, globalAnimation = point.series.chart.renderer.globalAnimation, animation = animObject(globalAnimation);
                var prop;
                function destroyPoint() {
                  if (point.graphic || point.graphics || point.dataLabel || point.dataLabels) {
                    removeEvent(point);
                    point.destroyElements();
                  }
                  for (prop in point) {
                    point[prop] = null;
                  }
                }
                if (point.legendItem) {
                  chart.legend.destroyItem(point);
                }
                if (hoverPoints) {
                  point.setState();
                  erase(hoverPoints, point);
                  if (!hoverPoints.length) {
                    chart.hoverPoints = null;
                  }
                }
                if (point === chart.hoverPoint) {
                  point.onMouseOut();
                }
                if (!dataSorting || !dataSorting.enabled) {
                  destroyPoint();
                } else {
                  this.animateBeforeDestroy();
                  syncTimeout(destroyPoint, animation.duration);
                }
                chart.pointCount--;
              };
              Point2.prototype.destroyElements = function(kinds) {
                var point = this, props = point.getGraphicalProps(kinds);
                props.singular.forEach(function(prop) {
                  point[prop] = point[prop].destroy();
                });
                props.plural.forEach(function(plural) {
                  point[plural].forEach(function(item) {
                    if (item && item.element) {
                      item.destroy();
                    }
                  });
                  delete point[plural];
                });
              };
              Point2.prototype.firePointEvent = function(eventType, eventArgs, defaultFunction) {
                var point = this, series = this.series, seriesOptions = series.options;
                if (seriesOptions.point.events[eventType] || point.options && point.options.events && point.options.events[eventType]) {
                  point.importEvents();
                }
                if (eventType === "click" && seriesOptions.allowPointSelect) {
                  defaultFunction = function(event) {
                    if (point.select) {
                      point.select(null, event.ctrlKey || event.metaKey || event.shiftKey);
                    }
                  };
                }
                fireEvent(point, eventType, eventArgs, defaultFunction);
              };
              Point2.prototype.getClassName = function() {
                var point = this;
                return "highcharts-point" + (point.selected ? " highcharts-point-select" : "") + (point.negative ? " highcharts-negative" : "") + (point.isNull ? " highcharts-null-point" : "") + (typeof point.colorIndex !== "undefined" ? " highcharts-color-" + point.colorIndex : "") + (point.options.className ? " " + point.options.className : "") + (point.zone && point.zone.className ? " " + point.zone.className.replace("highcharts-negative", "") : "");
              };
              Point2.prototype.getGraphicalProps = function(kinds) {
                var point = this, props = [], graphicalProps = {
                  singular: [],
                  plural: []
                };
                var prop, i;
                kinds = kinds || { graphic: 1, dataLabel: 1 };
                if (kinds.graphic) {
                  props.push("graphic", "shadowGroup");
                }
                if (kinds.dataLabel) {
                  props.push("dataLabel", "dataLabelPath", "dataLabelUpper", "connector");
                }
                i = props.length;
                while (i--) {
                  prop = props[i];
                  if (point[prop]) {
                    graphicalProps.singular.push(prop);
                  }
                }
                [
                  "graphic",
                  "dataLabel",
                  "connector"
                ].forEach(function(prop2) {
                  var plural = prop2 + "s";
                  if (kinds[prop2] && point[plural]) {
                    graphicalProps.plural.push(plural);
                  }
                });
                return graphicalProps;
              };
              Point2.prototype.getLabelConfig = function() {
                return {
                  x: this.category,
                  y: this.y,
                  color: this.color,
                  colorIndex: this.colorIndex,
                  key: this.name || this.category,
                  series: this.series,
                  point: this,
                  percentage: this.percentage,
                  total: this.total || this.stackTotal
                };
              };
              Point2.prototype.getNestedProperty = function(key) {
                if (!key) {
                  return;
                }
                if (key.indexOf("custom.") === 0) {
                  return getNestedProperty(key, this.options);
                }
                return this[key];
              };
              Point2.prototype.getZone = function() {
                var series = this.series, zones = series.zones, zoneAxis = series.zoneAxis || "y";
                var zone, i = 0;
                zone = zones[i];
                while (this[zoneAxis] >= zone.value) {
                  zone = zones[++i];
                }
                if (!this.nonZonedColor) {
                  this.nonZonedColor = this.color;
                }
                if (zone && zone.color && !this.options.color) {
                  this.color = zone.color;
                } else {
                  this.color = this.nonZonedColor;
                }
                return zone;
              };
              Point2.prototype.hasNewShapeType = function() {
                var point = this;
                var oldShapeType = point.graphic && (point.graphic.symbolName || point.graphic.element.nodeName);
                return oldShapeType !== this.shapeType;
              };
              Point2.prototype.init = function(series, options, x) {
                this.series = series;
                this.applyOptions(options, x);
                this.id = defined(this.id) ? this.id : uniqueKey();
                this.resolveColor();
                series.chart.pointCount++;
                fireEvent(this, "afterInit");
                return this;
              };
              Point2.prototype.isValid = function() {
                return this.x !== null && isNumber(this.y);
              };
              Point2.prototype.optionsToObject = function(options) {
                var series = this.series, keys = series.options.keys, pointArrayMap = keys || series.pointArrayMap || ["y"], valueCount = pointArrayMap.length;
                var ret = {}, firstItemType, i = 0, j = 0;
                if (isNumber(options) || options === null) {
                  ret[pointArrayMap[0]] = options;
                } else if (isArray(options)) {
                  if (!keys && options.length > valueCount) {
                    firstItemType = typeof options[0];
                    if (firstItemType === "string") {
                      ret.name = options[0];
                    } else if (firstItemType === "number") {
                      ret.x = options[0];
                    }
                    i++;
                  }
                  while (j < valueCount) {
                    if (!keys || typeof options[i] !== "undefined") {
                      if (pointArrayMap[j].indexOf(".") > 0) {
                        Point2.prototype.setNestedProperty(ret, options[i], pointArrayMap[j]);
                      } else {
                        ret[pointArrayMap[j]] = options[i];
                      }
                    }
                    i++;
                    j++;
                  }
                } else if (typeof options === "object") {
                  ret = options;
                  if (options.dataLabels) {
                    series._hasPointLabels = true;
                  }
                  if (options.marker) {
                    series._hasPointMarkers = true;
                  }
                }
                return ret;
              };
              Point2.prototype.pos = function(chartCoordinates, plotY) {
                if (plotY === void 0) {
                  plotY = this.plotY;
                }
                var _a = this, plotX = _a.plotX, series = _a.series, chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis;
                var posX = 0, posY = 0;
                if (isNumber(plotX) && isNumber(plotY)) {
                  if (chartCoordinates) {
                    posX = xAxis ? xAxis.pos : chart.plotLeft;
                    posY = yAxis ? yAxis.pos : chart.plotTop;
                  }
                  return chart.inverted && xAxis && yAxis ? [yAxis.len - plotY + posY, xAxis.len - plotX + posX] : [plotX + posX, plotY + posY];
                }
              };
              Point2.prototype.resolveColor = function() {
                var series = this.series, optionsChart = series.chart.options.chart, styledMode = series.chart.styledMode;
                var color2, colors, colorCount = optionsChart.colorCount, colorIndex;
                delete this.nonZonedColor;
                if (series.options.colorByPoint) {
                  if (!styledMode) {
                    colors = series.options.colors || series.chart.options.colors;
                    color2 = colors[series.colorCounter];
                    colorCount = colors.length;
                  }
                  colorIndex = series.colorCounter;
                  series.colorCounter++;
                  if (series.colorCounter === colorCount) {
                    series.colorCounter = 0;
                  }
                } else {
                  if (!styledMode) {
                    color2 = series.color;
                  }
                  colorIndex = series.colorIndex;
                }
                this.colorIndex = pick(this.options.colorIndex, colorIndex);
                this.color = pick(this.options.color, color2);
              };
              Point2.prototype.setNestedProperty = function(object, value, key) {
                var nestedKeys = key.split(".");
                nestedKeys.reduce(function(result, key2, i, arr) {
                  var isLastKey = arr.length - 1 === i;
                  result[key2] = isLastKey ? value : isObject(result[key2], true) ? result[key2] : {};
                  return result[key2];
                }, object);
                return object;
              };
              Point2.prototype.shouldDraw = function() {
                return !this.isNull;
              };
              Point2.prototype.tooltipFormatter = function(pointFormat) {
                var series = this.series, seriesTooltipOptions = series.tooltipOptions, valueDecimals = pick(seriesTooltipOptions.valueDecimals, ""), valuePrefix = seriesTooltipOptions.valuePrefix || "", valueSuffix = seriesTooltipOptions.valueSuffix || "";
                if (series.chart.styledMode) {
                  pointFormat = series.chart.tooltip.styledModeFormat(pointFormat);
                }
                (series.pointArrayMap || ["y"]).forEach(function(key) {
                  key = "{point." + key;
                  if (valuePrefix || valueSuffix) {
                    pointFormat = pointFormat.replace(RegExp(key + "}", "g"), valuePrefix + key + "}" + valueSuffix);
                  }
                  pointFormat = pointFormat.replace(RegExp(key + "}", "g"), key + ":,." + valueDecimals + "f}");
                });
                return format3(pointFormat, {
                  point: this,
                  series: this.series
                }, series.chart);
              };
              Point2.prototype.update = function(options, redraw, animation, runEvent) {
                var point = this, series = point.series, graphic = point.graphic, chart = series.chart, seriesOptions = series.options;
                var i;
                redraw = pick(redraw, true);
                function update() {
                  point.applyOptions(options);
                  var hasMockGraphic = graphic && point.hasMockGraphic;
                  var shouldDestroyGraphic = point.y === null ? !hasMockGraphic : hasMockGraphic;
                  if (graphic && shouldDestroyGraphic) {
                    point.graphic = graphic.destroy();
                    delete point.hasMockGraphic;
                  }
                  if (isObject(options, true)) {
                    if (graphic && graphic.element) {
                      if (options && options.marker && typeof options.marker.symbol !== "undefined") {
                        point.graphic = graphic.destroy();
                      }
                    }
                    if (options && options.dataLabels && point.dataLabel) {
                      point.dataLabel = point.dataLabel.destroy();
                    }
                    if (point.connector) {
                      point.connector = point.connector.destroy();
                    }
                  }
                  i = point.index;
                  series.updateParallelArrays(point, i);
                  seriesOptions.data[i] = isObject(seriesOptions.data[i], true) || isObject(options, true) ? point.options : pick(options, seriesOptions.data[i]);
                  series.isDirty = series.isDirtyData = true;
                  if (!series.fixedBox && series.hasCartesianSeries) {
                    chart.isDirtyBox = true;
                  }
                  if (seriesOptions.legendType === "point") {
                    chart.isDirtyLegend = true;
                  }
                  if (redraw) {
                    chart.redraw(animation);
                  }
                }
                if (runEvent === false) {
                  update();
                } else {
                  point.firePointEvent("update", { options }, update);
                }
              };
              Point2.prototype.remove = function(redraw, animation) {
                this.series.removePoint(this.series.data.indexOf(this), redraw, animation);
              };
              Point2.prototype.select = function(selected, accumulate) {
                var point = this, series = point.series, chart = series.chart;
                selected = pick(selected, !point.selected);
                this.selectedStaging = selected;
                point.firePointEvent(selected ? "select" : "unselect", { accumulate }, function() {
                  point.selected = point.options.selected = selected;
                  series.options.data[series.data.indexOf(point)] = point.options;
                  point.setState(selected && "select");
                  if (!accumulate) {
                    chart.getSelectedPoints().forEach(function(loopPoint) {
                      var loopSeries = loopPoint.series;
                      if (loopPoint.selected && loopPoint !== point) {
                        loopPoint.selected = loopPoint.options.selected = false;
                        loopSeries.options.data[loopSeries.data.indexOf(loopPoint)] = loopPoint.options;
                        loopPoint.setState(chart.hoverPoints && loopSeries.options.inactiveOtherPoints ? "inactive" : "");
                        loopPoint.firePointEvent("unselect");
                      }
                    });
                  }
                });
                delete this.selectedStaging;
              };
              Point2.prototype.onMouseOver = function(e) {
                var point = this, series = point.series, chart = series.chart, pointer = chart.pointer;
                e = e ? pointer.normalize(e) : (
                  // In cases where onMouseOver is called directly without an event
                  pointer.getChartCoordinatesFromPoint(point, chart.inverted)
                );
                pointer.runPointActions(e, point);
              };
              Point2.prototype.onMouseOut = function() {
                var point = this, chart = point.series.chart;
                point.firePointEvent("mouseOut");
                if (!point.series.options.inactiveOtherPoints) {
                  (chart.hoverPoints || []).forEach(function(p) {
                    p.setState();
                  });
                }
                chart.hoverPoints = chart.hoverPoint = null;
              };
              Point2.prototype.importEvents = function() {
                if (!this.hasImportedEvents) {
                  var point_1 = this, options = merge(
                    point_1.series.options.point,
                    point_1.options
                  ), events = options.events;
                  point_1.events = events;
                  objectEach(events, function(event, eventType) {
                    if (isFunction(event)) {
                      addEvent(point_1, eventType, event);
                    }
                  });
                  this.hasImportedEvents = true;
                }
              };
              Point2.prototype.setState = function(state, move) {
                var point = this, series = point.series, previousState = point.state, stateOptions = series.options.states[state || "normal"] || {}, markerOptions = defaultOptions.plotOptions[series.type].marker && series.options.marker, normalDisabled = markerOptions && markerOptions.enabled === false, markerStateOptions = markerOptions && markerOptions.states && markerOptions.states[state || "normal"] || {}, stateDisabled = markerStateOptions.enabled === false, pointMarker = point.marker || {}, chart = series.chart, hasMarkers = markerOptions && series.markerAttribs;
                var halo = series.halo, markerAttribs, pointAttribs, pointAttribsAnimation, stateMarkerGraphic = series.stateMarkerGraphic, newSymbol;
                state = state || "";
                if (
                  // already has this state
                  state === point.state && !move || // selected points don't respond to hover
                  point.selected && state !== "select" || // series' state options is disabled
                  stateOptions.enabled === false || // general point marker's state options is disabled
                  state && (stateDisabled || normalDisabled && markerStateOptions.enabled === false) || // individual point marker's state options is disabled
                  state && pointMarker.states && pointMarker.states[state] && pointMarker.states[state].enabled === false
                ) {
                  return;
                }
                point.state = state;
                if (hasMarkers) {
                  markerAttribs = series.markerAttribs(point, state);
                }
                if (point.graphic && !point.hasMockGraphic) {
                  if (previousState) {
                    point.graphic.removeClass("highcharts-point-" + previousState);
                  }
                  if (state) {
                    point.graphic.addClass("highcharts-point-" + state);
                  }
                  if (!chart.styledMode) {
                    pointAttribs = series.pointAttribs(point, state);
                    pointAttribsAnimation = pick(chart.options.chart.animation, stateOptions.animation);
                    var opacity_1 = pointAttribs.opacity;
                    if (series.options.inactiveOtherPoints && isNumber(opacity_1)) {
                      (point.dataLabels || []).forEach(function(label) {
                        if (label && !label.hasClass("highcharts-data-label-hidden")) {
                          label.animate({ opacity: opacity_1 }, pointAttribsAnimation);
                        }
                      });
                      if (point.connector) {
                        point.connector.animate({ opacity: opacity_1 }, pointAttribsAnimation);
                      }
                    }
                    point.graphic.animate(pointAttribs, pointAttribsAnimation);
                  }
                  if (markerAttribs) {
                    point.graphic.animate(markerAttribs, pick(
                      // Turn off globally:
                      chart.options.chart.animation,
                      markerStateOptions.animation,
                      markerOptions.animation
                    ));
                  }
                  if (stateMarkerGraphic) {
                    stateMarkerGraphic.hide();
                  }
                } else {
                  if (state && markerStateOptions) {
                    newSymbol = pointMarker.symbol || series.symbol;
                    if (stateMarkerGraphic && stateMarkerGraphic.currentSymbol !== newSymbol) {
                      stateMarkerGraphic = stateMarkerGraphic.destroy();
                    }
                    if (markerAttribs) {
                      if (!stateMarkerGraphic) {
                        if (newSymbol) {
                          series.stateMarkerGraphic = stateMarkerGraphic = chart.renderer.symbol(newSymbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height).add(series.markerGroup);
                          stateMarkerGraphic.currentSymbol = newSymbol;
                        }
                      } else {
                        stateMarkerGraphic[move ? "animate" : "attr"]({
                          x: markerAttribs.x,
                          y: markerAttribs.y
                        });
                      }
                    }
                    if (!chart.styledMode && stateMarkerGraphic && point.state !== "inactive") {
                      stateMarkerGraphic.attr(series.pointAttribs(point, state));
                    }
                  }
                  if (stateMarkerGraphic) {
                    stateMarkerGraphic[state && point.isInside ? "show" : "hide"]();
                    stateMarkerGraphic.element.point = point;
                    stateMarkerGraphic.addClass(point.getClassName(), true);
                  }
                }
                var haloOptions = stateOptions.halo;
                var markerGraphic = point.graphic || stateMarkerGraphic;
                var markerVisibility = markerGraphic && markerGraphic.visibility || "inherit";
                if (haloOptions && haloOptions.size && markerGraphic && markerVisibility !== "hidden" && !point.isCluster) {
                  if (!halo) {
                    series.halo = halo = chart.renderer.path().add(markerGraphic.parentGroup);
                  }
                  halo.show()[move ? "animate" : "attr"]({
                    d: point.haloPath(haloOptions.size)
                  });
                  halo.attr({
                    "class": "highcharts-halo highcharts-color-" + pick(point.colorIndex, series.colorIndex) + (point.className ? " " + point.className : ""),
                    "visibility": markerVisibility,
                    "zIndex": -1
                    // #4929, #8276
                  });
                  halo.point = point;
                  if (!chart.styledMode) {
                    halo.attr(extend2({
                      "fill": point.color || series.color,
                      "fill-opacity": haloOptions.opacity
                    }, AST.filterUserAttributes(haloOptions.attributes || {})));
                  }
                } else if (halo && halo.point && halo.point.haloPath) {
                  halo.animate(
                    { d: halo.point.haloPath(0) },
                    null,
                    // Hide after unhovering. The `complete` callback runs in the
                    // halo's context (#7681).
                    halo.hide
                  );
                }
                fireEvent(point, "afterSetState", { state });
              };
              Point2.prototype.haloPath = function(size) {
                var pos = this.pos();
                return pos ? this.series.chart.renderer.symbols.circle(Math.floor(pos[0]) - size, pos[1] - size, size * 2, size * 2) : [];
              };
              return Point2;
            }()
          );
          "";
          return Point;
        });
        _registerModule(_modules, "Core/Pointer.js", [_modules["Core/Color/Color.js"], _modules["Core/Globals.js"], _modules["Core/Tooltip.js"], _modules["Core/Utilities.js"]], function(Color2, H, Tooltip, U) {
          var color2 = Color2.parse;
          var charts = H.charts, noop2 = H.noop;
          var addEvent = U.addEvent, attr = U.attr, css = U.css, defined = U.defined, extend2 = U.extend, find2 = U.find, fireEvent = U.fireEvent, isNumber = U.isNumber, isObject = U.isObject, objectEach = U.objectEach, offset = U.offset, pick = U.pick, splat = U.splat;
          var Pointer = (
            /** @class */
            function() {
              function Pointer2(chart, options) {
                this.lastValidTouch = {};
                this.pinchDown = [];
                this.runChartClick = false;
                this.eventsToUnbind = [];
                this.chart = chart;
                this.hasDragged = false;
                this.options = options;
                this.init(chart, options);
              }
              Pointer2.prototype.applyInactiveState = function(points) {
                var activeSeries = [], series;
                (points || []).forEach(function(item) {
                  series = item.series;
                  activeSeries.push(series);
                  if (series.linkedParent) {
                    activeSeries.push(series.linkedParent);
                  }
                  if (series.linkedSeries) {
                    activeSeries = activeSeries.concat(series.linkedSeries);
                  }
                  if (series.navigatorSeries) {
                    activeSeries.push(series.navigatorSeries);
                  }
                });
                this.chart.series.forEach(function(inactiveSeries) {
                  if (activeSeries.indexOf(inactiveSeries) === -1) {
                    inactiveSeries.setState("inactive", true);
                  } else if (inactiveSeries.options.inactiveOtherPoints) {
                    inactiveSeries.setAllPointsToState("inactive");
                  }
                });
              };
              Pointer2.prototype.destroy = function() {
                var pointer = this;
                this.eventsToUnbind.forEach(function(unbind) {
                  return unbind();
                });
                this.eventsToUnbind = [];
                if (!H.chartCount) {
                  if (Pointer2.unbindDocumentMouseUp) {
                    Pointer2.unbindDocumentMouseUp = Pointer2.unbindDocumentMouseUp();
                  }
                  if (Pointer2.unbindDocumentTouchEnd) {
                    Pointer2.unbindDocumentTouchEnd = Pointer2.unbindDocumentTouchEnd();
                  }
                }
                clearInterval(pointer.tooltipTimeout);
                objectEach(pointer, function(_val, prop) {
                  pointer[prop] = void 0;
                });
              };
              Pointer2.prototype.getSelectionMarkerAttrs = function(chartX, chartY) {
                var _this = this;
                var e = {
                  args: {
                    chartX,
                    chartY
                  },
                  attrs: {},
                  shapeType: "rect"
                };
                fireEvent(this, "getSelectionMarkerAttrs", e, function(e2) {
                  var _a = _this, chart = _a.chart, _b = _a.mouseDownX, mouseDownX = _b === void 0 ? 0 : _b, _c = _a.mouseDownY, mouseDownY = _c === void 0 ? 0 : _c, zoomHor = _a.zoomHor, zoomVert = _a.zoomVert, attrs = e2.attrs;
                  var size;
                  attrs.x = chart.plotLeft;
                  attrs.y = chart.plotTop;
                  attrs.width = zoomHor ? 1 : chart.plotWidth;
                  attrs.height = zoomVert ? 1 : chart.plotHeight;
                  if (zoomHor) {
                    size = chartX - mouseDownX;
                    attrs.width = Math.abs(size);
                    attrs.x = (size > 0 ? 0 : size) + mouseDownX;
                  }
                  if (zoomVert) {
                    size = chartY - mouseDownY;
                    attrs.height = Math.abs(size);
                    attrs.y = (size > 0 ? 0 : size) + mouseDownY;
                  }
                });
                return e;
              };
              Pointer2.prototype.drag = function(e) {
                var chart = this.chart, chartOptions = chart.options.chart, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, mouseDownX = this.mouseDownX || 0, mouseDownY = this.mouseDownY || 0, panningEnabled = isObject(chartOptions.panning) ? chartOptions.panning && chartOptions.panning.enabled : chartOptions.panning, panKey = chartOptions.panKey && e[chartOptions.panKey + "Key"];
                var chartX = e.chartX, chartY = e.chartY, clickedInside, selectionMarker = this.selectionMarker;
                if (selectionMarker && selectionMarker.touch) {
                  return;
                }
                if (chartX < plotLeft) {
                  chartX = plotLeft;
                } else if (chartX > plotLeft + plotWidth) {
                  chartX = plotLeft + plotWidth;
                }
                if (chartY < plotTop) {
                  chartY = plotTop;
                } else if (chartY > plotTop + plotHeight) {
                  chartY = plotTop + plotHeight;
                }
                this.hasDragged = Math.sqrt(Math.pow(mouseDownX - chartX, 2) + Math.pow(mouseDownY - chartY, 2));
                if (this.hasDragged > 10) {
                  clickedInside = chart.isInsidePlot(mouseDownX - plotLeft, mouseDownY - plotTop, {
                    visiblePlotOnly: true
                  });
                  var _a = this.getSelectionMarkerAttrs(
                    chartX,
                    chartY
                  ), shapeType = _a.shapeType, attrs = _a.attrs;
                  if ((chart.hasCartesianSeries || chart.mapView) && (this.zoomX || this.zoomY) && clickedInside && !panKey) {
                    if (!selectionMarker) {
                      this.selectionMarker = selectionMarker = chart.renderer[shapeType]();
                      selectionMarker.attr({
                        "class": "highcharts-selection-marker",
                        zIndex: 7
                      }).add();
                      if (!chart.styledMode) {
                        selectionMarker.attr({
                          fill: chartOptions.selectionMarkerFill || color2(
                            "#335cad"
                            /* Palette.highlightColor80 */
                          ).setOpacity(0.25).get()
                        });
                      }
                    }
                  }
                  if (selectionMarker) {
                    selectionMarker.attr(attrs);
                  }
                  if (clickedInside && !selectionMarker && panningEnabled) {
                    chart.pan(e, chartOptions.panning);
                  }
                }
              };
              Pointer2.prototype.dragStart = function(e) {
                var chart = this.chart;
                chart.mouseIsDown = e.type;
                chart.cancelClick = false;
                chart.mouseDownX = this.mouseDownX = e.chartX;
                chart.mouseDownY = this.mouseDownY = e.chartY;
              };
              Pointer2.prototype.getSelectionBox = function(marker) {
                var e = {
                  args: { marker },
                  result: {}
                };
                fireEvent(this, "getSelectionBox", e, function(e2) {
                  e2.result = {
                    x: marker.attr ? +marker.attr("x") : marker.x,
                    y: marker.attr ? +marker.attr("y") : marker.y,
                    width: marker.attr ? marker.attr("width") : marker.width,
                    height: marker.attr ? marker.attr("height") : marker.height
                  };
                });
                return e.result;
              };
              Pointer2.prototype.drop = function(e) {
                var pointer = this, chart = this.chart, hasPinched = this.hasPinched;
                if (this.selectionMarker) {
                  var _a = this.getSelectionBox(this.selectionMarker), x_1 = _a.x, y_1 = _a.y, width_1 = _a.width, height_1 = _a.height;
                  var selectionData_1 = {
                    originalEvent: e,
                    xAxis: [],
                    yAxis: [],
                    x: x_1,
                    y: y_1,
                    width: width_1,
                    height: height_1
                  }, runZoom_1 = Boolean(chart.mapView);
                  if (this.hasDragged || hasPinched) {
                    chart.axes.forEach(function(axis) {
                      if (axis.zoomEnabled && defined(axis.min) && (hasPinched || pointer[{
                        xAxis: "zoomX",
                        yAxis: "zoomY"
                      }[axis.coll]]) && isNumber(x_1) && isNumber(y_1) && isNumber(width_1) && isNumber(height_1)) {
                        var horiz = axis.horiz, minPixelPadding = e.type === "touchend" ? axis.minPixelPadding : 0, selectionMin = axis.toValue((horiz ? x_1 : y_1) + minPixelPadding), selectionMax = axis.toValue((horiz ? x_1 + width_1 : y_1 + height_1) - minPixelPadding);
                        selectionData_1[axis.coll].push({
                          axis,
                          // Min/max for reversed axes
                          min: Math.min(selectionMin, selectionMax),
                          max: Math.max(selectionMin, selectionMax)
                        });
                        runZoom_1 = true;
                      }
                    });
                    if (runZoom_1) {
                      fireEvent(chart, "selection", selectionData_1, function(args) {
                        chart.zoom(extend2(args, hasPinched ? { animation: false } : null));
                      });
                    }
                  }
                  if (isNumber(chart.index)) {
                    this.selectionMarker = this.selectionMarker.destroy();
                  }
                  if (hasPinched) {
                    this.scaleGroups();
                  }
                }
                if (chart && isNumber(chart.index)) {
                  css(chart.container, { cursor: chart._cursor });
                  chart.cancelClick = this.hasDragged > 10;
                  chart.mouseIsDown = this.hasDragged = this.hasPinched = false;
                  this.pinchDown = [];
                }
              };
              Pointer2.prototype.findNearestKDPoint = function(series, shared, e) {
                var closest;
                function sort(p1, p2) {
                  var isCloserX = p1.distX - p2.distX, isCloser = p1.dist - p2.dist, isAbove = (p2.series.group && p2.series.group.zIndex) - (p1.series.group && p1.series.group.zIndex);
                  var result;
                  if (isCloserX !== 0 && shared) {
                    result = isCloserX;
                  } else if (isCloser !== 0) {
                    result = isCloser;
                  } else if (isAbove !== 0) {
                    result = isAbove;
                  } else {
                    result = p1.series.index > p2.series.index ? -1 : 1;
                  }
                  return result;
                }
                series.forEach(function(s) {
                  var noSharedTooltip = s.noSharedTooltip && shared, compareX = !noSharedTooltip && s.options.findNearestPointBy.indexOf("y") < 0, point = s.searchPoint(
                    e,
                    compareX
                  );
                  if (
                    // Check that we actually found a point on the series.
                    isObject(point, true) && point.series && // Use the new point if it is closer.
                    (!isObject(closest, true) || sort(closest, point) > 0)
                  ) {
                    closest = point;
                  }
                });
                return closest;
              };
              Pointer2.prototype.getChartCoordinatesFromPoint = function(point, inverted) {
                var series = point.series, xAxis = series.xAxis, yAxis = series.yAxis, shapeArgs = point.shapeArgs;
                if (xAxis && yAxis) {
                  var x = pick(
                    point.clientX,
                    point.plotX
                  );
                  var y = point.plotY || 0;
                  if (point.isNode && shapeArgs && isNumber(shapeArgs.x) && isNumber(shapeArgs.y)) {
                    x = shapeArgs.x;
                    y = shapeArgs.y;
                  }
                  return inverted ? {
                    chartX: yAxis.len + yAxis.pos - y,
                    chartY: xAxis.len + xAxis.pos - x
                  } : {
                    chartX: x + xAxis.pos,
                    chartY: y + yAxis.pos
                  };
                }
                if (shapeArgs && shapeArgs.x && shapeArgs.y) {
                  return {
                    chartX: shapeArgs.x,
                    chartY: shapeArgs.y
                  };
                }
              };
              Pointer2.prototype.getChartPosition = function() {
                if (this.chartPosition) {
                  return this.chartPosition;
                }
                var container = this.chart.container;
                var pos = offset(container);
                this.chartPosition = {
                  left: pos.left,
                  top: pos.top,
                  scaleX: 1,
                  scaleY: 1
                };
                var offsetWidth = container.offsetWidth;
                var offsetHeight = container.offsetHeight;
                if (offsetWidth > 2 && // #13342
                offsetHeight > 2) {
                  this.chartPosition.scaleX = pos.width / offsetWidth;
                  this.chartPosition.scaleY = pos.height / offsetHeight;
                }
                return this.chartPosition;
              };
              Pointer2.prototype.getCoordinates = function(e) {
                var coordinates = {
                  xAxis: [],
                  yAxis: []
                };
                this.chart.axes.forEach(function(axis) {
                  coordinates[axis.isXAxis ? "xAxis" : "yAxis"].push({
                    axis,
                    value: axis.toValue(e[axis.horiz ? "chartX" : "chartY"])
                  });
                });
                return coordinates;
              };
              Pointer2.prototype.getHoverData = function(existingHoverPoint, existingHoverSeries, series, isDirectTouch, shared, e) {
                var hoverPoints = [], useExisting = !!(isDirectTouch && existingHoverPoint), filter2 = function(s) {
                  return s.visible && !(!shared && s.directTouch) && // #3821
                  pick(
                    s.options.enableMouseTracking,
                    true
                  );
                };
                var hoverSeries = existingHoverSeries, searchSeries, eventArgs = {
                  chartX: e ? e.chartX : void 0,
                  chartY: e ? e.chartY : void 0,
                  shared
                };
                fireEvent(this, "beforeGetHoverData", eventArgs);
                var notSticky = hoverSeries && !hoverSeries.stickyTracking;
                searchSeries = notSticky ? (
                  // Only search on hovered series if it has stickyTracking false
                  [hoverSeries]
                ) : (
                  // Filter what series to look in.
                  series.filter(function(s) {
                    return s.stickyTracking && (eventArgs.filter || filter2)(s);
                  })
                );
                var hoverPoint = useExisting || !e ? existingHoverPoint : this.findNearestKDPoint(
                  searchSeries,
                  shared,
                  e
                );
                hoverSeries = hoverPoint && hoverPoint.series;
                if (hoverPoint) {
                  if (shared && !hoverSeries.noSharedTooltip) {
                    searchSeries = series.filter(function(s) {
                      return eventArgs.filter ? eventArgs.filter(s) : filter2(s) && !s.noSharedTooltip;
                    });
                    searchSeries.forEach(function(s) {
                      var point = find2(
                        s.points,
                        function(p) {
                          return p.x === hoverPoint.x && !p.isNull;
                        }
                      );
                      if (isObject(point)) {
                        if (s.boosted && s.boost) {
                          point = s.boost.getPoint(point);
                        }
                        hoverPoints.push(point);
                      }
                    });
                  } else {
                    hoverPoints.push(hoverPoint);
                  }
                }
                eventArgs = { hoverPoint };
                fireEvent(this, "afterGetHoverData", eventArgs);
                return {
                  hoverPoint: eventArgs.hoverPoint,
                  hoverSeries,
                  hoverPoints
                };
              };
              Pointer2.prototype.getPointFromEvent = function(e) {
                var target = e.target, point;
                while (target && !point) {
                  point = target.point;
                  target = target.parentNode;
                }
                return point;
              };
              Pointer2.prototype.onTrackerMouseOut = function(e) {
                var chart = this.chart;
                var relatedTarget = e.relatedTarget || e.toElement;
                var series = chart.hoverSeries;
                this.isDirectTouch = false;
                if (series && relatedTarget && !series.stickyTracking && !this.inClass(relatedTarget, "highcharts-tooltip") && (!this.inClass(relatedTarget, "highcharts-series-" + series.index) || // #2499, #4465, #5553
                !this.inClass(relatedTarget, "highcharts-tracker"))) {
                  series.onMouseOut();
                }
              };
              Pointer2.prototype.inClass = function(element, className) {
                var elem = element, elemClassName;
                while (elem) {
                  elemClassName = attr(elem, "class");
                  if (elemClassName) {
                    if (elemClassName.indexOf(className) !== -1) {
                      return true;
                    }
                    if (elemClassName.indexOf("highcharts-container") !== -1) {
                      return false;
                    }
                  }
                  elem = elem.parentElement;
                }
              };
              Pointer2.prototype.init = function(chart, options) {
                this.options = options;
                this.chart = chart;
                this.runChartClick = Boolean(options.chart.events && options.chart.events.click);
                this.pinchDown = [];
                this.lastValidTouch = {};
                if (Tooltip) {
                  chart.tooltip = new Tooltip(chart, options.tooltip);
                }
                this.setDOMEvents();
              };
              Pointer2.prototype.normalize = function(e, chartPosition) {
                var touches = e.touches;
                var ePos = touches ? touches.length ? touches.item(0) : pick(
                  // #13534
                  touches.changedTouches,
                  e.changedTouches
                )[0] : e;
                if (!chartPosition) {
                  chartPosition = this.getChartPosition();
                }
                var chartX = ePos.pageX - chartPosition.left, chartY = ePos.pageY - chartPosition.top;
                chartX /= chartPosition.scaleX;
                chartY /= chartPosition.scaleY;
                return extend2(e, {
                  chartX: Math.round(chartX),
                  chartY: Math.round(chartY)
                });
              };
              Pointer2.prototype.onContainerClick = function(e) {
                var chart = this.chart;
                var hoverPoint = chart.hoverPoint;
                var pEvt = this.normalize(e);
                var plotLeft = chart.plotLeft;
                var plotTop = chart.plotTop;
                if (!chart.cancelClick) {
                  if (hoverPoint && this.inClass(pEvt.target, "highcharts-tracker")) {
                    fireEvent(hoverPoint.series, "click", extend2(pEvt, {
                      point: hoverPoint
                    }));
                    if (chart.hoverPoint) {
                      hoverPoint.firePointEvent("click", pEvt);
                    }
                  } else {
                    extend2(pEvt, this.getCoordinates(pEvt));
                    if (chart.isInsidePlot(pEvt.chartX - plotLeft, pEvt.chartY - plotTop, {
                      visiblePlotOnly: true
                    })) {
                      fireEvent(chart, "click", pEvt);
                    }
                  }
                }
              };
              Pointer2.prototype.onContainerMouseDown = function(e) {
                var isPrimaryButton = ((e.buttons || e.button) & 1) === 1;
                e = this.normalize(e);
                if (H.isFirefox && e.button !== 0) {
                  this.onContainerMouseMove(e);
                }
                if (typeof e.button === "undefined" || isPrimaryButton) {
                  this.zoomOption(e);
                  if (isPrimaryButton && e.preventDefault) {
                    e.preventDefault();
                  }
                  this.dragStart(e);
                }
              };
              Pointer2.prototype.onContainerMouseLeave = function(e) {
                var chart = charts[pick(Pointer2.hoverChartIndex, -1)];
                var tooltip = this.chart.tooltip;
                e = this.normalize(e);
                if (chart && (e.relatedTarget || e.toElement)) {
                  chart.pointer.reset();
                  chart.pointer.chartPosition = void 0;
                }
                if (tooltip && !tooltip.isHidden) {
                  this.reset();
                }
              };
              Pointer2.prototype.onContainerMouseEnter = function(e) {
                delete this.chartPosition;
              };
              Pointer2.prototype.onContainerMouseMove = function(e) {
                var chart = this.chart, tooltip = chart.tooltip, pEvt = this.normalize(e);
                this.setHoverChartIndex();
                if (!pEvt.preventDefault) {
                  pEvt.returnValue = false;
                }
                if (chart.mouseIsDown === "mousedown" || this.touchSelect(pEvt)) {
                  this.drag(pEvt);
                }
                if (!chart.openMenu && (this.inClass(pEvt.target, "highcharts-tracker") || chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
                  visiblePlotOnly: true
                })) && // If the tooltip has stickOnContact enabled, do nothing. This
                // applies regardless of any combinations of the `split` and
                // `useHTML` options.
                !(tooltip && tooltip.shouldStickOnContact(pEvt))) {
                  if (this.inClass(pEvt.target, "highcharts-no-tooltip")) {
                    this.reset(false, 0);
                  } else {
                    this.runPointActions(pEvt);
                  }
                }
              };
              Pointer2.prototype.onDocumentTouchEnd = function(e) {
                var hoverChart = charts[pick(Pointer2.hoverChartIndex, -1)];
                if (hoverChart) {
                  hoverChart.pointer.drop(e);
                }
              };
              Pointer2.prototype.onContainerTouchMove = function(e) {
                if (this.touchSelect(e)) {
                  this.onContainerMouseMove(e);
                } else {
                  this.touch(e);
                }
              };
              Pointer2.prototype.onContainerTouchStart = function(e) {
                if (this.touchSelect(e)) {
                  this.onContainerMouseDown(e);
                } else {
                  this.zoomOption(e);
                  this.touch(e, true);
                }
              };
              Pointer2.prototype.onDocumentMouseMove = function(e) {
                var chart = this.chart;
                var tooltip = chart.tooltip;
                var chartPosition = this.chartPosition;
                var pEvt = this.normalize(
                  e,
                  chartPosition
                );
                if (chartPosition && !chart.isInsidePlot(pEvt.chartX - chart.plotLeft, pEvt.chartY - chart.plotTop, {
                  visiblePlotOnly: true
                }) && !(tooltip && tooltip.shouldStickOnContact(pEvt)) && !this.inClass(pEvt.target, "highcharts-tracker")) {
                  this.reset();
                }
              };
              Pointer2.prototype.onDocumentMouseUp = function(e) {
                var chart = charts[pick(Pointer2.hoverChartIndex, -1)];
                if (chart) {
                  chart.pointer.drop(e);
                }
              };
              Pointer2.prototype.pinch = function(e) {
                var self = this, chart = self.chart, pinchDown = self.pinchDown, touches = e.touches || [], touchesLength = touches.length, lastValidTouch = self.lastValidTouch, hasZoom = self.hasZoom, transform = {}, fireClickEvent = touchesLength === 1 && (self.inClass(e.target, "highcharts-tracker") && chart.runTrackerClick || self.runChartClick), clip = {}, tooltip = self.chart.tooltip, followTouchMove = touchesLength === 1 && pick(
                  tooltip && tooltip.options.followTouchMove,
                  true
                );
                var selectionMarker = self.selectionMarker;
                if (touchesLength > 1) {
                  self.initiated = true;
                } else if (followTouchMove) {
                  self.initiated = false;
                }
                if (hasZoom && self.initiated && !fireClickEvent && e.cancelable !== false) {
                  e.preventDefault();
                }
                [].map.call(touches, function(e2) {
                  return self.normalize(e2);
                });
                if (e.type === "touchstart") {
                  [].forEach.call(touches, function(e2, i) {
                    pinchDown[i] = { chartX: e2.chartX, chartY: e2.chartY };
                  });
                  lastValidTouch.x = [pinchDown[0].chartX, pinchDown[1] && pinchDown[1].chartX];
                  lastValidTouch.y = [pinchDown[0].chartY, pinchDown[1] && pinchDown[1].chartY];
                  chart.axes.forEach(function(axis) {
                    if (axis.zoomEnabled) {
                      var bounds = chart.bounds[axis.horiz ? "h" : "v"], minPixelPadding = axis.minPixelPadding, min2 = axis.toPixels(Math.min(
                        pick(
                          axis.options.min,
                          axis.dataMin
                        ),
                        axis.dataMin
                      )), max2 = axis.toPixels(Math.max(
                        pick(
                          axis.options.max,
                          axis.dataMax
                        ),
                        axis.dataMax
                      )), absMin = Math.min(
                        min2,
                        max2
                      ), absMax = Math.max(
                        min2,
                        max2
                      );
                      bounds.min = Math.min(axis.pos, absMin - minPixelPadding);
                      bounds.max = Math.max(axis.pos + axis.len, absMax + minPixelPadding);
                    }
                  });
                  self.res = true;
                } else if (followTouchMove) {
                  this.runPointActions(self.normalize(e));
                } else if (pinchDown.length) {
                  fireEvent(chart, "touchpan", { originalEvent: e }, function() {
                    if (!selectionMarker) {
                      self.selectionMarker = selectionMarker = extend2({
                        destroy: noop2,
                        touch: true
                      }, chart.plotBox);
                    }
                    self.pinchTranslate(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                    self.hasPinched = hasZoom;
                    self.scaleGroups(transform, clip);
                  });
                  if (self.res) {
                    self.res = false;
                    this.reset(false, 0);
                  }
                }
              };
              Pointer2.prototype.pinchTranslate = function(pinchDown, touches, transform, selectionMarker, clip, lastValidTouch) {
                if (this.zoomHor) {
                  this.pinchTranslateDirection(true, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                }
                if (this.zoomVert) {
                  this.pinchTranslateDirection(false, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch);
                }
              };
              Pointer2.prototype.pinchTranslateDirection = function(horiz, pinchDown, touches, transform, selectionMarker, clip, lastValidTouch, forcedScale) {
                var chart = this.chart, xy = horiz ? "x" : "y", XY = horiz ? "X" : "Y", sChartXY = "chart" + XY, wh = horiz ? "width" : "height", plotLeftTop = chart["plot" + (horiz ? "Left" : "Top")], inverted = chart.inverted, bounds = chart.bounds[horiz ? "h" : "v"], singleTouch = pinchDown.length === 1, touch0Start = pinchDown[0][sChartXY], touch1Start = !singleTouch && pinchDown[1][sChartXY], setScale = function() {
                  if (typeof touch1Now === "number" && Math.abs(touch0Start - touch1Start) > 20) {
                    scale = forcedScale || Math.abs(touch0Now - touch1Now) / Math.abs(touch0Start - touch1Start);
                  }
                  clipXY = (plotLeftTop - touch0Now) / scale + touch0Start;
                  selectionWH = chart["plot" + (horiz ? "Width" : "Height")] / scale;
                };
                var selectionWH, selectionXY, clipXY, scale = forcedScale || 1, touch0Now = touches[0][sChartXY], touch1Now = !singleTouch && touches[1][sChartXY], outOfBounds;
                setScale();
                selectionXY = clipXY;
                if (selectionXY < bounds.min) {
                  selectionXY = bounds.min;
                  outOfBounds = true;
                } else if (selectionXY + selectionWH > bounds.max) {
                  selectionXY = bounds.max - selectionWH;
                  outOfBounds = true;
                }
                if (outOfBounds) {
                  touch0Now -= 0.8 * (touch0Now - lastValidTouch[xy][0]);
                  if (typeof touch1Now === "number") {
                    touch1Now -= 0.8 * (touch1Now - lastValidTouch[xy][1]);
                  }
                  setScale();
                } else {
                  lastValidTouch[xy] = [touch0Now, touch1Now];
                }
                if (!inverted) {
                  clip[xy] = clipXY - plotLeftTop;
                  clip[wh] = selectionWH;
                }
                var scaleKey = inverted ? horiz ? "scaleY" : "scaleX" : "scale" + XY;
                var transformScale = inverted ? 1 / scale : scale;
                selectionMarker[wh] = selectionWH;
                selectionMarker[xy] = selectionXY;
                transform[scaleKey] = scale;
                transform["translate" + XY] = transformScale * plotLeftTop + (touch0Now - transformScale * touch0Start);
              };
              Pointer2.prototype.reset = function(allowMove, delay) {
                var pointer = this, chart = pointer.chart, hoverSeries = chart.hoverSeries, hoverPoint = chart.hoverPoint, hoverPoints = chart.hoverPoints, tooltip = chart.tooltip, tooltipPoints = tooltip && tooltip.shared ? hoverPoints : hoverPoint;
                if (allowMove && tooltipPoints) {
                  splat(tooltipPoints).forEach(function(point) {
                    if (point.series.isCartesian && typeof point.plotX === "undefined") {
                      allowMove = false;
                    }
                  });
                }
                if (allowMove) {
                  if (tooltip && tooltipPoints && splat(tooltipPoints).length) {
                    tooltip.refresh(tooltipPoints);
                    if (tooltip.shared && hoverPoints) {
                      hoverPoints.forEach(function(point) {
                        point.setState(point.state, true);
                        if (point.series.isCartesian) {
                          if (point.series.xAxis.crosshair) {
                            point.series.xAxis.drawCrosshair(null, point);
                          }
                          if (point.series.yAxis.crosshair) {
                            point.series.yAxis.drawCrosshair(null, point);
                          }
                        }
                      });
                    } else if (hoverPoint) {
                      hoverPoint.setState(hoverPoint.state, true);
                      chart.axes.forEach(function(axis) {
                        if (axis.crosshair && hoverPoint.series[axis.coll] === axis) {
                          axis.drawCrosshair(null, hoverPoint);
                        }
                      });
                    }
                  }
                } else {
                  if (hoverPoint) {
                    hoverPoint.onMouseOut();
                  }
                  if (hoverPoints) {
                    hoverPoints.forEach(function(point) {
                      point.setState();
                    });
                  }
                  if (hoverSeries) {
                    hoverSeries.onMouseOut();
                  }
                  if (tooltip) {
                    tooltip.hide(delay);
                  }
                  if (pointer.unDocMouseMove) {
                    pointer.unDocMouseMove = pointer.unDocMouseMove();
                  }
                  chart.axes.forEach(function(axis) {
                    axis.hideCrosshair();
                  });
                  pointer.hoverX = chart.hoverPoints = chart.hoverPoint = null;
                }
              };
              Pointer2.prototype.runPointActions = function(e, p, force) {
                var pointer = this, chart = pointer.chart, series = chart.series, tooltip = chart.tooltip && chart.tooltip.options.enabled ? chart.tooltip : void 0, shared = tooltip ? tooltip.shared : false;
                var hoverPoint = p || chart.hoverPoint, hoverSeries = hoverPoint && hoverPoint.series || chart.hoverSeries;
                var isDirectTouch = (!e || e.type !== "touchmove") && (!!p || hoverSeries && hoverSeries.directTouch && pointer.isDirectTouch), hoverData = this.getHoverData(
                  hoverPoint,
                  hoverSeries,
                  series,
                  isDirectTouch,
                  shared,
                  e
                );
                hoverPoint = hoverData.hoverPoint;
                hoverSeries = hoverData.hoverSeries;
                var points = hoverData.hoverPoints, followPointer = hoverSeries && hoverSeries.tooltipOptions.followPointer && !hoverSeries.tooltipOptions.split, useSharedTooltip = shared && hoverSeries && !hoverSeries.noSharedTooltip;
                if (hoverPoint && (force || hoverPoint !== chart.hoverPoint || tooltip && tooltip.isHidden)) {
                  (chart.hoverPoints || []).forEach(function(p2) {
                    if (points.indexOf(p2) === -1) {
                      p2.setState();
                    }
                  });
                  if (chart.hoverSeries !== hoverSeries) {
                    hoverSeries.onMouseOver();
                  }
                  pointer.applyInactiveState(points);
                  (points || []).forEach(function(p2) {
                    p2.setState("hover");
                  });
                  if (chart.hoverPoint) {
                    chart.hoverPoint.firePointEvent("mouseOut");
                  }
                  if (!hoverPoint.series) {
                    return;
                  }
                  chart.hoverPoints = points;
                  chart.hoverPoint = hoverPoint;
                  hoverPoint.firePointEvent("mouseOver", void 0, function() {
                    if (tooltip && hoverPoint) {
                      tooltip.refresh(useSharedTooltip ? points : hoverPoint, e);
                    }
                  });
                } else if (followPointer && tooltip && !tooltip.isHidden) {
                  var anchor = tooltip.getAnchor(
                    [{}],
                    e
                  );
                  if (chart.isInsidePlot(anchor[0], anchor[1], {
                    visiblePlotOnly: true
                  })) {
                    tooltip.updatePosition({ plotX: anchor[0], plotY: anchor[1] });
                  }
                }
                if (!pointer.unDocMouseMove) {
                  pointer.unDocMouseMove = addEvent(chart.container.ownerDocument, "mousemove", function(e2) {
                    var chart2 = charts[Pointer2.hoverChartIndex];
                    if (chart2) {
                      chart2.pointer.onDocumentMouseMove(e2);
                    }
                  });
                  pointer.eventsToUnbind.push(pointer.unDocMouseMove);
                }
                chart.axes.forEach(function drawAxisCrosshair(axis) {
                  var snap = pick(
                    (axis.crosshair || {}).snap,
                    true
                  );
                  var point;
                  if (snap) {
                    point = chart.hoverPoint;
                    if (!point || point.series[axis.coll] !== axis) {
                      point = find2(points, function(p2) {
                        return p2.series && p2.series[axis.coll] === axis;
                      });
                    }
                  }
                  if (point || !snap) {
                    axis.drawCrosshair(e, point);
                  } else {
                    axis.hideCrosshair();
                  }
                });
              };
              Pointer2.prototype.scaleGroups = function(attribs, clip) {
                var chart = this.chart;
                chart.series.forEach(function(series) {
                  var seriesAttribs = attribs || series.getPlotBox();
                  if (series.group && (series.xAxis && series.xAxis.zoomEnabled || chart.mapView)) {
                    series.group.attr(seriesAttribs);
                    if (series.markerGroup) {
                      series.markerGroup.attr(seriesAttribs);
                      series.markerGroup.clip(clip ? chart.clipRect : null);
                    }
                    if (series.dataLabelsGroup) {
                      series.dataLabelsGroup.attr(seriesAttribs);
                    }
                  }
                });
                chart.clipRect.attr(clip || chart.clipBox);
              };
              Pointer2.prototype.setDOMEvents = function() {
                var _this = this;
                var container = this.chart.container, ownerDoc = container.ownerDocument;
                container.onmousedown = this.onContainerMouseDown.bind(this);
                container.onmousemove = this.onContainerMouseMove.bind(this);
                container.onclick = this.onContainerClick.bind(this);
                this.eventsToUnbind.push(addEvent(container, "mouseenter", this.onContainerMouseEnter.bind(this)));
                this.eventsToUnbind.push(addEvent(container, "mouseleave", this.onContainerMouseLeave.bind(this)));
                if (!Pointer2.unbindDocumentMouseUp) {
                  Pointer2.unbindDocumentMouseUp = addEvent(ownerDoc, "mouseup", this.onDocumentMouseUp.bind(this));
                }
                var parent = this.chart.renderTo.parentElement;
                while (parent && parent.tagName !== "BODY") {
                  this.eventsToUnbind.push(addEvent(parent, "scroll", function() {
                    delete _this.chartPosition;
                  }));
                  parent = parent.parentElement;
                }
                if (H.hasTouch) {
                  this.eventsToUnbind.push(addEvent(container, "touchstart", this.onContainerTouchStart.bind(this), { passive: false }));
                  this.eventsToUnbind.push(addEvent(container, "touchmove", this.onContainerTouchMove.bind(this), { passive: false }));
                  if (!Pointer2.unbindDocumentTouchEnd) {
                    Pointer2.unbindDocumentTouchEnd = addEvent(ownerDoc, "touchend", this.onDocumentTouchEnd.bind(this), { passive: false });
                  }
                }
              };
              Pointer2.prototype.setHoverChartIndex = function() {
                var chart = this.chart;
                var hoverChart = H.charts[pick(Pointer2.hoverChartIndex, -1)];
                if (hoverChart && hoverChart !== chart) {
                  hoverChart.pointer.onContainerMouseLeave({ relatedTarget: chart.container });
                }
                if (!hoverChart || !hoverChart.mouseIsDown) {
                  Pointer2.hoverChartIndex = chart.index;
                }
              };
              Pointer2.prototype.touch = function(e, start2) {
                var chart = this.chart;
                var hasMoved, pinchDown, isInside;
                this.setHoverChartIndex();
                if (e.touches.length === 1) {
                  e = this.normalize(e);
                  isInside = chart.isInsidePlot(e.chartX - chart.plotLeft, e.chartY - chart.plotTop, {
                    visiblePlotOnly: true
                  });
                  if (isInside && !chart.openMenu) {
                    if (start2) {
                      this.runPointActions(e);
                    }
                    if (e.type === "touchmove") {
                      pinchDown = this.pinchDown;
                      hasMoved = pinchDown[0] ? Math.sqrt(
                        // #5266
                        Math.pow(pinchDown[0].chartX - e.chartX, 2) + Math.pow(pinchDown[0].chartY - e.chartY, 2)
                      ) >= 4 : false;
                    }
                    if (pick(hasMoved, true)) {
                      this.pinch(e);
                    }
                  } else if (start2) {
                    this.reset();
                  }
                } else if (e.touches.length === 2) {
                  this.pinch(e);
                }
              };
              Pointer2.prototype.touchSelect = function(e) {
                return Boolean(this.chart.options.chart.zooming.singleTouch && e.touches && e.touches.length === 1);
              };
              Pointer2.prototype.zoomOption = function(e) {
                var chart = this.chart, options = chart.options.chart, inverted = chart.inverted;
                var zoomType = options.zooming.type || "", zoomX, zoomY;
                if (/touch/.test(e.type)) {
                  zoomType = pick(options.zooming.pinchType, zoomType);
                }
                this.zoomX = zoomX = /x/.test(zoomType);
                this.zoomY = zoomY = /y/.test(zoomType);
                this.zoomHor = zoomX && !inverted || zoomY && inverted;
                this.zoomVert = zoomY && !inverted || zoomX && inverted;
                this.hasZoom = zoomX || zoomY;
              };
              return Pointer2;
            }()
          );
          "";
          return Pointer;
        });
        _registerModule(_modules, "Core/MSPointer.js", [_modules["Core/Globals.js"], _modules["Core/Pointer.js"], _modules["Core/Utilities.js"]], function(H, Pointer, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var charts = H.charts, doc = H.doc, noop2 = H.noop, win = H.win;
          var addEvent = U.addEvent, css = U.css, objectEach = U.objectEach, pick = U.pick, removeEvent = U.removeEvent;
          var touches = {};
          var hasPointerEvent = !!win.PointerEvent;
          function getWebkitTouches() {
            var fake = [];
            fake.item = function(i) {
              return this[i];
            };
            objectEach(touches, function(touch) {
              fake.push({
                pageX: touch.pageX,
                pageY: touch.pageY,
                target: touch.target
              });
            });
            return fake;
          }
          function translateMSPointer(e, method, wktype, func) {
            var chart = charts[Pointer.hoverChartIndex || NaN];
            if ((e.pointerType === "touch" || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && chart) {
              var p = chart.pointer;
              func(e);
              p[method]({
                type: wktype,
                target: e.currentTarget,
                preventDefault: noop2,
                touches: getWebkitTouches()
              });
            }
          }
          var MSPointer = (
            /** @class */
            function(_super) {
              __extends(MSPointer2, _super);
              function MSPointer2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              MSPointer2.isRequired = function() {
                return !!(!H.hasTouch && (win.PointerEvent || win.MSPointerEvent));
              };
              MSPointer2.prototype.batchMSEvents = function(fn) {
                fn(this.chart.container, hasPointerEvent ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
                fn(this.chart.container, hasPointerEvent ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
                fn(doc, hasPointerEvent ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
              };
              MSPointer2.prototype.destroy = function() {
                this.batchMSEvents(removeEvent);
                _super.prototype.destroy.call(this);
              };
              MSPointer2.prototype.init = function(chart, options) {
                _super.prototype.init.call(this, chart, options);
                if (this.hasZoom) {
                  css(chart.container, {
                    "-ms-touch-action": "none",
                    "touch-action": "none"
                  });
                }
              };
              MSPointer2.prototype.onContainerPointerDown = function(e) {
                translateMSPointer(e, "onContainerTouchStart", "touchstart", function(e2) {
                  touches[e2.pointerId] = {
                    pageX: e2.pageX,
                    pageY: e2.pageY,
                    target: e2.currentTarget
                  };
                });
              };
              MSPointer2.prototype.onContainerPointerMove = function(e) {
                translateMSPointer(e, "onContainerTouchMove", "touchmove", function(e2) {
                  touches[e2.pointerId] = { pageX: e2.pageX, pageY: e2.pageY };
                  if (!touches[e2.pointerId].target) {
                    touches[e2.pointerId].target = e2.currentTarget;
                  }
                });
              };
              MSPointer2.prototype.onDocumentPointerUp = function(e) {
                translateMSPointer(e, "onDocumentTouchEnd", "touchend", function(e2) {
                  delete touches[e2.pointerId];
                });
              };
              MSPointer2.prototype.setDOMEvents = function() {
                var tooltip = this.chart.tooltip;
                _super.prototype.setDOMEvents.call(this);
                if (this.hasZoom || pick(tooltip && tooltip.options.followTouchMove, true)) {
                  this.batchMSEvents(addEvent);
                }
              };
              return MSPointer2;
            }(Pointer)
          );
          return MSPointer;
        });
        _registerModule(_modules, "Core/Legend/Legend.js", [_modules["Core/Animation/AnimationUtilities.js"], _modules["Core/FormatUtilities.js"], _modules["Core/Globals.js"], _modules["Core/Series/Point.js"], _modules["Core/Renderer/RendererUtilities.js"], _modules["Core/Utilities.js"]], function(A, F, H, Point, R, U) {
          var animObject = A.animObject, setAnimation = A.setAnimation;
          var format3 = F.format;
          var isFirefox = H.isFirefox, marginNames = H.marginNames, win = H.win;
          var distribute = R.distribute;
          var addEvent = U.addEvent, createElement = U.createElement, css = U.css, defined = U.defined, discardElement = U.discardElement, find2 = U.find, fireEvent = U.fireEvent, isNumber = U.isNumber, merge = U.merge, pick = U.pick, relativeLength = U.relativeLength, stableSort = U.stableSort, syncTimeout = U.syncTimeout, wrap = U.wrap;
          var Legend = (
            /** @class */
            function() {
              function Legend2(chart, options) {
                this.allItems = [];
                this.box = void 0;
                this.contentGroup = void 0;
                this.display = false;
                this.group = void 0;
                this.initialItemY = 0;
                this.itemHeight = 0;
                this.itemMarginBottom = 0;
                this.itemMarginTop = 0;
                this.itemX = 0;
                this.itemY = 0;
                this.lastItemY = 0;
                this.lastLineHeight = 0;
                this.legendHeight = 0;
                this.legendWidth = 0;
                this.maxItemWidth = 0;
                this.maxLegendWidth = 0;
                this.offsetWidth = 0;
                this.options = void 0;
                this.padding = 0;
                this.pages = [];
                this.proximate = false;
                this.scrollGroup = void 0;
                this.symbolHeight = 0;
                this.symbolWidth = 0;
                this.titleHeight = 0;
                this.totalItemWidth = 0;
                this.widthOption = 0;
                this.chart = chart;
                this.init(chart, options);
              }
              Legend2.prototype.init = function(chart, options) {
                this.chart = chart;
                this.setOptions(options);
                if (options.enabled) {
                  this.render();
                  addEvent(this.chart, "endResize", function() {
                    this.legend.positionCheckboxes();
                  });
                  if (this.proximate) {
                    this.unchartrender = addEvent(this.chart, "render", function() {
                      this.legend.proximatePositions();
                      this.legend.positionItems();
                    });
                  } else if (this.unchartrender) {
                    this.unchartrender();
                  }
                }
              };
              Legend2.prototype.setOptions = function(options) {
                var padding = pick(options.padding, 8);
                this.options = options;
                if (!this.chart.styledMode) {
                  this.itemStyle = options.itemStyle;
                  this.itemHiddenStyle = merge(this.itemStyle, options.itemHiddenStyle);
                }
                this.itemMarginTop = options.itemMarginTop || 0;
                this.itemMarginBottom = options.itemMarginBottom || 0;
                this.padding = padding;
                this.initialItemY = padding - 5;
                this.symbolWidth = pick(options.symbolWidth, 16);
                this.pages = [];
                this.proximate = options.layout === "proximate" && !this.chart.inverted;
                this.baseline = void 0;
              };
              Legend2.prototype.update = function(options, redraw) {
                var chart = this.chart;
                this.setOptions(merge(true, this.options, options));
                this.destroy();
                chart.isDirtyLegend = chart.isDirtyBox = true;
                if (pick(redraw, true)) {
                  chart.redraw();
                }
                fireEvent(this, "afterUpdate");
              };
              Legend2.prototype.colorizeItem = function(item, visible) {
                var _a = item.legendItem || {}, group = _a.group, label = _a.label, line = _a.line, symbol = _a.symbol;
                if (group) {
                  group[visible ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
                }
                if (!this.chart.styledMode) {
                  var legend = this, options = legend.options, hiddenColor = legend.itemHiddenStyle.color, textColor = visible ? options.itemStyle.color : hiddenColor, symbolColor = visible ? item.color || hiddenColor : hiddenColor, markerOptions = item.options && item.options.marker;
                  var symbolAttr = { fill: symbolColor };
                  if (label) {
                    label.css({
                      fill: textColor,
                      color: textColor
                      // #1553, oldIE
                    });
                  }
                  if (line) {
                    line.attr({ stroke: symbolColor });
                  }
                  if (symbol) {
                    if (markerOptions && symbol.isMarker) {
                      symbolAttr = item.pointAttribs();
                      if (!visible) {
                        symbolAttr.stroke = symbolAttr.fill = hiddenColor;
                      }
                    }
                    symbol.attr(symbolAttr);
                  }
                }
                fireEvent(this, "afterColorizeItem", { item, visible });
              };
              Legend2.prototype.positionItems = function() {
                this.allItems.forEach(this.positionItem, this);
                if (!this.chart.isResizing) {
                  this.positionCheckboxes();
                }
              };
              Legend2.prototype.positionItem = function(item) {
                var _this = this;
                var legend = this, _a = item.legendItem || {}, group = _a.group, _b = _a.x, x = _b === void 0 ? 0 : _b, _c = _a.y, y = _c === void 0 ? 0 : _c, options = legend.options, symbolPadding = options.symbolPadding, ltr = !options.rtl, checkbox = item.checkbox;
                if (group && group.element) {
                  var attribs = {
                    translateX: ltr ? x : legend.legendWidth - x - 2 * symbolPadding - 4,
                    translateY: y
                  };
                  var complete = function() {
                    fireEvent(_this, "afterPositionItem", { item });
                  };
                  group[defined(group.translateY) ? "animate" : "attr"](attribs, void 0, complete);
                }
                if (checkbox) {
                  checkbox.x = x;
                  checkbox.y = y;
                }
              };
              Legend2.prototype.destroyItem = function(item) {
                var checkbox = item.checkbox, legendItem = item.legendItem || {};
                for (var _i = 0, _a = ["group", "label", "line", "symbol"]; _i < _a.length; _i++) {
                  var key = _a[_i];
                  if (legendItem[key]) {
                    legendItem[key] = legendItem[key].destroy();
                  }
                }
                if (checkbox) {
                  discardElement(checkbox);
                }
                item.legendItem = void 0;
              };
              Legend2.prototype.destroy = function() {
                var legend = this;
                for (var _i = 0, _a = this.getAllItems(); _i < _a.length; _i++) {
                  var item = _a[_i];
                  this.destroyItem(item);
                }
                for (var _b = 0, _c = [
                  "clipRect",
                  "up",
                  "down",
                  "pager",
                  "nav",
                  "box",
                  "title",
                  "group"
                ]; _b < _c.length; _b++) {
                  var key = _c[_b];
                  if (legend[key]) {
                    legend[key] = legend[key].destroy();
                  }
                }
                this.display = null;
              };
              Legend2.prototype.positionCheckboxes = function() {
                var alignAttr = this.group && this.group.alignAttr, clipHeight = this.clipHeight || this.legendHeight, titleHeight = this.titleHeight;
                var translateY;
                if (alignAttr) {
                  translateY = alignAttr.translateY;
                  this.allItems.forEach(function(item) {
                    var checkbox = item.checkbox;
                    var top;
                    if (checkbox) {
                      top = translateY + titleHeight + checkbox.y + (this.scrollOffset || 0) + 3;
                      css(checkbox, {
                        left: alignAttr.translateX + item.checkboxOffset + checkbox.x - 20 + "px",
                        top: top + "px",
                        display: this.proximate || top > translateY - 6 && top < translateY + clipHeight - 6 ? "" : "none"
                      });
                    }
                  }, this);
                }
              };
              Legend2.prototype.renderTitle = function() {
                var options = this.options, padding = this.padding, titleOptions = options.title;
                var bBox, titleHeight = 0;
                if (titleOptions.text) {
                  if (!this.title) {
                    this.title = this.chart.renderer.label(titleOptions.text, padding - 3, padding - 4, void 0, void 0, void 0, options.useHTML, void 0, "legend-title").attr({ zIndex: 1 });
                    if (!this.chart.styledMode) {
                      this.title.css(titleOptions.style);
                    }
                    this.title.add(this.group);
                  }
                  if (!titleOptions.width) {
                    this.title.css({
                      width: this.maxLegendWidth + "px"
                    });
                  }
                  bBox = this.title.getBBox();
                  titleHeight = bBox.height;
                  this.offsetWidth = bBox.width;
                  this.contentGroup.attr({ translateY: titleHeight });
                }
                this.titleHeight = titleHeight;
              };
              Legend2.prototype.setText = function(item) {
                var options = this.options;
                item.legendItem.label.attr({
                  text: options.labelFormat ? format3(options.labelFormat, item, this.chart) : options.labelFormatter.call(item)
                });
              };
              Legend2.prototype.renderItem = function(item) {
                var legend = this, legendItem = item.legendItem = item.legendItem || {}, chart = legend.chart, renderer = chart.renderer, options = legend.options, horizontal = options.layout === "horizontal", symbolWidth = legend.symbolWidth, symbolPadding = options.symbolPadding || 0, itemStyle = legend.itemStyle, itemHiddenStyle = legend.itemHiddenStyle, itemDistance = horizontal ? pick(options.itemDistance, 20) : 0, ltr = !options.rtl, isSeries = !item.series, series = !isSeries && item.series.drawLegendSymbol ? item.series : item, seriesOptions = series.options, showCheckbox = legend.createCheckboxForItem && seriesOptions && seriesOptions.showCheckbox, useHTML = options.useHTML, itemClassName = item.options.className;
                var label = legendItem.label, itemExtraWidth = symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);
                if (!label) {
                  legendItem.group = renderer.g("legend-item").addClass("highcharts-" + series.type + "-series highcharts-color-" + item.colorIndex + (itemClassName ? " " + itemClassName : "") + (isSeries ? " highcharts-series-" + item.index : "")).attr({ zIndex: 1 }).add(legend.scrollGroup);
                  legendItem.label = label = renderer.text("", ltr ? symbolWidth + symbolPadding : -symbolPadding, legend.baseline || 0, useHTML);
                  if (!chart.styledMode) {
                    label.css(merge(item.visible ? itemStyle : itemHiddenStyle));
                  }
                  label.attr({
                    align: ltr ? "left" : "right",
                    zIndex: 2
                  }).add(legendItem.group);
                  if (!legend.baseline) {
                    legend.fontMetrics = renderer.fontMetrics(chart.styledMode ? 12 : itemStyle.fontSize, label);
                    legend.baseline = legend.fontMetrics.f + 3 + legend.itemMarginTop;
                    label.attr("y", legend.baseline);
                    legend.symbolHeight = options.symbolHeight || legend.fontMetrics.f;
                    if (options.squareSymbol) {
                      legend.symbolWidth = pick(options.symbolWidth, Math.max(legend.symbolHeight, 16));
                      itemExtraWidth = legend.symbolWidth + symbolPadding + itemDistance + (showCheckbox ? 20 : 0);
                      if (ltr) {
                        label.attr("x", legend.symbolWidth + symbolPadding);
                      }
                    }
                  }
                  series.drawLegendSymbol(legend, item);
                  if (legend.setItemEvents) {
                    legend.setItemEvents(item, label, useHTML);
                  }
                }
                if (showCheckbox && !item.checkbox && legend.createCheckboxForItem) {
                  legend.createCheckboxForItem(item);
                }
                legend.colorizeItem(item, item.visible);
                if (chart.styledMode || !itemStyle.width) {
                  label.css({
                    width: (options.itemWidth || legend.widthOption || chart.spacingBox.width) - itemExtraWidth + "px"
                  });
                }
                legend.setText(item);
                var bBox = label.getBBox();
                var fontMetricsH = legend.fontMetrics && legend.fontMetrics.h || 0;
                item.itemWidth = item.checkboxOffset = options.itemWidth || legendItem.labelWidth || bBox.width + itemExtraWidth;
                legend.maxItemWidth = Math.max(legend.maxItemWidth, item.itemWidth);
                legend.totalItemWidth += item.itemWidth;
                legend.itemHeight = item.itemHeight = Math.round(legendItem.labelHeight || // use bBox for multiline (#16398)
                (bBox.height > fontMetricsH * 1.5 ? bBox.height : fontMetricsH));
              };
              Legend2.prototype.layoutItem = function(item) {
                var options = this.options, padding = this.padding, horizontal = options.layout === "horizontal", itemHeight = item.itemHeight, itemMarginBottom = this.itemMarginBottom, itemMarginTop = this.itemMarginTop, itemDistance = horizontal ? pick(options.itemDistance, 20) : 0, maxLegendWidth = this.maxLegendWidth, itemWidth = options.alignColumns && this.totalItemWidth > maxLegendWidth ? this.maxItemWidth : item.itemWidth, legendItem = item.legendItem || {};
                if (horizontal && this.itemX - padding + itemWidth > maxLegendWidth) {
                  this.itemX = padding;
                  if (this.lastLineHeight) {
                    this.itemY += itemMarginTop + this.lastLineHeight + itemMarginBottom;
                  }
                  this.lastLineHeight = 0;
                }
                this.lastItemY = itemMarginTop + this.itemY + itemMarginBottom;
                this.lastLineHeight = Math.max(
                  // #915
                  itemHeight,
                  this.lastLineHeight
                );
                legendItem.x = this.itemX;
                legendItem.y = this.itemY;
                if (horizontal) {
                  this.itemX += itemWidth;
                } else {
                  this.itemY += itemMarginTop + itemHeight + itemMarginBottom;
                  this.lastLineHeight = itemHeight;
                }
                this.offsetWidth = this.widthOption || Math.max((horizontal ? this.itemX - padding - (item.checkbox ? (
                  // decrease by itemDistance only when no checkbox #4853
                  0
                ) : itemDistance) : itemWidth) + padding, this.offsetWidth);
              };
              Legend2.prototype.getAllItems = function() {
                var allItems = [];
                this.chart.series.forEach(function(series) {
                  var seriesOptions = series && series.options;
                  if (series && pick(seriesOptions.showInLegend, !defined(seriesOptions.linkedTo) ? void 0 : false, true)) {
                    allItems = allItems.concat((series.legendItem || {}).labels || (seriesOptions.legendType === "point" ? series.data : series));
                  }
                });
                fireEvent(this, "afterGetAllItems", { allItems });
                return allItems;
              };
              Legend2.prototype.getAlignment = function() {
                var options = this.options;
                if (this.proximate) {
                  return options.align.charAt(0) + "tv";
                }
                return options.floating ? "" : options.align.charAt(0) + options.verticalAlign.charAt(0) + options.layout.charAt(0);
              };
              Legend2.prototype.adjustMargins = function(margin, spacing) {
                var chart = this.chart, options = this.options, alignment = this.getAlignment();
                if (alignment) {
                  [
                    /(lth|ct|rth)/,
                    /(rtv|rm|rbv)/,
                    /(rbh|cb|lbh)/,
                    /(lbv|lm|ltv)/
                  ].forEach(function(alignments, side) {
                    if (alignments.test(alignment) && !defined(margin[side])) {
                      chart[marginNames[side]] = Math.max(chart[marginNames[side]], chart.legend[(side + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][side] * options[side % 2 ? "x" : "y"] + pick(options.margin, 12) + spacing[side] + (chart.titleOffset[side] || 0));
                    }
                  });
                }
              };
              Legend2.prototype.proximatePositions = function() {
                var chart = this.chart, boxes = [], alignLeft = this.options.align === "left";
                this.allItems.forEach(function(item) {
                  var lastPoint, height, useFirstPoint = alignLeft, target, top;
                  if (item.yAxis) {
                    if (item.xAxis.options.reversed) {
                      useFirstPoint = !useFirstPoint;
                    }
                    if (item.points) {
                      lastPoint = find2(useFirstPoint ? item.points : item.points.slice(0).reverse(), function(item2) {
                        return isNumber(item2.plotY);
                      });
                    }
                    height = this.itemMarginTop + item.legendItem.label.getBBox().height + this.itemMarginBottom;
                    top = item.yAxis.top - chart.plotTop;
                    if (item.visible) {
                      target = lastPoint ? lastPoint.plotY : item.yAxis.height;
                      target += top - 0.3 * height;
                    } else {
                      target = top + item.yAxis.height;
                    }
                    boxes.push({
                      target,
                      size: height,
                      item
                    });
                  }
                }, this);
                var legendItem;
                for (var _i = 0, _a = distribute(boxes, chart.plotHeight); _i < _a.length; _i++) {
                  var box = _a[_i];
                  legendItem = box.item.legendItem || {};
                  if (isNumber(box.pos)) {
                    legendItem.y = chart.plotTop - chart.spacing[0] + box.pos;
                  }
                }
              };
              Legend2.prototype.render = function() {
                var legend = this, chart = legend.chart, renderer = chart.renderer, options = legend.options, padding = legend.padding, allItems = legend.getAllItems();
                var display, legendWidth, legendHeight, legendGroup = legend.group, allowedWidth, box = legend.box;
                legend.itemX = padding;
                legend.itemY = legend.initialItemY;
                legend.offsetWidth = 0;
                legend.lastItemY = 0;
                legend.widthOption = relativeLength(options.width, chart.spacingBox.width - padding);
                allowedWidth = chart.spacingBox.width - 2 * padding - options.x;
                if (["rm", "lm"].indexOf(legend.getAlignment().substring(0, 2)) > -1) {
                  allowedWidth /= 2;
                }
                legend.maxLegendWidth = legend.widthOption || allowedWidth;
                if (!legendGroup) {
                  legend.group = legendGroup = renderer.g("legend").addClass(options.className || "").attr({ zIndex: 7 }).add();
                  legend.contentGroup = renderer.g().attr({ zIndex: 1 }).add(legendGroup);
                  legend.scrollGroup = renderer.g().add(legend.contentGroup);
                }
                legend.renderTitle();
                stableSort(allItems, function(a, b) {
                  return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
                });
                if (options.reversed) {
                  allItems.reverse();
                }
                legend.allItems = allItems;
                legend.display = display = !!allItems.length;
                legend.lastLineHeight = 0;
                legend.maxItemWidth = 0;
                legend.totalItemWidth = 0;
                legend.itemHeight = 0;
                allItems.forEach(legend.renderItem, legend);
                allItems.forEach(legend.layoutItem, legend);
                legendWidth = (legend.widthOption || legend.offsetWidth) + padding;
                legendHeight = legend.lastItemY + legend.lastLineHeight + legend.titleHeight;
                legendHeight = legend.handleOverflow(legendHeight);
                legendHeight += padding;
                if (!box) {
                  legend.box = box = renderer.rect().addClass("highcharts-legend-box").attr({
                    r: options.borderRadius
                  }).add(legendGroup);
                }
                if (!chart.styledMode) {
                  box.attr({
                    stroke: options.borderColor,
                    "stroke-width": options.borderWidth || 0,
                    fill: options.backgroundColor || "none"
                  }).shadow(options.shadow);
                }
                if (legendWidth > 0 && legendHeight > 0) {
                  box[box.placed ? "animate" : "attr"](box.crisp.call({}, {
                    x: 0,
                    y: 0,
                    width: legendWidth,
                    height: legendHeight
                  }, box.strokeWidth()));
                }
                legendGroup[display ? "show" : "hide"]();
                if (chart.styledMode && legendGroup.getStyle("display") === "none") {
                  legendWidth = legendHeight = 0;
                }
                legend.legendWidth = legendWidth;
                legend.legendHeight = legendHeight;
                if (display) {
                  legend.align();
                }
                if (!this.proximate) {
                  this.positionItems();
                }
                fireEvent(this, "afterRender");
              };
              Legend2.prototype.align = function(alignTo) {
                if (alignTo === void 0) {
                  alignTo = this.chart.spacingBox;
                }
                var chart = this.chart, options = this.options;
                var y = alignTo.y;
                if (/(lth|ct|rth)/.test(this.getAlignment()) && chart.titleOffset[0] > 0) {
                  y += chart.titleOffset[0];
                } else if (/(lbh|cb|rbh)/.test(this.getAlignment()) && chart.titleOffset[2] > 0) {
                  y -= chart.titleOffset[2];
                }
                if (y !== alignTo.y) {
                  alignTo = merge(alignTo, { y });
                }
                if (!chart.hasRendered) {
                  this.group.placed = false;
                }
                this.group.align(merge(options, {
                  width: this.legendWidth,
                  height: this.legendHeight,
                  verticalAlign: this.proximate ? "top" : options.verticalAlign
                }), true, alignTo);
              };
              Legend2.prototype.handleOverflow = function(legendHeight) {
                var legend = this, chart = this.chart, renderer = chart.renderer, options = this.options, optionsY = options.y, alignTop = options.verticalAlign === "top", padding = this.padding, maxHeight = options.maxHeight, navOptions = options.navigation, animation = pick(
                  navOptions.animation,
                  true
                ), arrowSize = navOptions.arrowSize || 12, pages = this.pages, allItems = this.allItems, clipToHeight = function(height) {
                  if (typeof height === "number") {
                    clipRect.attr({
                      height
                    });
                  } else if (clipRect) {
                    legend.clipRect = clipRect.destroy();
                    legend.contentGroup.clip();
                  }
                  if (legend.contentGroup.div) {
                    legend.contentGroup.div.style.clip = height ? "rect(" + padding + "px,9999px," + (padding + height) + "px,0)" : "auto";
                  }
                }, addTracker = function(key) {
                  legend[key] = renderer.circle(0, 0, arrowSize * 1.3).translate(arrowSize / 2, arrowSize / 2).add(nav);
                  if (!chart.styledMode) {
                    legend[key].attr("fill", "rgba(0,0,0,0.0001)");
                  }
                  return legend[key];
                };
                var clipHeight, lastY, legendItem, spaceHeight = chart.spacingBox.height + (alignTop ? -optionsY : optionsY) - padding, nav = this.nav, clipRect = this.clipRect;
                if (options.layout === "horizontal" && options.verticalAlign !== "middle" && !options.floating) {
                  spaceHeight /= 2;
                }
                if (maxHeight) {
                  spaceHeight = Math.min(spaceHeight, maxHeight);
                }
                pages.length = 0;
                if (legendHeight && spaceHeight > 0 && legendHeight > spaceHeight && navOptions.enabled !== false) {
                  this.clipHeight = clipHeight = Math.max(spaceHeight - 20 - this.titleHeight - padding, 0);
                  this.currentPage = pick(this.currentPage, 1);
                  this.fullHeight = legendHeight;
                  allItems.forEach(function(item, i) {
                    legendItem = item.legendItem || {};
                    var y = legendItem.y || 0, h3 = Math.round(legendItem.label.getBBox().height);
                    var len = pages.length;
                    if (!len || y - pages[len - 1] > clipHeight && (lastY || y) !== pages[len - 1]) {
                      pages.push(lastY || y);
                      len++;
                    }
                    legendItem.pageIx = len - 1;
                    if (lastY) {
                      (allItems[i - 1].legendItem || {}).pageIx = len - 1;
                    }
                    if (
                      // check the last item
                      i === allItems.length - 1 && // if adding next page is needed
                      y + h3 - pages[len - 1] > clipHeight && // and will fully fit inside a new page
                      h3 <= clipHeight
                    ) {
                      pages.push(y);
                      legendItem.pageIx = len;
                    }
                    if (y !== lastY) {
                      lastY = y;
                    }
                  });
                  if (!clipRect) {
                    clipRect = legend.clipRect = renderer.clipRect(0, padding, 9999, 0);
                    legend.contentGroup.clip(clipRect);
                  }
                  clipToHeight(clipHeight);
                  if (!nav) {
                    this.nav = nav = renderer.g().attr({ zIndex: 1 }).add(this.group);
                    this.up = renderer.symbol("triangle", 0, 0, arrowSize, arrowSize).add(nav);
                    addTracker("upTracker").on("click", function() {
                      legend.scroll(-1, animation);
                    });
                    this.pager = renderer.text("", 15, 10).addClass("highcharts-legend-navigation");
                    if (!chart.styledMode && navOptions.style) {
                      this.pager.css(navOptions.style);
                    }
                    this.pager.add(nav);
                    this.down = renderer.symbol("triangle-down", 0, 0, arrowSize, arrowSize).add(nav);
                    addTracker("downTracker").on("click", function() {
                      legend.scroll(1, animation);
                    });
                  }
                  legend.scroll(0);
                  legendHeight = spaceHeight;
                } else if (nav) {
                  clipToHeight();
                  this.nav = nav.destroy();
                  this.scrollGroup.attr({
                    translateY: 1
                  });
                  this.clipHeight = 0;
                }
                return legendHeight;
              };
              Legend2.prototype.scroll = function(scrollBy, animation) {
                var _this = this;
                var chart = this.chart, pages = this.pages, pageCount = pages.length, clipHeight = this.clipHeight, navOptions = this.options.navigation, pager = this.pager, padding = this.padding;
                var currentPage = this.currentPage + scrollBy;
                if (currentPage > pageCount) {
                  currentPage = pageCount;
                }
                if (currentPage > 0) {
                  if (typeof animation !== "undefined") {
                    setAnimation(animation, chart);
                  }
                  this.nav.attr({
                    translateX: padding,
                    translateY: clipHeight + this.padding + 7 + this.titleHeight,
                    visibility: "inherit"
                  });
                  [this.up, this.upTracker].forEach(function(elem) {
                    elem.attr({
                      "class": currentPage === 1 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                    });
                  });
                  pager.attr({
                    text: currentPage + "/" + pageCount
                  });
                  [this.down, this.downTracker].forEach(function(elem) {
                    elem.attr({
                      // adjust to text width
                      x: 18 + this.pager.getBBox().width,
                      "class": currentPage === pageCount ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active"
                    });
                  }, this);
                  if (!chart.styledMode) {
                    this.up.attr({
                      fill: currentPage === 1 ? navOptions.inactiveColor : navOptions.activeColor
                    });
                    this.upTracker.css({
                      cursor: currentPage === 1 ? "default" : "pointer"
                    });
                    this.down.attr({
                      fill: currentPage === pageCount ? navOptions.inactiveColor : navOptions.activeColor
                    });
                    this.downTracker.css({
                      cursor: currentPage === pageCount ? "default" : "pointer"
                    });
                  }
                  this.scrollOffset = -pages[currentPage - 1] + this.initialItemY;
                  this.scrollGroup.animate({
                    translateY: this.scrollOffset
                  });
                  this.currentPage = currentPage;
                  this.positionCheckboxes();
                  var animOptions = animObject(pick(
                    animation,
                    chart.renderer.globalAnimation,
                    true
                  ));
                  syncTimeout(function() {
                    fireEvent(_this, "afterScroll", { currentPage });
                  }, animOptions.duration);
                }
              };
              Legend2.prototype.setItemEvents = function(item, legendLabel, useHTML) {
                var legend = this, legendItem = item.legendItem || {}, boxWrapper = legend.chart.renderer.boxWrapper, isPoint = item instanceof Point, activeClass = "highcharts-legend-" + (isPoint ? "point" : "series") + "-active", styledMode = legend.chart.styledMode, legendElements = useHTML ? [
                  legendLabel,
                  legendItem.symbol
                ] : [legendItem.group];
                var setOtherItemsState = function(state) {
                  legend.allItems.forEach(function(otherItem) {
                    if (item !== otherItem) {
                      [otherItem].concat(otherItem.linkedSeries || []).forEach(function(otherItem2) {
                        otherItem2.setState(state, !isPoint);
                      });
                    }
                  });
                };
                for (var _i = 0, legendElements_1 = legendElements; _i < legendElements_1.length; _i++) {
                  var element = legendElements_1[_i];
                  if (element) {
                    element.on("mouseover", function() {
                      if (item.visible) {
                        setOtherItemsState("inactive");
                      }
                      item.setState("hover");
                      if (item.visible) {
                        boxWrapper.addClass(activeClass);
                      }
                      if (!styledMode) {
                        legendLabel.css(legend.options.itemHoverStyle);
                      }
                    }).on("mouseout", function() {
                      if (!legend.chart.styledMode) {
                        legendLabel.css(merge(item.visible ? legend.itemStyle : legend.itemHiddenStyle));
                      }
                      setOtherItemsState("");
                      boxWrapper.removeClass(activeClass);
                      item.setState();
                    }).on("click", function(event) {
                      var strLegendItemClick = "legendItemClick", fnLegendItemClick = function() {
                        if (item.setVisible) {
                          item.setVisible();
                        }
                        setOtherItemsState(item.visible ? "inactive" : "");
                      };
                      boxWrapper.removeClass(activeClass);
                      event = {
                        browserEvent: event
                      };
                      if (item.firePointEvent) {
                        item.firePointEvent(strLegendItemClick, event, fnLegendItemClick);
                      } else {
                        fireEvent(item, strLegendItemClick, event, fnLegendItemClick);
                      }
                    });
                  }
                }
              };
              Legend2.prototype.createCheckboxForItem = function(item) {
                var legend = this;
                item.checkbox = createElement("input", {
                  type: "checkbox",
                  className: "highcharts-legend-checkbox",
                  checked: item.selected,
                  defaultChecked: item.selected
                  // required by IE7
                }, legend.options.itemCheckboxStyle, legend.chart.container);
                addEvent(item.checkbox, "click", function(event) {
                  var target = event.target;
                  fireEvent(item.series || item, "checkboxClick", {
                    checked: target.checked,
                    item
                  }, function() {
                    item.select();
                  });
                });
              };
              return Legend2;
            }()
          );
          "";
          return Legend;
        });
        _registerModule(_modules, "Core/Series/SeriesRegistry.js", [_modules["Core/Globals.js"], _modules["Core/Defaults.js"], _modules["Core/Series/Point.js"], _modules["Core/Utilities.js"]], function(H, D, Point, U) {
          var defaultOptions = D.defaultOptions;
          var extendClass = U.extendClass, merge = U.merge;
          var SeriesRegistry;
          (function(SeriesRegistry2) {
            SeriesRegistry2.seriesTypes = H.seriesTypes;
            function registerSeriesType(seriesType2, SeriesClass) {
              var defaultPlotOptions = defaultOptions.plotOptions || {}, seriesOptions = SeriesClass.defaultOptions, seriesProto = SeriesClass.prototype;
              seriesProto.type = seriesType2;
              if (!seriesProto.pointClass) {
                seriesProto.pointClass = Point;
              }
              if (seriesOptions) {
                defaultPlotOptions[seriesType2] = seriesOptions;
              }
              SeriesRegistry2.seriesTypes[seriesType2] = SeriesClass;
            }
            SeriesRegistry2.registerSeriesType = registerSeriesType;
            function seriesType(type, parent, options, seriesProto, pointProto) {
              var defaultPlotOptions = defaultOptions.plotOptions || {};
              parent = parent || "";
              defaultPlotOptions[type] = merge(defaultPlotOptions[parent], options);
              registerSeriesType(type, extendClass(SeriesRegistry2.seriesTypes[parent] || function() {
              }, seriesProto));
              SeriesRegistry2.seriesTypes[type].prototype.type = type;
              if (pointProto) {
                SeriesRegistry2.seriesTypes[type].prototype.pointClass = extendClass(Point, pointProto);
              }
              return SeriesRegistry2.seriesTypes[type];
            }
            SeriesRegistry2.seriesType = seriesType;
          })(SeriesRegistry || (SeriesRegistry = {}));
          return SeriesRegistry;
        });
        _registerModule(_modules, "Core/Chart/Chart.js", [_modules["Core/Animation/AnimationUtilities.js"], _modules["Core/Axis/Axis.js"], _modules["Core/Defaults.js"], _modules["Core/FormatUtilities.js"], _modules["Core/Foundation.js"], _modules["Core/Globals.js"], _modules["Core/Legend/Legend.js"], _modules["Core/MSPointer.js"], _modules["Core/Pointer.js"], _modules["Core/Renderer/RendererRegistry.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Renderer/SVG/SVGRenderer.js"], _modules["Core/Time.js"], _modules["Core/Utilities.js"], _modules["Core/Renderer/HTML/AST.js"]], function(A, Axis, D, FormatUtilities, Foundation, H, Legend, MSPointer, Pointer, RendererRegistry, SeriesRegistry, SVGRenderer, Time, U, AST) {
          var animate = A.animate, animObject = A.animObject, setAnimation = A.setAnimation;
          var defaultOptions = D.defaultOptions, defaultTime = D.defaultTime;
          var numberFormat = FormatUtilities.numberFormat;
          var registerEventOptions = Foundation.registerEventOptions;
          var charts = H.charts, doc = H.doc, marginNames = H.marginNames, svg = H.svg, win = H.win;
          var seriesTypes = SeriesRegistry.seriesTypes;
          var addEvent = U.addEvent, attr = U.attr, cleanRecursively = U.cleanRecursively, createElement = U.createElement, css = U.css, defined = U.defined, discardElement = U.discardElement, erase = U.erase, error = U.error, extend2 = U.extend, find2 = U.find, fireEvent = U.fireEvent, getStyle = U.getStyle, isArray = U.isArray, isNumber = U.isNumber, isObject = U.isObject, isString = U.isString, merge = U.merge, objectEach = U.objectEach, pick = U.pick, pInt = U.pInt, relativeLength = U.relativeLength, removeEvent = U.removeEvent, splat = U.splat, syncTimeout = U.syncTimeout, uniqueKey = U.uniqueKey;
          var Chart = (
            /** @class */
            function() {
              function Chart2(a, b, c) {
                this.axes = void 0;
                this.axisOffset = void 0;
                this.bounds = void 0;
                this.chartHeight = void 0;
                this.chartWidth = void 0;
                this.clipBox = void 0;
                this.colorCounter = void 0;
                this.container = void 0;
                this.eventOptions = void 0;
                this.index = void 0;
                this.isResizing = void 0;
                this.labelCollectors = void 0;
                this.legend = void 0;
                this.margin = void 0;
                this.numberFormatter = void 0;
                this.options = void 0;
                this.plotBox = void 0;
                this.plotHeight = void 0;
                this.plotLeft = void 0;
                this.plotTop = void 0;
                this.plotWidth = void 0;
                this.pointCount = void 0;
                this.pointer = void 0;
                this.renderer = void 0;
                this.renderTo = void 0;
                this.series = void 0;
                this.sharedClips = {};
                this.spacing = void 0;
                this.spacingBox = void 0;
                this.symbolCounter = void 0;
                this.time = void 0;
                this.titleOffset = void 0;
                this.userOptions = void 0;
                this.xAxis = void 0;
                this.yAxis = void 0;
                this.getArgs(a, b, c);
              }
              Chart2.chart = function(a, b, c) {
                return new Chart2(a, b, c);
              };
              Chart2.prototype.getArgs = function(a, b, c) {
                if (isString(a) || a.nodeName) {
                  this.renderTo = a;
                  this.init(b, c);
                } else {
                  this.init(a, b);
                }
              };
              Chart2.prototype.init = function(userOptions, callback) {
                var userPlotOptions = userOptions.plotOptions || {};
                fireEvent(this, "init", { args: arguments }, function() {
                  var options = merge(
                    defaultOptions,
                    userOptions
                  );
                  var optionsChart = options.chart;
                  objectEach(options.plotOptions, function(typeOptions, type) {
                    if (isObject(typeOptions)) {
                      typeOptions.tooltip = userPlotOptions[type] && // override by copy:
                      merge(userPlotOptions[type].tooltip) || void 0;
                    }
                  });
                  options.tooltip.userOptions = userOptions.chart && userOptions.chart.forExport && userOptions.tooltip.userOptions || userOptions.tooltip;
                  this.userOptions = userOptions;
                  this.margin = [];
                  this.spacing = [];
                  this.bounds = { h: {}, v: {} };
                  this.labelCollectors = [];
                  this.callback = callback;
                  this.isResizing = 0;
                  var zooming = optionsChart.zooming = optionsChart.zooming || {};
                  if (userOptions.chart && !userOptions.chart.zooming) {
                    zooming.resetButton = optionsChart.resetZoomButton;
                  }
                  zooming.key = pick(zooming.key, optionsChart.zoomKey);
                  zooming.pinchType = pick(zooming.pinchType, optionsChart.pinchType);
                  zooming.singleTouch = pick(zooming.singleTouch, optionsChart.zoomBySingleTouch);
                  zooming.type = pick(zooming.type, optionsChart.zoomType);
                  this.options = options;
                  this.axes = [];
                  this.series = [];
                  this.time = userOptions.time && Object.keys(userOptions.time).length ? new Time(userOptions.time) : H.time;
                  this.numberFormatter = optionsChart.numberFormatter || numberFormat;
                  this.styledMode = optionsChart.styledMode;
                  this.hasCartesianSeries = optionsChart.showAxes;
                  var chart = this;
                  chart.index = charts.length;
                  charts.push(chart);
                  H.chartCount++;
                  registerEventOptions(this, optionsChart);
                  chart.xAxis = [];
                  chart.yAxis = [];
                  chart.pointCount = chart.colorCounter = chart.symbolCounter = 0;
                  fireEvent(chart, "afterInit");
                  chart.firstRender();
                });
              };
              Chart2.prototype.initSeries = function(options) {
                var chart = this, optionsChart = chart.options.chart, type = options.type || optionsChart.type || optionsChart.defaultSeriesType, SeriesClass = seriesTypes[type];
                if (!SeriesClass) {
                  error(17, true, chart, { missingModuleFor: type });
                }
                var series = new SeriesClass();
                if (typeof series.init === "function") {
                  series.init(chart, options);
                }
                return series;
              };
              Chart2.prototype.setSeriesData = function() {
                this.getSeriesOrderByLinks().forEach(function(series) {
                  if (!series.points && !series.data && series.enabledDataSorting) {
                    series.setData(series.options.data, false);
                  }
                });
              };
              Chart2.prototype.getSeriesOrderByLinks = function() {
                return this.series.concat().sort(function(a, b) {
                  if (a.linkedSeries.length || b.linkedSeries.length) {
                    return b.linkedSeries.length - a.linkedSeries.length;
                  }
                  return 0;
                });
              };
              Chart2.prototype.orderSeries = function(fromIndex) {
                var series = this.series;
                for (var i = fromIndex || 0, iEnd = series.length; i < iEnd; ++i) {
                  if (series[i]) {
                    series[i].index = i;
                    series[i].name = series[i].getName();
                  }
                }
              };
              Chart2.prototype.isInsidePlot = function(plotX, plotY, options) {
                var _a;
                if (options === void 0) {
                  options = {};
                }
                var _b = this, inverted = _b.inverted, plotBox = _b.plotBox, plotLeft = _b.plotLeft, plotTop = _b.plotTop, scrollablePlotBox = _b.scrollablePlotBox;
                var scrollLeft = 0, scrollTop = 0;
                if (options.visiblePlotOnly && this.scrollingContainer) {
                  _a = this.scrollingContainer, scrollLeft = _a.scrollLeft, scrollTop = _a.scrollTop;
                }
                var series = options.series, box = options.visiblePlotOnly && scrollablePlotBox || plotBox, x = options.inverted ? plotY : plotX, y = options.inverted ? plotX : plotY, e = {
                  x,
                  y,
                  isInsidePlot: true,
                  options
                };
                if (!options.ignoreX) {
                  var xAxis = series && (inverted && !this.polar ? series.yAxis : series.xAxis) || {
                    pos: plotLeft,
                    len: Infinity
                  };
                  var chartX = options.paneCoordinates ? xAxis.pos + x : plotLeft + x;
                  if (!(chartX >= Math.max(scrollLeft + plotLeft, xAxis.pos) && chartX <= Math.min(scrollLeft + plotLeft + box.width, xAxis.pos + xAxis.len))) {
                    e.isInsidePlot = false;
                  }
                }
                if (!options.ignoreY && e.isInsidePlot) {
                  var yAxis = options.axis && !options.axis.isXAxis && options.axis || series && (inverted ? series.xAxis : series.yAxis) || {
                    pos: plotTop,
                    len: Infinity
                  };
                  var chartY = options.paneCoordinates ? yAxis.pos + y : plotTop + y;
                  if (!(chartY >= Math.max(scrollTop + plotTop, yAxis.pos) && chartY <= Math.min(scrollTop + plotTop + box.height, yAxis.pos + yAxis.len))) {
                    e.isInsidePlot = false;
                  }
                }
                fireEvent(this, "afterIsInsidePlot", e);
                return e.isInsidePlot;
              };
              Chart2.prototype.redraw = function(animation) {
                fireEvent(this, "beforeRedraw");
                var chart = this, axes = chart.hasCartesianSeries ? chart.axes : chart.colorAxis || [], series = chart.series, pointer = chart.pointer, legend = chart.legend, legendUserOptions = chart.userOptions.legend, renderer = chart.renderer, isHiddenChart = renderer.isHidden(), afterRedraw = [];
                var hasDirtyStacks, hasStackedSeries, i, isDirtyBox = chart.isDirtyBox, redrawLegend = chart.isDirtyLegend, serie;
                if (chart.setResponsive) {
                  chart.setResponsive(false);
                }
                setAnimation(chart.hasRendered ? animation : false, chart);
                if (isHiddenChart) {
                  chart.temporaryDisplay();
                }
                chart.layOutTitles();
                i = series.length;
                while (i--) {
                  serie = series[i];
                  if (serie.options.stacking || serie.options.centerInCategory) {
                    hasStackedSeries = true;
                    if (serie.isDirty) {
                      hasDirtyStacks = true;
                      break;
                    }
                  }
                }
                if (hasDirtyStacks) {
                  i = series.length;
                  while (i--) {
                    serie = series[i];
                    if (serie.options.stacking) {
                      serie.isDirty = true;
                    }
                  }
                }
                series.forEach(function(serie2) {
                  if (serie2.isDirty) {
                    if (serie2.options.legendType === "point") {
                      if (typeof serie2.updateTotals === "function") {
                        serie2.updateTotals();
                      }
                      redrawLegend = true;
                    } else if (legendUserOptions && (legendUserOptions.labelFormatter || legendUserOptions.labelFormat)) {
                      redrawLegend = true;
                    }
                  }
                  if (serie2.isDirtyData) {
                    fireEvent(serie2, "updatedData");
                  }
                });
                if (redrawLegend && legend && legend.options.enabled) {
                  legend.render();
                  chart.isDirtyLegend = false;
                }
                if (hasStackedSeries) {
                  chart.getStacks();
                }
                axes.forEach(function(axis) {
                  axis.updateNames();
                  axis.setScale();
                });
                chart.getMargins();
                axes.forEach(function(axis) {
                  if (axis.isDirty) {
                    isDirtyBox = true;
                  }
                });
                axes.forEach(function(axis) {
                  var key = axis.min + "," + axis.max;
                  if (axis.extKey !== key) {
                    axis.extKey = key;
                    afterRedraw.push(function() {
                      fireEvent(axis, "afterSetExtremes", extend2(axis.eventArgs, axis.getExtremes()));
                      delete axis.eventArgs;
                    });
                  }
                  if (isDirtyBox || hasStackedSeries) {
                    axis.redraw();
                  }
                });
                if (isDirtyBox) {
                  chart.drawChartBox();
                }
                fireEvent(chart, "predraw");
                series.forEach(function(serie2) {
                  if ((isDirtyBox || serie2.isDirty) && serie2.visible) {
                    serie2.redraw();
                  }
                  serie2.isDirtyData = false;
                });
                if (pointer) {
                  pointer.reset(true);
                }
                renderer.draw();
                fireEvent(chart, "redraw");
                fireEvent(chart, "render");
                if (isHiddenChart) {
                  chart.temporaryDisplay(true);
                }
                afterRedraw.forEach(function(callback) {
                  callback.call();
                });
              };
              Chart2.prototype.get = function(id2) {
                var series = this.series;
                function itemById(item) {
                  return item.id === id2 || item.options && item.options.id === id2;
                }
                var ret = (
                  // Search axes
                  find2(
                    this.axes,
                    itemById
                  ) || // Search series
                  find2(
                    this.series,
                    itemById
                  )
                );
                for (var i = 0; !ret && i < series.length; i++) {
                  ret = find2(series[i].points || [], itemById);
                }
                return ret;
              };
              Chart2.prototype.getAxes = function() {
                var chart = this, options = this.options, xAxisOptions = options.xAxis = splat(options.xAxis || {}), yAxisOptions = options.yAxis = splat(options.yAxis || {});
                fireEvent(this, "getAxes");
                xAxisOptions.forEach(function(axis, i) {
                  axis.index = i;
                  axis.isX = true;
                });
                yAxisOptions.forEach(function(axis, i) {
                  axis.index = i;
                });
                var optionsArray = xAxisOptions.concat(yAxisOptions);
                optionsArray.forEach(function(axisOptions) {
                  new Axis(chart, axisOptions);
                });
                fireEvent(this, "afterGetAxes");
              };
              Chart2.prototype.getSelectedPoints = function() {
                return this.series.reduce(function(acc, series) {
                  series.getPointsCollection().forEach(function(point) {
                    if (pick(point.selectedStaging, point.selected)) {
                      acc.push(point);
                    }
                  });
                  return acc;
                }, []);
              };
              Chart2.prototype.getSelectedSeries = function() {
                return this.series.filter(function(serie) {
                  return serie.selected;
                });
              };
              Chart2.prototype.setTitle = function(titleOptions, subtitleOptions, redraw) {
                this.applyDescription("title", titleOptions);
                this.applyDescription("subtitle", subtitleOptions);
                this.applyDescription("caption", void 0);
                this.layOutTitles(redraw);
              };
              Chart2.prototype.applyDescription = function(name, explicitOptions) {
                var chart = this;
                var style = name === "title" ? {
                  color: "#333333",
                  fontSize: this.options.isStock ? "16px" : "18px"
                  // #2944
                } : {
                  color: "#666666"
                  /* Palette.neutralColor60 */
                };
                var options = this.options[name] = merge(
                  // Default styles
                  !this.styledMode && { style },
                  this.options[name],
                  explicitOptions
                );
                var elem = this[name];
                if (elem && explicitOptions) {
                  this[name] = elem = elem.destroy();
                }
                if (options && !elem) {
                  elem = this.renderer.text(options.text, 0, 0, options.useHTML).attr({
                    align: options.align,
                    "class": "highcharts-" + name,
                    zIndex: options.zIndex || 4
                  }).add();
                  elem.update = function(updateOptions) {
                    var fn = {
                      title: "setTitle",
                      subtitle: "setSubtitle",
                      caption: "setCaption"
                    }[name];
                    chart[fn](updateOptions);
                  };
                  if (!this.styledMode) {
                    elem.css(options.style);
                  }
                  this[name] = elem;
                }
              };
              Chart2.prototype.layOutTitles = function(redraw) {
                var titleOffset = [0, 0, 0], renderer = this.renderer, spacingBox = this.spacingBox;
                ["title", "subtitle", "caption"].forEach(function(key) {
                  var title = this[key], titleOptions = this.options[key], verticalAlign = titleOptions.verticalAlign || "top", offset = key === "title" ? verticalAlign === "top" ? -3 : 0 : (
                    // Floating subtitle (#6574)
                    verticalAlign === "top" ? titleOffset[0] + 2 : 0
                  );
                  var titleSize, height;
                  if (title) {
                    if (!this.styledMode) {
                      titleSize = titleOptions.style && titleOptions.style.fontSize;
                    }
                    titleSize = renderer.fontMetrics(titleSize, title).b;
                    title.css({
                      width: (titleOptions.width || spacingBox.width + (titleOptions.widthAdjust || 0)) + "px"
                    });
                    height = Math.round(title.getBBox(titleOptions.useHTML).height);
                    title.align(extend2({
                      y: verticalAlign === "bottom" ? titleSize : offset + titleSize,
                      height
                    }, titleOptions), false, "spacingBox");
                    if (!titleOptions.floating) {
                      if (verticalAlign === "top") {
                        titleOffset[0] = Math.ceil(titleOffset[0] + height);
                      } else if (verticalAlign === "bottom") {
                        titleOffset[2] = Math.ceil(titleOffset[2] + height);
                      }
                    }
                  }
                }, this);
                if (titleOffset[0] && (this.options.title.verticalAlign || "top") === "top") {
                  titleOffset[0] += this.options.title.margin;
                }
                if (titleOffset[2] && this.options.caption.verticalAlign === "bottom") {
                  titleOffset[2] += this.options.caption.margin;
                }
                var requiresDirtyBox = !this.titleOffset || this.titleOffset.join(",") !== titleOffset.join(",");
                this.titleOffset = titleOffset;
                fireEvent(this, "afterLayOutTitles");
                if (!this.isDirtyBox && requiresDirtyBox) {
                  this.isDirtyBox = this.isDirtyLegend = requiresDirtyBox;
                  if (this.hasRendered && pick(redraw, true) && this.isDirtyBox) {
                    this.redraw();
                  }
                }
              };
              Chart2.prototype.getChartSize = function() {
                var chart = this, optionsChart = chart.options.chart, widthOption = optionsChart.width, heightOption = optionsChart.height, renderTo = chart.renderTo;
                if (!defined(widthOption)) {
                  chart.containerWidth = getStyle(renderTo, "width");
                }
                if (!defined(heightOption)) {
                  chart.containerHeight = getStyle(renderTo, "height");
                }
                chart.chartWidth = Math.max(
                  // #1393
                  0,
                  widthOption || chart.containerWidth || 600
                  // #1460
                );
                chart.chartHeight = Math.max(0, relativeLength(heightOption, chart.chartWidth) || (chart.containerHeight > 1 ? chart.containerHeight : 400));
              };
              Chart2.prototype.temporaryDisplay = function(revert) {
                var node = this.renderTo, tempStyle;
                if (!revert) {
                  while (node && node.style) {
                    if (!doc.body.contains(node) && !node.parentNode) {
                      node.hcOrigDetached = true;
                      doc.body.appendChild(node);
                    }
                    if (getStyle(node, "display", false) === "none" || node.hcOricDetached) {
                      node.hcOrigStyle = {
                        display: node.style.display,
                        height: node.style.height,
                        overflow: node.style.overflow
                      };
                      tempStyle = {
                        display: "block",
                        overflow: "hidden"
                      };
                      if (node !== this.renderTo) {
                        tempStyle.height = 0;
                      }
                      css(node, tempStyle);
                      if (!node.offsetWidth) {
                        node.style.setProperty("display", "block", "important");
                      }
                    }
                    node = node.parentNode;
                    if (node === doc.body) {
                      break;
                    }
                  }
                } else {
                  while (node && node.style) {
                    if (node.hcOrigStyle) {
                      css(node, node.hcOrigStyle);
                      delete node.hcOrigStyle;
                    }
                    if (node.hcOrigDetached) {
                      doc.body.removeChild(node);
                      node.hcOrigDetached = false;
                    }
                    node = node.parentNode;
                  }
                }
              };
              Chart2.prototype.setClassName = function(className) {
                this.container.className = "highcharts-container " + (className || "");
              };
              Chart2.prototype.getContainer = function() {
                var chart = this, options = chart.options, optionsChart = options.chart, indexAttrName = "data-highcharts-chart", containerId = uniqueKey();
                var containerStyle, renderTo = chart.renderTo;
                if (!renderTo) {
                  chart.renderTo = renderTo = optionsChart.renderTo;
                }
                if (isString(renderTo)) {
                  chart.renderTo = renderTo = doc.getElementById(renderTo);
                }
                if (!renderTo) {
                  error(13, true, chart);
                }
                var oldChartIndex = pInt(attr(
                  renderTo,
                  indexAttrName
                ));
                if (isNumber(oldChartIndex) && charts[oldChartIndex] && charts[oldChartIndex].hasRendered) {
                  charts[oldChartIndex].destroy();
                }
                attr(renderTo, indexAttrName, chart.index);
                renderTo.innerHTML = AST.emptyHTML;
                if (!optionsChart.skipClone && !renderTo.offsetWidth) {
                  chart.temporaryDisplay();
                }
                chart.getChartSize();
                var chartWidth = chart.chartWidth;
                var chartHeight = chart.chartHeight;
                css(renderTo, { overflow: "hidden" });
                if (!chart.styledMode) {
                  containerStyle = extend2({
                    position: "relative",
                    // needed for context menu (avoidscrollbars) and content
                    // overflow in IE
                    overflow: "hidden",
                    width: chartWidth + "px",
                    height: chartHeight + "px",
                    textAlign: "left",
                    lineHeight: "normal",
                    zIndex: 0,
                    "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
                    userSelect: "none",
                    "touch-action": "manipulation",
                    outline: "none"
                  }, optionsChart.style || {});
                }
                var container = createElement(
                  "div",
                  {
                    id: containerId
                  },
                  containerStyle,
                  renderTo
                );
                chart.container = container;
                chart._cursor = container.style.cursor;
                var Renderer = optionsChart.renderer || !svg ? RendererRegistry.getRendererType(optionsChart.renderer) : SVGRenderer;
                chart.renderer = new Renderer(container, chartWidth, chartHeight, void 0, optionsChart.forExport, options.exporting && options.exporting.allowHTML, chart.styledMode);
                setAnimation(void 0, chart);
                chart.setClassName(optionsChart.className);
                if (!chart.styledMode) {
                  chart.renderer.setStyle(optionsChart.style);
                } else {
                  for (var key in options.defs) {
                    this.renderer.definition(options.defs[key]);
                  }
                }
                chart.renderer.chartIndex = chart.index;
                fireEvent(this, "afterGetContainer");
              };
              Chart2.prototype.getMargins = function(skipAxes) {
                var _a = this, spacing = _a.spacing, margin = _a.margin, titleOffset = _a.titleOffset;
                this.resetMargins();
                if (titleOffset[0] && !defined(margin[0])) {
                  this.plotTop = Math.max(this.plotTop, titleOffset[0] + spacing[0]);
                }
                if (titleOffset[2] && !defined(margin[2])) {
                  this.marginBottom = Math.max(this.marginBottom, titleOffset[2] + spacing[2]);
                }
                if (this.legend && this.legend.display) {
                  this.legend.adjustMargins(margin, spacing);
                }
                fireEvent(this, "getMargins");
                if (!skipAxes) {
                  this.getAxisMargins();
                }
              };
              Chart2.prototype.getAxisMargins = function() {
                var chart = this, axisOffset = chart.axisOffset = [0, 0, 0, 0], colorAxis = chart.colorAxis, margin = chart.margin, getOffset = function(axes) {
                  axes.forEach(function(axis) {
                    if (axis.visible) {
                      axis.getOffset();
                    }
                  });
                };
                if (chart.hasCartesianSeries) {
                  getOffset(chart.axes);
                } else if (colorAxis && colorAxis.length) {
                  getOffset(colorAxis);
                }
                marginNames.forEach(function(m, side) {
                  if (!defined(margin[side])) {
                    chart[m] += axisOffset[side];
                  }
                });
                chart.setChartSize();
              };
              Chart2.prototype.reflow = function(e) {
                var chart = this, optionsChart = chart.options.chart, renderTo = chart.renderTo, hasUserSize = defined(optionsChart.width) && defined(optionsChart.height), width = optionsChart.width || getStyle(renderTo, "width"), height = optionsChart.height || getStyle(renderTo, "height"), target = e ? e.target : win;
                delete chart.pointer.chartPosition;
                if (!hasUserSize && !chart.isPrinting && width && height && (target === win || target === doc)) {
                  if (width !== chart.containerWidth || height !== chart.containerHeight) {
                    U.clearTimeout(chart.reflowTimeout);
                    chart.reflowTimeout = syncTimeout(function() {
                      if (chart.container) {
                        chart.setSize(void 0, void 0, false);
                      }
                    }, e ? 100 : 0);
                  }
                  chart.containerWidth = width;
                  chart.containerHeight = height;
                }
              };
              Chart2.prototype.setReflow = function(reflow) {
                var chart = this;
                if (reflow !== false && !this.unbindReflow) {
                  this.unbindReflow = addEvent(win, "resize", function(e) {
                    if (chart.options) {
                      chart.reflow(e);
                    }
                  });
                  addEvent(this, "destroy", this.unbindReflow);
                } else if (reflow === false && this.unbindReflow) {
                  this.unbindReflow = this.unbindReflow();
                }
              };
              Chart2.prototype.setSize = function(width, height, animation) {
                var chart = this, renderer = chart.renderer;
                chart.isResizing += 1;
                setAnimation(animation, chart);
                var globalAnimation = renderer.globalAnimation;
                chart.oldChartHeight = chart.chartHeight;
                chart.oldChartWidth = chart.chartWidth;
                if (typeof width !== "undefined") {
                  chart.options.chart.width = width;
                }
                if (typeof height !== "undefined") {
                  chart.options.chart.height = height;
                }
                chart.getChartSize();
                if (!chart.styledMode) {
                  (globalAnimation ? animate : css)(chart.container, {
                    width: chart.chartWidth + "px",
                    height: chart.chartHeight + "px"
                  }, globalAnimation);
                }
                chart.setChartSize(true);
                renderer.setSize(chart.chartWidth, chart.chartHeight, globalAnimation);
                chart.axes.forEach(function(axis) {
                  axis.isDirty = true;
                  axis.setScale();
                });
                chart.isDirtyLegend = true;
                chart.isDirtyBox = true;
                chart.layOutTitles();
                chart.getMargins();
                chart.redraw(globalAnimation);
                chart.oldChartHeight = null;
                fireEvent(chart, "resize");
                syncTimeout(function() {
                  if (chart) {
                    fireEvent(chart, "endResize", null, function() {
                      chart.isResizing -= 1;
                    });
                  }
                }, animObject(globalAnimation).duration);
              };
              Chart2.prototype.setChartSize = function(skipAxes) {
                var chart = this, inverted = chart.inverted, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, optionsChart = chart.options.chart, spacing = chart.spacing, clipOffset = chart.clipOffset;
                var plotLeft, plotTop, plotWidth, plotHeight;
                chart.plotLeft = plotLeft = Math.round(chart.plotLeft);
                chart.plotTop = plotTop = Math.round(chart.plotTop);
                chart.plotWidth = plotWidth = Math.max(0, Math.round(chartWidth - plotLeft - chart.marginRight));
                chart.plotHeight = plotHeight = Math.max(0, Math.round(chartHeight - plotTop - chart.marginBottom));
                chart.plotSizeX = inverted ? plotHeight : plotWidth;
                chart.plotSizeY = inverted ? plotWidth : plotHeight;
                chart.plotBorderWidth = optionsChart.plotBorderWidth || 0;
                chart.spacingBox = renderer.spacingBox = {
                  x: spacing[3],
                  y: spacing[0],
                  width: chartWidth - spacing[3] - spacing[1],
                  height: chartHeight - spacing[0] - spacing[2]
                };
                chart.plotBox = renderer.plotBox = {
                  x: plotLeft,
                  y: plotTop,
                  width: plotWidth,
                  height: plotHeight
                };
                var plotBorderWidth = 2 * Math.floor(chart.plotBorderWidth / 2), clipX = Math.ceil(Math.max(
                  plotBorderWidth,
                  clipOffset[3]
                ) / 2), clipY = Math.ceil(Math.max(
                  plotBorderWidth,
                  clipOffset[0]
                ) / 2);
                chart.clipBox = {
                  x: clipX,
                  y: clipY,
                  width: Math.floor(chart.plotSizeX - Math.max(plotBorderWidth, clipOffset[1]) / 2 - clipX),
                  height: Math.max(0, Math.floor(chart.plotSizeY - Math.max(plotBorderWidth, clipOffset[2]) / 2 - clipY))
                };
                if (!skipAxes) {
                  chart.axes.forEach(function(axis) {
                    axis.setAxisSize();
                    axis.setAxisTranslation();
                  });
                  renderer.alignElements();
                }
                fireEvent(chart, "afterSetChartSize", { skipAxes });
              };
              Chart2.prototype.resetMargins = function() {
                fireEvent(this, "resetMargins");
                var chart = this, chartOptions = chart.options.chart;
                ["margin", "spacing"].forEach(function splashArrays(target) {
                  var value = chartOptions[target], values = isObject(value) ? value : [
                    value,
                    value,
                    value,
                    value
                  ];
                  [
                    "Top",
                    "Right",
                    "Bottom",
                    "Left"
                  ].forEach(function(sideName, side) {
                    chart[target][side] = pick(chartOptions[target + sideName], values[side]);
                  });
                });
                marginNames.forEach(function(m, side) {
                  chart[m] = pick(chart.margin[side], chart.spacing[side]);
                });
                chart.axisOffset = [0, 0, 0, 0];
                chart.clipOffset = [0, 0, 0, 0];
              };
              Chart2.prototype.drawChartBox = function() {
                var chart = this, optionsChart = chart.options.chart, renderer = chart.renderer, chartWidth = chart.chartWidth, chartHeight = chart.chartHeight, styledMode = chart.styledMode, plotBGImage = chart.plotBGImage, chartBackgroundColor = optionsChart.backgroundColor, plotBackgroundColor = optionsChart.plotBackgroundColor, plotBackgroundImage = optionsChart.plotBackgroundImage, plotLeft = chart.plotLeft, plotTop = chart.plotTop, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotBox = chart.plotBox, clipRect = chart.clipRect, clipBox = chart.clipBox;
                var chartBackground = chart.chartBackground, plotBackground = chart.plotBackground, plotBorder = chart.plotBorder, chartBorderWidth, mgn, bgAttr, verb = "animate";
                if (!chartBackground) {
                  chart.chartBackground = chartBackground = renderer.rect().addClass("highcharts-background").add();
                  verb = "attr";
                }
                if (!styledMode) {
                  chartBorderWidth = optionsChart.borderWidth || 0;
                  mgn = chartBorderWidth + (optionsChart.shadow ? 8 : 0);
                  bgAttr = {
                    fill: chartBackgroundColor || "none"
                  };
                  if (chartBorderWidth || chartBackground["stroke-width"]) {
                    bgAttr.stroke = optionsChart.borderColor;
                    bgAttr["stroke-width"] = chartBorderWidth;
                  }
                  chartBackground.attr(bgAttr).shadow(optionsChart.shadow);
                } else {
                  chartBorderWidth = mgn = chartBackground.strokeWidth();
                }
                chartBackground[verb]({
                  x: mgn / 2,
                  y: mgn / 2,
                  width: chartWidth - mgn - chartBorderWidth % 2,
                  height: chartHeight - mgn - chartBorderWidth % 2,
                  r: optionsChart.borderRadius
                });
                verb = "animate";
                if (!plotBackground) {
                  verb = "attr";
                  chart.plotBackground = plotBackground = renderer.rect().addClass("highcharts-plot-background").add();
                }
                plotBackground[verb](plotBox);
                if (!styledMode) {
                  plotBackground.attr({
                    fill: plotBackgroundColor || "none"
                  }).shadow(optionsChart.plotShadow);
                  if (plotBackgroundImage) {
                    if (!plotBGImage) {
                      chart.plotBGImage = renderer.image(plotBackgroundImage, plotLeft, plotTop, plotWidth, plotHeight).add();
                    } else {
                      if (plotBackgroundImage !== plotBGImage.attr("href")) {
                        plotBGImage.attr("href", plotBackgroundImage);
                      }
                      plotBGImage.animate(plotBox);
                    }
                  }
                }
                if (!clipRect) {
                  chart.clipRect = renderer.clipRect(clipBox);
                } else {
                  clipRect.animate({
                    width: clipBox.width,
                    height: clipBox.height
                  });
                }
                verb = "animate";
                if (!plotBorder) {
                  verb = "attr";
                  chart.plotBorder = plotBorder = renderer.rect().addClass("highcharts-plot-border").attr({
                    zIndex: 1
                    // Above the grid
                  }).add();
                }
                if (!styledMode) {
                  plotBorder.attr({
                    stroke: optionsChart.plotBorderColor,
                    "stroke-width": optionsChart.plotBorderWidth || 0,
                    fill: "none"
                  });
                }
                plotBorder[verb](plotBorder.crisp({
                  x: plotLeft,
                  y: plotTop,
                  width: plotWidth,
                  height: plotHeight
                }, -plotBorder.strokeWidth()));
                chart.isDirtyBox = false;
                fireEvent(this, "afterDrawChartBox");
              };
              Chart2.prototype.propFromSeries = function() {
                var chart = this, optionsChart = chart.options.chart, seriesOptions = chart.options.series;
                var i, klass, value;
                ["inverted", "angular", "polar"].forEach(function(key) {
                  klass = seriesTypes[optionsChart.type || optionsChart.defaultSeriesType];
                  value = // It is set in the options:
                  optionsChart[key] || // The default series class:
                  klass && klass.prototype[key];
                  i = seriesOptions && seriesOptions.length;
                  while (!value && i--) {
                    klass = seriesTypes[seriesOptions[i].type];
                    if (klass && klass.prototype[key]) {
                      value = true;
                    }
                  }
                  chart[key] = value;
                });
              };
              Chart2.prototype.linkSeries = function() {
                var chart = this, chartSeries = chart.series;
                chartSeries.forEach(function(series) {
                  series.linkedSeries.length = 0;
                });
                chartSeries.forEach(function(series) {
                  var linkedTo = series.options.linkedTo;
                  if (isString(linkedTo)) {
                    if (linkedTo === ":previous") {
                      linkedTo = chart.series[series.index - 1];
                    } else {
                      linkedTo = chart.get(linkedTo);
                    }
                    if (linkedTo && linkedTo.linkedParent !== series) {
                      linkedTo.linkedSeries.push(series);
                      series.linkedParent = linkedTo;
                      if (linkedTo.enabledDataSorting) {
                        series.setDataSortingOptions();
                      }
                      series.visible = pick(series.options.visible, linkedTo.options.visible, series.visible);
                    }
                  }
                });
                fireEvent(this, "afterLinkSeries");
              };
              Chart2.prototype.renderSeries = function() {
                this.series.forEach(function(serie) {
                  serie.translate();
                  serie.render();
                });
              };
              Chart2.prototype.renderLabels = function() {
                var chart = this, labels = chart.options.labels;
                if (labels.items) {
                  labels.items.forEach(function(label) {
                    var style = extend2(
                      labels.style,
                      label.style
                    ), x = pInt(style.left) + chart.plotLeft, y = pInt(style.top) + chart.plotTop + 12;
                    delete style.left;
                    delete style.top;
                    chart.renderer.text(label.html, x, y).attr({ zIndex: 2 }).css(style).add();
                  });
                }
              };
              Chart2.prototype.render = function() {
                var chart = this, axes = chart.axes, colorAxis = chart.colorAxis, renderer = chart.renderer, options = chart.options, renderAxes = function(axes2) {
                  axes2.forEach(function(axis) {
                    if (axis.visible) {
                      axis.render();
                    }
                  });
                };
                var correction = 0;
                chart.setTitle();
                chart.legend = new Legend(chart, options.legend);
                if (chart.getStacks) {
                  chart.getStacks();
                }
                chart.getMargins(true);
                chart.setChartSize();
                var tempWidth = chart.plotWidth;
                axes.some(function(axis) {
                  if (axis.horiz && axis.visible && axis.options.labels.enabled && axis.series.length) {
                    correction = 21;
                    return true;
                  }
                });
                chart.plotHeight = Math.max(chart.plotHeight - correction, 0);
                var tempHeight = chart.plotHeight;
                axes.forEach(function(axis) {
                  axis.setScale();
                });
                chart.getAxisMargins();
                var redoHorizontal = tempWidth / chart.plotWidth > 1.1;
                var redoVertical = tempHeight / chart.plotHeight > 1.05;
                if (redoHorizontal || redoVertical) {
                  axes.forEach(function(axis) {
                    if (axis.horiz && redoHorizontal || !axis.horiz && redoVertical) {
                      axis.setTickInterval(true);
                    }
                  });
                  chart.getMargins();
                }
                chart.drawChartBox();
                if (chart.hasCartesianSeries) {
                  renderAxes(axes);
                } else if (colorAxis && colorAxis.length) {
                  renderAxes(colorAxis);
                }
                if (!chart.seriesGroup) {
                  chart.seriesGroup = renderer.g("series-group").attr({ zIndex: 3 }).add();
                }
                chart.renderSeries();
                chart.renderLabels();
                chart.addCredits();
                if (chart.setResponsive) {
                  chart.setResponsive();
                }
                chart.hasRendered = true;
              };
              Chart2.prototype.addCredits = function(credits) {
                var chart = this, creds = merge(
                  true,
                  this.options.credits,
                  credits
                );
                if (creds.enabled && !this.credits) {
                  this.credits = this.renderer.text(creds.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
                    if (creds.href) {
                      win.location.href = creds.href;
                    }
                  }).attr({
                    align: creds.position.align,
                    zIndex: 8
                  });
                  if (!chart.styledMode) {
                    this.credits.css(creds.style);
                  }
                  this.credits.add().align(creds.position);
                  this.credits.update = function(options) {
                    chart.credits = chart.credits.destroy();
                    chart.addCredits(options);
                  };
                }
              };
              Chart2.prototype.destroy = function() {
                var chart = this, axes = chart.axes, series = chart.series, container = chart.container, parentNode = container && container.parentNode;
                var i;
                fireEvent(chart, "destroy");
                if (chart.renderer.forExport) {
                  erase(charts, chart);
                } else {
                  charts[chart.index] = void 0;
                }
                H.chartCount--;
                chart.renderTo.removeAttribute("data-highcharts-chart");
                removeEvent(chart);
                i = axes.length;
                while (i--) {
                  axes[i] = axes[i].destroy();
                }
                if (this.scroller && this.scroller.destroy) {
                  this.scroller.destroy();
                }
                i = series.length;
                while (i--) {
                  series[i] = series[i].destroy();
                }
                [
                  "title",
                  "subtitle",
                  "chartBackground",
                  "plotBackground",
                  "plotBGImage",
                  "plotBorder",
                  "seriesGroup",
                  "clipRect",
                  "credits",
                  "pointer",
                  "rangeSelector",
                  "legend",
                  "resetZoomButton",
                  "tooltip",
                  "renderer"
                ].forEach(function(name) {
                  var prop = chart[name];
                  if (prop && prop.destroy) {
                    chart[name] = prop.destroy();
                  }
                });
                if (container) {
                  container.innerHTML = AST.emptyHTML;
                  removeEvent(container);
                  if (parentNode) {
                    discardElement(container);
                  }
                }
                objectEach(chart, function(val, key) {
                  delete chart[key];
                });
              };
              Chart2.prototype.firstRender = function() {
                var chart = this, options = chart.options;
                if (chart.isReadyToRender && !chart.isReadyToRender()) {
                  return;
                }
                chart.getContainer();
                chart.resetMargins();
                chart.setChartSize();
                chart.propFromSeries();
                chart.getAxes();
                (isArray(options.series) ? options.series : []).forEach(
                  // #9680
                  function(serieOptions) {
                    chart.initSeries(serieOptions);
                  }
                );
                chart.linkSeries();
                chart.setSeriesData();
                fireEvent(chart, "beforeRender");
                if (Pointer) {
                  if (MSPointer.isRequired()) {
                    chart.pointer = new MSPointer(chart, options);
                  } else {
                    chart.pointer = new Pointer(chart, options);
                  }
                }
                chart.render();
                chart.pointer.getChartPosition();
                if (!chart.renderer.imgCount && !chart.hasLoaded) {
                  chart.onload();
                }
                chart.temporaryDisplay(true);
              };
              Chart2.prototype.onload = function() {
                this.callbacks.concat([this.callback]).forEach(function(fn) {
                  if (fn && typeof this.index !== "undefined") {
                    fn.apply(this, [this]);
                  }
                }, this);
                fireEvent(this, "load");
                fireEvent(this, "render");
                if (defined(this.index)) {
                  this.setReflow(this.options.chart.reflow);
                }
                this.warnIfA11yModuleNotLoaded();
                this.hasLoaded = true;
              };
              Chart2.prototype.warnIfA11yModuleNotLoaded = function() {
                var _a = this, options = _a.options, title = _a.title;
                if (options && !this.accessibility) {
                  this.renderer.boxWrapper.attr({
                    role: "img",
                    "aria-label": (title && title.element.textContent || "").replace(/</g, "&lt;")
                  });
                  if (!(options.accessibility && options.accessibility.enabled === false)) {
                    error('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', false, this);
                  }
                }
              };
              Chart2.prototype.addSeries = function(options, redraw, animation) {
                var chart = this;
                var series;
                if (options) {
                  redraw = pick(redraw, true);
                  fireEvent(chart, "addSeries", { options }, function() {
                    series = chart.initSeries(options);
                    chart.isDirtyLegend = true;
                    chart.linkSeries();
                    if (series.enabledDataSorting) {
                      series.setData(options.data, false);
                    }
                    fireEvent(chart, "afterAddSeries", { series });
                    if (redraw) {
                      chart.redraw(animation);
                    }
                  });
                }
                return series;
              };
              Chart2.prototype.addAxis = function(options, isX, redraw, animation) {
                return this.createAxis(isX ? "xAxis" : "yAxis", { axis: options, redraw, animation });
              };
              Chart2.prototype.addColorAxis = function(options, redraw, animation) {
                return this.createAxis("colorAxis", { axis: options, redraw, animation });
              };
              Chart2.prototype.createAxis = function(type, options) {
                var axis = new Axis(
                  this,
                  merge(options.axis, {
                    index: this[type].length,
                    isX: type === "xAxis"
                  })
                );
                if (pick(options.redraw, true)) {
                  this.redraw(options.animation);
                }
                return axis;
              };
              Chart2.prototype.showLoading = function(str) {
                var chart = this, options = chart.options, loadingOptions = options.loading, setLoadingSize = function() {
                  if (loadingDiv) {
                    css(loadingDiv, {
                      left: chart.plotLeft + "px",
                      top: chart.plotTop + "px",
                      width: chart.plotWidth + "px",
                      height: chart.plotHeight + "px"
                    });
                  }
                };
                var loadingDiv = chart.loadingDiv, loadingSpan = chart.loadingSpan;
                if (!loadingDiv) {
                  chart.loadingDiv = loadingDiv = createElement("div", {
                    className: "highcharts-loading highcharts-loading-hidden"
                  }, null, chart.container);
                }
                if (!loadingSpan) {
                  chart.loadingSpan = loadingSpan = createElement("span", { className: "highcharts-loading-inner" }, null, loadingDiv);
                  addEvent(chart, "redraw", setLoadingSize);
                }
                loadingDiv.className = "highcharts-loading";
                AST.setElementHTML(loadingSpan, pick(str, options.lang.loading, ""));
                if (!chart.styledMode) {
                  css(loadingDiv, extend2(loadingOptions.style, {
                    zIndex: 10
                  }));
                  css(loadingSpan, loadingOptions.labelStyle);
                  if (!chart.loadingShown) {
                    css(loadingDiv, {
                      opacity: 0,
                      display: ""
                    });
                    animate(loadingDiv, {
                      opacity: loadingOptions.style.opacity || 0.5
                    }, {
                      duration: loadingOptions.showDuration || 0
                    });
                  }
                }
                chart.loadingShown = true;
                setLoadingSize();
              };
              Chart2.prototype.hideLoading = function() {
                var options = this.options, loadingDiv = this.loadingDiv;
                if (loadingDiv) {
                  loadingDiv.className = "highcharts-loading highcharts-loading-hidden";
                  if (!this.styledMode) {
                    animate(loadingDiv, {
                      opacity: 0
                    }, {
                      duration: options.loading.hideDuration || 100,
                      complete: function() {
                        css(loadingDiv, { display: "none" });
                      }
                    });
                  }
                }
                this.loadingShown = false;
              };
              Chart2.prototype.update = function(options, redraw, oneToOne, animation) {
                var chart = this, adders = {
                  credits: "addCredits",
                  title: "setTitle",
                  subtitle: "setSubtitle",
                  caption: "setCaption"
                }, isResponsiveOptions = options.isResponsiveOptions, itemsForRemoval = [];
                var updateAllAxes, updateAllSeries, runSetSize;
                fireEvent(chart, "update", { options });
                if (!isResponsiveOptions) {
                  chart.setResponsive(false, true);
                }
                options = cleanRecursively(options, chart.options);
                chart.userOptions = merge(chart.userOptions, options);
                var optionsChart = options.chart;
                if (optionsChart) {
                  merge(true, chart.options.chart, optionsChart);
                  if ("className" in optionsChart) {
                    chart.setClassName(optionsChart.className);
                  }
                  if ("reflow" in optionsChart) {
                    chart.setReflow(optionsChart.reflow);
                  }
                  if ("inverted" in optionsChart || "polar" in optionsChart || "type" in optionsChart) {
                    chart.propFromSeries();
                    updateAllAxes = true;
                  }
                  if ("alignTicks" in optionsChart) {
                    updateAllAxes = true;
                  }
                  if ("events" in optionsChart) {
                    registerEventOptions(this, optionsChart);
                  }
                  objectEach(optionsChart, function(val, key) {
                    if (chart.propsRequireUpdateSeries.indexOf("chart." + key) !== -1) {
                      updateAllSeries = true;
                    }
                    if (chart.propsRequireDirtyBox.indexOf(key) !== -1) {
                      chart.isDirtyBox = true;
                    }
                    if (chart.propsRequireReflow.indexOf(key) !== -1) {
                      if (isResponsiveOptions) {
                        chart.isDirtyBox = true;
                      } else {
                        runSetSize = true;
                      }
                    }
                  });
                  if (!chart.styledMode && optionsChart.style) {
                    chart.renderer.setStyle(chart.options.chart.style || {});
                  }
                }
                if (!chart.styledMode && options.colors) {
                  this.options.colors = options.colors;
                }
                if (options.time) {
                  if (this.time === defaultTime) {
                    this.time = new Time(options.time);
                  }
                  merge(true, chart.options.time, options.time);
                }
                objectEach(options, function(val, key) {
                  if (chart[key] && typeof chart[key].update === "function") {
                    chart[key].update(val, false);
                  } else if (typeof chart[adders[key]] === "function") {
                    chart[adders[key]](val);
                  } else if (key !== "colors" && chart.collectionsWithUpdate.indexOf(key) === -1) {
                    merge(true, chart.options[key], options[key]);
                  }
                  if (key !== "chart" && chart.propsRequireUpdateSeries.indexOf(key) !== -1) {
                    updateAllSeries = true;
                  }
                });
                this.collectionsWithUpdate.forEach(function(coll) {
                  var indexMap;
                  if (options[coll]) {
                    indexMap = [];
                    chart[coll].forEach(function(s, i) {
                      if (!s.options.isInternal) {
                        indexMap.push(pick(s.options.index, i));
                      }
                    });
                    splat(options[coll]).forEach(function(newOptions, i) {
                      var hasId = defined(newOptions.id);
                      var item;
                      if (hasId) {
                        item = chart.get(newOptions.id);
                      }
                      if (!item && chart[coll]) {
                        item = chart[coll][indexMap ? indexMap[i] : i];
                        if (item && hasId && defined(item.options.id)) {
                          item = void 0;
                        }
                      }
                      if (item && item.coll === coll) {
                        item.update(newOptions, false);
                        if (oneToOne) {
                          item.touched = true;
                        }
                      }
                      if (!item && oneToOne && chart.collectionsWithInit[coll]) {
                        chart.collectionsWithInit[coll][0].apply(
                          chart,
                          // [newOptions, ...extraArguments, redraw=false]
                          [
                            newOptions
                          ].concat(
                            // Not all initializers require extra args
                            chart.collectionsWithInit[coll][1] || []
                          ).concat([
                            false
                          ])
                        ).touched = true;
                      }
                    });
                    if (oneToOne) {
                      chart[coll].forEach(function(item) {
                        if (!item.touched && !item.options.isInternal) {
                          itemsForRemoval.push(item);
                        } else {
                          delete item.touched;
                        }
                      });
                    }
                  }
                });
                itemsForRemoval.forEach(function(item) {
                  if (item.chart && item.remove) {
                    item.remove(false);
                  }
                });
                if (updateAllAxes) {
                  chart.axes.forEach(function(axis) {
                    axis.update({}, false);
                  });
                }
                if (updateAllSeries) {
                  chart.getSeriesOrderByLinks().forEach(function(series) {
                    if (series.chart) {
                      series.update({}, false);
                    }
                  }, this);
                }
                var newWidth = optionsChart && optionsChart.width;
                var newHeight = optionsChart && (isString(optionsChart.height) ? relativeLength(
                  optionsChart.height,
                  newWidth || chart.chartWidth
                ) : optionsChart.height);
                if (
                  // In this case, run chart.setSize with newWidth and newHeight which
                  // are undefined, only for reflowing chart elements because margin
                  // or spacing has been set (#8190)
                  runSetSize || // In this case, the size is actually set
                  isNumber(newWidth) && newWidth !== chart.chartWidth || isNumber(newHeight) && newHeight !== chart.chartHeight
                ) {
                  chart.setSize(newWidth, newHeight, animation);
                } else if (pick(redraw, true)) {
                  chart.redraw(animation);
                }
                fireEvent(chart, "afterUpdate", {
                  options,
                  redraw,
                  animation
                });
              };
              Chart2.prototype.setSubtitle = function(options, redraw) {
                this.applyDescription("subtitle", options);
                this.layOutTitles(redraw);
              };
              Chart2.prototype.setCaption = function(options, redraw) {
                this.applyDescription("caption", options);
                this.layOutTitles(redraw);
              };
              Chart2.prototype.showResetZoom = function() {
                var chart = this, lang = defaultOptions.lang, btnOptions = chart.options.chart.zooming.resetButton, theme = btnOptions.theme, alignTo = btnOptions.relativeTo === "chart" || btnOptions.relativeTo === "spacingBox" ? null : "scrollablePlotBox";
                function zoomOut() {
                  chart.zoomOut();
                }
                fireEvent(this, "beforeShowResetZoom", null, function() {
                  chart.resetZoomButton = chart.renderer.button(lang.resetZoom, null, null, zoomOut, theme).attr({
                    align: btnOptions.position.align,
                    title: lang.resetZoomTitle
                  }).addClass("highcharts-reset-zoom").add().align(btnOptions.position, false, alignTo);
                });
                fireEvent(this, "afterShowResetZoom");
              };
              Chart2.prototype.zoomOut = function() {
                fireEvent(this, "selection", { resetSelection: true }, this.zoom);
              };
              Chart2.prototype.zoom = function(event) {
                var chart = this, pointer = chart.pointer;
                var displayButton = false, hasZoomed;
                if (!event || event.resetSelection) {
                  chart.axes.forEach(function(axis) {
                    hasZoomed = axis.zoom();
                  });
                  pointer.initiated = false;
                } else {
                  event.xAxis.concat(event.yAxis).forEach(function(axisData) {
                    var axis = axisData.axis, isXAxis = axis.isXAxis;
                    if (pointer[isXAxis ? "zoomX" : "zoomY"] && (defined(pointer.mouseDownX) && defined(pointer.mouseDownY) && chart.isInsidePlot(pointer.mouseDownX - chart.plotLeft, pointer.mouseDownY - chart.plotTop, { axis })) || !defined(chart.inverted ? pointer.mouseDownX : pointer.mouseDownY)) {
                      hasZoomed = axis.zoom(axisData.min, axisData.max);
                      if (axis.displayBtn) {
                        displayButton = true;
                      }
                    }
                  });
                }
                var resetZoomButton = chart.resetZoomButton;
                if (displayButton && !resetZoomButton) {
                  chart.showResetZoom();
                } else if (!displayButton && isObject(resetZoomButton)) {
                  chart.resetZoomButton = resetZoomButton.destroy();
                }
                if (hasZoomed) {
                  chart.redraw(pick(chart.options.chart.animation, event && event.animation, chart.pointCount < 100));
                }
              };
              Chart2.prototype.pan = function(e, panning) {
                var chart = this, hoverPoints = chart.hoverPoints, panningOptions = typeof panning === "object" ? panning : {
                  enabled: panning,
                  type: "x"
                }, chartOptions = chart.options.chart;
                if (chartOptions && chartOptions.panning) {
                  chartOptions.panning = panningOptions;
                }
                var type = panningOptions.type;
                var doRedraw;
                fireEvent(this, "pan", { originalEvent: e }, function() {
                  if (hoverPoints) {
                    hoverPoints.forEach(function(point) {
                      point.setState();
                    });
                  }
                  var axes = chart.xAxis;
                  if (type === "xy") {
                    axes = axes.concat(chart.yAxis);
                  } else if (type === "y") {
                    axes = chart.yAxis;
                  }
                  var nextMousePos = {};
                  axes.forEach(function(axis) {
                    if (!axis.options.panningEnabled || axis.options.isInternal) {
                      return;
                    }
                    var horiz = axis.horiz, mousePos = e[horiz ? "chartX" : "chartY"], mouseDown = horiz ? "mouseDownX" : "mouseDownY", startPos = chart[mouseDown], halfPointRange = axis.minPointOffset || 0, pointRangeDirection = axis.reversed && !chart.inverted || !axis.reversed && chart.inverted ? -1 : 1, extremes = axis.getExtremes(), panMin = axis.toValue(startPos - mousePos, true) + halfPointRange * pointRangeDirection, panMax = axis.toValue(startPos + axis.len - mousePos, true) - (halfPointRange * pointRangeDirection || axis.isXAxis && axis.pointRangePadding || 0), flipped = panMax < panMin, hasVerticalPanning = axis.hasVerticalPanning();
                    var newMin = flipped ? panMax : panMin, newMax = flipped ? panMin : panMax, panningState = axis.panningState, spill;
                    if (hasVerticalPanning && !axis.isXAxis && (!panningState || panningState.isDirty)) {
                      axis.series.forEach(function(series) {
                        var processedData = series.getProcessedData(true), dataExtremes = series.getExtremes(
                          processedData.yData,
                          true
                        );
                        if (!panningState) {
                          panningState = {
                            startMin: Number.MAX_VALUE,
                            startMax: -Number.MAX_VALUE
                          };
                        }
                        if (isNumber(dataExtremes.dataMin) && isNumber(dataExtremes.dataMax)) {
                          panningState.startMin = Math.min(pick(series.options.threshold, Infinity), dataExtremes.dataMin, panningState.startMin);
                          panningState.startMax = Math.max(pick(series.options.threshold, -Infinity), dataExtremes.dataMax, panningState.startMax);
                        }
                      });
                    }
                    var paddedMin = Math.min(
                      pick(
                        panningState && panningState.startMin,
                        extremes.dataMin
                      ),
                      halfPointRange ? extremes.min : axis.toValue(axis.toPixels(extremes.min) - axis.minPixelPadding)
                    );
                    var paddedMax = Math.max(
                      pick(
                        panningState && panningState.startMax,
                        extremes.dataMax
                      ),
                      halfPointRange ? extremes.max : axis.toValue(axis.toPixels(extremes.max) + axis.minPixelPadding)
                    );
                    axis.panningState = panningState;
                    if (!axis.isOrdinal) {
                      spill = paddedMin - newMin;
                      if (spill > 0) {
                        newMax += spill;
                        newMin = paddedMin;
                      }
                      spill = newMax - paddedMax;
                      if (spill > 0) {
                        newMax = paddedMax;
                        newMin -= spill;
                      }
                      if (axis.series.length && newMin !== extremes.min && newMax !== extremes.max && newMin >= paddedMin && newMax <= paddedMax) {
                        axis.setExtremes(newMin, newMax, false, false, { trigger: "pan" });
                        if (!chart.resetZoomButton && // Show reset zoom button only when both newMin and
                        // newMax values are between padded axis range.
                        newMin !== paddedMin && newMax !== paddedMax && type.match("y")) {
                          chart.showResetZoom();
                          axis.displayBtn = false;
                        }
                        doRedraw = true;
                      }
                      nextMousePos[mouseDown] = mousePos;
                    }
                  });
                  objectEach(nextMousePos, function(pos, down) {
                    chart[down] = pos;
                  });
                  if (doRedraw) {
                    chart.redraw(false);
                  }
                  css(chart.container, { cursor: "move" });
                });
              };
              return Chart2;
            }()
          );
          extend2(Chart.prototype, {
            // Hook for adding callbacks in modules
            callbacks: [],
            /**
             * These collections (arrays) implement `Chart.addSomethig` method used in
             * chart.update() to create new object in the collection. Equivalent for
             * deleting is resolved by simple `Somethig.remove()`.
             *
             * Note: We need to define these references after initializers are bound to
             * chart's prototype.
             *
             * @private
             */
            collectionsWithInit: {
              // collectionName: [ initializingMethod, [extraArguments] ]
              xAxis: [Chart.prototype.addAxis, [true]],
              yAxis: [Chart.prototype.addAxis, [false]],
              series: [Chart.prototype.addSeries]
            },
            /**
             * These collections (arrays) implement update() methods with support for
             * one-to-one option.
             * @private
             */
            collectionsWithUpdate: [
              "xAxis",
              "yAxis",
              "series"
            ],
            /**
             * These properties cause isDirtyBox to be set to true when updating. Can be
             * extended from plugins.
             * @private
             */
            propsRequireDirtyBox: [
              "backgroundColor",
              "borderColor",
              "borderWidth",
              "borderRadius",
              "plotBackgroundColor",
              "plotBackgroundImage",
              "plotBorderColor",
              "plotBorderWidth",
              "plotShadow",
              "shadow"
            ],
            /**
             * These properties require a full reflow of chart elements, best
             * implemented through running `Chart.setSize` internally (#8190).
             * @private
             */
            propsRequireReflow: [
              "margin",
              "marginTop",
              "marginRight",
              "marginBottom",
              "marginLeft",
              "spacing",
              "spacingTop",
              "spacingRight",
              "spacingBottom",
              "spacingLeft"
            ],
            /**
             * These properties cause all series to be updated when updating. Can be
             * extended from plugins.
             * @private
             */
            propsRequireUpdateSeries: [
              "chart.inverted",
              "chart.polar",
              "chart.ignoreHiddenSeries",
              "chart.type",
              "colors",
              "plotOptions",
              "time",
              "tooltip"
            ]
          });
          "";
          return Chart;
        });
        _registerModule(_modules, "Core/Legend/LegendSymbol.js", [_modules["Core/Utilities.js"]], function(U) {
          var extend2 = U.extend, merge = U.merge, pick = U.pick;
          var LegendSymbol;
          (function(LegendSymbol2) {
            function drawLineMarker(legend) {
              var legendItem = this.legendItem = this.legendItem || {}, options = this.options, symbolWidth = legend.symbolWidth, symbolHeight = legend.symbolHeight, generalRadius = symbolHeight / 2, renderer = this.chart.renderer, legendItemGroup = legendItem.group, verticalCenter = legend.baseline - Math.round(legend.fontMetrics.b * 0.3);
              var attr = {}, legendSymbol, markerOptions = options.marker, lineSizer = 0;
              if (!this.chart.styledMode) {
                attr = {
                  "stroke-width": Math.min(options.lineWidth || 0, 24)
                };
                if (options.dashStyle) {
                  attr.dashstyle = options.dashStyle;
                } else if (options.linecap !== "square") {
                  attr["stroke-linecap"] = "round";
                }
              }
              legendItem.line = renderer.path().addClass("highcharts-graph").attr(attr).add(legendItemGroup);
              if (attr["stroke-linecap"]) {
                lineSizer = Math.min(legendItem.line.strokeWidth(), symbolWidth) / 2;
              }
              legendItem.line.attr({
                d: [
                  ["M", lineSizer, verticalCenter],
                  ["L", symbolWidth - lineSizer, verticalCenter]
                ]
              });
              if (markerOptions && markerOptions.enabled !== false && symbolWidth) {
                var radius = Math.min(
                  pick(
                    markerOptions.radius,
                    generalRadius
                  ),
                  generalRadius
                );
                if (this.symbol.indexOf("url") === 0) {
                  markerOptions = merge(markerOptions, {
                    width: symbolHeight,
                    height: symbolHeight
                  });
                  radius = 0;
                }
                legendItem.symbol = legendSymbol = renderer.symbol(this.symbol, symbolWidth / 2 - radius, verticalCenter - radius, 2 * radius, 2 * radius, extend2({ context: "legend" }, markerOptions)).addClass("highcharts-point").add(legendItemGroup);
                legendSymbol.isMarker = true;
              }
            }
            LegendSymbol2.drawLineMarker = drawLineMarker;
            function drawRectangle(legend, item) {
              var legendItem = item.legendItem || {}, options = legend.options, symbolHeight = legend.symbolHeight, square = options.squareSymbol, symbolWidth = square ? symbolHeight : legend.symbolWidth;
              legendItem.symbol = this.chart.renderer.rect(
                square ? (legend.symbolWidth - symbolHeight) / 2 : 0,
                legend.baseline - symbolHeight + 1,
                // #3988
                symbolWidth,
                symbolHeight,
                pick(legend.options.symbolRadius, symbolHeight / 2)
              ).addClass("highcharts-point").attr({
                zIndex: 3
              }).add(legendItem.group);
            }
            LegendSymbol2.drawRectangle = drawRectangle;
          })(LegendSymbol || (LegendSymbol = {}));
          return LegendSymbol;
        });
        _registerModule(_modules, "Core/Series/SeriesDefaults.js", [], function() {
          var seriesDefaults = {
            // base series options
            /**
             * The SVG value used for the `stroke-linecap` and `stroke-linejoin`
             * of a line graph. Round means that lines are rounded in the ends and
             * bends.
             *
             * @type       {Highcharts.SeriesLinecapValue}
             * @default    round
             * @since      3.0.7
             * @apioption  plotOptions.line.linecap
             */
            /**
             * Pixel width of the graph line.
             *
             * @see In styled mode, the line stroke-width can be set with the
             *      `.highcharts-graph` class name.
             *
             * @sample {highcharts} highcharts/plotoptions/series-linewidth-general/
             *         On all series
             * @sample {highcharts} highcharts/plotoptions/series-linewidth-specific/
             *         On one single series
             *
             * @product highcharts highstock
             *
             * @private
             */
            lineWidth: 2,
            /**
             * For some series, there is a limit that shuts down animation
             * by default when the total number of points in the chart is too high.
             * For example, for a column chart and its derivatives, animation does
             * not run if there is more than 250 points totally. To disable this
             * cap, set `animationLimit` to `Infinity`. This option works if animation
             * is fired on individual points, not on a group of points like e.g. during
             * the initial animation.
             *
             * @sample {highcharts} highcharts/plotoptions/series-animationlimit/
             *         Animation limit on updating individual points
             *
             * @type      {number}
             * @apioption plotOptions.series.animationLimit
             */
            /**
             * Allow this series' points to be selected by clicking on the graphic
             * (columns, point markers, pie slices, map areas etc).
             *
             * The selected points can be handled by point select and unselect
             * events, or collectively by the [getSelectedPoints
             * ](/class-reference/Highcharts.Chart#getSelectedPoints) function.
             *
             * And alternative way of selecting points is through dragging.
             *
             * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-line/
             *         Line
             * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-column/
             *         Column
             * @sample {highcharts} highcharts/plotoptions/series-allowpointselect-pie/
             *         Pie
             * @sample {highcharts} highcharts/chart/events-selection-points/
             *         Select a range of points through a drag selection
             * @sample {highmaps} maps/plotoptions/series-allowpointselect/
             *         Map area
             * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
             *         Map bubble
             *
             * @since 1.2.0
             *
             * @private
             */
            allowPointSelect: false,
            /**
             * When true, each point or column edge is rounded to its nearest pixel
             * in order to render sharp on screen. In some cases, when there are a
             * lot of densely packed columns, this leads to visible difference
             * in column widths or distance between columns. In these cases,
             * setting `crisp` to `false` may look better, even though each column
             * is rendered blurry.
             *
             * @sample {highcharts} highcharts/plotoptions/column-crisp-false/
             *         Crisp is false
             *
             * @since   5.0.10
             * @product highcharts highstock gantt
             *
             * @private
             */
            crisp: true,
            /**
             * If true, a checkbox is displayed next to the legend item to allow
             * selecting the series. The state of the checkbox is determined by
             * the `selected` option.
             *
             * @productdesc {highmaps}
             * Note that if a `colorAxis` is defined, the color axis is represented
             * in the legend, not the series.
             *
             * @sample {highcharts} highcharts/plotoptions/series-showcheckbox-true/
             *         Show select box
             *
             * @since 1.2.0
             *
             * @private
             */
            showCheckbox: false,
            /**
             * Enable or disable the initial animation when a series is displayed.
             * The animation can also be set as a configuration object. Please
             * note that this option only applies to the initial animation of the
             * series itself. For other animations, see [chart.animation](
             * #chart.animation) and the animation parameter under the API methods.
             * The following properties are supported:
             *
             * - `defer`: The animation delay time in milliseconds.
             *
             * - `duration`: The duration of the animation in milliseconds. (Defaults to
             *   `1000`)
             *
             * - `easing`: Can be a string reference to an easing function set on
             *   the `Math` object or a function. See the _Custom easing function_
             *   demo below. (Defaults to `easeInOutSine`)
             *
             * Due to poor performance, animation is disabled in old IE browsers
             * for several chart types.
             *
             * @sample {highcharts} highcharts/plotoptions/series-animation-disabled/
             *         Animation disabled
             * @sample {highcharts} highcharts/plotoptions/series-animation-slower/
             *         Slower animation
             * @sample {highcharts} highcharts/plotoptions/series-animation-easing/
             *         Custom easing function
             * @sample {highstock} stock/plotoptions/animation-slower/
             *         Slower animation
             * @sample {highstock} stock/plotoptions/animation-easing/
             *         Custom easing function
             * @sample {highmaps} maps/plotoptions/series-animation-true/
             *         Animation enabled on map series
             * @sample {highmaps} maps/plotoptions/mapbubble-animation-false/
             *         Disabled on mapbubble series
             *
             * @type    {boolean|Highcharts.AnimationOptionsObject}
             * @default {highcharts} true
             * @default {highstock} true
             * @default {highmaps} false
             *
             * @private
             */
            animation: {
              /** @ignore-option */
              duration: 1e3
            },
            /**
             * An additional class name to apply to the series' graphical elements.
             * This option does not replace default class names of the graphical
             * element. Changes to the series' color will also be reflected in a
             * chart's legend and tooltip.
             *
             * @sample {highcharts} highcharts/css/point-series-classname
             *
             * @type      {string}
             * @since     5.0.0
             * @apioption plotOptions.series.className
             */
            /**
             * Disable this option to allow series rendering in the whole plotting
             * area.
             *
             * **Note:** Clipping should be always enabled when
             * [chart.zoomType](#chart.zoomType) is set
             *
             * @sample {highcharts} highcharts/plotoptions/series-clip/
             *         Disabled clipping
             *
             * @default   true
             * @type      {boolean}
             * @since     3.0.0
             * @apioption plotOptions.series.clip
             */
            /**
             * The main color of the series. In line type series it applies to the
             * line and the point markers unless otherwise specified. In bar type
             * series it applies to the bars unless a color is specified per point.
             * The default value is pulled from the `options.colors` array.
             *
             * In styled mode, the color can be defined by the
             * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series
             * color can be set with the `.highcharts-series`,
             * `.highcharts-color-{n}`, `.highcharts-{type}-series` or
             * `.highcharts-series-{n}` class, or individual classes given by the
             * `className` option.
             *
             * @productdesc {highmaps}
             * In maps, the series color is rarely used, as most choropleth maps use
             * the color to denote the value of each point. The series color can
             * however be used in a map with multiple series holding categorized
             * data.
             *
             * @sample {highcharts} highcharts/plotoptions/series-color-general/
             *         General plot option
             * @sample {highcharts} highcharts/plotoptions/series-color-specific/
             *         One specific series
             * @sample {highcharts} highcharts/plotoptions/series-color-area/
             *         Area color
             * @sample {highcharts} highcharts/series/infographic/
             *         Pattern fill
             * @sample {highmaps} maps/demo/category-map/
             *         Category map by multiple series
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @apioption plotOptions.series.color
             */
            /**
             * Styled mode only. A specific color index to use for the series, so its
             * graphic representations are given the class name `highcharts-color-{n}`.
             *
             * @sample    {highcharts} highcharts/css/colorindex/
             *            Series and point color index
             *
             * @type      {number}
             * @since     5.0.0
             * @apioption plotOptions.series.colorIndex
             */
            /**
             * Whether to connect a graph line across null points, or render a gap
             * between the two points on either side of the null.
             *
             * @sample {highcharts} highcharts/plotoptions/series-connectnulls-false/
             *         False by default
             * @sample {highcharts} highcharts/plotoptions/series-connectnulls-true/
             *         True
             *
             * @type      {boolean}
             * @default   false
             * @product   highcharts highstock
             * @apioption plotOptions.series.connectNulls
             */
            /**
             * You can set the cursor to "pointer" if you have click events attached
             * to the series, to signal to the user that the points and lines can
             * be clicked.
             *
             * In styled mode, the series cursor can be set with the same classes
             * as listed under [series.color](#plotOptions.series.color).
             *
             * @sample {highcharts} highcharts/plotoptions/series-cursor-line/
             *         On line graph
             * @sample {highcharts} highcharts/plotoptions/series-cursor-column/
             *         On columns
             * @sample {highcharts} highcharts/plotoptions/series-cursor-scatter/
             *         On scatter markers
             * @sample {highstock} stock/plotoptions/cursor/
             *         Pointer on a line graph
             * @sample {highmaps} maps/plotoptions/series-allowpointselect/
             *         Map area
             * @sample {highmaps} maps/plotoptions/mapbubble-allowpointselect/
             *         Map bubble
             *
             * @type      {string|Highcharts.CursorValue}
             * @apioption plotOptions.series.cursor
             */
            /**
             * A reserved subspace to store options and values for customized
             * functionality. Here you can add additional data for your own event
             * callbacks and formatter callbacks.
             *
             * @sample {highcharts} highcharts/point/custom/
             *         Point and series with custom data
             *
             * @type      {Highcharts.Dictionary<*>}
             * @apioption plotOptions.series.custom
             */
            /**
             * Name of the dash style to use for the graph, or for some series types
             * the outline of each shape.
             *
             * In styled mode, the
             * [stroke dash-array](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/series-dashstyle/)
             * can be set with the same classes as listed under
             * [series.color](#plotOptions.series.color).
             *
             * @sample {highcharts} highcharts/plotoptions/series-dashstyle-all/
             *         Possible values demonstrated
             * @sample {highcharts} highcharts/plotoptions/series-dashstyle/
             *         Chart suitable for printing in black and white
             * @sample {highstock} highcharts/plotoptions/series-dashstyle-all/
             *         Possible values demonstrated
             * @sample {highmaps} highcharts/plotoptions/series-dashstyle-all/
             *         Possible values demonstrated
             * @sample {highmaps} maps/plotoptions/series-dashstyle/
             *         Dotted borders on a map
             *
             * @type      {Highcharts.DashStyleValue}
             * @default   Solid
             * @since     2.1
             * @apioption plotOptions.series.dashStyle
             */
            /**
             * A description of the series to add to the screen reader information
             * about the series.
             *
             * @type      {string}
             * @since     5.0.0
             * @requires  modules/accessibility
             * @apioption plotOptions.series.description
             */
            /**
             * Options for the series data sorting.
             *
             * @type      {Highcharts.DataSortingOptionsObject}
             * @since     8.0.0
             * @product   highcharts highstock
             * @apioption plotOptions.series.dataSorting
             */
            /**
             * Enable or disable data sorting for the series. Use [xAxis.reversed](
             * #xAxis.reversed) to change the sorting order.
             *
             * @sample {highcharts} highcharts/datasorting/animation/
             *         Data sorting in scatter-3d
             * @sample {highcharts} highcharts/datasorting/labels-animation/
             *         Axis labels animation
             * @sample {highcharts} highcharts/datasorting/dependent-sorting/
             *         Dependent series sorting
             * @sample {highcharts} highcharts/datasorting/independent-sorting/
             *         Independent series sorting
             *
             * @type      {boolean}
             * @since     8.0.0
             * @apioption plotOptions.series.dataSorting.enabled
             */
            /**
             * Whether to allow matching points by name in an update. If this option
             * is disabled, points will be matched by order.
             *
             * @sample {highcharts} highcharts/datasorting/match-by-name/
             *         Enabled match by name
             *
             * @type      {boolean}
             * @since     8.0.0
             * @apioption plotOptions.series.dataSorting.matchByName
             */
            /**
             * Determines what data value should be used to sort by.
             *
             * @sample {highcharts} highcharts/datasorting/sort-key/
             *         Sort key as `z` value
             *
             * @type      {string}
             * @since     8.0.0
             * @default   y
             * @apioption plotOptions.series.dataSorting.sortKey
             */
            /**
             * Enable or disable the mouse tracking for a specific series. This
             * includes point tooltips and click events on graphs and points. For
             * large datasets it improves performance.
             *
             * @sample {highcharts} highcharts/plotoptions/series-enablemousetracking-false/
             *         No mouse tracking
             * @sample {highmaps} maps/plotoptions/series-enablemousetracking-false/
             *         No mouse tracking
             *
             * @type      {boolean}
             * @default   true
             * @apioption plotOptions.series.enableMouseTracking
             */
            /**
             * Whether to use the Y extremes of the total chart width or only the
             * zoomed area when zooming in on parts of the X axis. By default, the
             * Y axis adjusts to the min and max of the visible data. Cartesian
             * series only.
             *
             * @type      {boolean}
             * @default   false
             * @since     4.1.6
             * @product   highcharts highstock gantt
             * @apioption plotOptions.series.getExtremesFromAll
             */
            /**
             * An array specifying which option maps to which key in the data point
             * array. This makes it convenient to work with unstructured data arrays
             * from different sources.
             *
             * @see [series.data](#series.line.data)
             *
             * @sample {highcharts|highstock} highcharts/series/data-keys/
             *         An extended data array with keys
             * @sample {highcharts|highstock} highcharts/series/data-nested-keys/
             *         Nested keys used to access object properties
             *
             * @type      {Array<string>}
             * @since     4.1.6
             * @apioption plotOptions.series.keys
             */
            /**
             * The line cap used for line ends and line joins on the graph.
             *
             * @sample highcharts/series-line/linecap/
             *         Line cap comparison
             *
             * @type       {Highcharts.SeriesLinecapValue}
             * @default    round
             * @product    highcharts highstock
             * @apioption  plotOptions.series.linecap
             */
            /**
             * The [id](#series.id) of another series to link to. Additionally,
             * the value can be ":previous" to link to the previous series. When
             * two series are linked, only the first one appears in the legend.
             * Toggling the visibility of this also toggles the linked series.
             *
             * If master series uses data sorting and linked series does not have
             * its own sorting definition, the linked series will be sorted in the
             * same order as the master one.
             *
             * @sample {highcharts|highstock} highcharts/demo/arearange-line/
             *         Linked series
             *
             * @type      {string}
             * @since     3.0
             * @product   highcharts highstock gantt
             * @apioption plotOptions.series.linkedTo
             */
            /**
             * Options for the corresponding navigator series if `showInNavigator`
             * is `true` for this series. Available options are the same as any
             * series, documented at [plotOptions](#plotOptions.series) and
             * [series](#series).
             *
             * These options are merged with options in [navigator.series](
             * #navigator.series), and will take precedence if the same option is
             * defined both places.
             *
             * @see [navigator.series](#navigator.series)
             *
             * @type      {Highcharts.PlotSeriesOptions}
             * @since     5.0.0
             * @product   highstock
             * @apioption plotOptions.series.navigatorOptions
             */
            /**
             * The color for the parts of the graph or points that are below the
             * [threshold](#plotOptions.series.threshold). Note that `zones` takes
             * precedence over the negative color. Using `negativeColor` is
             * equivalent to applying a zone with value of 0.
             *
             * @see In styled mode, a negative color is applied by setting this option
             *      to `true` combined with the `.highcharts-negative` class name.
             *
             * @sample {highcharts} highcharts/plotoptions/series-negative-color/
             *         Spline, area and column
             * @sample {highcharts} highcharts/plotoptions/arearange-negativecolor/
             *         Arearange
             * @sample {highcharts} highcharts/css/series-negative-color/
             *         Styled mode
             * @sample {highstock} highcharts/plotoptions/series-negative-color/
             *         Spline, area and column
             * @sample {highstock} highcharts/plotoptions/arearange-negativecolor/
             *         Arearange
             * @sample {highmaps} highcharts/plotoptions/series-negative-color/
             *         Spline, area and column
             * @sample {highmaps} highcharts/plotoptions/arearange-negativecolor/
             *         Arearange
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @since     3.0
             * @apioption plotOptions.series.negativeColor
             */
            /**
             * Same as
             * [accessibility.series.descriptionFormatter](#accessibility.series.descriptionFormatter),
             * but for an individual series. Overrides the chart wide configuration.
             *
             * @type      {Function}
             * @since     5.0.12
             * @apioption plotOptions.series.pointDescriptionFormatter
             */
            /**
             * If no x values are given for the points in a series, `pointInterval`
             * defines the interval of the x values. For example, if a series
             * contains one value every decade starting from year 0, set
             * `pointInterval` to `10`. In true `datetime` axes, the `pointInterval`
             * is set in milliseconds.
             *
             * It can be also be combined with `pointIntervalUnit` to draw irregular
             * time intervals.
             *
             * If combined with `relativeXValue`, an x value can be set on each
             * point, and the `pointInterval` is added x times to the `pointStart`
             * setting.
             *
             * Please note that this options applies to the _series data_, not the
             * interval of the axis ticks, which is independent.
             *
             * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
             *         Datetime X axis
             * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
             *         Relative x value
             * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
             *         Using pointStart and pointInterval
             * @sample {highstock} stock/plotoptions/relativexvalue/
             *         Relative x value
             *
             * @type      {number}
             * @default   1
             * @product   highcharts highstock gantt
             * @apioption plotOptions.series.pointInterval
             */
            /**
             * On datetime series, this allows for setting the
             * [pointInterval](#plotOptions.series.pointInterval) to irregular time
             * units, `day`, `month` and `year`. A day is usually the same as 24
             * hours, but `pointIntervalUnit` also takes the DST crossover into
             * consideration when dealing with local time. Combine this option with
             * `pointInterval` to draw weeks, quarters, 6 months, 10 years etc.
             *
             * Please note that this options applies to the _series data_, not the
             * interval of the axis ticks, which is independent.
             *
             * @sample {highcharts} highcharts/plotoptions/series-pointintervalunit/
             *         One point a month
             * @sample {highstock} highcharts/plotoptions/series-pointintervalunit/
             *         One point a month
             *
             * @type       {string}
             * @since      4.1.0
             * @product    highcharts highstock gantt
             * @validvalue ["day", "month", "year"]
             * @apioption  plotOptions.series.pointIntervalUnit
             */
            /**
             * Possible values: `"on"`, `"between"`, `number`.
             *
             * In a column chart, when pointPlacement is `"on"`, the point will not
             * create any padding of the X axis. In a polar column chart this means
             * that the first column points directly north. If the pointPlacement is
             * `"between"`, the columns will be laid out between ticks. This is
             * useful for example for visualising an amount between two points in
             * time or in a certain sector of a polar chart.
             *
             * Since Highcharts 3.0.2, the point placement can also be numeric,
             * where 0 is on the axis value, -0.5 is between this value and the
             * previous, and 0.5 is between this value and the next. Unlike the
             * textual options, numeric point placement options won't affect axis
             * padding.
             *
             * Note that pointPlacement needs a [pointRange](
             * #plotOptions.series.pointRange) to work. For column series this is
             * computed, but for line-type series it needs to be set.
             *
             * For the `xrange` series type and gantt charts, if the Y axis is a
             * category axis, the `pointPlacement` applies to the Y axis rather than
             * the (typically datetime) X axis.
             *
             * Defaults to `undefined` in cartesian charts, `"between"` in polar
             * charts.
             *
             * @see [xAxis.tickmarkPlacement](#xAxis.tickmarkPlacement)
             *
             * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-between/
             *         Between in a column chart
             * @sample {highcharts|highstock} highcharts/plotoptions/series-pointplacement-numeric/
             *         Numeric placement for custom layout
             * @sample {highcharts|highstock} maps/plotoptions/heatmap-pointplacement/
             *         Placement in heatmap
             *
             * @type      {string|number}
             * @since     2.3.0
             * @product   highcharts highstock gantt
             * @apioption plotOptions.series.pointPlacement
             */
            /**
             * If no x values are given for the points in a series, pointStart
             * defines on what value to start. For example, if a series contains one
             * yearly value starting from 1945, set pointStart to 1945.
             *
             * If combined with `relativeXValue`, an x value can be set on each
             * point. The x value from the point options is multiplied by
             * `pointInterval` and added to `pointStart` to produce a modified x
             * value.
             *
             * @sample {highcharts} highcharts/plotoptions/series-pointstart-linear/
             *         Linear
             * @sample {highcharts} highcharts/plotoptions/series-pointstart-datetime/
             *         Datetime
             * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
             *         Relative x value
             * @sample {highstock} stock/plotoptions/pointinterval-pointstart/
             *         Using pointStart and pointInterval
             * @sample {highstock} stock/plotoptions/relativexvalue/
             *         Relative x value
             *
             * @type      {number}
             * @default   0
             * @product   highcharts highstock gantt
             * @apioption plotOptions.series.pointStart
             */
            /**
             * When true, X values in the data set are relative to the current
             * `pointStart`, `pointInterval` and `pointIntervalUnit` settings. This
             * allows compression of the data for datasets with irregular X values.
             *
             * The real X values are computed on the formula `f(x) = ax + b`, where
             * `a` is the `pointInterval` (optionally with a time unit given by
             * `pointIntervalUnit`), and `b` is the `pointStart`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-relativexvalue/
             *         Relative X value
             * @sample {highstock} stock/plotoptions/relativexvalue/
             *         Relative X value
             *
             * @type      {boolean}
             * @default   false
             * @product   highcharts highstock
             * @apioption plotOptions.series.relativeXValue
             */
            /**
             * Whether to select the series initially. If `showCheckbox` is true,
             * the checkbox next to the series name in the legend will be checked
             * for a selected series.
             *
             * @sample {highcharts} highcharts/plotoptions/series-selected/
             *         One out of two series selected
             *
             * @type      {boolean}
             * @default   false
             * @since     1.2.0
             * @apioption plotOptions.series.selected
             */
            /**
             * Whether to apply a drop shadow to the graph line. Since 2.3 the
             * shadow can be an object configuration containing `color`, `offsetX`,
             * `offsetY`, `opacity` and `width`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-shadow/
             *         Shadow enabled
             *
             * @type      {boolean|Highcharts.ShadowOptionsObject}
             * @default   false
             * @apioption plotOptions.series.shadow
             */
            /**
             * Whether to display this particular series or series type in the
             * legend. Standalone series are shown in legend by default, and linked
             * series are not. Since v7.2.0 it is possible to show series that use
             * colorAxis by setting this option to `true`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
             *         One series in the legend, one hidden
             *
             * @type      {boolean}
             * @apioption plotOptions.series.showInLegend
             */
            /**
             * Whether or not to show the series in the navigator. Takes precedence
             * over [navigator.baseSeries](#navigator.baseSeries) if defined.
             *
             * @type      {boolean}
             * @since     5.0.0
             * @product   highstock
             * @apioption plotOptions.series.showInNavigator
             */
            /**
             * If set to `true`, the accessibility module will skip past the points
             * in this series for keyboard navigation.
             *
             * @type      {boolean}
             * @since     5.0.12
             * @apioption plotOptions.series.skipKeyboardNavigation
             */
            /**
             * Whether to stack the values of each series on top of each other.
             * Possible values are `undefined` to disable, `"normal"` to stack by
             * value or `"percent"`.
             *
             * When stacking is enabled, data must be sorted
             * in ascending X order.
             *
             * Some stacking options are related to specific series types. In the
             * streamgraph series type, the stacking option is set to `"stream"`.
             * The second one is `"overlap"`, which only applies to waterfall
             * series.
             *
             * @see [yAxis.reversedStacks](#yAxis.reversedStacks)
             *
             * @sample {highcharts} highcharts/plotoptions/series-stacking-line/
             *         Line
             * @sample {highcharts} highcharts/plotoptions/series-stacking-column/
             *         Column
             * @sample {highcharts} highcharts/plotoptions/series-stacking-bar/
             *         Bar
             * @sample {highcharts} highcharts/plotoptions/series-stacking-area/
             *         Area
             * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-line/
             *         Line
             * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-column/
             *         Column
             * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-bar/
             *         Bar
             * @sample {highcharts} highcharts/plotoptions/series-stacking-percent-area/
             *         Area
             * @sample {highcharts} highcharts/plotoptions/series-waterfall-with-normal-stacking
             *         Waterfall with normal stacking
             * @sample {highcharts} highcharts/plotoptions/series-waterfall-with-overlap-stacking
             *         Waterfall with overlap stacking
             * @sample {highstock} stock/plotoptions/stacking/
             *         Area
             *
             * @type       {string}
             * @product    highcharts highstock
             * @validvalue ["normal", "overlap", "percent", "stream"]
             * @apioption  plotOptions.series.stacking
             */
            /**
             * Whether to apply steps to the line. Possible values are `left`,
             * `center` and `right`.
             *
             * @sample {highcharts} highcharts/plotoptions/line-step/
             *         Different step line options
             * @sample {highcharts} highcharts/plotoptions/area-step/
             *         Stepped, stacked area
             * @sample {highstock} stock/plotoptions/line-step/
             *         Step line
             *
             * @type       {string}
             * @since      1.2.5
             * @product    highcharts highstock
             * @validvalue ["left", "center", "right"]
             * @apioption  plotOptions.series.step
             */
            /**
             * The threshold, also called zero level or base level. For line type
             * series this is only used in conjunction with
             * [negativeColor](#plotOptions.series.negativeColor).
             *
             * @see [softThreshold](#plotOptions.series.softThreshold).
             *
             * @type      {number|null}
             * @default   0
             * @since     3.0
             * @product   highcharts highstock
             * @apioption plotOptions.series.threshold
             */
            /**
             * Set the initial visibility of the series.
             *
             * @sample {highcharts} highcharts/plotoptions/series-visible/
             *         Two series, one hidden and one visible
             * @sample {highstock} stock/plotoptions/series-visibility/
             *         Hidden series
             *
             * @type      {boolean}
             * @default   true
             * @apioption plotOptions.series.visible
             */
            /**
             * Defines the Axis on which the zones are applied.
             *
             * @see [zones](#plotOptions.series.zones)
             *
             * @sample {highcharts} highcharts/series/color-zones-zoneaxis-x/
             *         Zones on the X-Axis
             * @sample {highstock} highcharts/series/color-zones-zoneaxis-x/
             *         Zones on the X-Axis
             *
             * @type      {string}
             * @default   y
             * @since     4.1.0
             * @product   highcharts highstock
             * @apioption plotOptions.series.zoneAxis
             */
            /**
             * General event handlers for the series items. These event hooks can
             * also be attached to the series at run time using the
             * `Highcharts.addEvent` function.
             *
             * @declare Highcharts.SeriesEventsOptionsObject
             *
             * @private
             */
            events: {},
            /**
             * Fires after the series has finished its initial animation, or in case
             * animation is disabled, immediately as the series is displayed.
             *
             * @sample {highcharts} highcharts/plotoptions/series-events-afteranimate/
             *         Show label after animate
             * @sample {highstock} highcharts/plotoptions/series-events-afteranimate/
             *         Show label after animate
             *
             * @type      {Highcharts.SeriesAfterAnimateCallbackFunction}
             * @since     4.0
             * @product   highcharts highstock gantt
             * @context   Highcharts.Series
             * @apioption plotOptions.series.events.afterAnimate
             */
            /**
             * Fires when the checkbox next to the series' name in the legend is
             * clicked. One parameter, `event`, is passed to the function. The state
             * of the checkbox is found by `event.checked`. The checked item is
             * found by `event.item`. Return `false` to prevent the default action
             * which is to toggle the select state of the series.
             *
             * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
             *         Alert checkbox status
             *
             * @type      {Highcharts.SeriesCheckboxClickCallbackFunction}
             * @since     1.2.0
             * @context   Highcharts.Series
             * @apioption plotOptions.series.events.checkboxClick
             */
            /**
             * Fires when the series is clicked. One parameter, `event`, is passed
             * to the function, containing common event information. Additionally,
             * `event.point` holds a pointer to the nearest point on the graph.
             *
             * @sample {highcharts} highcharts/plotoptions/series-events-click/
             *         Alert click info
             * @sample {highstock} stock/plotoptions/series-events-click/
             *         Alert click info
             * @sample {highmaps} maps/plotoptions/series-events-click/
             *         Display click info in subtitle
             *
             * @type      {Highcharts.SeriesClickCallbackFunction}
             * @context   Highcharts.Series
             * @apioption plotOptions.series.events.click
             */
            /**
             * Fires when the series is hidden after chart generation time, either
             * by clicking the legend item or by calling `.hide()`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-events-hide/
             *         Alert when the series is hidden by clicking the legend item
             *
             * @type      {Highcharts.SeriesHideCallbackFunction}
             * @since     1.2.0
             * @context   Highcharts.Series
             * @apioption plotOptions.series.events.hide
             */
            /**
             * Fires when the legend item belonging to the series is clicked. One
             * parameter, `event`, is passed to the function. The default action
             * is to toggle the visibility of the series. This can be prevented
             * by returning `false` or calling `event.preventDefault()`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-events-legenditemclick/
             *         Confirm hiding and showing
             *
             * @type      {Highcharts.SeriesLegendItemClickCallbackFunction}
             * @context   Highcharts.Series
             * @apioption plotOptions.series.events.legendItemClick
             */
            /**
             * Fires when the mouse leaves the graph. One parameter, `event`, is
             * passed to the function, containing common event information. If the
             * [stickyTracking](#plotOptions.series) option is true, `mouseOut`
             * doesn't happen before the mouse enters another graph or leaves the
             * plot area.
             *
             * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
             *         With sticky tracking by default
             * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
             *         Without sticky tracking
             *
             * @type      {Highcharts.SeriesMouseOutCallbackFunction}
             * @context   Highcharts.Series
             * @apioption plotOptions.series.events.mouseOut
             */
            /**
             * Fires when the mouse enters the graph. One parameter, `event`, is
             * passed to the function, containing common event information.
             *
             * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-sticky/
             *         With sticky tracking by default
             * @sample {highcharts} highcharts/plotoptions/series-events-mouseover-no-sticky/
             *         Without sticky tracking
             *
             * @type      {Highcharts.SeriesMouseOverCallbackFunction}
             * @context   Highcharts.Series
             * @apioption plotOptions.series.events.mouseOver
             */
            /**
             * Fires when the series is shown after chart generation time, either
             * by clicking the legend item or by calling `.show()`.
             *
             * @sample {highcharts} highcharts/plotoptions/series-events-show/
             *         Alert when the series is shown by clicking the legend item.
             *
             * @type      {Highcharts.SeriesShowCallbackFunction}
             * @since     1.2.0
             * @context   Highcharts.Series
             * @apioption plotOptions.series.events.show
             */
            /**
             * Options for the point markers of line and scatter-like series. Properties
             * like `fillColor`, `lineColor` and `lineWidth` define the visual
             * appearance of the markers. The `symbol` option defines the shape. Other
             * series types, like column series, don't have markers, but have visual
             * options on the series level instead.
             *
             * In styled mode, the markers can be styled with the `.highcharts-point`,
             * `.highcharts-point-hover` and `.highcharts-point-select` class names.
             *
             * @declare Highcharts.PointMarkerOptionsObject
             *
             * @sample {highmaps} maps/demo/mappoint-mapmarker
             *         Using the mapmarker symbol for points
             *
             * @private
             */
            marker: {
              /**
               * Enable or disable the point marker. If `undefined`, the markers
               * are hidden when the data is dense, and shown for more widespread
               * data points.
               *
               * @sample {highcharts} highcharts/plotoptions/series-marker-enabled/
               *         Disabled markers
               * @sample {highcharts} highcharts/plotoptions/series-marker-enabled-false/
               *         Disabled in normal state but enabled on hover
               * @sample {highstock} stock/plotoptions/series-marker/
               *         Enabled markers
               *
               * @type      {boolean}
               * @default   {highcharts} undefined
               * @default   {highstock} false
               * @apioption plotOptions.series.marker.enabled
               */
              /**
               * The threshold for how dense the point markers should be before
               * they are hidden, given that `enabled` is not defined. The number
               * indicates the horizontal distance between the two closest points
               * in the series, as multiples of the `marker.radius`. In other
               * words, the default value of 2 means points are hidden if
               * overlapping horizontally.
               *
               * @sample highcharts/plotoptions/series-marker-enabledthreshold
               *         A higher threshold
               *
               * @since 6.0.5
               */
              enabledThreshold: 2,
              /**
               * The fill color of the point marker. When `undefined`, the series'
               * or point's color is used.
               *
               * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
               *         White fill
               *
               * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               * @apioption plotOptions.series.marker.fillColor
               */
              /**
               * Image markers only. Set the image width explicitly. When using
               * this option, a `width` must also be set.
               *
               * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
               *         Fixed width and height
               * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
               *         Fixed width and height
               *
               * @type      {number}
               * @since     4.0.4
               * @apioption plotOptions.series.marker.height
               */
              /**
               * The color of the point marker's outline. When `undefined`, the
               * series' or point's color is used.
               *
               * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
               *         Inherit from series color (undefined)
               *
               * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               */
              lineColor: "#ffffff",
              /**
               * The width of the point marker's outline.
               *
               * @sample {highcharts} highcharts/plotoptions/series-marker-fillcolor/
               *         2px blue marker
               */
              lineWidth: 0,
              /**
               * The radius of the point marker.
               *
               * @sample {highcharts} highcharts/plotoptions/series-marker-radius/
               *         Bigger markers
               *
               * @default {highstock} 2
               * @default {highcharts} 4
               *
               */
              radius: 4,
              /**
               * A predefined shape or symbol for the marker. When undefined, the
               * symbol is pulled from options.symbols. Other possible values are
               * `'circle'`, `'square'`,`'diamond'`, `'triangle'` and
               * `'triangle-down'`.
               *
               * Additionally, the URL to a graphic can be given on this form:
               * `'url(graphic.png)'`. Note that for the image to be applied to
               * exported charts, its URL needs to be accessible by the export
               * server.
               *
               * Custom callbacks for symbol path generation can also be added to
               * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
               * used by its method name, as shown in the demo.
               *
               * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
               *         Predefined, graphic and custom markers
               * @sample {highstock} highcharts/plotoptions/series-marker-symbol/
               *         Predefined, graphic and custom markers
               * @sample {highmaps} maps/demo/mappoint-mapmarker
               *         Using the mapmarker symbol for points
               *
               * @type      {string}
               * @apioption plotOptions.series.marker.symbol
               */
              /**
               * Image markers only. Set the image width explicitly. When using
               * this option, a `height` must also be set.
               *
               * @sample {highcharts} highcharts/plotoptions/series-marker-width-height/
               *         Fixed width and height
               * @sample {highstock} highcharts/plotoptions/series-marker-width-height/
               *         Fixed width and height
               *
               * @type      {number}
               * @since     4.0.4
               * @apioption plotOptions.series.marker.width
               */
              /**
               * States for a single point marker.
               *
               * @declare Highcharts.PointStatesOptionsObject
               */
              states: {
                /**
                 * The normal state of a single point marker. Currently only
                 * used for setting animation when returning to normal state
                 * from hover.
                 *
                 * @declare Highcharts.PointStatesNormalOptionsObject
                 */
                normal: {
                  /**
                   * Animation when returning to normal state after hovering.
                   *
                   * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                   */
                  animation: true
                },
                /**
                 * The hover state for a single point marker.
                 *
                 * @declare Highcharts.PointStatesHoverOptionsObject
                 */
                hover: {
                  /**
                   * Animation when hovering over the marker.
                   *
                   * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                   */
                  animation: {
                    /** @internal */
                    duration: 50
                  },
                  /**
                   * Enable or disable the point marker.
                   *
                   * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-enabled/
                   *         Disabled hover state
                   */
                  enabled: true,
                  /**
                   * The fill color of the marker in hover state. When
                   * `undefined`, the series' or point's fillColor for normal
                   * state is used.
                   *
                   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                   * @apioption plotOptions.series.marker.states.hover.fillColor
                   */
                  /**
                   * The color of the point marker's outline. When
                   * `undefined`, the series' or point's lineColor for normal
                   * state is used.
                   *
                   * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linecolor/
                   *         White fill color, black line color
                   *
                   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                   * @apioption plotOptions.series.marker.states.hover.lineColor
                   */
                  /**
                   * The width of the point marker's outline. When
                   * `undefined`, the series' or point's lineWidth for normal
                   * state is used.
                   *
                   * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-linewidth/
                   *         3px line width
                   *
                   * @type      {number}
                   * @apioption plotOptions.series.marker.states.hover.lineWidth
                   */
                  /**
                   * The radius of the point marker. In hover state, it
                   * defaults to the normal state's radius + 2 as per the
                   * [radiusPlus](#plotOptions.series.marker.states.hover.radiusPlus)
                   * option.
                   *
                   * @sample {highcharts} highcharts/plotoptions/series-marker-states-hover-radius/
                   *         10px radius
                   *
                   * @type      {number}
                   * @apioption plotOptions.series.marker.states.hover.radius
                   */
                  /**
                   * The number of pixels to increase the radius of the
                   * hovered point.
                   *
                   * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
                   *         5 pixels greater radius on hover
                   * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
                   *         5 pixels greater radius on hover
                   *
                   * @since 4.0.3
                   */
                  radiusPlus: 2,
                  /**
                   * The additional line width for a hovered point.
                   *
                   * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
                   *         2 pixels wider on hover
                   * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
                   *         2 pixels wider on hover
                   *
                   * @since 4.0.3
                   */
                  lineWidthPlus: 1
                },
                /**
                 * The appearance of the point marker when selected. In order to
                 * allow a point to be selected, set the
                 * `series.allowPointSelect` option to true.
                 *
                 * @declare Highcharts.PointStatesSelectOptionsObject
                 */
                select: {
                  /**
                   * Enable or disable visible feedback for selection.
                   *
                   * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-enabled/
                   *         Disabled select state
                   *
                   * @type      {boolean}
                   * @default   true
                   * @apioption plotOptions.series.marker.states.select.enabled
                   */
                  /**
                   * The radius of the point marker. In hover state, it
                   * defaults to the normal state's radius + 2.
                   *
                   * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-radius/
                   *         10px radius for selected points
                   *
                   * @type      {number}
                   * @apioption plotOptions.series.marker.states.select.radius
                   */
                  /**
                   * The fill color of the point marker.
                   *
                   * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-fillcolor/
                   *         Solid red discs for selected points
                   *
                   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                   */
                  fillColor: "#cccccc",
                  /**
                   * The color of the point marker's outline. When
                   * `undefined`, the series' or point's color is used.
                   *
                   * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linecolor/
                   *         Red line color for selected points
                   *
                   * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                   */
                  lineColor: "#000000",
                  /**
                   * The width of the point marker's outline.
                   *
                   * @sample {highcharts} highcharts/plotoptions/series-marker-states-select-linewidth/
                   *         3px line width for selected points
                   */
                  lineWidth: 2
                }
              }
            },
            /**
             * Properties for each single point.
             *
             * @declare Highcharts.PlotSeriesPointOptions
             *
             * @private
             */
            point: {
              /**
               * Fires when a point is clicked. One parameter, `event`, is passed
               * to the function, containing common event information.
               *
               * If the `series.allowPointSelect` option is true, the default
               * action for the point's click event is to toggle the point's
               * select state. Returning `false` cancels this action.
               *
               * @sample {highcharts} highcharts/plotoptions/series-point-events-click/
               *         Click marker to alert values
               * @sample {highcharts} highcharts/plotoptions/series-point-events-click-column/
               *         Click column
               * @sample {highcharts} highcharts/plotoptions/series-point-events-click-url/
               *         Go to URL
               * @sample {highmaps} maps/plotoptions/series-point-events-click/
               *         Click marker to display values
               * @sample {highmaps} maps/plotoptions/series-point-events-click-url/
               *         Go to URL
               *
               * @type      {Highcharts.PointClickCallbackFunction}
               * @context   Highcharts.Point
               * @apioption plotOptions.series.point.events.click
               */
              /**
               * Fires when the mouse leaves the area close to the point. One
               * parameter, `event`, is passed to the function, containing common
               * event information.
               *
               * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
               *         Show values in the chart's corner on mouse over
               *
               * @type      {Highcharts.PointMouseOutCallbackFunction}
               * @context   Highcharts.Point
               * @apioption plotOptions.series.point.events.mouseOut
               */
              /**
               * Fires when the mouse enters the area close to the point. One
               * parameter, `event`, is passed to the function, containing common
               * event information.
               *
               * Returning `false` cancels the default behavior, which is to show a
               * tooltip for the point.
               *
               * @sample {highcharts} highcharts/plotoptions/series-point-events-mouseover/
               *         Show values in the chart's corner on mouse over
               *
               * @type      {Highcharts.PointMouseOverCallbackFunction}
               * @context   Highcharts.Point
               * @apioption plotOptions.series.point.events.mouseOver
               */
              /**
               * Fires when the point is removed using the `.remove()` method. One
               * parameter, `event`, is passed to the function. Returning `false`
               * cancels the operation.
               *
               * @sample {highcharts} highcharts/plotoptions/series-point-events-remove/
               *         Remove point and confirm
               *
               * @type      {Highcharts.PointRemoveCallbackFunction}
               * @since     1.2.0
               * @context   Highcharts.Point
               * @apioption plotOptions.series.point.events.remove
               */
              /**
               * Fires when the point is selected either programmatically or
               * following a click on the point. One parameter, `event`, is passed
               * to the function. Returning `false` cancels the operation.
               *
               * @sample {highcharts} highcharts/plotoptions/series-point-events-select/
               *         Report the last selected point
               * @sample {highmaps} maps/plotoptions/series-allowpointselect/
               *         Report select and unselect
               *
               * @type      {Highcharts.PointSelectCallbackFunction}
               * @since     1.2.0
               * @context   Highcharts.Point
               * @apioption plotOptions.series.point.events.select
               */
              /**
               * Fires when the point is unselected either programmatically or
               * following a click on the point. One parameter, `event`, is passed
               * to the function.
               *  Returning `false` cancels the operation.
               *
               * @sample {highcharts} highcharts/plotoptions/series-point-events-unselect/
               *         Report the last unselected point
               * @sample {highmaps} maps/plotoptions/series-allowpointselect/
               *         Report select and unselect
               *
               * @type      {Highcharts.PointUnselectCallbackFunction}
               * @since     1.2.0
               * @context   Highcharts.Point
               * @apioption plotOptions.series.point.events.unselect
               */
              /**
               * Fires when the point is updated programmatically through the
               * `.update()` method. One parameter, `event`, is passed to the
               * function. The new point options can be accessed through
               * `event.options`. Returning `false` cancels the operation.
               *
               * @sample {highcharts} highcharts/plotoptions/series-point-events-update/
               *         Confirm point updating
               *
               * @type      {Highcharts.PointUpdateCallbackFunction}
               * @since     1.2.0
               * @context   Highcharts.Point
               * @apioption plotOptions.series.point.events.update
               */
              /**
               * Events for each single point.
               *
               * @declare Highcharts.PointEventsOptionsObject
               */
              events: {}
            },
            /**
             * Options for the series data labels, appearing next to each data
             * point.
             *
             * Since v6.2.0, multiple data labels can be applied to each single
             * point by defining them as an array of configs.
             *
             * In styled mode, the data labels can be styled with the
             * `.highcharts-data-label-box` and `.highcharts-data-label` class names
             * ([see example](https://www.highcharts.com/samples/highcharts/css/series-datalabels)).
             *
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled
             *         Data labels enabled
             * @sample {highcharts} highcharts/plotoptions/series-datalabels-multiple
             *         Multiple data labels on a bar series
             * @sample {highcharts} highcharts/css/series-datalabels
             *         Styled mode example
             * @sample {highmaps} maps/demo/color-axis
             *         Choropleth map with data labels
             * @sample {highmaps} maps/demo/mappoint-datalabels-mapmarker
             *         Using data labels as map markers
             *
             * @type    {*|Array<*>}
             * @product highcharts highstock highmaps gantt
             *
             * @private
             */
            dataLabels: {
              /**
               * Enable or disable the initial animation when a series is displayed
               * for the `dataLabels`. The animation can also be set as a
               * configuration object. Please note that this option only applies to
               * the initial animation.
               *
               * For other animations, see [chart.animation](#chart.animation) and the
               * animation parameter under the API methods. The following properties
               * are supported:
               *
               * - `defer`: The animation delay time in milliseconds.
               *
               * @sample {highcharts} highcharts/plotoptions/animation-defer/
               *          Animation defer settings
               *
               * @type      {boolean|Partial<Highcharts.AnimationOptionsObject>}
               * @since     8.2.0
               * @apioption plotOptions.series.dataLabels.animation
               */
              animation: {},
              /**
               * The animation delay time in milliseconds. Set to `0` to render the
               * data labels immediately. As `undefined` inherits defer time from the
               * [series.animation.defer](#plotOptions.series.animation.defer).
               *
               * @type      {number}
               * @since     8.2.0
               * @apioption plotOptions.series.dataLabels.animation.defer
               */
              /**
               * The alignment of the data label compared to the point. If `right`,
               * the right side of the label should be touching the point. For points
               * with an extent, like columns, the alignments also dictates how to
               * align it inside the box, as given with the
               * [inside](#plotOptions.column.dataLabels.inside) option. Can be one of
               * `left`, `center` or `right`.
               *
               * @sample {highcharts}
               *         highcharts/plotoptions/series-datalabels-align-left/ Left
               *         aligned
               * @sample {highcharts}
               *         highcharts/plotoptions/bar-datalabels-align-inside-bar/ Data
               *         labels inside the bar
               *
               * @type {Highcharts.AlignValue|null}
               */
              align: "center",
              /**
               * Whether to allow data labels to overlap. To make the labels less
               * sensitive for overlapping, the
               * [dataLabels.padding](#plotOptions.series.dataLabels.padding)
               * can be set to 0.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-allowoverlap-false/
               *         Don't allow overlap
               *
               * @type      {boolean}
               * @default   false
               * @since     4.1.0
               * @apioption plotOptions.series.dataLabels.allowOverlap
               */
              /**
               * The background color or gradient for the data label. Setting it to
               * `auto` will use the point's color.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
               *         Data labels box options
               * @sample {highmaps} maps/plotoptions/series-datalabels-box/
               *         Data labels box options
               * @sample {highmaps} maps/demo/mappoint-datalabels-mapmarker
               *         Data labels as map markers
               *
               * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               * @since     2.2.1
               * @apioption plotOptions.series.dataLabels.backgroundColor
               */
              /**
               * The border color for the data label. Setting it to `auto` will use
               * the point's color. Defaults to `undefined`.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
               *         Data labels box options
               *
               * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               * @since     2.2.1
               * @apioption plotOptions.series.dataLabels.borderColor
               */
              /**
               * The border radius in pixels for the data label.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
               *         Data labels box options
               * @sample {highmaps} maps/plotoptions/series-datalabels-box/
               *         Data labels box options
               *
               * @type      {number}
               * @default   0
               * @since     2.2.1
               * @apioption plotOptions.series.dataLabels.borderRadius
               */
              /**
               * The border width in pixels for the data label.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
               *         Data labels box options
               *
               * @type      {number}
               * @default   0
               * @since     2.2.1
               * @apioption plotOptions.series.dataLabels.borderWidth
               */
              borderWidth: 0,
              /**
               * A class name for the data label. Particularly in styled mode,
               * this can be used to give each series' or point's data label
               * unique styling. In addition to this option, a default color class
               * name is added so that we can give the labels a contrast text
               * shadow.
               *
               * @sample {highcharts} highcharts/css/data-label-contrast/
               *         Contrast text shadow
               * @sample {highcharts} highcharts/css/series-datalabels/
               *         Styling by CSS
               *
               * @type      {string}
               * @since     5.0.0
               * @apioption plotOptions.series.dataLabels.className
               */
              /**
               * This options is deprecated.
               * Use [style.color](#plotOptions.series.dataLabels.style) instead.
               *
               * The text color for the data labels. Defaults to `undefined`. For
               * certain series types, like column or map, the data labels can be
               * drawn inside the points. In this case the data label will be
               * drawn with maximum contrast by default. Additionally, it will be
               * given a `text-outline` style with the opposite color, to further
               * increase the contrast. This can be overridden by setting the
               * `text-outline` style to `none` in the `dataLabels.style` option.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-color/
               *         Red data labels
               * @sample {highmaps} maps/demo/color-axis/
               *         White data labels
               *
               * @see [style.color](#plotOptions.series.dataLabels.style)
               *
               * @type       {Highcharts.ColorType}
               * @deprecated 10.3
               * @apioption  plotOptions.series.dataLabels.color
               */
              /**
               * Whether to hide data labels that are outside the plot area. By
               * default, the data label is moved inside the plot area according
               * to the
               * [overflow](#plotOptions.series.dataLabels.overflow)
               * option.
               *
               * @type      {boolean}
               * @default   true
               * @since     2.3.3
               * @apioption plotOptions.series.dataLabels.crop
               */
              /**
               * Whether to defer displaying the data labels until the initial
               * series animation has finished. Setting to `false` renders the
               * data label immediately. If set to `true` inherits the defer
               * time set in [plotOptions.series.animation](#plotOptions.series.animation).
               * If set to a number, a defer time is specified in milliseconds.
               *
               * @sample highcharts/plotoptions/animation-defer
               *         Set defer time
               *
               * @since     4.0.0
               * @type      {boolean|number}
               * @product   highcharts highstock gantt
               */
              defer: true,
              /**
               * Enable or disable the data labels.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-enabled/
               *         Data labels enabled
               * @sample {highmaps} maps/demo/color-axis/
               *         Data labels enabled
               *
               * @type      {boolean}
               * @default   false
               * @apioption plotOptions.series.dataLabels.enabled
               */
              /**
               * A declarative filter to control of which data labels to display.
               * The declarative filter is designed for use when callback
               * functions are not available, like when the chart options require
               * a pure JSON structure or for use with graphical editors. For
               * programmatic control, use the `formatter` instead, and return
               * `undefined` to disable a single data label.
               *
               * @example
               * filter: {
               *     property: 'percentage',
               *     operator: '>',
               *     value: 4
               * }
               *
               * @sample {highcharts} highcharts/demo/pie-monochrome
               *         Data labels filtered by percentage
               *
               * @declare   Highcharts.DataLabelsFilterOptionsObject
               * @since     6.0.3
               * @apioption plotOptions.series.dataLabels.filter
               */
              /**
               * The operator to compare by. Can be one of `>`, `<`, `>=`, `<=`,
               * `==`, and `===`.
               *
               * @type       {string}
               * @validvalue [">", "<", ">=", "<=", "==", "==="]
               * @apioption  plotOptions.series.dataLabels.filter.operator
               */
              /**
               * The point property to filter by. Point options are passed
               * directly to properties, additionally there are `y` value,
               * `percentage` and others listed under {@link Highcharts.Point}
               * members.
               *
               * @type      {string}
               * @apioption plotOptions.series.dataLabels.filter.property
               */
              /**
               * The value to compare against.
               *
               * @type      {number}
               * @apioption plotOptions.series.dataLabels.filter.value
               */
              /**
               * A
               * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
               * for the data label. Available variables are the same as for
               * `formatter`.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/
               *         Add a unit
               * @sample {highmaps} maps/plotoptions/series-datalabels-format/
               *         Formatted value in the data label
               *
               * @type      {string}
               * @default   y
               * @default   point.value
               * @since     3.0
               * @apioption plotOptions.series.dataLabels.format
               */
              // eslint-disable-next-line valid-jsdoc
              /**
               * Callback JavaScript function to format the data label. Note that if a
               * `format` is defined, the format takes precedence and the formatter is
               * ignored.
               *
               * @sample {highmaps} maps/plotoptions/series-datalabels-format/
               *         Formatted value
               *
               * @type {Highcharts.DataLabelsFormatterCallbackFunction}
               */
              formatter: function() {
                var numberFormatter = this.series.chart.numberFormatter;
                return typeof this.y !== "number" ? "" : numberFormatter(this.y, -1);
              },
              /**
               * For points with an extent, like columns or map areas, whether to
               * align the data label inside the box or to the actual value point.
               * Defaults to `false` in most cases, `true` in stacked columns.
               *
               * @type      {boolean}
               * @since     3.0
               * @apioption plotOptions.series.dataLabels.inside
               */
              /**
               * Format for points with the value of null. Works analogously to
               * [format](#plotOptions.series.dataLabels.format). `nullFormat` can
               * be applied only to series which support displaying null points
               * i.e `heatmap` or `tilemap`. Does not work with series that don't
               * display null points, like `line`, `column`, `bar` or `pie`.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-nullformat/
               *         Format data label for null points in heat map
               *
               * @type      {boolean|string}
               * @since     7.1.0
               * @apioption plotOptions.series.dataLabels.nullFormat
               */
              /**
               * Callback JavaScript function that defines formatting for points
               * with the value of null. Works analogously to
               * [formatter](#plotOptions.series.dataLabels.formatter).
               * `nullFormatter` can be applied only to series which support
               * displaying null points i.e `heatmap` or `tilemap`. Does not work
               * with series that don't display null points, like `line`, `column`,
               * `bar` or `pie`.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-nullformat/
               *         Format data label for null points in heat map
               *
               * @type      {Highcharts.DataLabelsFormatterCallbackFunction}
               * @since     7.1.0
               * @apioption plotOptions.series.dataLabels.nullFormatter
               */
              /**
               * How to handle data labels that flow outside the plot area. The
               * default is `"justify"`, which aligns them inside the plot area.
               * For columns and bars, this means it will be moved inside the bar.
               * To display data labels outside the plot area, set `crop` to
               * `false` and `overflow` to `"allow"`.
               *
               * @type       {Highcharts.DataLabelsOverflowValue}
               * @default    justify
               * @since      3.0.6
               * @apioption  plotOptions.series.dataLabels.overflow
               */
              /**
               * When either the `borderWidth` or the `backgroundColor` is set,
               * this is the padding within the box.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
               *         Data labels box options
               * @sample {highmaps} maps/plotoptions/series-datalabels-box/
               *         Data labels box options
               *
               * @since 2.2.1
               */
              padding: 5,
              /**
               * Aligns data labels relative to points. If `center` alignment is
               * not possible, it defaults to `right`.
               *
               * @type      {Highcharts.AlignValue}
               * @default   center
               * @apioption plotOptions.series.dataLabels.position
               */
              /**
               * Text rotation in degrees. Note that due to a more complex
               * structure, backgrounds, borders and padding will be lost on a
               * rotated data label.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
               *         Vertical labels
               *
               * @type      {number}
               * @default   0
               * @apioption plotOptions.series.dataLabels.rotation
               */
              /**
               * The shadow of the box. Works best with `borderWidth` or
               * `backgroundColor`. Since 2.3 the shadow can be an object
               * configuration containing `color`, `offsetX`, `offsetY`, `opacity`
               * and `width`.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-box/
               *         Data labels box options
               *
               * @type      {boolean|Highcharts.ShadowOptionsObject}
               * @default   false
               * @since     2.2.1
               * @apioption plotOptions.series.dataLabels.shadow
               */
              /**
               * The name of a symbol to use for the border around the label.
               * Symbols are predefined functions on the Renderer object.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-shape/
               *         A callout for annotations
               *
               * @type      {string}
               * @default   square
               * @since     4.1.2
               * @apioption plotOptions.series.dataLabels.shape
               */
              /**
               * Styles for the label. The default `color` setting is
               * `"contrast"`, which is a pseudo color that Highcharts picks up
               * and applies the maximum contrast to the underlying point item,
               * for example the bar in a bar chart.
               *
               * The `textOutline` is a pseudo property that applies an outline of
               * the given width with the given color, which by default is the
               * maximum contrast to the text. So a bright text color will result
               * in a black text outline for maximum readability on a mixed
               * background. In some cases, especially with grayscale text, the
               * text outline doesn't work well, in which cases it can be disabled
               * by setting it to `"none"`. When `useHTML` is true, the
               * `textOutline` will not be picked up. In this, case, the same
               * effect can be acheived through the `text-shadow` CSS property.
               *
               * For some series types, where each point has an extent, like for
               * example tree maps, the data label may overflow the point. There
               * are two strategies for handling overflow. By default, the text
               * will wrap to multiple lines. The other strategy is to set
               * `style.textOverflow` to `ellipsis`, which will keep the text on
               * one line plus it will break inside long words.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-style/
               *         Bold labels
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow/
               *         Long labels truncated with an ellipsis in a pie
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow-wrap/
               *         Long labels are wrapped in a pie
               * @sample {highmaps} maps/demo/color-axis/
               *         Bold labels
               *
               * @type      {Highcharts.CSSObject}
               * @since     4.1.0
               * @apioption plotOptions.series.dataLabels.style
               */
              style: {
                /** @internal */
                fontSize: "11px",
                /** @internal */
                fontWeight: "bold",
                /** @internal */
                color: "contrast",
                /** @internal */
                textOutline: "1px contrast"
              },
              /**
               * Options for a label text which should follow marker's shape.
               * Border and background are disabled for a label that follows a
               * path.
               *
               * **Note:** Only SVG-based renderer supports this option. Setting
               * `useHTML` to true will disable this option.
               *
               * @declare   Highcharts.DataLabelsTextPathOptionsObject
               * @since     7.1.0
               * @apioption plotOptions.series.dataLabels.textPath
               */
              /**
               * Presentation attributes for the text path.
               *
               * @type      {Highcharts.SVGAttributes}
               * @since     7.1.0
               * @apioption plotOptions.series.dataLabels.textPath.attributes
               */
              /**
               * Enable or disable `textPath` option for link's or marker's data
               * labels.
               *
               * @type      {boolean}
               * @since     7.1.0
               * @apioption plotOptions.series.dataLabels.textPath.enabled
               */
              /**
               * Whether to
               * [use HTML](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting#html)
               * to render the labels.
               *
               * @type      {boolean}
               * @default   false
               * @apioption plotOptions.series.dataLabels.useHTML
               */
              /**
               * The vertical alignment of a data label. Can be one of `top`,
               * `middle` or `bottom`. The default value depends on the data, for
               * instance in a column chart, the label is above positive values
               * and below negative values.
               *
               * @type  {Highcharts.VerticalAlignValue|null}
               * @since 2.3.3
               */
              verticalAlign: "bottom",
              /**
               * The x position offset of the label relative to the point in
               * pixels.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
               *         Vertical and positioned
               * @sample {highcharts} highcharts/plotoptions/bar-datalabels-align-inside-bar/
               *         Data labels inside the bar
               */
              x: 0,
              /**
               * The z index of the data labels. Use a `zIndex` of 6 to display it above
               * the series, or use a `zIndex` of 2 to display it behind the series.
               *
               * @type      {number}
               * @default   6
               * @since     2.3.5
               * @apioption plotOptions.series.dataLabels.zIndex
               */
              /**
               * The y position offset of the label relative to the point in
               * pixels.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-rotation/
               *         Vertical and positioned
               */
              y: 0
            },
            /**
             * When the series contains less points than the crop threshold, all
             * points are drawn, even if the points fall outside the visible plot
             * area at the current zoom. The advantage of drawing all points
             * (including markers and columns), is that animation is performed on
             * updates. On the other hand, when the series contains more points than
             * the crop threshold, the series data is cropped to only contain points
             * that fall within the plot area. The advantage of cropping away
             * invisible points is to increase performance on large series.
             *
             * @since   2.2
             * @product highcharts highstock
             *
             * @private
             */
            cropThreshold: 300,
            /**
             * Opacity of a series parts: line, fill (e.g. area) and dataLabels.
             *
             * @see [states.inactive.opacity](#plotOptions.series.states.inactive.opacity)
             *
             * @since 7.1.0
             *
             * @private
             */
            opacity: 1,
            /**
             * The width of each point on the x axis. For example in a column chart
             * with one value each day, the pointRange would be 1 day (= 24 * 3600
             * * 1000 milliseconds). This is normally computed automatically, but
             * this option can be used to override the automatic value.
             *
             * @product highstock
             *
             * @private
             */
            pointRange: 0,
            /**
             * When this is true, the series will not cause the Y axis to cross
             * the zero plane (or [threshold](#plotOptions.series.threshold) option)
             * unless the data actually crosses the plane.
             *
             * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
             * 3 will make the Y axis show negative values according to the
             * `minPadding` option. If `softThreshold` is `true`, the Y axis starts
             * at 0.
             *
             * @since   4.1.9
             * @product highcharts highstock
             *
             * @private
             */
            softThreshold: true,
            /**
             * @declare Highcharts.SeriesStatesOptionsObject
             *
             * @private
             */
            states: {
              /**
               * The normal state of a series, or for point items in column, pie
               * and similar series. Currently only used for setting animation
               * when returning to normal state from hover.
               *
               * @declare Highcharts.SeriesStatesNormalOptionsObject
               */
              normal: {
                /**
                 * Animation when returning to normal state after hovering.
                 *
                     * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 */
                animation: true
              },
              /**
               * Options for the hovered series. These settings override the
               * normal state options when a series is moused over or touched.
               *
               * @declare Highcharts.SeriesStatesHoverOptionsObject
               */
              hover: {
                /**
                 * Enable separate styles for the hovered series to visualize
                 * that the user hovers either the series itself or the legend.
                 *
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled/
                 *         Line
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-column/
                 *         Column
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-enabled-pie/
                 *         Pie
                 *
                 * @type      {boolean}
                 * @default   true
                 * @since     1.2
                 * @apioption plotOptions.series.states.hover.enabled
                 */
                /**
                 * Animation setting for hovering the graph in line-type series.
                 *
                 * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 * @since   5.0.8
                 * @product highcharts highstock
                 */
                animation: {
                  /**
                   * The duration of the hover animation in milliseconds. By
                   * default the hover state animates quickly in, and slowly
                   * back to normal.
                   *
                   * @internal
                   */
                  duration: 50
                },
                /**
                 * Pixel width of the graph line. By default this property is
                 * undefined, and the `lineWidthPlus` property dictates how much
                 * to increase the linewidth from normal state.
                 *
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidth/
                 *         5px line on hover
                 *
                 * @type      {number}
                 * @product   highcharts highstock
                 * @apioption plotOptions.series.states.hover.lineWidth
                 */
                /**
                 * The additional line width for the graph of a hovered series.
                 *
                 * @sample {highcharts} highcharts/plotoptions/series-states-hover-linewidthplus/
                 *         5 pixels wider
                 * @sample {highstock} highcharts/plotoptions/series-states-hover-linewidthplus/
                 *         5 pixels wider
                 *
                 * @since   4.0.3
                 * @product highcharts highstock
                 */
                lineWidthPlus: 1,
                /**
                 * In Highcharts 1.0, the appearance of all markers belonging
                 * to the hovered series. For settings on the hover state of the
                 * individual point, see
                 * [marker.states.hover](#plotOptions.series.marker.states.hover).
                 *
                 * @deprecated
                 *
                 * @extends   plotOptions.series.marker
                 * @excluding states, symbol
                 * @product   highcharts highstock
                 */
                marker: {
                  // lineWidth: base + 1,
                  // radius: base + 1
                },
                /**
                 * Options for the halo appearing around the hovered point in
                 * line-type series as well as outside the hovered slice in pie
                 * charts. By default the halo is filled by the current point or
                 * series color with an opacity of 0.25\. The halo can be
                 * disabled by setting the `halo` option to `null`.
                 *
                 * In styled mode, the halo is styled with the
                 * `.highcharts-halo` class, with colors inherited from
                 * `.highcharts-color-{n}`.
                 *
                 * @sample {highcharts} highcharts/plotoptions/halo/
                 *         Halo options
                 * @sample {highstock} highcharts/plotoptions/halo/
                 *         Halo options
                 *
                 * @declare Highcharts.SeriesStatesHoverHaloOptionsObject
                 * @type    {null|*}
                 * @since   4.0
                 * @product highcharts highstock
                 */
                halo: {
                  /**
                   * A collection of SVG attributes to override the appearance
                   * of the halo, for example `fill`, `stroke` and
                   * `stroke-width`.
                   *
                   * @type      {Highcharts.SVGAttributes}
                   * @since     4.0
                   * @product   highcharts highstock
                   * @apioption plotOptions.series.states.hover.halo.attributes
                   */
                  /**
                   * The pixel size of the halo. For point markers this is the
                   * radius of the halo. For pie slices it is the width of the
                   * halo outside the slice. For bubbles it defaults to 5 and
                   * is the width of the halo outside the bubble.
                   *
                   * @since   4.0
                   * @product highcharts highstock
                   */
                  size: 10,
                  /**
                   * Opacity for the halo unless a specific fill is overridden
                   * using the `attributes` setting. Note that Highcharts is
                   * only able to apply opacity to colors of hex or rgb(a)
                   * formats.
                   *
                   * @since   4.0
                   * @product highcharts highstock
                   */
                  opacity: 0.25
                }
              },
              /**
               * Specific options for point in selected states, after being
               * selected by
               * [allowPointSelect](#plotOptions.series.allowPointSelect)
               * or programmatically.
               *
               * @sample maps/plotoptions/series-allowpointselect/
               *         Allow point select demo
               *
               * @declare   Highcharts.SeriesStatesSelectOptionsObject
               * @extends   plotOptions.series.states.hover
               * @excluding brightness
               */
              select: {
                animation: {
                  /** @internal */
                  duration: 0
                }
              },
              /**
               * The opposite state of a hover for series.
               *
               * @sample highcharts/plotoptions/series-states-inactive-disabled
               *         Disabled inactive state
               *
               * @declare Highcharts.SeriesStatesInactiveOptionsObject
               */
              inactive: {
                /**
                 * Enable or disable the inactive state for a series
                 *
                 * @sample highcharts/plotoptions/series-states-inactive-disabled
                 *         Disabled inactive state
                 *
                 * @type {boolean}
                 * @default true
                 * @apioption plotOptions.series.states.inactive.enabled
                 */
                /**
                 * The animation for entering the inactive state.
                 *
                 * @type {boolean|Partial<Highcharts.AnimationOptionsObject>}
                 */
                animation: {
                  /** @internal */
                  duration: 50
                },
                /**
                 * Opacity of series elements (dataLabels, line, area).
                 *
                 * @type {number}
                 */
                opacity: 0.2
              }
            },
            /**
             * Sticky tracking of mouse events. When true, the `mouseOut` event on a
             * series isn't triggered until the mouse moves over another series, or
             * out of the plot area. When false, the `mouseOut` event on a series is
             * triggered when the mouse leaves the area around the series' graph or
             * markers. This also implies the tooltip when not shared. When
             * `stickyTracking` is false and `tooltip.shared` is false, the tooltip
             * will be hidden when moving the mouse between series. Defaults to true
             * for line and area type series, but to false for columns, pies etc.
             *
             * **Note:** The boost module will force this option because of
             * technical limitations.
             *
             * @sample {highcharts} highcharts/plotoptions/series-stickytracking-true/
             *         True by default
             * @sample {highcharts} highcharts/plotoptions/series-stickytracking-false/
             *         False
             *
             * @default {highcharts} true
             * @default {highstock} true
             * @default {highmaps} false
             * @since   2.0
             *
             * @private
             */
            stickyTracking: true,
            /**
             * A configuration object for the tooltip rendering of each single
             * series. Properties are inherited from [tooltip](#tooltip), but only
             * the following properties can be defined on a series level.
             *
             * @declare   Highcharts.SeriesTooltipOptionsObject
             * @since     2.3
             * @extends   tooltip
             * @excluding animation, backgroundColor, borderColor, borderRadius,
             *            borderWidth, className, crosshairs, enabled, formatter,
             *            headerShape, hideDelay, outside, padding, positioner,
             *            shadow, shape, shared, snap, split, stickOnContact,
             *            style, useHTML
             * @apioption plotOptions.series.tooltip
             */
            /**
             * When a series contains a data array that is longer than this, only
             * one dimensional arrays of numbers, or two dimensional arrays with
             * x and y values are allowed. Also, only the first point is tested,
             * and the rest are assumed to be the same format. This saves expensive
             * data checking and indexing in long series. Set it to `0` disable.
             *
             * Note:
             * In boost mode turbo threshold is forced. Only array of numbers or
             * two dimensional arrays are allowed.
             *
             * @since   2.2
             * @product highcharts highstock gantt
             *
             * @private
             */
            turboThreshold: 1e3,
            /**
             * An array defining zones within a series. Zones can be applied to the
             * X axis, Y axis or Z axis for bubbles, according to the `zoneAxis`
             * option. The zone definitions have to be in ascending order regarding
             * to the value.
             *
             * In styled mode, the color zones are styled with the
             * `.highcharts-zone-{n}` class, or custom classed from the `className`
             * option
             * ([view live demo](https://jsfiddle.net/gh/get/library/pure/highcharts/highcharts/tree/master/samples/highcharts/css/color-zones/)).
             *
             * @see [zoneAxis](#plotOptions.series.zoneAxis)
             *
             * @sample {highcharts} highcharts/series/color-zones-simple/
             *         Color zones
             * @sample {highstock} highcharts/series/color-zones-simple/
             *         Color zones
             *
             * @declare   Highcharts.SeriesZonesOptionsObject
             * @type      {Array<*>}
             * @since     4.1.0
             * @product   highcharts highstock
             * @apioption plotOptions.series.zones
             */
            /**
             * Styled mode only. A custom class name for the zone.
             *
             * @sample highcharts/css/color-zones/
             *         Zones styled by class name
             *
             * @type      {string}
             * @since     5.0.0
             * @apioption plotOptions.series.zones.className
             */
            /**
             * Defines the color of the series.
             *
             * @see [series color](#plotOptions.series.color)
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @since     4.1.0
             * @product   highcharts highstock
             * @apioption plotOptions.series.zones.color
             */
            /**
             * A name for the dash style to use for the graph.
             *
             * @see [plotOptions.series.dashStyle](#plotOptions.series.dashStyle)
             *
             * @sample {highcharts|highstock} highcharts/series/color-zones-dashstyle-dot/
             *         Dashed line indicates prognosis
             *
             * @type      {Highcharts.DashStyleValue}
             * @since     4.1.0
             * @product   highcharts highstock
             * @apioption plotOptions.series.zones.dashStyle
             */
            /**
             * Defines the fill color for the series (in area type series)
             *
             * @see [fillColor](#plotOptions.area.fillColor)
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @since     4.1.0
             * @product   highcharts highstock
             * @apioption plotOptions.series.zones.fillColor
             */
            /**
             * The value up to where the zone extends, if undefined the zones
             * stretches to the last value in the series.
             *
             * @type      {number}
             * @since     4.1.0
             * @product   highcharts highstock
             * @apioption plotOptions.series.zones.value
             */
            /**
             * When using dual or multiple color axes, this number defines which
             * colorAxis the particular series is connected to. It refers to
             * either the
             * {@link #colorAxis.id|axis id}
             * or the index of the axis in the colorAxis array, with 0 being the
             * first. Set this option to false to prevent a series from connecting
             * to the default color axis.
             *
             * Since v7.2.0 the option can also be an axis id or an axis index
             * instead of a boolean flag.
             *
             * @sample highcharts/coloraxis/coloraxis-with-pie/
             *         Color axis with pie series
             * @sample highcharts/coloraxis/multiple-coloraxis/
             *         Multiple color axis
             *
             * @type      {number|string|boolean}
             * @default   0
             * @product   highcharts highstock highmaps
             * @apioption plotOptions.series.colorAxis
             */
            /**
             * Determines what data value should be used to calculate point color
             * if `colorAxis` is used. Requires to set `min` and `max` if some
             * custom point property is used or if approximation for data grouping
             * is set to `'sum'`.
             *
             * @sample highcharts/coloraxis/custom-color-key/
             *         Custom color key
             * @sample highcharts/coloraxis/color-key-with-stops/
             *         Custom colorKey with color axis stops
             * @sample highcharts/coloraxis/changed-default-color-key/
             *         Changed default color key
             *
             * @type      {string}
             * @default   y
             * @since     7.2.0
             * @product   highcharts highstock highmaps
             * @apioption plotOptions.series.colorKey
             */
            /**
             * Determines whether the series should look for the nearest point
             * in both dimensions or just the x-dimension when hovering the series.
             * Defaults to `'xy'` for scatter series and `'x'` for most other
             * series. If the data has duplicate x-values, it is recommended to
             * set this to `'xy'` to allow hovering over all points.
             *
             * Applies only to series types using nearest neighbor search (not
             * direct hover) for tooltip.
             *
             * @sample {highcharts} highcharts/series/findnearestpointby/
             *         Different hover behaviors
             * @sample {highstock} highcharts/series/findnearestpointby/
             *         Different hover behaviors
             * @sample {highmaps} highcharts/series/findnearestpointby/
             *         Different hover behaviors
             *
             * @since      5.0.10
             * @validvalue ["x", "xy"]
             *
             * @private
             */
            findNearestPointBy: "x"
          };
          return seriesDefaults;
        });
        _registerModule(_modules, "Core/Series/Series.js", [_modules["Core/Animation/AnimationUtilities.js"], _modules["Core/Defaults.js"], _modules["Core/Foundation.js"], _modules["Core/Globals.js"], _modules["Core/Legend/LegendSymbol.js"], _modules["Core/Series/Point.js"], _modules["Core/Series/SeriesDefaults.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Renderer/SVG/SVGElement.js"], _modules["Core/Utilities.js"]], function(A, D, F, H, LegendSymbol, Point, SeriesDefaults, SeriesRegistry, SVGElement, U) {
          var animObject = A.animObject, setAnimation = A.setAnimation;
          var defaultOptions = D.defaultOptions;
          var registerEventOptions = F.registerEventOptions;
          var hasTouch = H.hasTouch, svg = H.svg, win = H.win;
          var seriesTypes = SeriesRegistry.seriesTypes;
          var addEvent = U.addEvent, arrayMax = U.arrayMax, arrayMin = U.arrayMin, clamp = U.clamp, cleanRecursively = U.cleanRecursively, correctFloat = U.correctFloat, defined = U.defined, erase = U.erase, error = U.error, extend2 = U.extend, find2 = U.find, fireEvent = U.fireEvent, getNestedProperty = U.getNestedProperty, isArray = U.isArray, isNumber = U.isNumber, isString = U.isString, merge = U.merge, objectEach = U.objectEach, pick = U.pick, removeEvent = U.removeEvent, splat = U.splat, syncTimeout = U.syncTimeout;
          var Series = (
            /** @class */
            function() {
              function Series2() {
                this._i = void 0;
                this.chart = void 0;
                this.data = void 0;
                this.eventOptions = void 0;
                this.eventsToUnbind = void 0;
                this.index = void 0;
                this.linkedSeries = void 0;
                this.options = void 0;
                this.points = void 0;
                this.processedXData = void 0;
                this.processedYData = void 0;
                this.tooltipOptions = void 0;
                this.userOptions = void 0;
                this.xAxis = void 0;
                this.yAxis = void 0;
                this.zones = void 0;
              }
              Series2.prototype.init = function(chart, userOptions) {
                fireEvent(this, "init", { options: userOptions });
                var series = this, chartSeries = chart.series;
                this.eventsToUnbind = [];
                series.chart = chart;
                series.options = series.setOptions(userOptions);
                var options = series.options;
                series.linkedSeries = [];
                series.bindAxes();
                extend2(series, {
                  /**
                   * The series name as given in the options. Defaults to
                   * "Series {n}".
                   *
                   * @name Highcharts.Series#name
                   * @type {string}
                   */
                  name: options.name,
                  state: "",
                  /**
                   * Read only. The series' visibility state as set by {@link
                   * Series#show}, {@link Series#hide}, or in the initial
                   * configuration.
                   *
                   * @name Highcharts.Series#visible
                   * @type {boolean}
                   */
                  visible: options.visible !== false,
                  /**
                   * Read only. The series' selected state as set by {@link
                   * Highcharts.Series#select}.
                   *
                   * @name Highcharts.Series#selected
                   * @type {boolean}
                   */
                  selected: options.selected === true
                  // false by default
                });
                registerEventOptions(this, options);
                var events = options.events;
                if (events && events.click || options.point && options.point.events && options.point.events.click || options.allowPointSelect) {
                  chart.runTrackerClick = true;
                }
                series.getColor();
                series.getSymbol();
                series.parallelArrays.forEach(function(key) {
                  if (!series[key + "Data"]) {
                    series[key + "Data"] = [];
                  }
                });
                if (series.isCartesian) {
                  chart.hasCartesianSeries = true;
                }
                var lastSeries;
                if (chartSeries.length) {
                  lastSeries = chartSeries[chartSeries.length - 1];
                }
                series._i = pick(lastSeries && lastSeries._i, -1) + 1;
                series.opacity = series.options.opacity;
                chart.orderSeries(this.insert(chartSeries));
                if (options.dataSorting && options.dataSorting.enabled) {
                  series.setDataSortingOptions();
                } else if (!series.points && !series.data) {
                  series.setData(options.data, false);
                }
                fireEvent(this, "afterInit");
              };
              Series2.prototype.is = function(type) {
                return seriesTypes[type] && this instanceof seriesTypes[type];
              };
              Series2.prototype.insert = function(collection) {
                var indexOption = this.options.index;
                var i;
                if (isNumber(indexOption)) {
                  i = collection.length;
                  while (i--) {
                    if (indexOption >= pick(collection[i].options.index, collection[i]._i)) {
                      collection.splice(i + 1, 0, this);
                      break;
                    }
                  }
                  if (i === -1) {
                    collection.unshift(this);
                  }
                  i = i + 1;
                } else {
                  collection.push(this);
                }
                return pick(i, collection.length - 1);
              };
              Series2.prototype.bindAxes = function() {
                var series = this, seriesOptions = series.options, chart = series.chart;
                var axisOptions;
                fireEvent(this, "bindAxes", null, function() {
                  (series.axisTypes || []).forEach(function(AXIS) {
                    var index = 0;
                    chart[AXIS].forEach(function(axis) {
                      axisOptions = axis.options;
                      if (seriesOptions[AXIS] === index && !axisOptions.isInternal || typeof seriesOptions[AXIS] !== "undefined" && seriesOptions[AXIS] === axisOptions.id || typeof seriesOptions[AXIS] === "undefined" && axisOptions.index === 0) {
                        series.insert(axis.series);
                        series[AXIS] = axis;
                        axis.isDirty = true;
                      }
                      if (!axisOptions.isInternal) {
                        index++;
                      }
                    });
                    if (!series[AXIS] && series.optionalAxis !== AXIS) {
                      error(18, true, chart);
                    }
                  });
                });
                fireEvent(this, "afterBindAxes");
              };
              Series2.prototype.updateParallelArrays = function(point, i) {
                var series = point.series, args = arguments, fn = isNumber(i) ? (
                  // Insert the value in the given position
                  function(key) {
                    var val = key === "y" && series.toYData ? series.toYData(point) : point[key];
                    series[key + "Data"][i] = val;
                  }
                ) : (
                  // Apply the method specified in i with the following
                  // arguments as arguments
                  function(key) {
                    Array.prototype[i].apply(series[key + "Data"], Array.prototype.slice.call(args, 2));
                  }
                );
                series.parallelArrays.forEach(fn);
              };
              Series2.prototype.hasData = function() {
                return this.visible && typeof this.dataMax !== "undefined" && typeof this.dataMin !== "undefined" || // #3703
                this.visible && this.yData && this.yData.length > 0;
              };
              Series2.prototype.autoIncrement = function(x) {
                var options = this.options, pointIntervalUnit = options.pointIntervalUnit, relativeXValue = options.relativeXValue, time = this.chart.time;
                var xIncrement = this.xIncrement, date, pointInterval;
                xIncrement = pick(xIncrement, options.pointStart, 0);
                this.pointInterval = pointInterval = pick(this.pointInterval, options.pointInterval, 1);
                if (relativeXValue && isNumber(x)) {
                  pointInterval *= x;
                }
                if (pointIntervalUnit) {
                  date = new time.Date(xIncrement);
                  if (pointIntervalUnit === "day") {
                    time.set("Date", date, time.get("Date", date) + pointInterval);
                  } else if (pointIntervalUnit === "month") {
                    time.set("Month", date, time.get("Month", date) + pointInterval);
                  } else if (pointIntervalUnit === "year") {
                    time.set("FullYear", date, time.get("FullYear", date) + pointInterval);
                  }
                  pointInterval = date.getTime() - xIncrement;
                }
                if (relativeXValue && isNumber(x)) {
                  return xIncrement + pointInterval;
                }
                this.xIncrement = xIncrement + pointInterval;
                return xIncrement;
              };
              Series2.prototype.setDataSortingOptions = function() {
                var options = this.options;
                extend2(this, {
                  requireSorting: false,
                  sorted: false,
                  enabledDataSorting: true,
                  allowDG: false
                });
                if (!defined(options.pointRange)) {
                  options.pointRange = 1;
                }
              };
              Series2.prototype.setOptions = function(itemOptions) {
                var chart = this.chart, chartOptions = chart.options, plotOptions = chartOptions.plotOptions, userOptions = chart.userOptions || {}, seriesUserOptions = merge(itemOptions), styledMode = chart.styledMode, e = {
                  plotOptions,
                  userOptions: seriesUserOptions
                };
                var zone;
                fireEvent(this, "setOptions", e);
                var typeOptions = e.plotOptions[this.type], userPlotOptions = userOptions.plotOptions || {};
                this.userOptions = e.userOptions;
                var options = merge(
                  typeOptions,
                  plotOptions.series,
                  // #3881, chart instance plotOptions[type] should trump
                  // plotOptions.series
                  userOptions.plotOptions && userOptions.plotOptions[this.type],
                  seriesUserOptions
                );
                this.tooltipOptions = merge(
                  defaultOptions.tooltip,
                  // 1
                  defaultOptions.plotOptions.series && defaultOptions.plotOptions.series.tooltip,
                  // 2
                  defaultOptions.plotOptions[this.type].tooltip,
                  // 3
                  chartOptions.tooltip.userOptions,
                  // 4
                  plotOptions.series && plotOptions.series.tooltip,
                  // 5
                  plotOptions[this.type].tooltip,
                  // 6
                  seriesUserOptions.tooltip
                  // 7
                );
                this.stickyTracking = pick(seriesUserOptions.stickyTracking, userPlotOptions[this.type] && userPlotOptions[this.type].stickyTracking, userPlotOptions.series && userPlotOptions.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : options.stickyTracking);
                if (typeOptions.marker === null) {
                  delete options.marker;
                }
                this.zoneAxis = options.zoneAxis;
                var zones = this.zones = (options.zones || []).slice();
                if ((options.negativeColor || options.negativeFillColor) && !options.zones) {
                  zone = {
                    value: options[this.zoneAxis + "Threshold"] || options.threshold || 0,
                    className: "highcharts-negative"
                  };
                  if (!styledMode) {
                    zone.color = options.negativeColor;
                    zone.fillColor = options.negativeFillColor;
                  }
                  zones.push(zone);
                }
                if (zones.length) {
                  if (defined(zones[zones.length - 1].value)) {
                    zones.push(styledMode ? {} : {
                      color: this.color,
                      fillColor: this.fillColor
                    });
                  }
                }
                fireEvent(this, "afterSetOptions", { options });
                return options;
              };
              Series2.prototype.getName = function() {
                return pick(this.options.name, "Series " + (this.index + 1));
              };
              Series2.prototype.getCyclic = function(prop, value, defaults) {
                var chart = this.chart, userOptions = this.userOptions, indexName = prop + "Index", counterName = prop + "Counter", len = defaults ? defaults.length : pick(chart.options.chart[prop + "Count"], chart[prop + "Count"]);
                var i, setting;
                if (!value) {
                  setting = pick(userOptions[indexName], userOptions["_" + indexName]);
                  if (defined(setting)) {
                    i = setting;
                  } else {
                    if (!chart.series.length) {
                      chart[counterName] = 0;
                    }
                    userOptions["_" + indexName] = i = chart[counterName] % len;
                    chart[counterName] += 1;
                  }
                  if (defaults) {
                    value = defaults[i];
                  }
                }
                if (typeof i !== "undefined") {
                  this[indexName] = i;
                }
                this[prop] = value;
              };
              Series2.prototype.getColor = function() {
                if (this.chart.styledMode) {
                  this.getCyclic("color");
                } else if (this.options.colorByPoint) {
                  this.color = "#cccccc";
                } else {
                  this.getCyclic("color", this.options.color || defaultOptions.plotOptions[this.type].color, this.chart.options.colors);
                }
              };
              Series2.prototype.getPointsCollection = function() {
                return (this.hasGroupedData ? this.points : this.data) || [];
              };
              Series2.prototype.getSymbol = function() {
                var seriesMarkerOption = this.options.marker;
                this.getCyclic("symbol", seriesMarkerOption.symbol, this.chart.options.symbols);
              };
              Series2.prototype.findPointIndex = function(optionsObject, fromIndex) {
                var id2 = optionsObject.id, x = optionsObject.x, oldData = this.points, dataSorting = this.options.dataSorting;
                var matchingPoint, matchedById, pointIndex;
                if (id2) {
                  var item = this.chart.get(id2);
                  if (item instanceof Point) {
                    matchingPoint = item;
                  }
                } else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
                  var matcher = function(oldPoint) {
                    return !oldPoint.touched && oldPoint.index === optionsObject.index;
                  };
                  if (dataSorting && dataSorting.matchByName) {
                    matcher = function(oldPoint) {
                      return !oldPoint.touched && oldPoint.name === optionsObject.name;
                    };
                  } else if (this.options.relativeXValue) {
                    matcher = function(oldPoint) {
                      return !oldPoint.touched && oldPoint.options.x === optionsObject.x;
                    };
                  }
                  matchingPoint = find2(oldData, matcher);
                  if (!matchingPoint) {
                    return void 0;
                  }
                }
                if (matchingPoint) {
                  pointIndex = matchingPoint && matchingPoint.index;
                  if (typeof pointIndex !== "undefined") {
                    matchedById = true;
                  }
                }
                if (typeof pointIndex === "undefined" && isNumber(x)) {
                  pointIndex = this.xData.indexOf(x, fromIndex);
                }
                if (pointIndex !== -1 && typeof pointIndex !== "undefined" && this.cropped) {
                  pointIndex = pointIndex >= this.cropStart ? pointIndex - this.cropStart : pointIndex;
                }
                if (!matchedById && isNumber(pointIndex) && oldData[pointIndex] && oldData[pointIndex].touched) {
                  pointIndex = void 0;
                }
                return pointIndex;
              };
              Series2.prototype.updateData = function(data, animation) {
                var options = this.options, dataSorting = options.dataSorting, oldData = this.points, pointsToAdd = [], requireSorting = this.requireSorting, equalLength = data.length === oldData.length;
                var hasUpdatedByKey, i, point, lastIndex, succeeded = true;
                this.xIncrement = null;
                data.forEach(function(pointOptions, i2) {
                  var optionsObject = defined(pointOptions) && this.pointClass.prototype.optionsToObject.call(
                    { series: this },
                    pointOptions
                  ) || {};
                  var pointIndex;
                  var x = optionsObject.x, id2 = optionsObject.id;
                  if (id2 || isNumber(x)) {
                    pointIndex = this.findPointIndex(optionsObject, lastIndex);
                    if (pointIndex === -1 || typeof pointIndex === "undefined") {
                      pointsToAdd.push(pointOptions);
                    } else if (oldData[pointIndex] && pointOptions !== options.data[pointIndex]) {
                      oldData[pointIndex].update(pointOptions, false, null, false);
                      oldData[pointIndex].touched = true;
                      if (requireSorting) {
                        lastIndex = pointIndex + 1;
                      }
                    } else if (oldData[pointIndex]) {
                      oldData[pointIndex].touched = true;
                    }
                    if (!equalLength || i2 !== pointIndex || dataSorting && dataSorting.enabled || this.hasDerivedData) {
                      hasUpdatedByKey = true;
                    }
                  } else {
                    pointsToAdd.push(pointOptions);
                  }
                }, this);
                if (hasUpdatedByKey) {
                  i = oldData.length;
                  while (i--) {
                    point = oldData[i];
                    if (point && !point.touched && point.remove) {
                      point.remove(false, animation);
                    }
                  }
                } else if (equalLength && (!dataSorting || !dataSorting.enabled)) {
                  data.forEach(function(point2, i2) {
                    if (point2 !== oldData[i2].y && oldData[i2].update) {
                      oldData[i2].update(point2, false, null, false);
                    }
                  });
                  pointsToAdd.length = 0;
                } else {
                  succeeded = false;
                }
                oldData.forEach(function(point2) {
                  if (point2) {
                    point2.touched = false;
                  }
                });
                if (!succeeded) {
                  return false;
                }
                pointsToAdd.forEach(function(point2) {
                  this.addPoint(point2, false, null, null, false);
                }, this);
                if (this.xIncrement === null && this.xData && this.xData.length) {
                  this.xIncrement = arrayMax(this.xData);
                  this.autoIncrement();
                }
                return true;
              };
              Series2.prototype.setData = function(data, redraw, animation, updatePoints) {
                if (redraw === void 0) {
                  redraw = true;
                }
                var series = this, oldData = series.points, oldDataLength = oldData && oldData.length || 0, options = series.options, chart = series.chart, dataSorting = options.dataSorting, xAxis = series.xAxis, turboThreshold = options.turboThreshold, xData = this.xData, yData = this.yData, pointArrayMap = series.pointArrayMap, valueCount = pointArrayMap && pointArrayMap.length, keys = options.keys;
                var i, pt, updatedData, indexOfX = 0, indexOfY = 1, firstPoint = null, copiedData;
                if (!chart.options.chart.allowMutatingData) {
                  if (options.data) {
                    delete series.options.data;
                  }
                  if (series.userOptions.data) {
                    delete series.userOptions.data;
                  }
                  copiedData = merge(true, data);
                }
                data = copiedData || data || [];
                var dataLength = data.length;
                if (dataSorting && dataSorting.enabled) {
                  data = this.sortData(data);
                }
                if (chart.options.chart.allowMutatingData && updatePoints !== false && dataLength && oldDataLength && !series.cropped && !series.hasGroupedData && series.visible && // Soft updating has no benefit in boost, and causes JS error
                // (#8355)
                !series.boosted) {
                  updatedData = this.updateData(data, animation);
                }
                if (!updatedData) {
                  series.xIncrement = null;
                  series.colorCounter = 0;
                  this.parallelArrays.forEach(function(key) {
                    series[key + "Data"].length = 0;
                  });
                  if (turboThreshold && dataLength > turboThreshold) {
                    firstPoint = series.getFirstValidPoint(data);
                    if (isNumber(firstPoint)) {
                      for (i = 0; i < dataLength; i++) {
                        xData[i] = this.autoIncrement();
                        yData[i] = data[i];
                      }
                    } else if (isArray(firstPoint)) {
                      if (valueCount) {
                        if (firstPoint.length === valueCount) {
                          for (i = 0; i < dataLength; i++) {
                            xData[i] = this.autoIncrement();
                            yData[i] = data[i];
                          }
                        } else {
                          for (i = 0; i < dataLength; i++) {
                            pt = data[i];
                            xData[i] = pt[0];
                            yData[i] = pt.slice(1, valueCount + 1);
                          }
                        }
                      } else {
                        if (keys) {
                          indexOfX = keys.indexOf("x");
                          indexOfY = keys.indexOf("y");
                          indexOfX = indexOfX >= 0 ? indexOfX : 0;
                          indexOfY = indexOfY >= 0 ? indexOfY : 1;
                        }
                        if (firstPoint.length === 1) {
                          indexOfY = 0;
                        }
                        if (indexOfX === indexOfY) {
                          for (i = 0; i < dataLength; i++) {
                            xData[i] = this.autoIncrement();
                            yData[i] = data[i][indexOfY];
                          }
                        } else {
                          for (i = 0; i < dataLength; i++) {
                            pt = data[i];
                            xData[i] = pt[indexOfX];
                            yData[i] = pt[indexOfY];
                          }
                        }
                      }
                    } else {
                      error(12, false, chart);
                    }
                  } else {
                    for (i = 0; i < dataLength; i++) {
                      if (typeof data[i] !== "undefined") {
                        pt = { series };
                        series.pointClass.prototype.applyOptions.apply(pt, [data[i]]);
                        series.updateParallelArrays(pt, i);
                      }
                    }
                  }
                  if (yData && isString(yData[0])) {
                    error(14, true, chart);
                  }
                  series.data = [];
                  series.options.data = series.userOptions.data = data;
                  i = oldDataLength;
                  while (i--) {
                    if (oldData[i] && oldData[i].destroy) {
                      oldData[i].destroy();
                    }
                  }
                  if (xAxis) {
                    xAxis.minRange = xAxis.userMinRange;
                  }
                  series.isDirty = chart.isDirtyBox = true;
                  series.isDirtyData = !!oldData;
                  animation = false;
                }
                if (options.legendType === "point") {
                  this.processData();
                  this.generatePoints();
                }
                if (redraw) {
                  chart.redraw(animation);
                }
              };
              Series2.prototype.sortData = function(data) {
                var series = this, options = series.options, dataSorting = options.dataSorting, sortKey = dataSorting.sortKey || "y", getPointOptionsObject = function(series2, pointOptions) {
                  return defined(pointOptions) && series2.pointClass.prototype.optionsToObject.call(
                    {
                      series: series2
                    },
                    pointOptions
                  ) || {};
                };
                data.forEach(function(pointOptions, i) {
                  data[i] = getPointOptionsObject(series, pointOptions);
                  data[i].index = i;
                }, this);
                var sortedData = data.concat().sort(function(a, b) {
                  var aValue = getNestedProperty(
                    sortKey,
                    a
                  );
                  var bValue = getNestedProperty(
                    sortKey,
                    b
                  );
                  return bValue < aValue ? -1 : bValue > aValue ? 1 : 0;
                });
                sortedData.forEach(function(point, i) {
                  point.x = i;
                }, this);
                if (series.linkedSeries) {
                  series.linkedSeries.forEach(function(linkedSeries) {
                    var options2 = linkedSeries.options, seriesData = options2.data;
                    if ((!options2.dataSorting || !options2.dataSorting.enabled) && seriesData) {
                      seriesData.forEach(function(pointOptions, i) {
                        seriesData[i] = getPointOptionsObject(linkedSeries, pointOptions);
                        if (data[i]) {
                          seriesData[i].x = data[i].x;
                          seriesData[i].index = i;
                        }
                      });
                      linkedSeries.setData(seriesData, false);
                    }
                  });
                }
                return data;
              };
              Series2.prototype.getProcessedData = function(forceExtremesFromAll) {
                var series = this, xAxis = series.xAxis, options = series.options, cropThreshold = options.cropThreshold, getExtremesFromAll = forceExtremesFromAll || series.getExtremesFromAll || options.getExtremesFromAll, isCartesian = series.isCartesian, val2lin = xAxis && xAxis.val2lin, isLog = !!(xAxis && xAxis.logarithmic);
                var croppedData, cropped, cropStart = 0, distance, closestPointRange, i, xExtremes, min2, max2, processedXData = series.xData, processedYData = series.yData, throwOnUnsorted = series.requireSorting, updatingNames = false;
                var dataLength = processedXData.length;
                if (xAxis) {
                  xExtremes = xAxis.getExtremes();
                  min2 = xExtremes.min;
                  max2 = xExtremes.max;
                  updatingNames = !!(xAxis.categories && !xAxis.names.length);
                }
                if (isCartesian && series.sorted && !getExtremesFromAll && (!cropThreshold || dataLength > cropThreshold || series.forceCrop)) {
                  if (processedXData[dataLength - 1] < min2 || processedXData[0] > max2) {
                    processedXData = [];
                    processedYData = [];
                  } else if (series.yData && (processedXData[0] < min2 || processedXData[dataLength - 1] > max2)) {
                    croppedData = this.cropData(series.xData, series.yData, min2, max2);
                    processedXData = croppedData.xData;
                    processedYData = croppedData.yData;
                    cropStart = croppedData.start;
                    cropped = true;
                  }
                }
                i = processedXData.length || 1;
                while (--i) {
                  distance = isLog ? val2lin(processedXData[i]) - val2lin(processedXData[i - 1]) : processedXData[i] - processedXData[i - 1];
                  if (distance > 0 && (typeof closestPointRange === "undefined" || distance < closestPointRange)) {
                    closestPointRange = distance;
                  } else if (distance < 0 && throwOnUnsorted && !updatingNames) {
                    error(15, false, series.chart);
                    throwOnUnsorted = false;
                  }
                }
                return {
                  xData: processedXData,
                  yData: processedYData,
                  cropped,
                  cropStart,
                  closestPointRange
                };
              };
              Series2.prototype.processData = function(force) {
                var series = this, xAxis = series.xAxis;
                if (series.isCartesian && !series.isDirty && !xAxis.isDirty && !series.yAxis.isDirty && !force) {
                  return false;
                }
                var processedData = series.getProcessedData();
                series.cropped = processedData.cropped;
                series.cropStart = processedData.cropStart;
                series.processedXData = processedData.xData;
                series.processedYData = processedData.yData;
                series.closestPointRange = series.basePointRange = processedData.closestPointRange;
                fireEvent(series, "afterProcessData");
              };
              Series2.prototype.cropData = function(xData, yData, min2, max2, cropShoulder) {
                var dataLength = xData.length;
                var i, j, cropStart = 0, cropEnd = dataLength;
                cropShoulder = pick(cropShoulder, this.cropShoulder);
                for (i = 0; i < dataLength; i++) {
                  if (xData[i] >= min2) {
                    cropStart = Math.max(0, i - cropShoulder);
                    break;
                  }
                }
                for (j = i; j < dataLength; j++) {
                  if (xData[j] > max2) {
                    cropEnd = j + cropShoulder;
                    break;
                  }
                }
                return {
                  xData: xData.slice(cropStart, cropEnd),
                  yData: yData.slice(cropStart, cropEnd),
                  start: cropStart,
                  end: cropEnd
                };
              };
              Series2.prototype.generatePoints = function() {
                var series = this, options = series.options, dataOptions = series.processedData || options.data, processedXData = series.processedXData, processedYData = series.processedYData, PointClass = series.pointClass, processedDataLength = processedXData.length, cropStart = series.cropStart || 0, hasGroupedData = series.hasGroupedData, keys = options.keys, points = [], groupCropStartIndex = options.dataGrouping && options.dataGrouping.groupAll ? cropStart : 0;
                var dataLength, cursor, point, i, data = series.data;
                if (!data && !hasGroupedData) {
                  var arr = [];
                  arr.length = dataOptions.length;
                  data = series.data = arr;
                }
                if (keys && hasGroupedData) {
                  series.options.keys = false;
                }
                for (i = 0; i < processedDataLength; i++) {
                  cursor = cropStart + i;
                  if (!hasGroupedData) {
                    point = data[cursor];
                    if (!point && typeof dataOptions[cursor] !== "undefined") {
                      data[cursor] = point = new PointClass().init(series, dataOptions[cursor], processedXData[i]);
                    }
                  } else {
                    point = new PointClass().init(series, [processedXData[i]].concat(splat(processedYData[i])));
                    point.dataGroup = series.groupMap[groupCropStartIndex + i];
                    if (point.dataGroup.options) {
                      point.options = point.dataGroup.options;
                      extend2(point, point.dataGroup.options);
                      delete point.dataLabels;
                    }
                  }
                  if (point) {
                    point.index = hasGroupedData ? groupCropStartIndex + i : cursor;
                    points[i] = point;
                  }
                }
                series.options.keys = keys;
                if (data && (processedDataLength !== (dataLength = data.length) || hasGroupedData)) {
                  for (i = 0; i < dataLength; i++) {
                    if (i === cropStart && !hasGroupedData) {
                      i += processedDataLength;
                    }
                    if (data[i]) {
                      data[i].destroyElements();
                      data[i].plotX = void 0;
                    }
                  }
                }
                series.data = data;
                series.points = points;
                fireEvent(this, "afterGeneratePoints");
              };
              Series2.prototype.getXExtremes = function(xData) {
                return {
                  min: arrayMin(xData),
                  max: arrayMax(xData)
                };
              };
              Series2.prototype.getExtremes = function(yData, forceExtremesFromAll) {
                var xAxis = this.xAxis, yAxis = this.yAxis, xData = this.processedXData || this.xData, activeYData = [], shoulder = this.requireSorting ? this.cropShoulder : 0, positiveValuesOnly = yAxis ? yAxis.positiveValuesOnly : false;
                var xExtremes, validValue, withinRange, x, y, i, j, xMin = 0, xMax = 0, activeCounter = 0;
                yData = yData || this.stackedYData || this.processedYData || [];
                var yDataLength = yData.length;
                if (xAxis) {
                  xExtremes = xAxis.getExtremes();
                  xMin = xExtremes.min;
                  xMax = xExtremes.max;
                }
                for (i = 0; i < yDataLength; i++) {
                  x = xData[i];
                  y = yData[i];
                  validValue = (isNumber(y) || isArray(y)) && (y.length || y > 0 || !positiveValuesOnly);
                  withinRange = forceExtremesFromAll || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !xAxis || // for colorAxis support
                  (xData[i + shoulder] || x) >= xMin && (xData[i - shoulder] || x) <= xMax;
                  if (validValue && withinRange) {
                    j = y.length;
                    if (j) {
                      while (j--) {
                        if (isNumber(y[j])) {
                          activeYData[activeCounter++] = y[j];
                        }
                      }
                    } else {
                      activeYData[activeCounter++] = y;
                    }
                  }
                }
                var dataExtremes = {
                  activeYData,
                  dataMin: arrayMin(activeYData),
                  dataMax: arrayMax(activeYData)
                };
                fireEvent(this, "afterGetExtremes", { dataExtremes });
                return dataExtremes;
              };
              Series2.prototype.applyExtremes = function() {
                var dataExtremes = this.getExtremes();
                this.dataMin = dataExtremes.dataMin;
                this.dataMax = dataExtremes.dataMax;
                return dataExtremes;
              };
              Series2.prototype.getFirstValidPoint = function(data) {
                var dataLength = data.length;
                var i = 0, firstPoint = null;
                while (firstPoint === null && i < dataLength) {
                  firstPoint = data[i];
                  i++;
                }
                return firstPoint;
              };
              Series2.prototype.translate = function() {
                if (!this.processedXData) {
                  this.processData();
                }
                this.generatePoints();
                var series = this, options = series.options, stacking = options.stacking, xAxis = series.xAxis, categories = xAxis.categories, enabledDataSorting = series.enabledDataSorting, yAxis = series.yAxis, points = series.points, dataLength = points.length, pointPlacement = series.pointPlacementToXValue(), dynamicallyPlaced = Boolean(pointPlacement), threshold = options.threshold, stackThreshold = options.startFromThreshold ? threshold : 0, zoneAxis = this.zoneAxis || "y";
                var i, plotX, lastPlotX, stackIndicator, closestPointRangePx = Number.MAX_VALUE;
                function limitedRange(val) {
                  return clamp(val, -1e5, 1e5);
                }
                for (i = 0; i < dataLength; i++) {
                  var point = points[i], xValue = point.x;
                  var pointStack = void 0, stackValues = void 0, yValue = point.y, yBottom = point.low;
                  var stack = stacking && yAxis.stacking && yAxis.stacking.stacks[(series.negStacks && yValue < (stackThreshold ? 0 : threshold) ? "-" : "") + series.stackKey];
                  if (yAxis.positiveValuesOnly && !yAxis.validatePositiveValue(yValue) || xAxis.positiveValuesOnly && !xAxis.validatePositiveValue(xValue)) {
                    point.isNull = true;
                  }
                  point.plotX = plotX = correctFloat(
                    // #5236
                    // Get the plotX translation
                    limitedRange(xAxis.translate(
                      // #3923
                      xValue,
                      0,
                      0,
                      0,
                      1,
                      pointPlacement,
                      this.type === "flags"
                    ))
                    // #3923
                  );
                  if (stacking && series.visible && stack && stack[xValue]) {
                    stackIndicator = series.getStackIndicator(stackIndicator, xValue, series.index);
                    if (!point.isNull && stackIndicator.key) {
                      pointStack = stack[xValue];
                      stackValues = pointStack.points[stackIndicator.key];
                    }
                    if (pointStack && isArray(stackValues)) {
                      yBottom = stackValues[0];
                      yValue = stackValues[1];
                      if (yBottom === stackThreshold && stackIndicator.key === stack[xValue].base) {
                        yBottom = pick(isNumber(threshold) ? threshold : yAxis.min);
                      }
                      if (yAxis.positiveValuesOnly && defined(yBottom) && yBottom <= 0) {
                        yBottom = void 0;
                      }
                      point.total = point.stackTotal = pick(pointStack.total);
                      point.percentage = defined(point.y) && pointStack.total ? point.y / pointStack.total * 100 : void 0;
                      point.stackY = yValue;
                      if (!series.irregularWidths) {
                        pointStack.setOffset(series.pointXOffset || 0, series.barW || 0, void 0, void 0, void 0, series.xAxis);
                      }
                    }
                  }
                  point.yBottom = defined(yBottom) ? limitedRange(yAxis.translate(yBottom, 0, 1, 0, 1)) : void 0;
                  if (series.dataModify) {
                    yValue = series.dataModify.modifyValue(yValue, i);
                  }
                  point.plotY = void 0;
                  if (isNumber(yValue)) {
                    var translated = yAxis.translate(
                      yValue,
                      false,
                      true,
                      false,
                      true
                    );
                    if (typeof translated !== "undefined") {
                      point.plotY = limitedRange(translated);
                    }
                  }
                  point.isInside = this.isPointInside(point);
                  point.clientX = dynamicallyPlaced ? correctFloat(xAxis.translate(xValue, 0, 0, 0, 1, pointPlacement)) : plotX;
                  point.negative = point[zoneAxis] < (options[zoneAxis + "Threshold"] || threshold || 0);
                  point.category = pick(categories && categories[point.x], point.x);
                  if (!point.isNull && point.visible !== false) {
                    if (typeof lastPlotX !== "undefined") {
                      closestPointRangePx = Math.min(closestPointRangePx, Math.abs(plotX - lastPlotX));
                    }
                    lastPlotX = plotX;
                  }
                  point.zone = this.zones.length ? point.getZone() : void 0;
                  if (!point.graphic && series.group && enabledDataSorting) {
                    point.isNew = true;
                  }
                }
                series.closestPointRangePx = closestPointRangePx;
                fireEvent(this, "afterTranslate");
              };
              Series2.prototype.getValidPoints = function(points, insideOnly, allowNull) {
                var chart = this.chart;
                return (points || this.points || []).filter(function(point) {
                  if (insideOnly && !chart.isInsidePlot(point.plotX, point.plotY, { inverted: chart.inverted })) {
                    return false;
                  }
                  return point.visible !== false && (allowNull || !point.isNull);
                });
              };
              Series2.prototype.getClipBox = function() {
                var _a = this, chart = _a.chart, xAxis = _a.xAxis, yAxis = _a.yAxis;
                var seriesBox = merge(chart.clipBox);
                if (xAxis && xAxis.len !== chart.plotSizeX) {
                  seriesBox.width = xAxis.len;
                }
                if (yAxis && yAxis.len !== chart.plotSizeY) {
                  seriesBox.height = yAxis.len;
                }
                return seriesBox;
              };
              Series2.prototype.getSharedClipKey = function() {
                this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
                return this.sharedClipKey;
              };
              Series2.prototype.setClip = function() {
                var _a = this, chart = _a.chart, group = _a.group, markerGroup = _a.markerGroup, sharedClips = chart.sharedClips, renderer = chart.renderer, clipBox = this.getClipBox(), sharedClipKey = this.getSharedClipKey();
                var clipRect = sharedClips[sharedClipKey];
                if (!clipRect) {
                  sharedClips[sharedClipKey] = clipRect = renderer.clipRect(clipBox);
                } else {
                  clipRect.animate(clipBox);
                }
                if (group) {
                  group.clip(this.options.clip === false ? void 0 : clipRect);
                }
                if (markerGroup) {
                  markerGroup.clip();
                }
              };
              Series2.prototype.animate = function(init3) {
                var _a = this, chart = _a.chart, group = _a.group, markerGroup = _a.markerGroup, inverted = chart.inverted, animation = animObject(this.options.animation), animationClipKey = [
                  this.getSharedClipKey(),
                  animation.duration,
                  animation.easing,
                  animation.defer
                ].join(",");
                var animationClipRect = chart.sharedClips[animationClipKey], markerAnimationClipRect = chart.sharedClips[animationClipKey + "m"];
                if (init3 && group) {
                  var clipBox = this.getClipBox();
                  if (!animationClipRect) {
                    clipBox.width = 0;
                    if (inverted) {
                      clipBox.x = chart.plotHeight;
                    }
                    animationClipRect = chart.renderer.clipRect(clipBox);
                    chart.sharedClips[animationClipKey] = animationClipRect;
                    var markerClipBox = {
                      x: inverted ? -99 : -99,
                      y: inverted ? -99 : -99,
                      width: inverted ? chart.plotWidth + 199 : 99,
                      height: inverted ? 99 : chart.plotHeight + 199
                    };
                    markerAnimationClipRect = chart.renderer.clipRect(markerClipBox);
                    chart.sharedClips[animationClipKey + "m"] = markerAnimationClipRect;
                  } else {
                    animationClipRect.attr("height", clipBox.height);
                  }
                  group.clip(animationClipRect);
                  if (markerGroup) {
                    markerGroup.clip(markerAnimationClipRect);
                  }
                } else if (animationClipRect && // Only first series in this pane
                !animationClipRect.hasClass("highcharts-animating")) {
                  var finalBox = this.getClipBox(), step_1 = animation.step;
                  if (markerGroup && markerGroup.element.childNodes.length) {
                    animation.step = function(val, fx) {
                      if (step_1) {
                        step_1.apply(fx, arguments);
                      }
                      if (fx.prop === "width" && markerAnimationClipRect && markerAnimationClipRect.element) {
                        markerAnimationClipRect.attr(inverted ? "height" : "width", val + 99);
                      }
                    };
                  }
                  animationClipRect.addClass("highcharts-animating").animate(finalBox, animation);
                }
              };
              Series2.prototype.afterAnimate = function() {
                var _this = this;
                this.setClip();
                objectEach(this.chart.sharedClips, function(clip, key, sharedClips) {
                  if (clip && !_this.chart.container.querySelector('[clip-path="url(#'.concat(clip.id, ')"]'))) {
                    clip.destroy();
                    delete sharedClips[key];
                  }
                });
                this.finishedAnimating = true;
                fireEvent(this, "afterAnimate");
              };
              Series2.prototype.drawPoints = function(points) {
                if (points === void 0) {
                  points = this.points;
                }
                var series = this, chart = series.chart, styledMode = chart.styledMode, colorAxis = series.colorAxis, options = series.options, seriesMarkerOptions = options.marker, markerGroup = series[series.specialGroup || "markerGroup"], xAxis = series.xAxis, globallyEnabled = pick(
                  seriesMarkerOptions.enabled,
                  !xAxis || xAxis.isRadial ? true : null,
                  // Use larger or equal as radius is null in bubbles (#6321)
                  series.closestPointRangePx >= seriesMarkerOptions.enabledThreshold * seriesMarkerOptions.radius
                );
                var i, point, graphic, verb, pointMarkerOptions, hasPointMarker, markerAttribs;
                if (seriesMarkerOptions.enabled !== false || series._hasPointMarkers) {
                  for (i = 0; i < points.length; i++) {
                    point = points[i];
                    graphic = point.graphic;
                    verb = graphic ? "animate" : "attr";
                    pointMarkerOptions = point.marker || {};
                    hasPointMarker = !!point.marker;
                    var shouldDrawMarker = (globallyEnabled && typeof pointMarkerOptions.enabled === "undefined" || pointMarkerOptions.enabled) && !point.isNull && point.visible !== false;
                    if (shouldDrawMarker) {
                      var symbol = pick(
                        pointMarkerOptions.symbol,
                        series.symbol,
                        "rect"
                      );
                      markerAttribs = series.markerAttribs(point, point.selected && "select");
                      if (series.enabledDataSorting) {
                        point.startXPos = xAxis.reversed ? -(markerAttribs.width || 0) : xAxis.width;
                      }
                      var isInside = point.isInside !== false;
                      if (!graphic && isInside && ((markerAttribs.width || 0) > 0 || point.hasImage)) {
                        point.graphic = graphic = chart.renderer.symbol(symbol, markerAttribs.x, markerAttribs.y, markerAttribs.width, markerAttribs.height, hasPointMarker ? pointMarkerOptions : seriesMarkerOptions).add(markerGroup);
                        if (series.enabledDataSorting && chart.hasRendered) {
                          graphic.attr({
                            x: point.startXPos
                          });
                          verb = "animate";
                        }
                      }
                      if (graphic && verb === "animate") {
                        graphic[isInside ? "show" : "hide"](isInside).animate(markerAttribs);
                      }
                      if (graphic) {
                        var pointAttr = series.pointAttribs(point, styledMode || !point.selected ? void 0 : "select");
                        if (!styledMode) {
                          graphic[verb](pointAttr);
                        } else if (colorAxis) {
                          graphic["css"]({
                            fill: pointAttr.fill
                          });
                        }
                      }
                      if (graphic) {
                        graphic.addClass(point.getClassName(), true);
                      }
                    } else if (graphic) {
                      point.graphic = graphic.destroy();
                    }
                  }
                }
              };
              Series2.prototype.markerAttribs = function(point, state) {
                var seriesOptions = this.options, seriesMarkerOptions = seriesOptions.marker, pointMarkerOptions = point.marker || {}, symbol = pointMarkerOptions.symbol || seriesMarkerOptions.symbol, attribs = {};
                var seriesStateOptions, pointStateOptions, radius = pick(
                  pointMarkerOptions.radius,
                  seriesMarkerOptions && seriesMarkerOptions.radius
                );
                if (state) {
                  seriesStateOptions = seriesMarkerOptions.states[state];
                  pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state];
                  radius = pick(pointStateOptions && pointStateOptions.radius, seriesStateOptions && seriesStateOptions.radius, radius && radius + (seriesStateOptions && seriesStateOptions.radiusPlus || 0));
                }
                point.hasImage = symbol && symbol.indexOf("url") === 0;
                if (point.hasImage) {
                  radius = 0;
                }
                var pos = point.pos();
                if (isNumber(radius) && pos) {
                  attribs.x = pos[0] - radius;
                  attribs.y = pos[1] - radius;
                  if (seriesOptions.crisp) {
                    attribs.x = Math.floor(attribs.x);
                  }
                }
                if (radius) {
                  attribs.width = attribs.height = 2 * radius;
                }
                return attribs;
              };
              Series2.prototype.pointAttribs = function(point, state) {
                var seriesMarkerOptions = this.options.marker, pointOptions = point && point.options, pointMarkerOptions = pointOptions && pointOptions.marker || {}, pointColorOption = pointOptions && pointOptions.color, pointColor = point && point.color, zoneColor = point && point.zone && point.zone.color;
                var seriesStateOptions, pointStateOptions, color2 = this.color, fill, stroke, strokeWidth = pick(
                  pointMarkerOptions.lineWidth,
                  seriesMarkerOptions.lineWidth
                ), opacity = 1;
                color2 = pointColorOption || zoneColor || pointColor || color2;
                fill = pointMarkerOptions.fillColor || seriesMarkerOptions.fillColor || color2;
                stroke = pointMarkerOptions.lineColor || seriesMarkerOptions.lineColor || color2;
                state = state || "normal";
                if (state) {
                  seriesStateOptions = seriesMarkerOptions.states[state] || {};
                  pointStateOptions = pointMarkerOptions.states && pointMarkerOptions.states[state] || {};
                  strokeWidth = pick(pointStateOptions.lineWidth, seriesStateOptions.lineWidth, strokeWidth + pick(pointStateOptions.lineWidthPlus, seriesStateOptions.lineWidthPlus, 0));
                  fill = pointStateOptions.fillColor || seriesStateOptions.fillColor || fill;
                  stroke = pointStateOptions.lineColor || seriesStateOptions.lineColor || stroke;
                  opacity = pick(pointStateOptions.opacity, seriesStateOptions.opacity, opacity);
                }
                return {
                  "stroke": stroke,
                  "stroke-width": strokeWidth,
                  "fill": fill,
                  "opacity": opacity
                };
              };
              Series2.prototype.destroy = function(keepEventsForUpdate) {
                var series = this, chart = series.chart, issue134 = /AppleWebKit\/533/.test(win.navigator.userAgent), data = series.data || [];
                var destroy, i, point, axis;
                fireEvent(series, "destroy", { keepEventsForUpdate });
                this.removeEvents(keepEventsForUpdate);
                (series.axisTypes || []).forEach(function(AXIS) {
                  axis = series[AXIS];
                  if (axis && axis.series) {
                    erase(axis.series, series);
                    axis.isDirty = axis.forceRedraw = true;
                  }
                });
                if (series.legendItem) {
                  series.chart.legend.destroyItem(series);
                }
                i = data.length;
                while (i--) {
                  point = data[i];
                  if (point && point.destroy) {
                    point.destroy();
                  }
                }
                if (series.clips) {
                  series.clips.forEach(function(clip) {
                    return clip.destroy();
                  });
                }
                U.clearTimeout(series.animationTimeout);
                objectEach(series, function(val, prop) {
                  if (val instanceof SVGElement && !val.survive) {
                    destroy = issue134 && prop === "group" ? "hide" : "destroy";
                    val[destroy]();
                  }
                });
                if (chart.hoverSeries === series) {
                  chart.hoverSeries = void 0;
                }
                erase(chart.series, series);
                chart.orderSeries();
                objectEach(series, function(val, prop) {
                  if (!keepEventsForUpdate || prop !== "hcEvents") {
                    delete series[prop];
                  }
                });
              };
              Series2.prototype.applyZones = function() {
                var series = this, chart = this.chart, renderer = chart.renderer, zones = this.zones, clips = this.clips || [], graph = this.graph, area = this.area, plotSizeMax = Math.max(
                  chart.plotWidth,
                  chart.plotHeight
                ), axis = this[(this.zoneAxis || "y") + "Axis"], inverted = chart.inverted;
                var translatedFrom, translatedTo, clipAttr, extremes, reversed, horiz, pxRange, pxPosMin, pxPosMax, zoneArea, zoneGraph, ignoreZones = false;
                if (zones.length && (graph || area) && axis && typeof axis.min !== "undefined") {
                  reversed = axis.reversed;
                  horiz = axis.horiz;
                  if (graph && !this.showLine) {
                    graph.hide();
                  }
                  if (area) {
                    area.hide();
                  }
                  extremes = axis.getExtremes();
                  zones.forEach(function(threshold, i) {
                    translatedFrom = reversed ? horiz ? chart.plotWidth : 0 : horiz ? 0 : axis.toPixels(extremes.min) || 0;
                    translatedFrom = clamp(pick(translatedTo, translatedFrom), 0, plotSizeMax);
                    translatedTo = clamp(Math.round(axis.toPixels(pick(threshold.value, extremes.max), true) || 0), 0, plotSizeMax);
                    if (ignoreZones) {
                      translatedFrom = translatedTo = axis.toPixels(extremes.max);
                    }
                    pxRange = Math.abs(translatedFrom - translatedTo);
                    pxPosMin = Math.min(translatedFrom, translatedTo);
                    pxPosMax = Math.max(translatedFrom, translatedTo);
                    if (axis.isXAxis) {
                      clipAttr = {
                        x: inverted ? pxPosMax : pxPosMin,
                        y: 0,
                        width: pxRange,
                        height: plotSizeMax
                      };
                      if (!horiz) {
                        clipAttr.x = chart.plotHeight - clipAttr.x;
                      }
                    } else {
                      clipAttr = {
                        x: 0,
                        y: inverted ? pxPosMax : pxPosMin,
                        width: plotSizeMax,
                        height: pxRange
                      };
                      if (horiz) {
                        clipAttr.y = chart.plotWidth - clipAttr.y;
                      }
                    }
                    if (inverted && renderer.isVML) {
                      if (axis.isXAxis) {
                        clipAttr = {
                          x: 0,
                          y: reversed ? pxPosMin : pxPosMax,
                          height: clipAttr.width,
                          width: chart.chartWidth
                        };
                      } else {
                        clipAttr = {
                          x: clipAttr.y - chart.plotLeft - chart.spacingBox.x,
                          y: 0,
                          width: clipAttr.height,
                          height: chart.chartHeight
                        };
                      }
                    }
                    if (clips[i]) {
                      clips[i].animate(clipAttr);
                    } else {
                      clips[i] = renderer.clipRect(clipAttr);
                    }
                    zoneArea = series["zone-area-" + i];
                    zoneGraph = series["zone-graph-" + i];
                    if (graph && zoneGraph) {
                      zoneGraph.clip(clips[i]);
                    }
                    if (area && zoneArea) {
                      zoneArea.clip(clips[i]);
                    }
                    ignoreZones = threshold.value > extremes.max;
                    if (series.resetZones && translatedTo === 0) {
                      translatedTo = void 0;
                    }
                  });
                  this.clips = clips;
                } else if (series.visible) {
                  if (graph) {
                    graph.show();
                  }
                  if (area) {
                    area.show();
                  }
                }
              };
              Series2.prototype.plotGroup = function(prop, name, visibility, zIndex, parent) {
                var group = this[prop];
                var isNew = !group, attrs = {
                  visibility,
                  zIndex: zIndex || 0.1
                  // IE8 and pointer logic use this
                };
                if (typeof this.opacity !== "undefined" && !this.chart.styledMode && this.state !== "inactive") {
                  attrs.opacity = this.opacity;
                }
                if (isNew) {
                  this[prop] = group = this.chart.renderer.g().add(parent);
                }
                group.addClass("highcharts-" + name + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (defined(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (group.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true);
                group.attr(attrs)[isNew ? "attr" : "animate"](this.getPlotBox(name));
                return group;
              };
              Series2.prototype.getPlotBox = function(name) {
                var horAxis = this.xAxis, vertAxis = this.yAxis;
                var chart = this.chart, inverted = chart.inverted && !chart.polar && horAxis && this.invertible !== false && name === "series";
                if (chart.inverted) {
                  horAxis = vertAxis;
                  vertAxis = this.xAxis;
                }
                return {
                  translateX: horAxis ? horAxis.left : chart.plotLeft,
                  translateY: vertAxis ? vertAxis.top : chart.plotTop,
                  rotation: inverted ? 90 : 0,
                  rotationOriginX: inverted ? (horAxis.len - vertAxis.len) / 2 : 0,
                  rotationOriginY: inverted ? (horAxis.len + vertAxis.len) / 2 : 0,
                  scaleX: inverted ? -1 : 1,
                  scaleY: 1
                };
              };
              Series2.prototype.removeEvents = function(keepEventsForUpdate) {
                var series = this;
                if (!keepEventsForUpdate) {
                  removeEvent(series);
                }
                if (series.eventsToUnbind.length) {
                  series.eventsToUnbind.forEach(function(unbind) {
                    unbind();
                  });
                  series.eventsToUnbind.length = 0;
                }
              };
              Series2.prototype.render = function() {
                var series = this, chart = series.chart, options = series.options, animOptions = animObject(options.animation), visibility = series.visible ? "inherit" : "hidden", zIndex = options.zIndex, hasRendered = series.hasRendered, chartSeriesGroup = chart.seriesGroup, inverted = chart.inverted;
                var animDuration = !series.finishedAnimating && chart.renderer.isSVG ? animOptions.duration : 0;
                fireEvent(this, "render");
                var group = series.plotGroup("group", "series", visibility, zIndex, chartSeriesGroup);
                series.markerGroup = series.plotGroup("markerGroup", "markers", visibility, zIndex, chartSeriesGroup);
                if (options.clip !== false) {
                  series.setClip();
                }
                if (series.animate && animDuration) {
                  series.animate(true);
                }
                if (series.drawGraph) {
                  series.drawGraph();
                  series.applyZones();
                }
                if (series.visible) {
                  series.drawPoints();
                }
                if (series.drawDataLabels) {
                  series.drawDataLabels();
                }
                if (series.redrawPoints) {
                  series.redrawPoints();
                }
                if (series.drawTracker && series.options.enableMouseTracking !== false) {
                  series.drawTracker();
                }
                if (series.animate && animDuration) {
                  series.animate();
                }
                if (!hasRendered) {
                  if (animDuration && animOptions.defer) {
                    animDuration += animOptions.defer;
                  }
                  series.animationTimeout = syncTimeout(function() {
                    series.afterAnimate();
                  }, animDuration || 0);
                }
                series.isDirty = false;
                series.hasRendered = true;
                fireEvent(series, "afterRender");
              };
              Series2.prototype.redraw = function() {
                var wasDirty = this.isDirty || this.isDirtyData;
                this.translate();
                this.render();
                if (wasDirty) {
                  delete this.kdTree;
                }
              };
              Series2.prototype.searchPoint = function(e, compareX) {
                var series = this, xAxis = series.xAxis, yAxis = series.yAxis, inverted = series.chart.inverted;
                return this.searchKDTree({
                  clientX: inverted ? xAxis.len - e.chartY + xAxis.pos : e.chartX - xAxis.pos,
                  plotY: inverted ? yAxis.len - e.chartX + yAxis.pos : e.chartY - yAxis.pos
                }, compareX, e);
              };
              Series2.prototype.buildKDTree = function(e) {
                this.buildingKdTree = true;
                var series = this, dimensions = series.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
                function _kdtree(points, depth, dimensions2) {
                  var length = points && points.length;
                  var axis, median;
                  if (length) {
                    axis = series.kdAxisArray[depth % dimensions2];
                    points.sort(function(a, b) {
                      return a[axis] - b[axis];
                    });
                    median = Math.floor(length / 2);
                    return {
                      point: points[median],
                      left: _kdtree(points.slice(0, median), depth + 1, dimensions2),
                      right: _kdtree(points.slice(median + 1), depth + 1, dimensions2)
                    };
                  }
                }
                function startRecursive() {
                  series.kdTree = _kdtree(series.getValidPoints(
                    null,
                    // For line-type series restrict to plot area, but
                    // column-type series not (#3916, #4511)
                    !series.directTouch
                  ), dimensions, dimensions);
                  series.buildingKdTree = false;
                }
                delete series.kdTree;
                syncTimeout(startRecursive, series.options.kdNow || e && e.type === "touchstart" ? 0 : 1);
              };
              Series2.prototype.searchKDTree = function(point, compareX, e) {
                var series = this, kdX = this.kdAxisArray[0], kdY = this.kdAxisArray[1], kdComparer = compareX ? "distX" : "dist", kdDimensions = series.options.findNearestPointBy.indexOf("y") > -1 ? 2 : 1;
                function setDistance(p1, p2) {
                  var x = defined(p1[kdX]) && defined(p2[kdX]) ? Math.pow(p1[kdX] - p2[kdX], 2) : null, y = defined(p1[kdY]) && defined(p2[kdY]) ? Math.pow(p1[kdY] - p2[kdY], 2) : null, r = (x || 0) + (y || 0);
                  p2.dist = defined(r) ? Math.sqrt(r) : Number.MAX_VALUE;
                  p2.distX = defined(x) ? Math.sqrt(x) : Number.MAX_VALUE;
                }
                function _search(search, tree, depth, dimensions) {
                  var point2 = tree.point, axis = series.kdAxisArray[depth % dimensions];
                  var nPoint1, nPoint2, ret = point2;
                  setDistance(search, point2);
                  var tdist = search[axis] - point2[axis], sideA = tdist < 0 ? "left" : "right", sideB = tdist < 0 ? "right" : "left";
                  if (tree[sideA]) {
                    nPoint1 = _search(search, tree[sideA], depth + 1, dimensions);
                    ret = nPoint1[kdComparer] < ret[kdComparer] ? nPoint1 : point2;
                  }
                  if (tree[sideB]) {
                    if (Math.sqrt(tdist * tdist) < ret[kdComparer]) {
                      nPoint2 = _search(search, tree[sideB], depth + 1, dimensions);
                      ret = nPoint2[kdComparer] < ret[kdComparer] ? nPoint2 : ret;
                    }
                  }
                  return ret;
                }
                if (!this.kdTree && !this.buildingKdTree) {
                  this.buildKDTree(e);
                }
                if (this.kdTree) {
                  return _search(point, this.kdTree, kdDimensions, kdDimensions);
                }
              };
              Series2.prototype.pointPlacementToXValue = function() {
                var _a = this, _b = _a.options, pointPlacement = _b.pointPlacement, pointRange = _b.pointRange, axis = _a.xAxis;
                var factor = pointPlacement;
                if (factor === "between") {
                  factor = axis.reversed ? -0.5 : 0.5;
                }
                return isNumber(factor) ? factor * (pointRange || axis.pointRange) : 0;
              };
              Series2.prototype.isPointInside = function(point) {
                var _a = this, chart = _a.chart, xAxis = _a.xAxis, yAxis = _a.yAxis, isInside = typeof point.plotY !== "undefined" && typeof point.plotX !== "undefined" && point.plotY >= 0 && point.plotY <= (yAxis ? yAxis.len : chart.plotHeight) && point.plotX >= 0 && point.plotX <= (xAxis ? xAxis.len : chart.plotWidth);
                return isInside;
              };
              Series2.prototype.drawTracker = function() {
                var series = this, options = series.options, trackByArea = options.trackByArea, trackerPath = [].concat(trackByArea ? series.areaPath : series.graphPath), chart = series.chart, pointer = chart.pointer, renderer = chart.renderer, snap = chart.options.tooltip.snap, tracker = series.tracker, onMouseOver = function(e) {
                  if (chart.hoverSeries !== series) {
                    series.onMouseOver();
                  }
                }, TRACKER_FILL = "rgba(192,192,192," + (svg ? 1e-4 : 2e-3) + ")";
                var i;
                if (tracker) {
                  tracker.attr({ d: trackerPath });
                } else if (series.graph) {
                  series.tracker = renderer.path(trackerPath).attr({
                    visibility: series.visible ? "inherit" : "hidden",
                    zIndex: 2
                  }).addClass(trackByArea ? "highcharts-tracker-area" : "highcharts-tracker-line").add(series.group);
                  if (!chart.styledMode) {
                    series.tracker.attr({
                      "stroke-linecap": "round",
                      "stroke-linejoin": "round",
                      stroke: TRACKER_FILL,
                      fill: trackByArea ? TRACKER_FILL : "none",
                      "stroke-width": series.graph.strokeWidth() + (trackByArea ? 0 : 2 * snap)
                    });
                  }
                  [
                    series.tracker,
                    series.markerGroup,
                    series.dataLabelsGroup
                  ].forEach(function(tracker2) {
                    if (tracker2) {
                      tracker2.addClass("highcharts-tracker").on("mouseover", onMouseOver).on("mouseout", function(e) {
                        pointer.onTrackerMouseOut(e);
                      });
                      if (options.cursor && !chart.styledMode) {
                        tracker2.css({ cursor: options.cursor });
                      }
                      if (hasTouch) {
                        tracker2.on("touchstart", onMouseOver);
                      }
                    }
                  });
                }
                fireEvent(this, "afterDrawTracker");
              };
              Series2.prototype.addPoint = function(options, redraw, shift, animation, withEvent) {
                var series = this, seriesOptions = series.options, data = series.data, chart = series.chart, xAxis = series.xAxis, names = xAxis && xAxis.hasNames && xAxis.names, dataOptions = seriesOptions.data, xData = series.xData;
                var isInTheMiddle, i;
                redraw = pick(redraw, true);
                var point = { series };
                series.pointClass.prototype.applyOptions.apply(point, [options]);
                var x = point.x;
                i = xData.length;
                if (series.requireSorting && x < xData[i - 1]) {
                  isInTheMiddle = true;
                  while (i && xData[i - 1] > x) {
                    i--;
                  }
                }
                series.updateParallelArrays(point, "splice", i, 0, 0);
                series.updateParallelArrays(point, i);
                if (names && point.name) {
                  names[x] = point.name;
                }
                dataOptions.splice(i, 0, options);
                if (isInTheMiddle || // When processedData is present we need to splice an empty slot
                // into series.data, otherwise generatePoints won't pick it up.
                series.processedData) {
                  series.data.splice(i, 0, null);
                  series.processData();
                }
                if (seriesOptions.legendType === "point") {
                  series.generatePoints();
                }
                if (shift) {
                  if (data[0] && data[0].remove) {
                    data[0].remove(false);
                  } else {
                    data.shift();
                    series.updateParallelArrays(point, "shift");
                    dataOptions.shift();
                  }
                }
                if (withEvent !== false) {
                  fireEvent(series, "addPoint", { point });
                }
                series.isDirty = true;
                series.isDirtyData = true;
                if (redraw) {
                  chart.redraw(animation);
                }
              };
              Series2.prototype.removePoint = function(i, redraw, animation) {
                var series = this, data = series.data, point = data[i], points = series.points, chart = series.chart, remove2 = function() {
                  if (points && points.length === data.length) {
                    points.splice(i, 1);
                  }
                  data.splice(i, 1);
                  series.options.data.splice(i, 1);
                  series.updateParallelArrays(point || { series }, "splice", i, 1);
                  if (point) {
                    point.destroy();
                  }
                  series.isDirty = true;
                  series.isDirtyData = true;
                  if (redraw) {
                    chart.redraw();
                  }
                };
                setAnimation(animation, chart);
                redraw = pick(redraw, true);
                if (point) {
                  point.firePointEvent("remove", null, remove2);
                } else {
                  remove2();
                }
              };
              Series2.prototype.remove = function(redraw, animation, withEvent, keepEvents) {
                var series = this, chart = series.chart;
                function remove2() {
                  series.destroy(keepEvents);
                  chart.isDirtyLegend = chart.isDirtyBox = true;
                  chart.linkSeries();
                  if (pick(redraw, true)) {
                    chart.redraw(animation);
                  }
                }
                if (withEvent !== false) {
                  fireEvent(series, "remove", null, remove2);
                } else {
                  remove2();
                }
              };
              Series2.prototype.update = function(options, redraw) {
                options = cleanRecursively(options, this.userOptions);
                fireEvent(this, "update", { options });
                var series = this, chart = series.chart, oldOptions = series.userOptions, initialType = series.initialType || series.type, plotOptions = chart.options.plotOptions, initialSeriesProto = seriesTypes[initialType].prototype, groups = [
                  "group",
                  "markerGroup",
                  "dataLabelsGroup",
                  "transformGroup",
                  "shadowGroup"
                ], animation = series.finishedAnimating && { animation: false }, kinds = {};
                var seriesOptions, n, preserve = [
                  "eventOptions",
                  "navigatorSeries",
                  "baseSeries"
                ], newType = options.type || oldOptions.type || chart.options.chart.type;
                var keepPoints = !// Indicators, histograms etc recalculate the data. It should be
                // possible to omit this.
                (this.hasDerivedData || // New type requires new point classes
                newType && newType !== this.type || // New options affecting how the data points are built
                typeof options.pointStart !== "undefined" || typeof options.pointInterval !== "undefined" || typeof options.relativeXValue !== "undefined" || options.joinBy || options.mapData || // #11636
                // Changes to data grouping requires new points in new group
                series.hasOptionChanged("dataGrouping") || series.hasOptionChanged("pointStart") || series.hasOptionChanged("pointInterval") || series.hasOptionChanged("pointIntervalUnit") || series.hasOptionChanged("keys"));
                newType = newType || initialType;
                if (keepPoints) {
                  preserve.push(
                    "data",
                    "isDirtyData",
                    "points",
                    "processedData",
                    // #17057
                    "processedXData",
                    "processedYData",
                    "xIncrement",
                    "cropped",
                    "_hasPointMarkers",
                    "_hasPointLabels",
                    "clips",
                    // #15420
                    // Networkgraph (#14397)
                    "nodes",
                    "layout",
                    // Treemap
                    "level",
                    // Map specific, consider moving it to series-specific preserve-
                    // properties (#10617)
                    "mapMap",
                    "mapData",
                    "minY",
                    "maxY",
                    "minX",
                    "maxX"
                  );
                  if (options.visible !== false) {
                    preserve.push("area", "graph");
                  }
                  series.parallelArrays.forEach(function(key) {
                    preserve.push(key + "Data");
                  });
                  if (options.data) {
                    if (options.dataSorting) {
                      extend2(series.options.dataSorting, options.dataSorting);
                    }
                    this.setData(options.data, false);
                  }
                }
                options = merge(oldOptions, animation, {
                  // When oldOptions.index is null it should't be cleared.
                  // Otherwise navigator series will have wrong indexes (#10193).
                  index: typeof oldOptions.index === "undefined" ? series.index : oldOptions.index,
                  pointStart: pick(
                    // when updating from blank (#7933)
                    plotOptions && plotOptions.series && plotOptions.series.pointStart,
                    oldOptions.pointStart,
                    // when updating after addPoint
                    series.xData[0]
                  )
                }, !keepPoints && { data: series.options.data }, options);
                if (keepPoints && options.data) {
                  options.data = series.options.data;
                }
                preserve = groups.concat(preserve);
                preserve.forEach(function(prop) {
                  preserve[prop] = series[prop];
                  delete series[prop];
                });
                var casting = false;
                if (seriesTypes[newType]) {
                  casting = newType !== series.type;
                  series.remove(false, false, false, true);
                  if (casting) {
                    if (Object.setPrototypeOf) {
                      Object.setPrototypeOf(series, seriesTypes[newType].prototype);
                    } else {
                      var ownEvents = Object.hasOwnProperty.call(series, "hcEvents") && series.hcEvents;
                      for (n in initialSeriesProto) {
                        series[n] = void 0;
                      }
                      extend2(series, seriesTypes[newType].prototype);
                      if (ownEvents) {
                        series.hcEvents = ownEvents;
                      } else {
                        delete series.hcEvents;
                      }
                    }
                  }
                } else {
                  error(17, true, chart, { missingModuleFor: newType });
                }
                preserve.forEach(function(prop) {
                  series[prop] = preserve[prop];
                });
                series.init(chart, options);
                if (keepPoints && this.points) {
                  seriesOptions = series.options;
                  if (seriesOptions.visible === false) {
                    kinds.graphic = 1;
                    kinds.dataLabel = 1;
                  } else if (!series._hasPointLabels) {
                    var marker = seriesOptions.marker, dataLabels = seriesOptions.dataLabels, oldMarker = oldOptions.marker || {};
                    if (marker && (marker.enabled === false || oldMarker.symbol !== marker.symbol || // #10870, #15946
                    oldMarker.height !== marker.height || // #16274
                    oldMarker.width !== marker.width)) {
                      kinds.graphic = 1;
                    }
                    if (dataLabels && dataLabels.enabled === false) {
                      kinds.dataLabel = 1;
                    }
                  }
                  for (var _a = 0, _b = this.points; _a < _b.length; _a++) {
                    var point = _b[_a];
                    if (point && point.series) {
                      point.resolveColor();
                      if (Object.keys(kinds).length) {
                        point.destroyElements(kinds);
                      }
                      if (seriesOptions.showInLegend === false && point.legendItem) {
                        chart.legend.destroyItem(point);
                      }
                    }
                  }
                }
                series.initialType = initialType;
                chart.linkSeries();
                if (casting && series.linkedSeries.length) {
                  series.isDirtyData = true;
                }
                fireEvent(this, "afterUpdate");
                if (pick(redraw, true)) {
                  chart.redraw(keepPoints ? void 0 : false);
                }
              };
              Series2.prototype.setName = function(name) {
                this.name = this.options.name = this.userOptions.name = name;
                this.chart.isDirtyLegend = true;
              };
              Series2.prototype.hasOptionChanged = function(optionName) {
                var chart = this.chart, option = this.options[optionName], plotOptions = chart.options.plotOptions, oldOption = this.userOptions[optionName];
                if (oldOption) {
                  return option !== oldOption;
                }
                return option !== pick(plotOptions && plotOptions[this.type] && plotOptions[this.type][optionName], plotOptions && plotOptions.series && plotOptions.series[optionName], option);
              };
              Series2.prototype.onMouseOver = function() {
                var series = this, chart = series.chart, hoverSeries = chart.hoverSeries, pointer = chart.pointer;
                pointer.setHoverChartIndex();
                if (hoverSeries && hoverSeries !== series) {
                  hoverSeries.onMouseOut();
                }
                if (series.options.events.mouseOver) {
                  fireEvent(series, "mouseOver");
                }
                series.setState("hover");
                chart.hoverSeries = series;
              };
              Series2.prototype.onMouseOut = function() {
                var series = this, options = series.options, chart = series.chart, tooltip = chart.tooltip, hoverPoint = chart.hoverPoint;
                chart.hoverSeries = null;
                if (hoverPoint) {
                  hoverPoint.onMouseOut();
                }
                if (series && options.events.mouseOut) {
                  fireEvent(series, "mouseOut");
                }
                if (tooltip && !series.stickyTracking && (!tooltip.shared || series.noSharedTooltip)) {
                  tooltip.hide();
                }
                chart.series.forEach(function(s) {
                  s.setState("", true);
                });
              };
              Series2.prototype.setState = function(state, inherit2) {
                var series = this, options = series.options, graph = series.graph, inactiveOtherPoints = options.inactiveOtherPoints, stateOptions = options.states, stateAnimation = pick(
                  stateOptions[state || "normal"] && stateOptions[state || "normal"].animation,
                  series.chart.options.chart.animation
                );
                var attribs, lineWidth = options.lineWidth, i = 0, opacity = options.opacity;
                state = state || "";
                if (series.state !== state) {
                  [
                    series.group,
                    series.markerGroup,
                    series.dataLabelsGroup
                  ].forEach(function(group) {
                    if (group) {
                      if (series.state) {
                        group.removeClass("highcharts-series-" + series.state);
                      }
                      if (state) {
                        group.addClass("highcharts-series-" + state);
                      }
                    }
                  });
                  series.state = state;
                  if (!series.chart.styledMode) {
                    if (stateOptions[state] && stateOptions[state].enabled === false) {
                      return;
                    }
                    if (state) {
                      lineWidth = stateOptions[state].lineWidth || lineWidth + (stateOptions[state].lineWidthPlus || 0);
                      opacity = pick(stateOptions[state].opacity, opacity);
                    }
                    if (graph && !graph.dashstyle && isNumber(lineWidth)) {
                      attribs = {
                        "stroke-width": lineWidth
                      };
                      graph.animate(attribs, stateAnimation);
                      while (series["zone-graph-" + i]) {
                        series["zone-graph-" + i].animate(attribs, stateAnimation);
                        i = i + 1;
                      }
                    }
                    if (!inactiveOtherPoints) {
                      [
                        series.group,
                        series.markerGroup,
                        series.dataLabelsGroup,
                        series.labelBySeries
                      ].forEach(function(group) {
                        if (group) {
                          group.animate({
                            opacity
                          }, stateAnimation);
                        }
                      });
                    }
                  }
                }
                if (inherit2 && inactiveOtherPoints && series.points) {
                  series.setAllPointsToState(state || void 0);
                }
              };
              Series2.prototype.setAllPointsToState = function(state) {
                this.points.forEach(function(point) {
                  if (point.setState) {
                    point.setState(state);
                  }
                });
              };
              Series2.prototype.setVisible = function(vis, redraw) {
                var series = this, chart = series.chart, ignoreHiddenSeries = chart.options.chart.ignoreHiddenSeries, oldVisibility = series.visible;
                series.visible = vis = series.options.visible = series.userOptions.visible = typeof vis === "undefined" ? !oldVisibility : vis;
                var showOrHide = vis ? "show" : "hide";
                [
                  "group",
                  "dataLabelsGroup",
                  "markerGroup",
                  "tracker",
                  "tt"
                ].forEach(function(key) {
                  if (series[key]) {
                    series[key][showOrHide]();
                  }
                });
                if (chart.hoverSeries === series || (chart.hoverPoint && chart.hoverPoint.series) === series) {
                  series.onMouseOut();
                }
                if (series.legendItem) {
                  chart.legend.colorizeItem(series, vis);
                }
                series.isDirty = true;
                if (series.options.stacking) {
                  chart.series.forEach(function(otherSeries) {
                    if (otherSeries.options.stacking && otherSeries.visible) {
                      otherSeries.isDirty = true;
                    }
                  });
                }
                series.linkedSeries.forEach(function(otherSeries) {
                  otherSeries.setVisible(vis, false);
                });
                if (ignoreHiddenSeries) {
                  chart.isDirtyBox = true;
                }
                fireEvent(series, showOrHide);
                if (redraw !== false) {
                  chart.redraw();
                }
              };
              Series2.prototype.show = function() {
                this.setVisible(true);
              };
              Series2.prototype.hide = function() {
                this.setVisible(false);
              };
              Series2.prototype.select = function(selected) {
                var series = this;
                series.selected = selected = this.options.selected = typeof selected === "undefined" ? !series.selected : selected;
                if (series.checkbox) {
                  series.checkbox.checked = selected;
                }
                fireEvent(series, selected ? "select" : "unselect");
              };
              Series2.prototype.shouldShowTooltip = function(plotX, plotY, options) {
                if (options === void 0) {
                  options = {};
                }
                options.series = this;
                options.visiblePlotOnly = true;
                return this.chart.isInsidePlot(plotX, plotY, options);
              };
              Series2.defaultOptions = SeriesDefaults;
              Series2.types = SeriesRegistry.seriesTypes;
              Series2.registerType = SeriesRegistry.registerSeriesType;
              return Series2;
            }()
          );
          extend2(Series.prototype, {
            axisTypes: ["xAxis", "yAxis"],
            coll: "series",
            colorCounter: 0,
            cropShoulder: 1,
            directTouch: false,
            drawLegendSymbol: LegendSymbol.drawLineMarker,
            isCartesian: true,
            kdAxisArray: ["clientX", "plotY"],
            // each point's x and y values are stored in this.xData and this.yData:
            parallelArrays: ["x", "y"],
            pointClass: Point,
            requireSorting: true,
            // requires the data to be sorted:
            sorted: true
          });
          SeriesRegistry.series = Series;
          "";
          "";
          return Series;
        });
        _registerModule(_modules, "Extensions/ScrollablePlotArea.js", [_modules["Core/Animation/AnimationUtilities.js"], _modules["Core/Axis/Axis.js"], _modules["Core/Chart/Chart.js"], _modules["Core/Series/Series.js"], _modules["Core/Renderer/RendererRegistry.js"], _modules["Core/Utilities.js"]], function(A, Axis, Chart, Series, RendererRegistry, U) {
          var stop = A.stop;
          var addEvent = U.addEvent, createElement = U.createElement, defined = U.defined, merge = U.merge, pick = U.pick;
          addEvent(Chart, "afterSetChartSize", function(e) {
            var scrollablePlotArea = this.options.chart.scrollablePlotArea, scrollableMinWidth = scrollablePlotArea && scrollablePlotArea.minWidth, scrollableMinHeight = scrollablePlotArea && scrollablePlotArea.minHeight, scrollablePixelsX, scrollablePixelsY, corrections;
            if (!this.renderer.forExport) {
              if (scrollableMinWidth) {
                this.scrollablePixelsX = scrollablePixelsX = Math.max(0, scrollableMinWidth - this.chartWidth);
                if (scrollablePixelsX) {
                  this.scrollablePlotBox = this.renderer.scrollablePlotBox = merge(this.plotBox);
                  this.plotBox.width = this.plotWidth += scrollablePixelsX;
                  if (this.inverted) {
                    this.clipBox.height += scrollablePixelsX;
                  } else {
                    this.clipBox.width += scrollablePixelsX;
                  }
                  corrections = {
                    // Corrections for right side
                    1: { name: "right", value: scrollablePixelsX }
                  };
                }
              } else if (scrollableMinHeight) {
                this.scrollablePixelsY = scrollablePixelsY = Math.max(0, scrollableMinHeight - this.chartHeight);
                if (defined(scrollablePixelsY)) {
                  this.scrollablePlotBox = this.renderer.scrollablePlotBox = merge(this.plotBox);
                  this.plotBox.height = this.plotHeight += scrollablePixelsY;
                  if (this.inverted) {
                    this.clipBox.width += scrollablePixelsY;
                  } else {
                    this.clipBox.height += scrollablePixelsY;
                  }
                  corrections = {
                    2: { name: "bottom", value: scrollablePixelsY }
                  };
                }
              }
              if (corrections && !e.skipAxes) {
                this.axes.forEach(function(axis) {
                  if (corrections[axis.side]) {
                    axis.getPlotLinePath = function() {
                      var marginName = corrections[axis.side].name, correctionValue = corrections[axis.side].value, margin = this[marginName], path;
                      this[marginName] = margin - correctionValue;
                      path = Axis.prototype.getPlotLinePath.apply(this, arguments);
                      this[marginName] = margin;
                      return path;
                    };
                  } else {
                    axis.setAxisSize();
                    axis.setAxisTranslation();
                  }
                });
              }
            }
          });
          addEvent(Chart, "render", function() {
            if (this.scrollablePixelsX || this.scrollablePixelsY) {
              if (this.setUpScrolling) {
                this.setUpScrolling();
              }
              this.applyFixed();
            } else if (this.fixedDiv) {
              this.applyFixed();
            }
          });
          Chart.prototype.setUpScrolling = function() {
            var _this = this;
            var css = {
              WebkitOverflowScrolling: "touch",
              overflowX: "hidden",
              overflowY: "hidden"
            };
            if (this.scrollablePixelsX) {
              css.overflowX = "auto";
            }
            if (this.scrollablePixelsY) {
              css.overflowY = "auto";
            }
            this.scrollingParent = createElement("div", {
              className: "highcharts-scrolling-parent"
            }, {
              position: "relative"
            }, this.renderTo);
            this.scrollingContainer = createElement("div", {
              "className": "highcharts-scrolling"
            }, css, this.scrollingParent);
            var lastHoverPoint;
            addEvent(this.scrollingContainer, "scroll", function() {
              if (_this.pointer) {
                delete _this.pointer.chartPosition;
                if (_this.hoverPoint) {
                  lastHoverPoint = _this.hoverPoint;
                }
                _this.pointer.runPointActions(void 0, lastHoverPoint, true);
              }
            });
            this.innerContainer = createElement("div", {
              "className": "highcharts-inner-container"
            }, null, this.scrollingContainer);
            this.innerContainer.appendChild(this.container);
            this.setUpScrolling = null;
          };
          Chart.prototype.moveFixedElements = function() {
            var container = this.container, fixedRenderer = this.fixedRenderer, fixedSelectors = [
              ".highcharts-breadcrumbs-group",
              ".highcharts-contextbutton",
              ".highcharts-credits",
              ".highcharts-legend",
              ".highcharts-legend-checkbox",
              ".highcharts-navigator-series",
              ".highcharts-navigator-xaxis",
              ".highcharts-navigator-yaxis",
              ".highcharts-navigator",
              ".highcharts-reset-zoom",
              ".highcharts-drillup-button",
              ".highcharts-scrollbar",
              ".highcharts-subtitle",
              ".highcharts-title"
            ], axisClass;
            if (this.scrollablePixelsX && !this.inverted) {
              axisClass = ".highcharts-yaxis";
            } else if (this.scrollablePixelsX && this.inverted) {
              axisClass = ".highcharts-xaxis";
            } else if (this.scrollablePixelsY && !this.inverted) {
              axisClass = ".highcharts-xaxis";
            } else if (this.scrollablePixelsY && this.inverted) {
              axisClass = ".highcharts-yaxis";
            }
            if (axisClass) {
              fixedSelectors.push("" + axisClass + ":not(.highcharts-radial-axis)", "" + axisClass + "-labels:not(.highcharts-radial-axis-labels)");
            }
            fixedSelectors.forEach(function(className) {
              [].forEach.call(container.querySelectorAll(className), function(elem) {
                (elem.namespaceURI === fixedRenderer.SVG_NS ? fixedRenderer.box : fixedRenderer.box.parentNode).appendChild(elem);
                elem.style.pointerEvents = "auto";
              });
            });
          };
          Chart.prototype.applyFixed = function() {
            var firstTime = !this.fixedDiv, chartOptions = this.options.chart, scrollableOptions = chartOptions.scrollablePlotArea, Renderer = RendererRegistry.getRendererType();
            var fixedRenderer, scrollableWidth, scrollableHeight;
            if (firstTime) {
              this.fixedDiv = createElement("div", {
                className: "highcharts-fixed"
              }, {
                position: "absolute",
                overflow: "hidden",
                pointerEvents: "none",
                zIndex: (chartOptions.style && chartOptions.style.zIndex || 0) + 2,
                top: 0
              }, null, true);
              if (this.scrollingContainer) {
                this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer);
              }
              this.renderTo.style.overflow = "visible";
              this.fixedRenderer = fixedRenderer = new Renderer(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style);
              this.scrollableMask = fixedRenderer.path().attr({
                fill: this.options.chart.backgroundColor || "#fff",
                "fill-opacity": pick(scrollableOptions.opacity, 0.85),
                zIndex: -1
              }).addClass("highcharts-scrollable-mask").add();
              addEvent(this, "afterShowResetZoom", this.moveFixedElements);
              addEvent(this, "afterApplyDrilldown", this.moveFixedElements);
              addEvent(this, "afterLayOutTitles", this.moveFixedElements);
            } else {
              this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
            }
            if (this.scrollableDirty || firstTime) {
              this.scrollableDirty = false;
              this.moveFixedElements();
            }
            scrollableWidth = this.chartWidth + (this.scrollablePixelsX || 0);
            scrollableHeight = this.chartHeight + (this.scrollablePixelsY || 0);
            stop(this.container);
            this.container.style.width = scrollableWidth + "px";
            this.container.style.height = scrollableHeight + "px";
            this.renderer.boxWrapper.attr({
              width: scrollableWidth,
              height: scrollableHeight,
              viewBox: [0, 0, scrollableWidth, scrollableHeight].join(" ")
            });
            this.chartBackground.attr({
              width: scrollableWidth,
              height: scrollableHeight
            });
            this.scrollingContainer.style.height = this.chartHeight + "px";
            if (firstTime) {
              if (scrollableOptions.scrollPositionX) {
                this.scrollingContainer.scrollLeft = this.scrollablePixelsX * scrollableOptions.scrollPositionX;
              }
              if (scrollableOptions.scrollPositionY) {
                this.scrollingContainer.scrollTop = this.scrollablePixelsY * scrollableOptions.scrollPositionY;
              }
            }
            var axisOffset = this.axisOffset, maskTop = this.plotTop - axisOffset[0] - 1, maskLeft = this.plotLeft - axisOffset[3] - 1, maskBottom = this.plotTop + this.plotHeight + axisOffset[2] + 1, maskRight = this.plotLeft + this.plotWidth + axisOffset[1] + 1, maskPlotRight = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0), maskPlotBottom = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0), d;
            if (this.scrollablePixelsX) {
              d = [
                // Left side
                ["M", 0, maskTop],
                ["L", this.plotLeft - 1, maskTop],
                ["L", this.plotLeft - 1, maskBottom],
                ["L", 0, maskBottom],
                ["Z"],
                // Right side
                ["M", maskPlotRight, maskTop],
                ["L", this.chartWidth, maskTop],
                ["L", this.chartWidth, maskBottom],
                ["L", maskPlotRight, maskBottom],
                ["Z"]
              ];
            } else if (this.scrollablePixelsY) {
              d = [
                // Top side
                ["M", maskLeft, 0],
                ["L", maskLeft, this.plotTop - 1],
                ["L", maskRight, this.plotTop - 1],
                ["L", maskRight, 0],
                ["Z"],
                // Bottom side
                ["M", maskLeft, maskPlotBottom],
                ["L", maskLeft, this.chartHeight],
                ["L", maskRight, this.chartHeight],
                ["L", maskRight, maskPlotBottom],
                ["Z"]
              ];
            } else {
              d = [["M", 0, 0]];
            }
            if (this.redrawTrigger !== "adjustHeight") {
              this.scrollableMask.attr({ d });
            }
          };
          addEvent(Axis, "afterInit", function() {
            this.chart.scrollableDirty = true;
          });
          addEvent(Series, "show", function() {
            this.chart.scrollableDirty = true;
          });
          "";
        });
        _registerModule(_modules, "Core/Axis/Stacking/StackItem.js", [_modules["Core/FormatUtilities.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(FU, SeriesRegistry, U) {
          var format3 = FU.format;
          var Series = SeriesRegistry.series;
          var destroyObjectProperties = U.destroyObjectProperties, pick = U.pick, isNumber = U.isNumber;
          var StackItem = (
            /** @class */
            function() {
              function StackItem2(axis, options, negativeValue, x, stackOption) {
                var inverted = axis.chart.inverted, reversed = axis.reversed;
                this.axis = axis;
                var isNegative = this.isNegative = !!negativeValue !== !!reversed;
                this.options = options = options || {};
                this.x = x;
                this.total = null;
                this.cumulative = null;
                this.points = {};
                this.hasValidPoints = false;
                this.stack = stackOption;
                this.leftCliff = 0;
                this.rightCliff = 0;
                this.alignOptions = {
                  align: options.align || (inverted ? isNegative ? "left" : "right" : "center"),
                  verticalAlign: options.verticalAlign || (inverted ? "middle" : isNegative ? "bottom" : "top"),
                  y: options.y,
                  x: options.x
                };
                this.textAlign = options.textAlign || (inverted ? !isNegative ? "left" : "right" : "center");
              }
              StackItem2.prototype.destroy = function() {
                destroyObjectProperties(this, this.axis);
              };
              StackItem2.prototype.render = function(group) {
                var chart = this.axis.chart, options = this.options, formatOption = options.format, str = formatOption ? format3(
                  formatOption,
                  this,
                  chart
                ) : options.formatter.call(this);
                if (this.label) {
                  this.label.attr({ text: str, visibility: "hidden" });
                } else {
                  this.label = chart.renderer.label(str, null, void 0, options.shape, void 0, void 0, options.useHTML, false, "stack-labels");
                  var attr = {
                    r: options.borderRadius || 0,
                    text: str,
                    // set default padding to 5 as it is in datalabels #12308
                    padding: pick(options.padding, 5),
                    visibility: "hidden"
                    // hidden until setOffset is called
                  };
                  if (!chart.styledMode) {
                    attr.fill = options.backgroundColor;
                    attr.stroke = options.borderColor;
                    attr["stroke-width"] = options.borderWidth;
                    this.label.css(options.style || {});
                  }
                  this.label.attr(attr);
                  if (!this.label.added) {
                    this.label.add(group);
                  }
                }
                this.label.labelrank = chart.plotSizeY;
              };
              StackItem2.prototype.setOffset = function(xOffset, xWidth, boxBottom, boxTop, defaultX, xAxis) {
                var _a = this, alignOptions = _a.alignOptions, axis = _a.axis, label = _a.label, options = _a.options, textAlign = _a.textAlign, chart = axis.chart, stackBox = this.getStackBox({
                  xOffset,
                  width: xWidth,
                  boxBottom,
                  boxTop,
                  defaultX,
                  xAxis
                }), verticalAlign = alignOptions.verticalAlign;
                if (label && stackBox) {
                  var labelBox = label.getBBox(), padding = label.padding;
                  var isJustify = pick(options.overflow, "justify") === "justify", visible = void 0;
                  alignOptions.x = options.x || 0;
                  alignOptions.y = options.y || 0;
                  var _b = this.adjustStackPosition({
                    labelBox,
                    verticalAlign,
                    textAlign
                  }), x = _b.x, y = _b.y;
                  stackBox.x -= x;
                  stackBox.y -= y;
                  label.align(alignOptions, false, stackBox);
                  visible = chart.isInsidePlot(label.alignAttr.x + alignOptions.x + x, label.alignAttr.y + alignOptions.y + y);
                  if (!visible) {
                    isJustify = false;
                  }
                  if (isJustify) {
                    Series.prototype.justifyDataLabel.call(axis, label, alignOptions, label.alignAttr, labelBox, stackBox);
                  }
                  label.attr({
                    x: label.alignAttr.x,
                    y: label.alignAttr.y,
                    rotation: options.rotation,
                    rotationOriginX: labelBox.width / 2,
                    rotationOriginY: labelBox.height / 2
                  });
                  if (pick(!isJustify && options.crop, true)) {
                    visible = isNumber(label.x) && isNumber(label.y) && chart.isInsidePlot(label.x - padding + label.width, label.y) && chart.isInsidePlot(label.x + padding, label.y);
                  }
                  label[visible ? "show" : "hide"]();
                }
              };
              StackItem2.prototype.adjustStackPosition = function(_a) {
                var labelBox = _a.labelBox, verticalAlign = _a.verticalAlign, textAlign = _a.textAlign;
                var factorMap = {
                  bottom: 0,
                  middle: 1,
                  top: 2,
                  right: 1,
                  center: 0,
                  left: -1
                }, verticalAlignFactor = factorMap[verticalAlign], textAlignFactor = factorMap[textAlign];
                return {
                  x: labelBox.width / 2 + labelBox.width / 2 * textAlignFactor,
                  y: labelBox.height / 2 * verticalAlignFactor
                };
              };
              StackItem2.prototype.getStackBox = function(stackBoxProps) {
                var stackItem = this, axis = this.axis, chart = axis.chart, boxTop = stackBoxProps.boxTop, defaultX = stackBoxProps.defaultX, xOffset = stackBoxProps.xOffset, width = stackBoxProps.width, boxBottom = stackBoxProps.boxBottom, totalStackValue = axis.stacking.usePercentage ? 100 : pick(
                  boxTop,
                  this.total,
                  0
                ), y = axis.toPixels(totalStackValue), xAxis = stackBoxProps.xAxis || chart.xAxis[0], x = pick(
                  defaultX,
                  xAxis.toPixels(this.x)
                ) + xOffset, yZero = axis.toPixels(boxBottom ? boxBottom : 0), height = Math.abs(y - yZero), inverted = chart.inverted, neg = stackItem.isNegative;
                return inverted ? {
                  x: (neg ? y : y - height) - chart.plotLeft,
                  y: x - chart.plotTop,
                  width: height,
                  height: width
                } : {
                  x: x - chart.plotLeft,
                  y: (neg ? y - height : y) - chart.plotTop,
                  width,
                  height
                };
              };
              return StackItem2;
            }()
          );
          "";
          return StackItem;
        });
        _registerModule(_modules, "Core/Axis/Stacking/StackingAxis.js", [_modules["Core/Animation/AnimationUtilities.js"], _modules["Core/Axis/Axis.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Axis/Stacking/StackItem.js"], _modules["Core/Utilities.js"]], function(A, Axis, SeriesRegistry, StackItem, U) {
          var getDeferredAnimation = A.getDeferredAnimation;
          var seriesProto = SeriesRegistry.series.prototype;
          var addEvent = U.addEvent, correctFloat = U.correctFloat, defined = U.defined, destroyObjectProperties = U.destroyObjectProperties, fireEvent = U.fireEvent, isArray = U.isArray, isNumber = U.isNumber, objectEach = U.objectEach, pick = U.pick;
          function chartGetStacks() {
            var chart = this, inverted = chart.inverted;
            chart.yAxis.forEach(function(axis) {
              if (axis.stacking && axis.stacking.stacks && axis.hasVisibleSeries) {
                axis.stacking.oldStacks = axis.stacking.stacks;
              }
            });
            chart.series.forEach(function(series) {
              var xAxisOptions = series.xAxis && series.xAxis.options || {};
              if (series.options.stacking && (series.visible === true || chart.options.chart.ignoreHiddenSeries === false)) {
                series.stackKey = [
                  series.type,
                  pick(series.options.stack, ""),
                  inverted ? xAxisOptions.top : xAxisOptions.left,
                  inverted ? xAxisOptions.height : xAxisOptions.width
                ].join(",");
              }
            });
          }
          function onAxisDestroy() {
            var stacking = this.stacking;
            if (!stacking) {
              return;
            }
            var stacks = stacking.stacks;
            objectEach(stacks, function(stack, stackKey) {
              destroyObjectProperties(stack);
              stacks[stackKey] = null;
            });
            if (stacking && stacking.stackTotalGroup) {
              stacking.stackTotalGroup.destroy();
            }
          }
          function onAxisInit() {
            if (this.coll === "yAxis" && !this.stacking) {
              this.stacking = new AxisAdditions(this);
            }
          }
          function seriesGetStackIndicator(stackIndicator, x, index, key) {
            if (!defined(stackIndicator) || stackIndicator.x !== x || key && stackIndicator.stackKey !== key) {
              stackIndicator = {
                x,
                index: 0,
                key,
                stackKey: key
              };
            } else {
              stackIndicator.index++;
            }
            stackIndicator.key = [index, x, stackIndicator.index].join(",");
            return stackIndicator;
          }
          function seriesModifyStacks() {
            var series = this, yAxis = series.yAxis, stackKey = series.stackKey, stacks = yAxis.stacking.stacks, processedXData = series.processedXData, stacking = series.options.stacking, stacker = series[stacking + "Stacker"];
            var stackIndicator;
            if (stacker) {
              [stackKey, "-" + stackKey].forEach(function(key) {
                var i = processedXData.length, x, stack, pointExtremes;
                while (i--) {
                  x = processedXData[i];
                  stackIndicator = series.getStackIndicator(stackIndicator, x, series.index, key);
                  stack = stacks[key] && stacks[key][x];
                  pointExtremes = stack && stack.points[stackIndicator.key];
                  if (pointExtremes) {
                    stacker.call(series, pointExtremes, stack, i);
                  }
                }
              });
            }
          }
          function seriesPercentStacker(pointExtremes, stack, i) {
            var totalFactor = stack.total ? 100 / stack.total : 0;
            pointExtremes[0] = correctFloat(pointExtremes[0] * totalFactor);
            pointExtremes[1] = correctFloat(pointExtremes[1] * totalFactor);
            this.stackedYData[i] = pointExtremes[1];
          }
          function seriesSetGroupedPoints() {
            var stacking = this.yAxis.stacking;
            if (this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && // With stacking enabled, we already have stacks that we can compute
            // from
            !this.options.stacking && // With only one series, we don't need to consider centerInCategory
            this.chart.series.length > 1) {
              seriesProto.setStackedPoints.call(this, "group");
            } else if (stacking) {
              objectEach(stacking.stacks, function(type, key) {
                if (key.slice(-5) === "group") {
                  objectEach(type, function(stack) {
                    return stack.destroy();
                  });
                  delete stacking.stacks[key];
                }
              });
            }
          }
          function seriesSetStackedPoints(stackingParam) {
            var chart = this.chart, stacking = stackingParam || this.options.stacking;
            if (!stacking || this.visible !== true && chart.options.chart.ignoreHiddenSeries !== false) {
              return;
            }
            var series = this, xData = series.processedXData, yData = series.processedYData, stackedYData = [], yDataLength = yData.length, seriesOptions = series.options, threshold = seriesOptions.threshold, stackThreshold = pick(seriesOptions.startFromThreshold && threshold, 0), stackOption = seriesOptions.stack, stackKey = stackingParam ? "" + series.type + ",".concat(stacking) : series.stackKey, negKey = "-" + stackKey, negStacks = series.negStacks, yAxis = stacking === "group" ? chart.yAxis[0] : series.yAxis, stacks = yAxis.stacking.stacks, oldStacks = yAxis.stacking.oldStacks;
            var stackIndicator, isNegative, stack, other, key, pointKey, i, x, y;
            yAxis.stacking.stacksTouched += 1;
            for (i = 0; i < yDataLength; i++) {
              x = xData[i];
              y = yData[i];
              stackIndicator = series.getStackIndicator(stackIndicator, x, series.index);
              pointKey = stackIndicator.key;
              isNegative = negStacks && y < (stackThreshold ? 0 : threshold);
              key = isNegative ? negKey : stackKey;
              if (!stacks[key]) {
                stacks[key] = {};
              }
              if (!stacks[key][x]) {
                if (oldStacks[key] && oldStacks[key][x]) {
                  stacks[key][x] = oldStacks[key][x];
                  stacks[key][x].total = null;
                } else {
                  stacks[key][x] = new StackItem(yAxis, yAxis.options.stackLabels, !!isNegative, x, stackOption);
                }
              }
              stack = stacks[key][x];
              if (y !== null) {
                stack.points[pointKey] = stack.points[series.index] = [pick(stack.cumulative, stackThreshold)];
                if (!defined(stack.cumulative)) {
                  stack.base = pointKey;
                }
                stack.touched = yAxis.stacking.stacksTouched;
                if (stackIndicator.index > 0 && series.singleStacks === false) {
                  stack.points[pointKey][0] = stack.points[series.index + "," + x + ",0"][0];
                }
              } else {
                stack.points[pointKey] = stack.points[series.index] = null;
              }
              if (stacking === "percent") {
                other = isNegative ? stackKey : negKey;
                if (negStacks && stacks[other] && stacks[other][x]) {
                  other = stacks[other][x];
                  stack.total = other.total = Math.max(other.total, stack.total) + Math.abs(y) || 0;
                } else {
                  stack.total = correctFloat(stack.total + (Math.abs(y) || 0));
                }
              } else if (stacking === "group") {
                if (isArray(y)) {
                  y = y[0];
                }
                if (y !== null) {
                  stack.total = (stack.total || 0) + 1;
                }
              } else {
                stack.total = correctFloat(stack.total + (y || 0));
              }
              if (stacking === "group") {
                stack.cumulative = (stack.total || 1) - 1;
              } else {
                stack.cumulative = pick(stack.cumulative, stackThreshold) + (y || 0);
              }
              if (y !== null) {
                stack.points[pointKey].push(stack.cumulative);
                stackedYData[i] = stack.cumulative;
                stack.hasValidPoints = true;
              }
            }
            if (stacking === "percent") {
              yAxis.stacking.usePercentage = true;
            }
            if (stacking !== "group") {
              this.stackedYData = stackedYData;
            }
            yAxis.stacking.oldStacks = {};
          }
          var AxisAdditions = (
            /** @class */
            function() {
              function AxisAdditions2(axis) {
                this.oldStacks = {};
                this.stacks = {};
                this.stacksTouched = 0;
                this.axis = axis;
              }
              AxisAdditions2.prototype.buildStacks = function() {
                var stacking = this;
                var axis = stacking.axis;
                var axisSeries = axis.series;
                var reversedStacks = axis.options.reversedStacks;
                var len = axisSeries.length;
                var actualSeries, i;
                stacking.usePercentage = false;
                i = len;
                while (i--) {
                  actualSeries = axisSeries[reversedStacks ? i : len - i - 1];
                  actualSeries.setStackedPoints();
                  actualSeries.setGroupedPoints();
                }
                for (i = 0; i < len; i++) {
                  axisSeries[i].modifyStacks();
                }
                fireEvent(axis, "afterBuildStacks");
              };
              AxisAdditions2.prototype.cleanStacks = function() {
                var stacking = this;
                var stacks;
                if (stacking.oldStacks) {
                  stacks = stacking.stacks = stacking.oldStacks;
                }
                objectEach(stacks, function(type) {
                  objectEach(type, function(stack) {
                    stack.cumulative = stack.total;
                  });
                });
              };
              AxisAdditions2.prototype.resetStacks = function() {
                var _this = this;
                objectEach(this.stacks, function(type) {
                  objectEach(type, function(stack, x) {
                    if (isNumber(stack.touched) && stack.touched < _this.stacksTouched) {
                      stack.destroy();
                      delete type[x];
                    } else {
                      stack.total = null;
                      stack.cumulative = null;
                    }
                  });
                });
              };
              AxisAdditions2.prototype.renderStackTotals = function() {
                var stacking = this, axis = stacking.axis, chart = axis.chart, renderer = chart.renderer, stacks = stacking.stacks, stackLabelsAnim = axis.options.stackLabels && axis.options.stackLabels.animation, animationConfig = getDeferredAnimation(
                  chart,
                  stackLabelsAnim || false
                ), stackTotalGroup = stacking.stackTotalGroup = stacking.stackTotalGroup || renderer.g("stack-labels").attr({
                  zIndex: 6,
                  opacity: 0
                }).add();
                stackTotalGroup.translate(chart.plotLeft, chart.plotTop);
                objectEach(stacks, function(type) {
                  objectEach(type, function(stack) {
                    stack.render(stackTotalGroup);
                  });
                });
                stackTotalGroup.animate({
                  opacity: 1
                }, animationConfig);
              };
              return AxisAdditions2;
            }()
          );
          var StackingAxis;
          (function(StackingAxis2) {
            var composedClasses = [];
            function compose(AxisClass, ChartClass, SeriesClass) {
              if (composedClasses.indexOf(AxisClass) === -1) {
                composedClasses.push(AxisClass);
                addEvent(AxisClass, "init", onAxisInit);
                addEvent(AxisClass, "destroy", onAxisDestroy);
              }
              if (composedClasses.indexOf(ChartClass) === -1) {
                composedClasses.push(ChartClass);
                var chartProto = ChartClass.prototype;
                chartProto.getStacks = chartGetStacks;
              }
              if (composedClasses.indexOf(SeriesClass) === -1) {
                composedClasses.push(SeriesClass);
                var seriesProto_1 = SeriesClass.prototype;
                seriesProto_1.getStackIndicator = seriesGetStackIndicator;
                seriesProto_1.modifyStacks = seriesModifyStacks;
                seriesProto_1.percentStacker = seriesPercentStacker;
                seriesProto_1.setGroupedPoints = seriesSetGroupedPoints;
                seriesProto_1.setStackedPoints = seriesSetStackedPoints;
              }
            }
            StackingAxis2.compose = compose;
          })(StackingAxis || (StackingAxis = {}));
          return StackingAxis;
        });
        _registerModule(_modules, "Series/Line/LineSeries.js", [_modules["Core/Series/Series.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(Series, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var defined = U.defined, merge = U.merge;
          var LineSeries = (
            /** @class */
            function(_super) {
              __extends(LineSeries2, _super);
              function LineSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.data = void 0;
                _this.options = void 0;
                _this.points = void 0;
                return _this;
              }
              LineSeries2.prototype.drawGraph = function() {
                var series = this, options = this.options, graphPath = (this.gappedPath || this.getGraphPath).call(this), styledMode = this.chart.styledMode;
                var props = [[
                  "graph",
                  "highcharts-graph"
                ]];
                if (!styledMode) {
                  props[0].push(options.lineColor || this.color || "#cccccc", options.dashStyle);
                }
                props = series.getZonesGraphs(props);
                props.forEach(function(prop, i) {
                  var graphKey = prop[0];
                  var attribs, graph = series[graphKey];
                  var verb = graph ? "animate" : "attr";
                  if (graph) {
                    graph.endX = series.preventGraphAnimation ? null : graphPath.xMap;
                    graph.animate({ d: graphPath });
                  } else if (graphPath.length) {
                    series[graphKey] = graph = series.chart.renderer.path(graphPath).addClass(prop[1]).attr({ zIndex: 1 }).add(series.group);
                  }
                  if (graph && !styledMode) {
                    attribs = {
                      "stroke": prop[2],
                      "stroke-width": options.lineWidth || 0,
                      // Polygon series use filled graph
                      "fill": series.fillGraph && series.color || "none"
                    };
                    if (prop[3]) {
                      attribs.dashstyle = prop[3];
                    } else if (options.linecap !== "square") {
                      attribs["stroke-linecap"] = attribs["stroke-linejoin"] = "round";
                    }
                    graph[verb](attribs).shadow(i < 2 && options.shadow);
                  }
                  if (graph) {
                    graph.startX = graphPath.xMap;
                    graph.isArea = graphPath.isArea;
                  }
                });
              };
              LineSeries2.prototype.getGraphPath = function(points, nullsAsZeroes, connectCliffs) {
                var series = this, options = series.options, graphPath = [], xMap = [];
                var gap, step = options.step;
                points = points || series.points;
                var reversed = points.reversed;
                if (reversed) {
                  points.reverse();
                }
                step = {
                  right: 1,
                  center: 2
                }[step] || step && 3;
                if (step && reversed) {
                  step = 4 - step;
                }
                points = this.getValidPoints(points, false, !(options.connectNulls && !nullsAsZeroes && !connectCliffs));
                points.forEach(function(point, i) {
                  var plotX = point.plotX, plotY = point.plotY, lastPoint = points[i - 1];
                  var pathToPoint;
                  if ((point.leftCliff || lastPoint && lastPoint.rightCliff) && !connectCliffs) {
                    gap = true;
                  }
                  if (point.isNull && !defined(nullsAsZeroes) && i > 0) {
                    gap = !options.connectNulls;
                  } else if (point.isNull && !nullsAsZeroes) {
                    gap = true;
                  } else {
                    if (i === 0 || gap) {
                      pathToPoint = [[
                        "M",
                        point.plotX,
                        point.plotY
                      ]];
                    } else if (series.getPointSpline) {
                      pathToPoint = [series.getPointSpline(points, point, i)];
                    } else if (step) {
                      if (step === 1) {
                        pathToPoint = [[
                          "L",
                          lastPoint.plotX,
                          plotY
                        ]];
                      } else if (step === 2) {
                        pathToPoint = [[
                          "L",
                          (lastPoint.plotX + plotX) / 2,
                          lastPoint.plotY
                        ], [
                          "L",
                          (lastPoint.plotX + plotX) / 2,
                          plotY
                        ]];
                      } else {
                        pathToPoint = [[
                          "L",
                          plotX,
                          lastPoint.plotY
                        ]];
                      }
                      pathToPoint.push([
                        "L",
                        plotX,
                        plotY
                      ]);
                    } else {
                      pathToPoint = [[
                        "L",
                        plotX,
                        plotY
                      ]];
                    }
                    xMap.push(point.x);
                    if (step) {
                      xMap.push(point.x);
                      if (step === 2) {
                        xMap.push(point.x);
                      }
                    }
                    graphPath.push.apply(graphPath, pathToPoint);
                    gap = false;
                  }
                });
                graphPath.xMap = xMap;
                series.graphPath = graphPath;
                return graphPath;
              };
              LineSeries2.prototype.getZonesGraphs = function(props) {
                this.zones.forEach(function(zone, i) {
                  var propset = [
                    "zone-graph-" + i,
                    "highcharts-graph highcharts-zone-graph-" + i + " " + (zone.className || "")
                  ];
                  if (!this.chart.styledMode) {
                    propset.push(zone.color || this.color, zone.dashStyle || this.options.dashStyle);
                  }
                  props.push(propset);
                }, this);
                return props;
              };
              LineSeries2.defaultOptions = merge(
                Series.defaultOptions,
                /**
                 * General options for all series types.
                 *
                 * @optionparent plotOptions.series
                 */
                {
                  // nothing here yet
                }
              );
              return LineSeries2;
            }(Series)
          );
          SeriesRegistry.registerSeriesType("line", LineSeries);
          "";
          return LineSeries;
        });
        _registerModule(_modules, "Series/Area/AreaSeries.js", [_modules["Core/Color/Color.js"], _modules["Core/Legend/LegendSymbol.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(Color2, LegendSymbol, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var color2 = Color2.parse;
          var LineSeries = SeriesRegistry.seriesTypes.line;
          var extend2 = U.extend, merge = U.merge, objectEach = U.objectEach, pick = U.pick;
          var AreaSeries = (
            /** @class */
            function(_super) {
              __extends(AreaSeries2, _super);
              function AreaSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.data = void 0;
                _this.options = void 0;
                _this.points = void 0;
                return _this;
              }
              AreaSeries2.prototype.drawGraph = function() {
                this.areaPath = [];
                _super.prototype.drawGraph.apply(this);
                var series = this, areaPath = this.areaPath, options = this.options, zones = this.zones, props = [[
                  "area",
                  "highcharts-area",
                  this.color,
                  options.fillColor
                ]];
                zones.forEach(function(zone, i) {
                  props.push([
                    "zone-area-" + i,
                    "highcharts-area highcharts-zone-area-" + i + " " + zone.className,
                    zone.color || series.color,
                    zone.fillColor || options.fillColor
                  ]);
                });
                props.forEach(function(prop) {
                  var areaKey = prop[0], attribs = {};
                  var area = series[areaKey];
                  var verb = area ? "animate" : "attr";
                  if (area) {
                    area.endX = series.preventGraphAnimation ? null : areaPath.xMap;
                    area.animate({ d: areaPath });
                  } else {
                    attribs.zIndex = 0;
                    area = series[areaKey] = series.chart.renderer.path(areaPath).addClass(prop[1]).add(series.group);
                    area.isArea = true;
                  }
                  if (!series.chart.styledMode) {
                    attribs.fill = pick(prop[3], color2(prop[2]).setOpacity(pick(options.fillOpacity, 0.75)).get());
                  }
                  area[verb](attribs);
                  area.startX = areaPath.xMap;
                  area.shiftUnit = options.step ? 2 : 1;
                });
              };
              AreaSeries2.prototype.getGraphPath = function(points) {
                var getGraphPath = LineSeries.prototype.getGraphPath, options = this.options, stacking = options.stacking, yAxis = this.yAxis, bottomPoints = [], graphPoints = [], seriesIndex = this.index, stacks = yAxis.stacking.stacks[this.stackKey], threshold = options.threshold, translatedThreshold = Math.round(
                  // #10909
                  yAxis.getThreshold(options.threshold)
                ), connectNulls = pick(
                  // #10574
                  options.connectNulls,
                  stacking === "percent"
                ), addDummyPoints = function(i2, otherI, side) {
                  var point = points[i2], stackedValues = stacking && stacks[point.x].points[seriesIndex], nullVal = point[side + "Null"] || 0, cliffVal = point[side + "Cliff"] || 0;
                  var top, bottom, isNull2 = true;
                  if (cliffVal || nullVal) {
                    top = (nullVal ? stackedValues[0] : stackedValues[1]) + cliffVal;
                    bottom = stackedValues[0] + cliffVal;
                    isNull2 = !!nullVal;
                  } else if (!stacking && points[otherI] && points[otherI].isNull) {
                    top = bottom = threshold;
                  }
                  if (typeof top !== "undefined") {
                    graphPoints.push({
                      plotX,
                      plotY: top === null ? translatedThreshold : yAxis.getThreshold(top),
                      isNull: isNull2,
                      isCliff: true
                    });
                    bottomPoints.push({
                      plotX,
                      plotY: bottom === null ? translatedThreshold : yAxis.getThreshold(bottom),
                      doCurve: false
                      // #1041, gaps in areaspline areas
                    });
                  }
                };
                var plotX, isNull, yBottom;
                points = points || this.points;
                if (stacking) {
                  points = this.getStackPoints(points);
                }
                for (var i = 0, iEnd = points.length; i < iEnd; ++i) {
                  if (!stacking) {
                    points[i].leftCliff = points[i].rightCliff = points[i].leftNull = points[i].rightNull = void 0;
                  }
                  isNull = points[i].isNull;
                  plotX = pick(points[i].rectPlotX, points[i].plotX);
                  yBottom = stacking ? pick(points[i].yBottom, translatedThreshold) : translatedThreshold;
                  if (!isNull || connectNulls) {
                    if (!connectNulls) {
                      addDummyPoints(i, i - 1, "left");
                    }
                    if (!(isNull && !stacking && connectNulls)) {
                      graphPoints.push(points[i]);
                      bottomPoints.push({
                        x: i,
                        plotX,
                        plotY: yBottom
                      });
                    }
                    if (!connectNulls) {
                      addDummyPoints(i, i + 1, "right");
                    }
                  }
                }
                var topPath = getGraphPath.call(
                  this,
                  graphPoints,
                  true,
                  true
                );
                bottomPoints.reversed = true;
                var bottomPath = getGraphPath.call(
                  this,
                  bottomPoints,
                  true,
                  true
                );
                var firstBottomPoint = bottomPath[0];
                if (firstBottomPoint && firstBottomPoint[0] === "M") {
                  bottomPath[0] = ["L", firstBottomPoint[1], firstBottomPoint[2]];
                }
                var areaPath = topPath.concat(bottomPath);
                if (areaPath.length) {
                  areaPath.push(["Z"]);
                }
                var graphPath = getGraphPath.call(
                  this,
                  graphPoints,
                  false,
                  connectNulls
                );
                areaPath.xMap = topPath.xMap;
                this.areaPath = areaPath;
                return graphPath;
              };
              AreaSeries2.prototype.getStackPoints = function(points) {
                var series = this, segment = [], keys = [], xAxis = this.xAxis, yAxis = this.yAxis, stack = yAxis.stacking.stacks[this.stackKey], pointMap = {}, yAxisSeries = yAxis.series, seriesLength = yAxisSeries.length, upOrDown = yAxis.options.reversedStacks ? 1 : -1, seriesIndex = yAxisSeries.indexOf(series);
                points = points || this.points;
                if (this.options.stacking) {
                  for (var i = 0; i < points.length; i++) {
                    points[i].leftNull = points[i].rightNull = void 0;
                    pointMap[points[i].x] = points[i];
                  }
                  objectEach(stack, function(stackX, x) {
                    if (stackX.total !== null) {
                      keys.push(x);
                    }
                  });
                  keys.sort(function(a, b) {
                    return a - b;
                  });
                  var visibleSeries_1 = yAxisSeries.map(function(s) {
                    return s.visible;
                  });
                  keys.forEach(function(x, idx) {
                    var y = 0, stackPoint, stackedValues;
                    if (pointMap[x] && !pointMap[x].isNull) {
                      segment.push(pointMap[x]);
                      [-1, 1].forEach(function(direction) {
                        var nullName = direction === 1 ? "rightNull" : "leftNull", cliffName = direction === 1 ? "rightCliff" : "leftCliff", otherStack = stack[keys[idx + direction]];
                        var cliff = 0;
                        if (otherStack) {
                          var i3 = seriesIndex;
                          while (i3 >= 0 && i3 < seriesLength) {
                            var si2 = yAxisSeries[i3].index;
                            stackPoint = otherStack.points[si2];
                            if (!stackPoint) {
                              if (si2 === series.index) {
                                pointMap[x][nullName] = true;
                              } else if (visibleSeries_1[i3]) {
                                stackedValues = stack[x].points[si2];
                                if (stackedValues) {
                                  cliff -= stackedValues[1] - stackedValues[0];
                                }
                              }
                            }
                            i3 += upOrDown;
                          }
                        }
                        pointMap[x][cliffName] = cliff;
                      });
                    } else {
                      var i2 = seriesIndex;
                      while (i2 >= 0 && i2 < seriesLength) {
                        var si = yAxisSeries[i2].index;
                        stackPoint = stack[x].points[si];
                        if (stackPoint) {
                          y = stackPoint[1];
                          break;
                        }
                        i2 += upOrDown;
                      }
                      y = pick(y, 0);
                      y = yAxis.translate(
                        // #6272
                        y,
                        0,
                        1,
                        0,
                        1
                      );
                      segment.push({
                        isNull: true,
                        plotX: xAxis.translate(
                          // #6272
                          x,
                          0,
                          0,
                          0,
                          1
                        ),
                        x,
                        plotY: y,
                        yBottom: y
                      });
                    }
                  });
                }
                return segment;
              };
              AreaSeries2.defaultOptions = merge(LineSeries.defaultOptions, {
                /**
                 * @see [fillColor](#plotOptions.area.fillColor)
                 * @see [fillOpacity](#plotOptions.area.fillOpacity)
                 *
                 * @apioption plotOptions.area.color
                 */
                /**
                 * Fill color or gradient for the area. When `null`, the series' `color`
                 * is used with the series' `fillOpacity`.
                 *
                 * In styled mode, the fill color can be set with the `.highcharts-area`
                 * class name.
                 *
                 * @see [color](#plotOptions.area.color)
                 * @see [fillOpacity](#plotOptions.area.fillOpacity)
                 *
                 * @sample {highcharts} highcharts/plotoptions/area-fillcolor-default/
                 *         Null by default
                 * @sample {highcharts} highcharts/plotoptions/area-fillcolor-gradient/
                 *         Gradient
                 *
                 * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @product   highcharts highstock
                 * @apioption plotOptions.area.fillColor
                 */
                /**
                 * Fill opacity for the area. When you set an explicit `fillColor`,
                 * the `fillOpacity` is not applied. Instead, you should define the
                 * opacity in the `fillColor` with an rgba color definition. The
                 * `fillOpacity` setting, also the default setting, overrides the alpha
                 * component of the `color` setting.
                 *
                 * In styled mode, the fill opacity can be set with the
                 * `.highcharts-area` class name.
                 *
                 * @see [color](#plotOptions.area.color)
                 * @see [fillColor](#plotOptions.area.fillColor)
                 *
                 * @sample {highcharts} highcharts/plotoptions/area-fillopacity/
                 *         Automatic fill color and fill opacity of 0.1
                 *
                 * @type      {number}
                 * @default   {highcharts} 0.75
                 * @default   {highstock} 0.75
                 * @product   highcharts highstock
                 * @apioption plotOptions.area.fillOpacity
                 */
                /**
                 * A separate color for the graph line. By default the line takes the
                 * `color` of the series, but the lineColor setting allows setting a
                 * separate color for the line without altering the `fillColor`.
                 *
                 * In styled mode, the line stroke can be set with the
                 * `.highcharts-graph` class name.
                 *
                 * @sample {highcharts} highcharts/plotoptions/area-linecolor/
                 *         Dark gray line
                 *
                 * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @product   highcharts highstock
                 * @apioption plotOptions.area.lineColor
                 */
                /**
                 * A separate color for the negative part of the area.
                 *
                 * In styled mode, a negative color is set with the
                 * `.highcharts-negative` class name.
                 *
                 * @see [negativeColor](#plotOptions.area.negativeColor)
                 *
                 * @sample {highcharts} highcharts/css/series-negative-color/
                 *         Negative color in styled mode
                 *
                 * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @since     3.0
                 * @product   highcharts
                 * @apioption plotOptions.area.negativeFillColor
                 */
                /**
                 * Whether the whole area or just the line should respond to mouseover
                 * tooltips and other mouse or touch events.
                 *
                 * @sample {highcharts|highstock} highcharts/plotoptions/area-trackbyarea/
                 *         Display the tooltip when the area is hovered
                 *
                 * @type      {boolean}
                 * @default   false
                 * @since     1.1.6
                 * @product   highcharts highstock
                 * @apioption plotOptions.area.trackByArea
                 */
                /**
                 * The Y axis value to serve as the base for the area, for
                 * distinguishing between values above and below a threshold. The area
                 * between the graph and the threshold is filled.
                 *
                 * * If a number is given, the Y axis will scale to the threshold.
                 * * If `null`, the scaling behaves like a line series with fill between
                 *   the graph and the Y axis minimum.
                 * * If `Infinity` or `-Infinity`, the area between the graph and the
                 *   corresponding Y axis extreme is filled (since v6.1.0).
                 *
                 * @sample {highcharts} highcharts/plotoptions/area-threshold/
                 *         A threshold of 100
                 * @sample {highcharts} highcharts/plotoptions/area-threshold-infinity/
                 *         A threshold of Infinity
                 *
                 * @type    {number|null}
                 * @since   2.0
                 * @product highcharts highstock
                 */
                threshold: 0
              });
              return AreaSeries2;
            }(LineSeries)
          );
          extend2(AreaSeries.prototype, {
            singleStacks: false,
            drawLegendSymbol: LegendSymbol.drawRectangle
          });
          SeriesRegistry.registerSeriesType("area", AreaSeries);
          "";
          return AreaSeries;
        });
        _registerModule(_modules, "Series/Spline/SplineSeries.js", [_modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var LineSeries = SeriesRegistry.seriesTypes.line;
          var merge = U.merge, pick = U.pick;
          var SplineSeries = (
            /** @class */
            function(_super) {
              __extends(SplineSeries2, _super);
              function SplineSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.data = void 0;
                _this.options = void 0;
                _this.points = void 0;
                return _this;
              }
              SplineSeries2.prototype.getPointSpline = function(points, point, i) {
                var smoothing = 1.5, denom = smoothing + 1, plotX = point.plotX || 0, plotY = point.plotY || 0, lastPoint = points[i - 1], nextPoint = points[i + 1];
                var leftContX, leftContY, rightContX, rightContY;
                function doCurve(otherPoint) {
                  return otherPoint && !otherPoint.isNull && otherPoint.doCurve !== false && // #6387, area splines next to null:
                  !point.isCliff;
                }
                if (doCurve(lastPoint) && doCurve(nextPoint)) {
                  var lastX = lastPoint.plotX || 0, lastY = lastPoint.plotY || 0, nextX = nextPoint.plotX || 0, nextY = nextPoint.plotY || 0;
                  var correction = 0;
                  leftContX = (smoothing * plotX + lastX) / denom;
                  leftContY = (smoothing * plotY + lastY) / denom;
                  rightContX = (smoothing * plotX + nextX) / denom;
                  rightContY = (smoothing * plotY + nextY) / denom;
                  if (rightContX !== leftContX) {
                    correction = (rightContY - leftContY) * (rightContX - plotX) / (rightContX - leftContX) + plotY - rightContY;
                  }
                  leftContY += correction;
                  rightContY += correction;
                  if (leftContY > lastY && leftContY > plotY) {
                    leftContY = Math.max(lastY, plotY);
                    rightContY = 2 * plotY - leftContY;
                  } else if (leftContY < lastY && leftContY < plotY) {
                    leftContY = Math.min(lastY, plotY);
                    rightContY = 2 * plotY - leftContY;
                  }
                  if (rightContY > nextY && rightContY > plotY) {
                    rightContY = Math.max(nextY, plotY);
                    leftContY = 2 * plotY - rightContY;
                  } else if (rightContY < nextY && rightContY < plotY) {
                    rightContY = Math.min(nextY, plotY);
                    leftContY = 2 * plotY - rightContY;
                  }
                  point.rightContX = rightContX;
                  point.rightContY = rightContY;
                }
                var ret = [
                  "C",
                  pick(
                    lastPoint.rightContX,
                    lastPoint.plotX,
                    0
                  ),
                  pick(
                    lastPoint.rightContY,
                    lastPoint.plotY,
                    0
                  ),
                  pick(
                    leftContX,
                    plotX,
                    0
                  ),
                  pick(
                    leftContY,
                    plotY,
                    0
                  ),
                  plotX,
                  plotY
                ];
                lastPoint.rightContX = lastPoint.rightContY = void 0;
                return ret;
              };
              SplineSeries2.defaultOptions = merge(LineSeries.defaultOptions);
              return SplineSeries2;
            }(LineSeries)
          );
          SeriesRegistry.registerSeriesType("spline", SplineSeries);
          "";
          return SplineSeries;
        });
        _registerModule(_modules, "Series/AreaSpline/AreaSplineSeries.js", [_modules["Series/Spline/SplineSeries.js"], _modules["Core/Legend/LegendSymbol.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(SplineSeries, LegendSymbol, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var _a = SeriesRegistry.seriesTypes, AreaSeries = _a.area, areaProto = _a.area.prototype;
          var extend2 = U.extend, merge = U.merge;
          var AreaSplineSeries = (
            /** @class */
            function(_super) {
              __extends(AreaSplineSeries2, _super);
              function AreaSplineSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.data = void 0;
                _this.points = void 0;
                _this.options = void 0;
                return _this;
              }
              AreaSplineSeries2.defaultOptions = merge(SplineSeries.defaultOptions, AreaSeries.defaultOptions);
              return AreaSplineSeries2;
            }(SplineSeries)
          );
          extend2(AreaSplineSeries.prototype, {
            getGraphPath: areaProto.getGraphPath,
            getStackPoints: areaProto.getStackPoints,
            drawGraph: areaProto.drawGraph,
            drawLegendSymbol: LegendSymbol.drawRectangle
          });
          SeriesRegistry.registerSeriesType("areaspline", AreaSplineSeries);
          "";
          return AreaSplineSeries;
        });
        _registerModule(_modules, "Series/Column/ColumnSeriesDefaults.js", [], function() {
          var ColumnSeriesDefaults = {
            /**
             * The corner radius of the border surrounding each column or bar.
             *
             * @sample {highcharts} highcharts/plotoptions/column-borderradius/
             *         Rounded columns
             *
             * @product highcharts highstock gantt
             */
            borderRadius: 0,
            /**
                 * When using automatic point colors pulled from the global
                 * [colors](colors) or series-specific
                 * [plotOptions.column.colors](series.colors) collections,
            this option
                 * determines whether the chart should receive one color per series or
                 * one color per point.
                 *
                 * In styled mode,
            the `colors` or `series.colors` arrays are not
                 * supported,
            and instead this option gives the points individual color
                 * class names on the form `highcharts-color-{n}`.
                 *
                 * @see [series colors](#plotOptions.column.colors)
                 *
                 * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-false/
                 *         False by default
                 * @sample {highcharts} highcharts/plotoptions/column-colorbypoint-true/
                 *         True
                 *
                 * @type      {boolean}
                 * @default   false
                 * @since     2.0
                 * @product   highcharts highstock gantt
                 * @apioption plotOptions.column.colorByPoint
                 */
            /**
             * A series specific or series type specific color set to apply instead
             * of the global [colors](#colors) when [colorByPoint](
             * #plotOptions.column.colorByPoint) is true.
             *
             * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}
             * @since     3.0
             * @product   highcharts highstock gantt
             * @apioption plotOptions.column.colors
             */
            /**
                 * When `true`,
            the columns will center in the category,
            ignoring null
                 * or missing points. When `false`,
            space will be reserved for null or
                 * missing points.
                 *
                 * @sample {highcharts} highcharts/series-column/centerincategory/
                 *         Center in category
                 *
                 * @since   8.0.1
                 * @product highcharts highstock gantt
                 */
            centerInCategory: false,
            /**
                 * Padding between each value groups,
            in x axis units.
                 *
                 * @sample {highcharts} highcharts/plotoptions/column-grouppadding-default/
                 *         0.2 by default
                 * @sample {highcharts} highcharts/plotoptions/column-grouppadding-none/
                 *         No group padding - all columns are evenly spaced
                 *
                 * @product highcharts highstock gantt
                 */
            groupPadding: 0.2,
            /**
             * Whether to group non-stacked columns or to let them render
             * independent of each other. Non-grouped columns will be laid out
             * individually and overlap each other.
             *
             * @sample {highcharts} highcharts/plotoptions/column-grouping-false/
             *         Grouping disabled
             * @sample {highstock} highcharts/plotoptions/column-grouping-false/
             *         Grouping disabled
             *
             * @type      {boolean}
             * @default   true
             * @since     2.3.0
             * @product   highcharts highstock gantt
             * @apioption plotOptions.column.grouping
             */
            /** @ignore-option */
            marker: null,
            /**
                 * The maximum allowed pixel width for a column,
            translated to the
                 * height of a bar in a bar chart. This prevents the columns from
                 * becoming too wide when there is a small number of points in the
                 * chart.
                 *
                 * @see [pointWidth](#plotOptions.column.pointWidth)
                 *
                 * @sample {highcharts} highcharts/plotoptions/column-maxpointwidth-20/
                 *         Limited to 50
                 * @sample {highstock} highcharts/plotoptions/column-maxpointwidth-20/
                 *         Limited to 50
                 *
                 * @type      {number}
                 * @since     4.1.8
                 * @product   highcharts highstock gantt
                 * @apioption plotOptions.column.maxPointWidth
                 */
            /**
                 * Padding between each column or bar,
            in x axis units.
                 *
                 * @sample {highcharts} highcharts/plotoptions/column-pointpadding-default/
                 *         0.1 by default
                 * @sample {highcharts} highcharts/plotoptions/column-pointpadding-025/
                 *          0.25
                 * @sample {highcharts} highcharts/plotoptions/column-pointpadding-none/
                 *         0 for tightly packed columns
                 *
                 * @product highcharts highstock gantt
                 */
            pointPadding: 0.1,
            /**
                 * A pixel value specifying a fixed width for each column or bar point.
                 * When set to `undefined`,
            the width is calculated from the
                 * `pointPadding` and `groupPadding`. The width effects the dimension
                 * that is not based on the point value. For column series it is the
                 * hoizontal length and for bar series it is the vertical length.
                 *
                 * @see [maxPointWidth](#plotOptions.column.maxPointWidth)
                 *
                 * @sample {highcharts} highcharts/plotoptions/column-pointwidth-20/
                 *         20px wide columns regardless of chart width or the amount of
                 *         data points
                 *
                 * @type      {number}
                 * @since     1.2.5
                 * @product   highcharts highstock gantt
                 * @apioption plotOptions.column.pointWidth
                 */
            /**
             * A pixel value specifying a fixed width for the column or bar.
             * Overrides pointWidth on the series.
             *
             * @see [series.pointWidth](#plotOptions.column.pointWidth)
             *
             * @type      {number}
             * @default   undefined
             * @since     7.0.0
             * @product   highcharts highstock gantt
             * @apioption series.column.data.pointWidth
             */
            /**
                 * The minimal height for a column or width for a bar. By default,
                 * 0 values are not shown. To visualize a 0 (or close to zero) point,
                 * set the minimal point length to a pixel value like 3\. In stacked
                 * column charts,
            minPointLength might not be respected for tightly
                 * packed values.
                 *
                 * @sample {highcharts} highcharts/plotoptions/column-minpointlength/
                 *         Zero base value
                 * @sample {highcharts} highcharts/plotoptions/column-minpointlength-pos-and-neg/
                 *         Positive and negative close to zero values
                 *
                 * @product highcharts highstock gantt
                 */
            minPointLength: 0,
            /**
                 * When the series contains less points than the crop threshold,
            all
                 * points are drawn,
            event if the points fall outside the visible plot
                 * area at the current zoom. The advantage of drawing all points
                 * (including markers and columns),
            is that animation is performed on
                 * updates. On the other hand,
            when the series contains more points than
                 * the crop threshold,
            the series data is cropped to only contain points
                 * that fall within the plot area. The advantage of cropping away
                 * invisible points is to increase performance on large series.
                 *
                 * @product highcharts highstock gantt
                 */
            cropThreshold: 50,
            /**
                 * The X axis range that each point is valid for. This determines the
                 * width of the column. On a categorized axis,
            the range will be 1
                 * by default (one category unit). On linear and datetime axes,
            the
                 * range will be computed as the distance between the two closest data
                 * points.
                 *
                 * The default `null` means it is computed automatically,
            but this
                 * option can be used to override the automatic value.
                 *
                 * This option is set by default to 1 if data sorting is enabled.
                 *
                 * @sample {highcharts} highcharts/plotoptions/column-pointrange/
                 *         Set the point range to one day on a data set with one week
                 *         between the points
                 *
                 * @type    {number|null}
                 * @since   2.3
                 * @product highcharts highstock gantt
                 */
            pointRange: null,
            states: {
              /**
                       * Options for the hovered point. These settings override the normal
                       * state options when a point is moused over or touched.
                       *
                       * @extends   plotOptions.series.states.hover
                       * @excluding halo,
              lineWidth,
              lineWidthPlus,
              marker
                       * @product   highcharts highstock gantt
                       */
              hover: {
                /** @ignore-option */
                halo: false,
                /**
                 * A specific border color for the hovered point. Defaults to
                 * inherit the normal state border color.
                 *
                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @product   highcharts gantt
                 * @apioption plotOptions.column.states.hover.borderColor
                 */
                /**
                 * A specific color for the hovered point.
                 *
                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @product   highcharts gantt
                 * @apioption plotOptions.column.states.hover.color
                 */
                /**
                             * How much to brighten the point on interaction. Requires the
                             * main color to be defined in hex or rgb(a) format.
                             *
                             * In styled mode,
                the hover brightening is by default replaced
                             * with a fill-opacity set in the `.highcharts-point:hover`
                             * rule.
                             *
                             * @sample {highcharts} highcharts/plotoptions/column-states-hover-brightness/
                             *         Brighten by 0.5
                             *
                             * @product highcharts highstock gantt
                             */
                brightness: 0.1
              },
              /**
                       * Options for the selected point. These settings override the
                       * normal state options when a point is selected.
                       *
                       * @extends   plotOptions.series.states.select
                       * @excluding halo,
              lineWidth,
              lineWidthPlus,
              marker
                       * @product   highcharts highstock gantt
                       */
              select: {
                /**
                 * A specific color for the selected point.
                 *
                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @default #cccccc
                 * @product highcharts highstock gantt
                 */
                color: "#cccccc",
                /**
                 * A specific border color for the selected point.
                 *
                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @default #000000
                 * @product highcharts highstock gantt
                 */
                borderColor: "#000000"
                /* Palette.neutralColor100 */
              }
            },
            dataLabels: {
              align: void 0,
              verticalAlign: void 0,
              /**
               * The y position offset of the label relative to the point in
               * pixels.
               *
               * @type {number}
               */
              y: void 0
            },
            // false doesn't work well: https://jsfiddle.net/highcharts/hz8fopan/14/
            /** @ignore-option */
            startFromThreshold: true,
            stickyTracking: false,
            tooltip: {
              distance: 6
            },
            /**
                 * The Y axis value to serve as the base for the columns,
            for
                 * distinguishing between values above and below a threshold. If `null`,
                 * the columns extend from the padding Y axis minimum.
                 *
                 * @type    {number|null}
                 * @since   2.0
                 * @product highcharts
                 */
            threshold: 0,
            /**
                 * The width of the border surrounding each column or bar. Defaults to
                 * `1` when there is room for a border,
            but to `0` when the columns are
                 * so dense that a border would cover the next column.
                 *
                 * In styled mode,
            the stroke width can be set with the
                 * `.highcharts-point` rule.
                 *
                 * @sample {highcharts} highcharts/plotoptions/column-borderwidth/
                 *         2px black border
                 *
                 * @type      {number}
                 * @default   undefined
                 * @product   highcharts highstock gantt
                 * @apioption plotOptions.column.borderWidth
                 */
            /**
                 * The color of the border surrounding each column or bar.
                 *
                 * In styled mode,
            the border stroke can be set with the
                 * `.highcharts-point` rule.
                 *
                 * @sample {highcharts} highcharts/plotoptions/column-bordercolor/
                 *         Dark gray border
                 *
                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @default   #ffffff
                 * @product   highcharts highstock gantt
                 */
            borderColor: "#ffffff"
            /* Palette.backgroundColor */
          };
          "";
          return ColumnSeriesDefaults;
        });
        _registerModule(_modules, "Series/Column/ColumnSeries.js", [_modules["Core/Animation/AnimationUtilities.js"], _modules["Core/Color/Color.js"], _modules["Series/Column/ColumnSeriesDefaults.js"], _modules["Core/Globals.js"], _modules["Core/Legend/LegendSymbol.js"], _modules["Core/Series/Series.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(A, Color2, ColumnSeriesDefaults, H, LegendSymbol, Series, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var animObject = A.animObject;
          var color2 = Color2.parse;
          var hasTouch = H.hasTouch, noop2 = H.noop;
          var clamp = U.clamp, css = U.css, defined = U.defined, extend2 = U.extend, fireEvent = U.fireEvent, isArray = U.isArray, isNumber = U.isNumber, merge = U.merge, pick = U.pick, objectEach = U.objectEach;
          var ColumnSeries = (
            /** @class */
            function(_super) {
              __extends(ColumnSeries2, _super);
              function ColumnSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.borderWidth = void 0;
                _this.data = void 0;
                _this.group = void 0;
                _this.options = void 0;
                _this.points = void 0;
                return _this;
              }
              ColumnSeries2.prototype.animate = function(init3) {
                var series = this, yAxis = this.yAxis, options = series.options, inverted = this.chart.inverted, attr = {}, translateProp = inverted ? "translateX" : "translateY";
                var translateStart, translatedThreshold;
                if (init3) {
                  attr.scaleY = 1e-3;
                  translatedThreshold = clamp(yAxis.toPixels(options.threshold), yAxis.pos, yAxis.pos + yAxis.len);
                  if (inverted) {
                    attr.translateX = translatedThreshold - yAxis.len;
                  } else {
                    attr.translateY = translatedThreshold;
                  }
                  if (series.clipBox) {
                    series.setClip();
                  }
                  series.group.attr(attr);
                } else {
                  translateStart = Number(series.group.attr(translateProp));
                  series.group.animate({ scaleY: 1 }, extend2(animObject(series.options.animation), {
                    // Do the scale synchronously to ensure smooth
                    // updating (#5030, #7228)
                    step: function(val, fx) {
                      if (series.group) {
                        attr[translateProp] = translateStart + fx.pos * (yAxis.pos - translateStart);
                        series.group.attr(attr);
                      }
                    }
                  }));
                }
              };
              ColumnSeries2.prototype.init = function(chart, options) {
                _super.prototype.init.apply(this, arguments);
                var series = this;
                chart = series.chart;
                if (chart.hasRendered) {
                  chart.series.forEach(function(otherSeries) {
                    if (otherSeries.type === series.type) {
                      otherSeries.isDirty = true;
                    }
                  });
                }
              };
              ColumnSeries2.prototype.getColumnMetrics = function() {
                var series = this, options = series.options, xAxis = series.xAxis, yAxis = series.yAxis, reversedStacks = xAxis.options.reversedStacks, reverseStacks = xAxis.reversed && !reversedStacks || !xAxis.reversed && reversedStacks, stackGroups = {};
                var stackKey, columnCount = 0;
                if (options.grouping === false) {
                  columnCount = 1;
                } else {
                  series.chart.series.forEach(function(otherSeries) {
                    var otherYAxis = otherSeries.yAxis, otherOptions = otherSeries.options;
                    var columnIndex;
                    if (otherSeries.type === series.type && (otherSeries.visible || !series.chart.options.chart.ignoreHiddenSeries) && yAxis.len === otherYAxis.len && yAxis.pos === otherYAxis.pos) {
                      if (otherOptions.stacking && otherOptions.stacking !== "group") {
                        stackKey = otherSeries.stackKey;
                        if (typeof stackGroups[stackKey] === "undefined") {
                          stackGroups[stackKey] = columnCount++;
                        }
                        columnIndex = stackGroups[stackKey];
                      } else if (otherOptions.grouping !== false) {
                        columnIndex = columnCount++;
                      }
                      otherSeries.columnIndex = columnIndex;
                    }
                  });
                }
                var categoryWidth = Math.min(
                  Math.abs(xAxis.transA) * (xAxis.ordinal && xAxis.ordinal.slope || options.pointRange || xAxis.closestPointRange || xAxis.tickInterval || 1),
                  // #2610
                  xAxis.len
                  // #1535
                ), groupPadding = categoryWidth * options.groupPadding, groupWidth = categoryWidth - 2 * groupPadding, pointOffsetWidth = groupWidth / (columnCount || 1), pointWidth = Math.min(
                  options.maxPointWidth || xAxis.len,
                  pick(
                    options.pointWidth,
                    pointOffsetWidth * (1 - 2 * options.pointPadding)
                  )
                ), pointPadding = (pointOffsetWidth - pointWidth) / 2, colIndex = (series.columnIndex || 0) + (reverseStacks ? 1 : 0), pointXOffset = pointPadding + (groupPadding + colIndex * pointOffsetWidth - categoryWidth / 2) * (reverseStacks ? -1 : 1);
                series.columnMetrics = {
                  width: pointWidth,
                  offset: pointXOffset,
                  paddedWidth: pointOffsetWidth,
                  columnCount
                };
                return series.columnMetrics;
              };
              ColumnSeries2.prototype.crispCol = function(x, y, w, h3) {
                var chart = this.chart, borderWidth = this.borderWidth, xCrisp = -(borderWidth % 2 ? 0.5 : 0);
                var right, yCrisp = borderWidth % 2 ? 0.5 : 1;
                if (chart.inverted && chart.renderer.isVML) {
                  yCrisp += 1;
                }
                if (this.options.crisp) {
                  right = Math.round(x + w) + xCrisp;
                  x = Math.round(x) + xCrisp;
                  w = right - x;
                }
                var bottom = Math.round(y + h3) + yCrisp, fromTop = Math.abs(y) <= 0.5 && bottom > 0.5;
                y = Math.round(y) + yCrisp;
                h3 = bottom - y;
                if (fromTop && h3) {
                  y -= 1;
                  h3 += 1;
                }
                return {
                  x,
                  y,
                  width: w,
                  height: h3
                };
              };
              ColumnSeries2.prototype.adjustForMissingColumns = function(x, pointWidth, point, metrics) {
                var _this = this;
                var stacking = this.options.stacking;
                if (!point.isNull && metrics.columnCount > 1) {
                  var reversedStacks_1 = this.yAxis.options.reversedStacks;
                  var indexInCategory_1 = 0, totalInCategory_1 = reversedStacks_1 ? 0 : -metrics.columnCount;
                  objectEach(this.yAxis.stacking && this.yAxis.stacking.stacks, function(stack) {
                    if (typeof point.x === "number") {
                      var stackItem_1 = stack[point.x.toString()];
                      if (stackItem_1) {
                        var pointValues = stackItem_1.points[_this.index];
                        if (stacking) {
                          if (pointValues) {
                            indexInCategory_1 = totalInCategory_1;
                          }
                          if (stackItem_1.hasValidPoints) {
                            reversedStacks_1 ? (
                              // #16169
                              totalInCategory_1++
                            ) : totalInCategory_1--;
                          }
                        } else if (isArray(pointValues)) {
                          var seriesIndexes = Object.keys(stackItem_1.points).filter(function(pointKey) {
                            return !pointKey.match(",") && // Filter out null points
                            stackItem_1.points[pointKey] && stackItem_1.points[pointKey].length > 1;
                          }).map(parseFloat).sort(function(a, b) {
                            return b - a;
                          });
                          indexInCategory_1 = seriesIndexes.indexOf(_this.index);
                          totalInCategory_1 = seriesIndexes.length;
                        }
                      }
                    }
                  });
                  var boxWidth = (totalInCategory_1 - 1) * metrics.paddedWidth + pointWidth;
                  x = (point.plotX || 0) + boxWidth / 2 - pointWidth - indexInCategory_1 * metrics.paddedWidth;
                }
                return x;
              };
              ColumnSeries2.prototype.translate = function() {
                var series = this, chart = series.chart, options = series.options, dense = series.dense = series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick(
                  options.borderWidth,
                  dense ? 0 : 1
                  // #3635
                ), xAxis = series.xAxis, yAxis = series.yAxis, threshold = options.threshold, translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold), minPointLength = pick(options.minPointLength, 5), metrics = series.getColumnMetrics(), seriesPointWidth = metrics.width, seriesXOffset = series.pointXOffset = metrics.offset, dataMin = series.dataMin, dataMax = series.dataMax;
                var seriesBarW = series.barW = Math.max(seriesPointWidth, 1 + 2 * borderWidth);
                if (chart.inverted) {
                  translatedThreshold -= 0.5;
                }
                if (options.pointPadding) {
                  seriesBarW = Math.ceil(seriesBarW);
                }
                Series.prototype.translate.apply(series);
                series.points.forEach(function(point) {
                  var yBottom = pick(
                    point.yBottom,
                    translatedThreshold
                  ), safeDistance = 999 + Math.abs(yBottom), plotX = point.plotX || 0, plotY = clamp(
                    point.plotY,
                    -safeDistance,
                    yAxis.len + safeDistance
                  );
                  var up, barY = Math.min(
                    plotY,
                    yBottom
                  ), barH = Math.max(
                    plotY,
                    yBottom
                  ) - barY, pointWidth = seriesPointWidth, barX = plotX + seriesXOffset, barW = seriesBarW;
                  if (minPointLength && Math.abs(barH) < minPointLength) {
                    barH = minPointLength;
                    up = !yAxis.reversed && !point.negative || yAxis.reversed && point.negative;
                    if (isNumber(threshold) && isNumber(dataMax) && point.y === threshold && dataMax <= threshold && // and if there's room for it (#7311)
                    (yAxis.min || 0) < threshold && // if all points are the same value (i.e zero) not draw
                    // as negative points (#10646), but only if there's room
                    // for it (#14876)
                    (dataMin !== dataMax || (yAxis.max || 0) <= threshold)) {
                      up = !up;
                    }
                    barY = Math.abs(barY - translatedThreshold) > minPointLength ? (
                      // ...keep position
                      yBottom - minPointLength
                    ) : (
                      // #1485, #4051
                      translatedThreshold - (up ? minPointLength : 0)
                    );
                  }
                  if (defined(point.options.pointWidth)) {
                    pointWidth = barW = Math.ceil(point.options.pointWidth);
                    barX -= Math.round((pointWidth - seriesPointWidth) / 2);
                  }
                  if (options.centerInCategory) {
                    barX = series.adjustForMissingColumns(barX, pointWidth, point, metrics);
                  }
                  point.barX = barX;
                  point.pointWidth = pointWidth;
                  point.tooltipPos = chart.inverted ? [
                    clamp(yAxis.len + yAxis.pos - chart.plotLeft - plotY, yAxis.pos - chart.plotLeft, yAxis.len + yAxis.pos - chart.plotLeft),
                    xAxis.len + xAxis.pos - chart.plotTop - barX - barW / 2,
                    barH
                  ] : [
                    xAxis.left - chart.plotLeft + barX + barW / 2,
                    clamp(plotY + yAxis.pos - chart.plotTop, yAxis.pos - chart.plotTop, yAxis.len + yAxis.pos - chart.plotTop),
                    barH
                  ];
                  point.shapeType = series.pointClass.prototype.shapeType || "rect";
                  point.shapeArgs = series.crispCol.apply(series, point.isNull ? (
                    // #3169, drilldown from null must have a position to work
                    // from #6585, dataLabel should be placed on xAxis, not
                    // floating in the middle of the chart
                    [barX, translatedThreshold, barW, 0]
                  ) : [barX, barY, barW, barH]);
                });
              };
              ColumnSeries2.prototype.drawGraph = function() {
                this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
              };
              ColumnSeries2.prototype.pointAttribs = function(point, state) {
                var options = this.options, p2o = this.pointAttrToOptions || {}, strokeOption = p2o.stroke || "borderColor", strokeWidthOption = p2o["stroke-width"] || "borderWidth";
                var stateOptions, zone, brightness, fill = point && point.color || this.color, stroke = point && point[strokeOption] || options[strokeOption] || fill, dashstyle = point && point.options.dashStyle || options.dashStyle, strokeWidth = point && point[strokeWidthOption] || options[strokeWidthOption] || this[strokeWidthOption] || 0, opacity = pick(
                  point && point.opacity,
                  options.opacity,
                  1
                );
                if (point && this.zones.length) {
                  zone = point.getZone();
                  fill = point.options.color || zone && (zone.color || point.nonZonedColor) || this.color;
                  if (zone) {
                    stroke = zone.borderColor || stroke;
                    dashstyle = zone.dashStyle || dashstyle;
                    strokeWidth = zone.borderWidth || strokeWidth;
                  }
                }
                if (state && point) {
                  stateOptions = merge(
                    options.states[state],
                    // #6401
                    point.options.states && point.options.states[state] || {}
                  );
                  brightness = stateOptions.brightness;
                  fill = stateOptions.color || typeof brightness !== "undefined" && color2(fill).brighten(stateOptions.brightness).get() || fill;
                  stroke = stateOptions[strokeOption] || stroke;
                  strokeWidth = stateOptions[strokeWidthOption] || strokeWidth;
                  dashstyle = stateOptions.dashStyle || dashstyle;
                  opacity = pick(stateOptions.opacity, opacity);
                }
                var ret = {
                  fill,
                  stroke,
                  "stroke-width": strokeWidth,
                  opacity
                };
                if (dashstyle) {
                  ret.dashstyle = dashstyle;
                }
                return ret;
              };
              ColumnSeries2.prototype.drawPoints = function(points) {
                if (points === void 0) {
                  points = this.points;
                }
                var series = this, chart = this.chart, options = series.options, renderer = chart.renderer, animationLimit = options.animationLimit || 250;
                var shapeArgs;
                points.forEach(function(point) {
                  var plotY = point.plotY;
                  var graphic = point.graphic, hasGraphic = !!graphic, verb = graphic && chart.pointCount < animationLimit ? "animate" : "attr";
                  if (isNumber(plotY) && point.y !== null) {
                    shapeArgs = point.shapeArgs;
                    if (graphic && point.hasNewShapeType()) {
                      graphic = graphic.destroy();
                    }
                    if (series.enabledDataSorting) {
                      point.startXPos = series.xAxis.reversed ? -(shapeArgs ? shapeArgs.width || 0 : 0) : series.xAxis.width;
                    }
                    if (!graphic) {
                      point.graphic = graphic = renderer[point.shapeType](shapeArgs).add(point.group || series.group);
                      if (graphic && series.enabledDataSorting && chart.hasRendered && chart.pointCount < animationLimit) {
                        graphic.attr({
                          x: point.startXPos
                        });
                        hasGraphic = true;
                        verb = "animate";
                      }
                    }
                    if (graphic && hasGraphic) {
                      graphic[verb](merge(shapeArgs));
                    }
                    if (options.borderRadius) {
                      graphic[verb]({
                        r: options.borderRadius
                      });
                    }
                    if (!chart.styledMode) {
                      graphic[verb](series.pointAttribs(point, point.selected && "select")).shadow(point.allowShadow !== false && options.shadow, null, options.stacking && !options.borderRadius);
                    }
                    if (graphic) {
                      graphic.addClass(point.getClassName(), true);
                      graphic.attr({
                        visibility: point.visible ? "inherit" : "hidden"
                      });
                    }
                  } else if (graphic) {
                    point.graphic = graphic.destroy();
                  }
                });
              };
              ColumnSeries2.prototype.drawTracker = function(points) {
                if (points === void 0) {
                  points = this.points;
                }
                var series = this, chart = series.chart, pointer = chart.pointer, onMouseOver = function(e) {
                  var point = pointer.getPointFromEvent(e);
                  if (typeof point !== "undefined") {
                    pointer.isDirectTouch = true;
                    point.onMouseOver(e);
                  }
                };
                var dataLabels;
                points.forEach(function(point) {
                  dataLabels = isArray(point.dataLabels) ? point.dataLabels : point.dataLabel ? [point.dataLabel] : [];
                  if (point.graphic) {
                    point.graphic.element.point = point;
                  }
                  dataLabels.forEach(function(dataLabel) {
                    if (dataLabel.div) {
                      dataLabel.div.point = point;
                    } else {
                      dataLabel.element.point = point;
                    }
                  });
                });
                if (!series._hasTracking) {
                  series.trackerGroups.forEach(function(key) {
                    if (series[key]) {
                      series[key].addClass("highcharts-tracker").on("mouseover", onMouseOver).on("mouseout", function(e) {
                        pointer.onTrackerMouseOut(e);
                      });
                      if (hasTouch) {
                        series[key].on("touchstart", onMouseOver);
                      }
                      if (!chart.styledMode && series.options.cursor) {
                        series[key].css({ cursor: series.options.cursor });
                      }
                    }
                  });
                  series._hasTracking = true;
                }
                fireEvent(this, "afterDrawTracker");
              };
              ColumnSeries2.prototype.remove = function() {
                var series = this, chart = series.chart;
                if (chart.hasRendered) {
                  chart.series.forEach(function(otherSeries) {
                    if (otherSeries.type === series.type) {
                      otherSeries.isDirty = true;
                    }
                  });
                }
                Series.prototype.remove.apply(series, arguments);
              };
              ColumnSeries2.defaultOptions = merge(Series.defaultOptions, ColumnSeriesDefaults);
              return ColumnSeries2;
            }(Series)
          );
          extend2(ColumnSeries.prototype, {
            cropShoulder: 0,
            // When tooltip is not shared, this series (and derivatives) requires
            // direct touch/hover. KD-tree does not apply.
            directTouch: true,
            /**
             * Use a solid rectangle like the area series types
             *
             * @private
             * @function Highcharts.seriesTypes.column#drawLegendSymbol
             *
             * @param {Highcharts.Legend} legend
             *        The legend object
             *
             * @param {Highcharts.Series|Highcharts.Point} item
             *        The series (this) or point
             */
            drawLegendSymbol: LegendSymbol.drawRectangle,
            getSymbol: noop2,
            // use separate negative stacks, unlike area stacks where a negative
            // point is substracted from previous (#1910)
            negStacks: true,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          SeriesRegistry.registerSeriesType("column", ColumnSeries);
          "";
          return ColumnSeries;
        });
        _registerModule(_modules, "Core/Series/DataLabel.js", [_modules["Core/Animation/AnimationUtilities.js"], _modules["Core/FormatUtilities.js"], _modules["Core/Utilities.js"]], function(A, F, U) {
          var getDeferredAnimation = A.getDeferredAnimation;
          var format3 = F.format;
          var defined = U.defined, extend2 = U.extend, fireEvent = U.fireEvent, isArray = U.isArray, isString = U.isString, merge = U.merge, objectEach = U.objectEach, pick = U.pick, splat = U.splat;
          var DataLabel;
          (function(DataLabel2) {
            var composedClasses = [];
            function alignDataLabel(point, dataLabel, options, alignTo, isNew) {
              var series = this, chart = this.chart, inverted = this.isCartesian && chart.inverted, enabledDataSorting = this.enabledDataSorting, plotX = point.plotX, plotY = point.plotY, rotation = options.rotation, align = options.align, isInsidePlot = defined(plotX) && defined(plotY) && chart.isInsidePlot(
                plotX,
                Math.round(plotY),
                {
                  inverted,
                  paneCoordinates: true,
                  series
                }
              ), setStartPos = function(alignOptions) {
                if (enabledDataSorting && series.xAxis && !justify) {
                  series.setDataLabelStartPos(
                    point,
                    dataLabel,
                    isNew,
                    isInsidePlot,
                    alignOptions
                  );
                }
              };
              var baseline, rotCorr, alignAttr, justify = pick(options.overflow, enabledDataSorting ? "none" : "justify") === "justify", visible = this.visible && point.visible !== false && defined(plotX) && (point.series.forceDL || enabledDataSorting && !justify || isInsidePlot || // If the data label is inside the align box, it is
              // enough that parts of the align box is inside the
              // plot area (#12370). When stacking, it is always
              // inside regardless of the option (#15148).
              pick(options.inside, !!this.options.stacking) && alignTo && chart.isInsidePlot(plotX, inverted ? alignTo.x + 1 : alignTo.y + alignTo.height - 1, {
                inverted,
                paneCoordinates: true,
                series
              }));
              var pos = point.pos();
              if (visible && pos) {
                if (rotation) {
                  dataLabel.attr({ align });
                }
                var bBox = dataLabel.getBBox(true), bBoxCorrection = [0, 0];
                baseline = chart.renderer.fontMetrics(chart.styledMode ? void 0 : options.style.fontSize, dataLabel).b;
                alignTo = extend2({
                  x: pos[0],
                  y: Math.round(pos[1]),
                  width: 0,
                  height: 0
                }, alignTo);
                extend2(options, {
                  width: bBox.width,
                  height: bBox.height
                });
                if (rotation) {
                  justify = false;
                  rotCorr = chart.renderer.rotCorr(baseline, rotation);
                  alignAttr = {
                    x: alignTo.x + (options.x || 0) + alignTo.width / 2 + rotCorr.x,
                    y: alignTo.y + (options.y || 0) + { top: 0, middle: 0.5, bottom: 1 }[options.verticalAlign] * alignTo.height
                  };
                  bBoxCorrection = [
                    bBox.x - Number(dataLabel.attr("x")),
                    bBox.y - Number(dataLabel.attr("y"))
                  ];
                  setStartPos(alignAttr);
                  dataLabel[isNew ? "attr" : "animate"](alignAttr);
                } else {
                  setStartPos(alignTo);
                  dataLabel.align(options, void 0, alignTo);
                  alignAttr = dataLabel.alignAttr;
                }
                if (justify && alignTo.height >= 0) {
                  this.justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew);
                } else if (pick(options.crop, true)) {
                  var x = alignAttr.x, y = alignAttr.y;
                  x += bBoxCorrection[0];
                  y += bBoxCorrection[1];
                  visible = chart.isInsidePlot(x, y, {
                    paneCoordinates: true,
                    series
                  }) && chart.isInsidePlot(x + bBox.width, y + bBox.height, {
                    paneCoordinates: true,
                    series
                  });
                }
                if (options.shape && !rotation) {
                  dataLabel[isNew ? "attr" : "animate"]({
                    anchorX: pos[0],
                    anchorY: pos[1]
                  });
                }
              }
              if (isNew && enabledDataSorting) {
                dataLabel.placed = false;
              }
              if (!visible && (!enabledDataSorting || justify)) {
                dataLabel.hide();
                dataLabel.placed = false;
              } else {
                dataLabel.show();
              }
            }
            function applyFilter(point, options) {
              var filter2 = options.filter;
              if (filter2) {
                var op = filter2.operator;
                var prop = point[filter2.property];
                var val = filter2.value;
                if (op === ">" && prop > val || op === "<" && prop < val || op === ">=" && prop >= val || op === "<=" && prop <= val || op === "==" && prop == val || // eslint-disable-line eqeqeq
                op === "===" && prop === val) {
                  return true;
                }
                return false;
              }
              return true;
            }
            function compose(SeriesClass) {
              if (composedClasses.indexOf(SeriesClass) === -1) {
                var seriesProto = SeriesClass.prototype;
                composedClasses.push(SeriesClass);
                seriesProto.alignDataLabel = alignDataLabel;
                seriesProto.drawDataLabels = drawDataLabels;
                seriesProto.justifyDataLabel = justifyDataLabel;
                seriesProto.setDataLabelStartPos = setDataLabelStartPos;
              }
            }
            DataLabel2.compose = compose;
            function drawDataLabels(points) {
              if (points === void 0) {
                points = this.points;
              }
              var series = this, chart = series.chart, seriesOptions = series.options, hasRendered = series.hasRendered || 0, renderer = chart.renderer, _a = chart.options.chart, backgroundColor = _a.backgroundColor, plotBackgroundColor = _a.plotBackgroundColor, contrastColor = renderer.getContrast(
                isString(plotBackgroundColor) && plotBackgroundColor || isString(backgroundColor) && backgroundColor || "#000000"
                /* Palette.neutralColor100 */
              );
              var seriesDlOptions = seriesOptions.dataLabels, pointOptions, dataLabelsGroup;
              var dataLabelAnim = seriesDlOptions.animation, animationConfig = seriesDlOptions.defer ? getDeferredAnimation(
                chart,
                dataLabelAnim,
                series
              ) : {
                defer: 0,
                duration: 0
              };
              seriesDlOptions = mergeArrays(mergeArrays(chart.options.plotOptions && chart.options.plotOptions.series && chart.options.plotOptions.series.dataLabels, chart.options.plotOptions && chart.options.plotOptions[series.type] && chart.options.plotOptions[series.type].dataLabels), seriesDlOptions);
              fireEvent(this, "drawDataLabels");
              if (isArray(seriesDlOptions) || seriesDlOptions.enabled || series._hasPointLabels) {
                dataLabelsGroup = series.plotGroup(
                  "dataLabelsGroup",
                  "data-labels",
                  !hasRendered ? "hidden" : "inherit",
                  // #5133, #10220
                  seriesDlOptions.zIndex || 6
                );
                dataLabelsGroup.attr({ opacity: +hasRendered });
                if (!hasRendered) {
                  var group = series.dataLabelsGroup;
                  if (group) {
                    if (series.visible) {
                      dataLabelsGroup.show();
                    }
                    group[seriesOptions.animation ? "animate" : "attr"]({ opacity: 1 }, animationConfig);
                  }
                }
                points.forEach(function(point) {
                  pointOptions = splat(mergeArrays(
                    seriesDlOptions,
                    // dlOptions is used in treemaps
                    point.dlOptions || point.options && point.options.dataLabels
                  ));
                  pointOptions.forEach(function(labelOptions, i) {
                    var labelEnabled = labelOptions.enabled && // #2282, #4641, #7112, #10049
                    (!point.isNull || point.dataLabelOnNull) && applyFilter(
                      point,
                      labelOptions
                    ), connector = point.connectors ? point.connectors[i] : point.connector;
                    var labelConfig, formatString, labelText, style, rotation, attr, dataLabel = point.dataLabels ? point.dataLabels[i] : point.dataLabel, isNew = !dataLabel;
                    var labelDistance = pick(
                      labelOptions.distance,
                      point.labelDistance
                    );
                    if (labelEnabled) {
                      labelConfig = point.getLabelConfig();
                      formatString = pick(labelOptions[point.formatPrefix + "Format"], labelOptions.format);
                      labelText = defined(formatString) ? format3(formatString, labelConfig, chart) : (labelOptions[point.formatPrefix + "Formatter"] || labelOptions.formatter).call(labelConfig, labelOptions);
                      style = labelOptions.style;
                      rotation = labelOptions.rotation;
                      if (!chart.styledMode) {
                        style.color = pick(
                          labelOptions.color,
                          style.color,
                          series.color,
                          "#000000"
                          /* Palette.neutralColor100 */
                        );
                        if (style.color === "contrast") {
                          point.contrastColor = renderer.getContrast(point.color || series.color);
                          style.color = !defined(labelDistance) && labelOptions.inside || labelDistance < 0 || !!seriesOptions.stacking ? point.contrastColor : contrastColor;
                        } else {
                          delete point.contrastColor;
                        }
                        if (seriesOptions.cursor) {
                          style.cursor = seriesOptions.cursor;
                        }
                      }
                      attr = {
                        r: labelOptions.borderRadius || 0,
                        rotation,
                        padding: labelOptions.padding,
                        zIndex: 1
                      };
                      if (!chart.styledMode) {
                        var backgroundColor_1 = labelOptions.backgroundColor, borderColor = labelOptions.borderColor;
                        attr.fill = backgroundColor_1 === "auto" ? point.color : backgroundColor_1;
                        attr.stroke = borderColor === "auto" ? point.color : borderColor;
                        attr["stroke-width"] = labelOptions.borderWidth;
                      }
                      objectEach(attr, function(val, name) {
                        if (typeof val === "undefined") {
                          delete attr[name];
                        }
                      });
                    }
                    if (dataLabel && (!labelEnabled || !defined(labelText) || !!dataLabel.div !== !!labelOptions.useHTML || // Change from no rotation to rotation and
                    // vice versa. Don't use defined() because
                    // rotation = 0 means also rotation = undefined
                    (!dataLabel.rotation || !labelOptions.rotation) && dataLabel.rotation !== labelOptions.rotation)) {
                      isNew = true;
                      point.dataLabel = dataLabel = point.dataLabel && point.dataLabel.destroy();
                      if (point.dataLabels) {
                        if (point.dataLabels.length === 1) {
                          delete point.dataLabels;
                        } else {
                          delete point.dataLabels[i];
                        }
                      }
                      if (!i) {
                        delete point.dataLabel;
                      }
                      if (connector) {
                        point.connector = point.connector.destroy();
                        if (point.connectors) {
                          if (point.connectors.length === 1) {
                            delete point.connectors;
                          } else {
                            delete point.connectors[i];
                          }
                        }
                      }
                    }
                    if (labelEnabled && defined(labelText)) {
                      if (!dataLabel) {
                        point.dataLabels = point.dataLabels || [];
                        dataLabel = point.dataLabels[i] = rotation ? (
                          // Labels don't rotate, use text element
                          renderer.text(labelText, 0, 0, labelOptions.useHTML).addClass("highcharts-data-label")
                        ) : (
                          // We can use label
                          renderer.label(labelText, 0, 0, labelOptions.shape, null, null, labelOptions.useHTML, null, "data-label")
                        );
                        if (!i) {
                          point.dataLabel = dataLabel;
                        }
                        dataLabel.addClass(" highcharts-data-label-color-" + point.colorIndex + " " + (labelOptions.className || "") + // #3398
                        (labelOptions.useHTML ? " highcharts-tracker" : ""));
                      } else {
                        attr.text = labelText;
                      }
                      dataLabel.options = labelOptions;
                      dataLabel.attr(attr);
                      if (!chart.styledMode) {
                        dataLabel.css(style).shadow(labelOptions.shadow);
                      }
                      var textPathOptions = labelOptions[point.formatPrefix + "TextPath"] || labelOptions.textPath;
                      if (textPathOptions && !labelOptions.useHTML) {
                        dataLabel.setTextPath(point.getDataLabelPath && point.getDataLabelPath(dataLabel) || point.graphic, textPathOptions);
                        if (point.dataLabelPath && !textPathOptions.enabled) {
                          point.dataLabelPath = point.dataLabelPath.destroy();
                        }
                      }
                      if (!dataLabel.added) {
                        dataLabel.add(dataLabelsGroup);
                      }
                      series.alignDataLabel(point, dataLabel, labelOptions, null, isNew);
                    } else if (dataLabel) {
                      dataLabel.hide();
                    }
                  });
                });
              }
              fireEvent(this, "afterDrawDataLabels");
            }
            function justifyDataLabel(dataLabel, options, alignAttr, bBox, alignTo, isNew) {
              var chart = this.chart, align = options.align, verticalAlign = options.verticalAlign, padding = dataLabel.box ? 0 : dataLabel.padding || 0;
              var _a = options.x, x = _a === void 0 ? 0 : _a, _b = options.y, y = _b === void 0 ? 0 : _b, off, justified;
              off = (alignAttr.x || 0) + padding;
              if (off < 0) {
                if (align === "right" && x >= 0) {
                  options.align = "left";
                  options.inside = true;
                } else {
                  x -= off;
                }
                justified = true;
              }
              off = (alignAttr.x || 0) + bBox.width - padding;
              if (off > chart.plotWidth) {
                if (align === "left" && x <= 0) {
                  options.align = "right";
                  options.inside = true;
                } else {
                  x += chart.plotWidth - off;
                }
                justified = true;
              }
              off = alignAttr.y + padding;
              if (off < 0) {
                if (verticalAlign === "bottom" && y >= 0) {
                  options.verticalAlign = "top";
                  options.inside = true;
                } else {
                  y -= off;
                }
                justified = true;
              }
              off = (alignAttr.y || 0) + bBox.height - padding;
              if (off > chart.plotHeight) {
                if (verticalAlign === "top" && y <= 0) {
                  options.verticalAlign = "bottom";
                  options.inside = true;
                } else {
                  y += chart.plotHeight - off;
                }
                justified = true;
              }
              if (justified) {
                options.x = x;
                options.y = y;
                dataLabel.placed = !isNew;
                dataLabel.align(options, void 0, alignTo);
              }
              return justified;
            }
            function mergeArrays(one2, two) {
              var res = [], i;
              if (isArray(one2) && !isArray(two)) {
                res = one2.map(function(el) {
                  return merge(el, two);
                });
              } else if (isArray(two) && !isArray(one2)) {
                res = two.map(function(el) {
                  return merge(one2, el);
                });
              } else if (!isArray(one2) && !isArray(two)) {
                res = merge(one2, two);
              } else {
                i = Math.max(one2.length, two.length);
                while (i--) {
                  res[i] = merge(one2[i], two[i]);
                }
              }
              return res;
            }
            function setDataLabelStartPos(point, dataLabel, isNew, isInside, alignOptions) {
              var chart = this.chart, inverted = chart.inverted, xAxis = this.xAxis, reversed = xAxis.reversed, labelCenter = inverted ? dataLabel.height / 2 : dataLabel.width / 2, pointWidth = point.pointWidth, halfWidth = pointWidth ? pointWidth / 2 : 0;
              dataLabel.startXPos = inverted ? alignOptions.x : reversed ? -labelCenter - halfWidth : xAxis.width - labelCenter + halfWidth;
              dataLabel.startYPos = inverted ? reversed ? this.yAxis.height - labelCenter + halfWidth : -labelCenter - halfWidth : alignOptions.y;
              if (!isInside) {
                dataLabel.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, dataLabel.hide);
              } else if (dataLabel.visibility === "hidden") {
                dataLabel.show();
                dataLabel.attr({ opacity: 0 }).animate({ opacity: 1 });
              }
              if (!chart.hasRendered) {
                return;
              }
              if (isNew) {
                dataLabel.attr({ x: dataLabel.startXPos, y: dataLabel.startYPos });
              }
              dataLabel.placed = true;
            }
          })(DataLabel || (DataLabel = {}));
          "";
          return DataLabel;
        });
        _registerModule(_modules, "Series/Column/ColumnDataLabel.js", [_modules["Core/Series/DataLabel.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(DataLabel, SeriesRegistry, U) {
          var Series = SeriesRegistry.series;
          var merge = U.merge, pick = U.pick;
          var ColumnDataLabel;
          (function(ColumnDataLabel2) {
            var composedClasses = [];
            function alignDataLabel(point, dataLabel, options, alignTo, isNew) {
              var inverted = this.chart.inverted, series = point.series, xLen = (series.xAxis ? series.xAxis.len : this.chart.plotSizeX) || 0, yLen = (series.yAxis ? series.yAxis.len : this.chart.plotSizeY) || 0, dlBox = point.dlBox || point.shapeArgs, below = pick(
                point.below,
                // range series
                point.plotY > pick(
                  this.translatedThreshold,
                  yLen
                )
              ), inside = pick(options.inside, !!this.options.stacking), overshoot;
              if (dlBox) {
                alignTo = merge(dlBox);
                if (alignTo.y < 0) {
                  alignTo.height += alignTo.y;
                  alignTo.y = 0;
                }
                overshoot = alignTo.y + alignTo.height - yLen;
                if (overshoot > 0 && overshoot < alignTo.height) {
                  alignTo.height -= overshoot;
                }
                if (inverted) {
                  alignTo = {
                    x: yLen - alignTo.y - alignTo.height,
                    y: xLen - alignTo.x - alignTo.width,
                    width: alignTo.height,
                    height: alignTo.width
                  };
                }
                if (!inside) {
                  if (inverted) {
                    alignTo.x += below ? 0 : alignTo.width;
                    alignTo.width = 0;
                  } else {
                    alignTo.y += below ? alignTo.height : 0;
                    alignTo.height = 0;
                  }
                }
              }
              options.align = pick(options.align, !inverted || inside ? "center" : below ? "right" : "left");
              options.verticalAlign = pick(options.verticalAlign, inverted || inside ? "middle" : below ? "top" : "bottom");
              Series.prototype.alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
              if (options.inside && point.contrastColor) {
                dataLabel.css({
                  color: point.contrastColor
                });
              }
            }
            function compose(ColumnSeriesClass) {
              DataLabel.compose(Series);
              if (composedClasses.indexOf(ColumnSeriesClass) === -1) {
                composedClasses.push(ColumnSeriesClass);
                ColumnSeriesClass.prototype.alignDataLabel = alignDataLabel;
              }
            }
            ColumnDataLabel2.compose = compose;
          })(ColumnDataLabel || (ColumnDataLabel = {}));
          return ColumnDataLabel;
        });
        _registerModule(_modules, "Series/Bar/BarSeries.js", [_modules["Series/Column/ColumnSeries.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(ColumnSeries, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var extend2 = U.extend, merge = U.merge;
          var BarSeries = (
            /** @class */
            function(_super) {
              __extends(BarSeries2, _super);
              function BarSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.data = void 0;
                _this.options = void 0;
                _this.points = void 0;
                return _this;
              }
              BarSeries2.defaultOptions = merge(ColumnSeries.defaultOptions, {
                // nothing here yet
              });
              return BarSeries2;
            }(ColumnSeries)
          );
          extend2(BarSeries.prototype, {
            inverted: true
          });
          SeriesRegistry.registerSeriesType("bar", BarSeries);
          "";
          return BarSeries;
        });
        _registerModule(_modules, "Series/Scatter/ScatterSeriesDefaults.js", [], function() {
          var ScatterSeriesDefaults = {
            /**
             * The width of the line connecting the data points.
             *
             * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-none/
             *         0 by default
             * @sample {highcharts} highcharts/plotoptions/scatter-linewidth-1/
             *         1px
             *
             * @product highcharts highstock
             */
            lineWidth: 0,
            findNearestPointBy: "xy",
            /**
                 * Apply a jitter effect for the rendered markers. When plotting
                 * discrete values,
            a little random noise may help telling the points
                 * apart. The jitter setting applies a random displacement of up to `n`
                 * axis units in either direction. So for example on a horizontal X
                 * axis,
            setting the `jitter.x` to 0.24 will render the point in a
                 * random position between 0.24 units to the left and 0.24 units to the
                 * right of the true axis position. On a category axis,
            setting it to
                 * 0.5 will fill up the bin and make the data appear continuous.
                 *
                 * When rendered on top of a box plot or a column series,
            a jitter value
                 * of 0.24 will correspond to the underlying series' default
                 * [groupPadding](
                 * https://api.highcharts.com/highcharts/plotOptions.column.groupPadding)
                 * and [pointPadding](
                 * https://api.highcharts.com/highcharts/plotOptions.column.pointPadding)
                 * settings.
                 *
                 * @sample {highcharts} highcharts/demo/scatter-jitter
                 *         Jitter on a scatter plot
                 *
                 * @sample {highcharts} highcharts/series-scatter/jitter-boxplot
                 *         Jittered scatter plot on top of a box plot
                 *
                 * @product highcharts highstock
                 * @since 7.0.2
                 */
            jitter: {
              /**
               * The maximal X offset for the random jitter effect.
               */
              x: 0,
              /**
               * The maximal Y offset for the random jitter effect.
               */
              y: 0
            },
            marker: {
              enabled: true
              // Overrides auto-enabling in line series (#3647)
            },
            /**
                 * Sticky tracking of mouse events. When true,
            the `mouseOut` event
                 * on a series isn't triggered until the mouse moves over another
                 * series,
            or out of the plot area. When false,
            the `mouseOut` event on
                 * a series is triggered when the mouse leaves the area around the
                 * series' graph or markers. This also implies the tooltip. When
                 * `stickyTracking` is false and `tooltip.shared` is false,
            the tooltip
                 * will be hidden when moving the mouse between series.
                 *
                 * @type      {boolean}
                 * @default   false
                 * @product   highcharts highstock highmaps
                 * @apioption plotOptions.scatter.stickyTracking
                 */
            /**
                 * A configuration object for the tooltip rendering of each single
                 * series. Properties are inherited from [tooltip](#tooltip).
                 * Overridable properties are `headerFormat`,
            `pointFormat`,
                 * `yDecimals`,
            `xDateFormat`,
            `yPrefix` and `ySuffix`. Unlike other
                 * series,
            in a scatter plot the series.name by default shows in the
                 * headerFormat and point.x and point.y in the pointFormat.
                 *
                 * @product highcharts highstock highmaps
                 */
            tooltip: {
              /**
               * @product highcharts highstock
               */
              headerFormat: '<span style="color:{point.color}">\u25CF</span> <span style="font-size: 10px"> {series.name}</span><br/>',
              pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"
            }
          };
          "";
          return ScatterSeriesDefaults;
        });
        _registerModule(_modules, "Series/Scatter/ScatterSeries.js", [_modules["Series/Scatter/ScatterSeriesDefaults.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(ScatterSeriesDefaults, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var _a = SeriesRegistry.seriesTypes, ColumnSeries = _a.column, LineSeries = _a.line;
          var addEvent = U.addEvent, extend2 = U.extend, merge = U.merge;
          var ScatterSeries = (
            /** @class */
            function(_super) {
              __extends(ScatterSeries2, _super);
              function ScatterSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.data = void 0;
                _this.options = void 0;
                _this.points = void 0;
                return _this;
              }
              ScatterSeries2.prototype.applyJitter = function() {
                var series = this, jitter = this.options.jitter, len = this.points.length;
                function unrandom(seed) {
                  var rand = Math.sin(seed) * 1e4;
                  return rand - Math.floor(rand);
                }
                if (jitter) {
                  this.points.forEach(function(point, i) {
                    ["x", "y"].forEach(function(dim, j) {
                      var axis, plotProp = "plot" + dim.toUpperCase(), min2, max2, translatedJitter;
                      if (jitter[dim] && !point.isNull) {
                        axis = series[dim + "Axis"];
                        translatedJitter = jitter[dim] * axis.transA;
                        if (axis && !axis.isLog) {
                          min2 = Math.max(0, point[plotProp] - translatedJitter);
                          max2 = Math.min(axis.len, point[plotProp] + translatedJitter);
                          point[plotProp] = min2 + (max2 - min2) * unrandom(i + j * len);
                          if (dim === "x") {
                            point.clientX = point.plotX;
                          }
                        }
                      }
                    });
                  });
                }
              };
              ScatterSeries2.prototype.drawGraph = function() {
                if (this.options.lineWidth) {
                  _super.prototype.drawGraph.call(this);
                } else if (this.graph) {
                  this.graph = this.graph.destroy();
                }
              };
              ScatterSeries2.defaultOptions = merge(LineSeries.defaultOptions, ScatterSeriesDefaults);
              return ScatterSeries2;
            }(LineSeries)
          );
          extend2(ScatterSeries.prototype, {
            drawTracker: ColumnSeries.prototype.drawTracker,
            sorted: false,
            requireSorting: false,
            noSharedTooltip: true,
            trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
            takeOrdinalPosition: false
            // #2342
          });
          addEvent(ScatterSeries, "afterTranslate", function() {
            this.applyJitter();
          });
          SeriesRegistry.registerSeriesType("scatter", ScatterSeries);
          return ScatterSeries;
        });
        _registerModule(_modules, "Series/CenteredUtilities.js", [_modules["Core/Globals.js"], _modules["Core/Series/Series.js"], _modules["Core/Utilities.js"]], function(H, Series, U) {
          var deg2rad = H.deg2rad;
          var fireEvent = U.fireEvent, isNumber = U.isNumber, pick = U.pick, relativeLength = U.relativeLength;
          var CenteredUtilities;
          (function(CenteredUtilities2) {
            function getCenter() {
              var options = this.options, chart = this.chart, slicingRoom = 2 * (options.slicedOffset || 0), plotWidth = chart.plotWidth - 2 * slicingRoom, plotHeight = chart.plotHeight - 2 * slicingRoom, centerOption = options.center, smallestSize = Math.min(
                plotWidth,
                plotHeight
              ), thickness = options.thickness;
              var handleSlicingRoom, size = options.size, innerSize = options.innerSize || 0, i, value;
              if (typeof size === "string") {
                size = parseFloat(size);
              }
              if (typeof innerSize === "string") {
                innerSize = parseFloat(innerSize);
              }
              var positions = [
                pick(centerOption[0], "50%"),
                pick(centerOption[1], "50%"),
                // Prevent from negative values
                pick(size && size < 0 ? void 0 : options.size, "100%"),
                pick(innerSize && innerSize < 0 ? void 0 : options.innerSize || 0, "0%")
              ];
              if (chart.angular && !(this instanceof Series)) {
                positions[3] = 0;
              }
              for (i = 0; i < 4; ++i) {
                value = positions[i];
                handleSlicingRoom = i < 2 || i === 2 && /%$/.test(value);
                positions[i] = relativeLength(value, [plotWidth, plotHeight, smallestSize, positions[2]][i]) + (handleSlicingRoom ? slicingRoom : 0);
              }
              if (positions[3] > positions[2]) {
                positions[3] = positions[2];
              }
              if (isNumber(thickness) && thickness * 2 < positions[2] && thickness > 0) {
                positions[3] = positions[2] - thickness * 2;
              }
              fireEvent(this, "afterGetCenter", { positions });
              return positions;
            }
            CenteredUtilities2.getCenter = getCenter;
            function getStartAndEndRadians(start2, end) {
              var startAngle = isNumber(start2) ? start2 : 0, endAngle = isNumber(end) && // must be a number
              end > startAngle && // must be larger than the start angle
              // difference must be less than 360 degrees
              end - startAngle < 360 ? end : startAngle + 360, correction = -90;
              return {
                start: deg2rad * (startAngle + correction),
                end: deg2rad * (endAngle + correction)
              };
            }
            CenteredUtilities2.getStartAndEndRadians = getStartAndEndRadians;
          })(CenteredUtilities || (CenteredUtilities = {}));
          "";
          return CenteredUtilities;
        });
        _registerModule(_modules, "Series/Pie/PiePoint.js", [_modules["Core/Animation/AnimationUtilities.js"], _modules["Core/Series/Point.js"], _modules["Core/Utilities.js"]], function(A, Point, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var setAnimation = A.setAnimation;
          var addEvent = U.addEvent, defined = U.defined, extend2 = U.extend, isNumber = U.isNumber, pick = U.pick, relativeLength = U.relativeLength;
          var PiePoint = (
            /** @class */
            function(_super) {
              __extends(PiePoint2, _super);
              function PiePoint2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.labelDistance = void 0;
                _this.options = void 0;
                _this.series = void 0;
                return _this;
              }
              PiePoint2.prototype.getConnectorPath = function() {
                var labelPosition = this.labelPosition, options = this.series.options.dataLabels, predefinedShapes = this.connectorShapes;
                var connectorShape = options.connectorShape;
                if (predefinedShapes[connectorShape]) {
                  connectorShape = predefinedShapes[connectorShape];
                }
                return connectorShape.call(this, {
                  // pass simplified label position object for user's convenience
                  x: labelPosition.final.x,
                  y: labelPosition.final.y,
                  alignment: labelPosition.alignment
                }, labelPosition.connectorPosition, options);
              };
              PiePoint2.prototype.getTranslate = function() {
                return this.sliced ? this.slicedTranslation : {
                  translateX: 0,
                  translateY: 0
                };
              };
              PiePoint2.prototype.haloPath = function(size) {
                var shapeArgs = this.shapeArgs;
                return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(shapeArgs.x, shapeArgs.y, shapeArgs.r + size, shapeArgs.r + size, {
                  // Substract 1px to ensure the background is not bleeding
                  // through between the halo and the slice (#7495).
                  innerR: shapeArgs.r - 1,
                  start: shapeArgs.start,
                  end: shapeArgs.end
                });
              };
              PiePoint2.prototype.init = function() {
                var _this = this;
                _super.prototype.init.apply(this, arguments);
                this.name = pick(this.name, "Slice");
                var toggleSlice = function(e) {
                  _this.slice(e.type === "select");
                };
                addEvent(this, "select", toggleSlice);
                addEvent(this, "unselect", toggleSlice);
                return this;
              };
              PiePoint2.prototype.isValid = function() {
                return isNumber(this.y) && this.y >= 0;
              };
              PiePoint2.prototype.setVisible = function(vis, redraw) {
                var _this = this;
                var series = this.series, chart = series.chart, ignoreHiddenPoint = series.options.ignoreHiddenPoint;
                redraw = pick(redraw, ignoreHiddenPoint);
                if (vis !== this.visible) {
                  this.visible = this.options.visible = vis = typeof vis === "undefined" ? !this.visible : vis;
                  series.options.data[series.data.indexOf(this)] = this.options;
                  ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function(key) {
                    if (_this[key]) {
                      _this[key][vis ? "show" : "hide"](vis);
                    }
                  });
                  if (this.legendItem) {
                    chart.legend.colorizeItem(this, vis);
                  }
                  if (!vis && this.state === "hover") {
                    this.setState("");
                  }
                  if (ignoreHiddenPoint) {
                    series.isDirty = true;
                  }
                  if (redraw) {
                    chart.redraw();
                  }
                }
              };
              PiePoint2.prototype.slice = function(sliced, redraw, animation) {
                var series = this.series, chart = series.chart;
                setAnimation(animation, chart);
                redraw = pick(redraw, true);
                this.sliced = this.options.sliced = sliced = defined(sliced) ? sliced : !this.sliced;
                series.options.data[series.data.indexOf(this)] = this.options;
                if (this.graphic) {
                  this.graphic.animate(this.getTranslate());
                }
                if (this.shadowGroup) {
                  this.shadowGroup.animate(this.getTranslate());
                }
              };
              return PiePoint2;
            }(Point)
          );
          extend2(PiePoint.prototype, {
            connectorShapes: {
              // only one available before v7.0.0
              fixedOffset: function(labelPosition, connectorPosition, options) {
                var breakAt = connectorPosition.breakAt, touchingSliceAt = connectorPosition.touchingSliceAt, lineSegment = options.softConnector ? [
                  "C",
                  // 1st control point (of the curve)
                  labelPosition.x + // 5 gives the connector a little horizontal bend
                  (labelPosition.alignment === "left" ? -5 : 5),
                  labelPosition.y,
                  2 * breakAt.x - touchingSliceAt.x,
                  2 * breakAt.y - touchingSliceAt.y,
                  breakAt.x,
                  breakAt.y
                  //
                ] : [
                  "L",
                  breakAt.x,
                  breakAt.y
                ];
                return [
                  ["M", labelPosition.x, labelPosition.y],
                  lineSegment,
                  ["L", touchingSliceAt.x, touchingSliceAt.y]
                ];
              },
              straight: function(labelPosition, connectorPosition) {
                var touchingSliceAt = connectorPosition.touchingSliceAt;
                return [
                  ["M", labelPosition.x, labelPosition.y],
                  ["L", touchingSliceAt.x, touchingSliceAt.y]
                ];
              },
              crookedLine: function(labelPosition, connectorPosition, options) {
                var touchingSliceAt = connectorPosition.touchingSliceAt, series = this.series, pieCenterX = series.center[0], plotWidth = series.chart.plotWidth, plotLeft = series.chart.plotLeft, alignment = labelPosition.alignment, radius = this.shapeArgs.r, crookDistance = relativeLength(
                  // % to fraction
                  options.crookDistance,
                  1
                ), crookX = alignment === "left" ? pieCenterX + radius + (plotWidth + plotLeft - pieCenterX - radius) * (1 - crookDistance) : plotLeft + (pieCenterX - radius) * crookDistance, segmentWithCrook = [
                  "L",
                  crookX,
                  labelPosition.y
                ];
                var useCrook = true;
                if (alignment === "left" ? crookX > labelPosition.x || crookX < touchingSliceAt.x : crookX < labelPosition.x || crookX > touchingSliceAt.x) {
                  useCrook = false;
                }
                var path = [[
                  "M",
                  labelPosition.x,
                  labelPosition.y
                ]];
                if (useCrook) {
                  path.push(segmentWithCrook);
                }
                path.push(["L", touchingSliceAt.x, touchingSliceAt.y]);
                return path;
              }
            }
          });
          return PiePoint;
        });
        _registerModule(_modules, "Series/Pie/PieSeriesDefaults.js", [], function() {
          var PieSeriesDefaults = {
            /**
             * @excluding legendItemClick
             * @apioption plotOptions.pie.events
             */
            /**
             * Fires when the checkbox next to the point name in the legend is
             * clicked. One parameter, event, is passed to the function. The state
             * of the checkbox is found by event.checked. The checked item is found
             * by event.item. Return false to prevent the default action which is to
             * toggle the select state of the series.
             *
             * @sample {highcharts} highcharts/plotoptions/series-events-checkboxclick/
             *         Alert checkbox status
             *
             * @type      {Function}
             * @since     1.2.0
             * @product   highcharts highmaps
             * @context   Highcharts.Point
             * @apioption plotOptions.pie.events.checkboxClick
             */
            /**
             * Fires when the legend item belonging to the pie point (slice) is
             * clicked. The `this` keyword refers to the point itself. One
             * parameter, `event`, is passed to the function, containing common
             * event information. The default action is to toggle the visibility of
             * the point. This can be prevented by calling `event.preventDefault()`.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-point-events-legenditemclick/
             *         Confirm toggle visibility
             *
             * @type      {Highcharts.PointLegendItemClickCallbackFunction}
             * @since     1.2.0
             * @product   highcharts highmaps
             * @apioption plotOptions.pie.point.events.legendItemClick
             */
            /**
             * The center of the pie chart relative to the plot area. Can be
             * percentages or pixel values. The default behaviour (as of 3.0) is to
             * center the pie so that all slices and data labels are within the plot
             * area. As a consequence, the pie may actually jump around in a chart
             * with dynamic values, as the data labels move. In that case, the
             * center should be explicitly set, for example to `["50%", "50%"]`.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-center/
             *         Centered at 100, 100
             *
             * @type    {Array<(number|string|null),(number|string|null)>}
             * @default [null, null]
             * @product highcharts highmaps
             *
             * @private
             */
            center: [null, null],
            /**
             * The color of the pie series. A pie series is represented as an empty
             * circle if the total sum of its values is 0. Use this property to
             * define the color of its border.
             *
             * In styled mode, the color can be defined by the
             * [colorIndex](#plotOptions.series.colorIndex) option. Also, the series
             * color can be set with the `.highcharts-series`,
             * `.highcharts-color-{n}`, `.highcharts-{type}-series` or
             * `.highcharts-series-{n}` class, or individual classes given by the
             * `className` option.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-emptyseries/
             *         Empty pie series
             *
             * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @default   #cccccc
             * @apioption plotOptions.pie.color
             */
            /**
             * @product highcharts
             *
             * @private
             */
            clip: false,
            /**
             * @ignore-option
             *
             * @private
             */
            colorByPoint: true,
            /**
             * A series specific or series type specific color set to use instead
             * of the global [colors](#colors).
             *
             * @sample {highcharts} highcharts/demo/pie-monochrome/
             *         Set default colors for all pies
             *
             * @type      {Array<Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject>}
             * @since     3.0
             * @product   highcharts highmaps
             * @apioption plotOptions.pie.colors
             */
            /**
             * @declare   Highcharts.SeriesPieDataLabelsOptionsObject
             * @extends   plotOptions.series.dataLabels
             * @excluding align, allowOverlap, inside, staggerLines, step
             * @private
             */
            dataLabels: {
              /**
               * Alignment method for data labels. Possible values are:
               *
               * - `plotEdges`: Each label touches the nearest vertical edge of
               *   the plot area.
               *
               * - `connectors`: Connectors have the same x position and the
               *   widest label of each half (left & right) touches the nearest
               *   vertical edge of the plot area.
               *
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-alignto-connectors/
               *         alignTo: connectors
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-alignto-plotedges/
               *         alignTo: plotEdges
               *
               * @type      {string}
               * @since     7.0.0
               * @product   highcharts highmaps
               * @apioption plotOptions.pie.dataLabels.alignTo
               */
              allowOverlap: true,
              /**
               * The color of the line connecting the data label to the pie slice.
               * The default color is the same as the point's color.
               *
               * In styled mode, the connector stroke is given in the
               * `.highcharts-data-label-connector` class.
               *
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorcolor/
               *         Blue connectors
               * @sample {highcharts} highcharts/css/pie-point/
               *         Styled connectors
               *
               * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               * @since     2.1
               * @product   highcharts highmaps
               * @apioption plotOptions.pie.dataLabels.connectorColor
               */
              /**
               * The distance from the data label to the connector. Note that
               * data labels also have a default `padding`, so in order for the
               * connector to touch the text, the `padding` must also be 0.
               *
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorpadding/
               *         No padding
               *
               * @since   2.1
               * @product highcharts highmaps
               */
              connectorPadding: 5,
              /**
               * Specifies the method that is used to generate the connector path.
               * Highcharts provides 3 built-in connector shapes: `'fixedOffset'`
               * (default), `'straight'` and `'crookedLine'`. Using
               * `'crookedLine'` has the most sense (in most of the cases) when
               * `'alignTo'` is set.
               *
               * Users can provide their own method by passing a function instead
               * of a String. 3 arguments are passed to the callback:
               *
               * - Object that holds the information about the coordinates of the
               *   label (`x` & `y` properties) and how the label is located in
               *   relation to the pie (`alignment` property). `alignment` can by
               *   one of the following:
               *   `'left'` (pie on the left side of the data label),
               *   `'right'` (pie on the right side of the data label) or
               *   `'center'` (data label overlaps the pie).
               *
               * - Object that holds the information about the position of the
               *   connector. Its `touchingSliceAt`  porperty tells the position
               *   of the place where the connector touches the slice.
               *
               * - Data label options
               *
               * The function has to return an SVG path definition in array form
               * (see the example).
               *
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorshape-string/
               *         connectorShape is a String
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorshape-function/
               *         connectorShape is a function
               *
               * @type    {string|Function}
               * @since   7.0.0
               * @product highcharts highmaps
               */
              connectorShape: "fixedOffset",
              /**
               * The width of the line connecting the data label to the pie slice.
               *
               * In styled mode, the connector stroke width is given in the
               * `.highcharts-data-label-connector` class.
               *
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-connectorwidth-disabled/
               *         Disable the connector
               * @sample {highcharts} highcharts/css/pie-point/
               *         Styled connectors
               *
               * @type      {number}
               * @default   1
               * @since     2.1
               * @product   highcharts highmaps
               * @apioption plotOptions.pie.dataLabels.connectorWidth
               */
              /**
               * Works only if `connectorShape` is `'crookedLine'`. It defines how
               * far from the vertical plot edge the coonnector path should be
               * crooked.
               *
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-crookdistance/
               *         crookDistance set to 90%
               *
               * @since   7.0.0
               * @product highcharts highmaps
               */
              crookDistance: "70%",
              /**
               * The distance of the data label from the pie's edge. Negative
               * numbers put the data label on top of the pie slices. Can also be
               * defined as a percentage of pie's radius. Connectors are only
               * shown for data labels outside the pie.
               *
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-distance/
               *         Data labels on top of the pie
               *
               * @type    {number|string}
               * @since   2.1
               * @product highcharts highmaps
               */
              distance: 30,
              enabled: true,
              /**
               * A
               * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
               * for the data label. Available variables are the same as for
               * `formatter`.
               *
               * @sample {highcharts} highcharts/plotoptions/series-datalabels-format/
               *         Add a unit
               *
               * @type      {string}
               * @default   undefined
               * @since     3.0
               * @apioption plotOptions.pie.dataLabels.format
               */
              // eslint-disable-next-line valid-jsdoc
              /**
               * Callback JavaScript function to format the data label. Note that
               * if a `format` is defined, the format takes precedence and the
               * formatter is ignored.
               *
               * @type {Highcharts.DataLabelsFormatterCallbackFunction}
               * @default function () { return this.point.isNull ? void 0 : this.point.name; }
               */
              formatter: function() {
                return this.point.isNull ? void 0 : this.point.name;
              },
              /**
               * Whether to render the connector as a soft arc or a line with
               * sharp break. Works only if `connectorShape` equals to
               * `fixedOffset`.
               *
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-softconnector-true/
               *         Soft
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-softconnector-false/
               *         Non soft
               *
               * @since   2.1.7
               * @product highcharts highmaps
               */
              softConnector: true,
              /**
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow
               *         Long labels truncated with an ellipsis
               * @sample {highcharts} highcharts/plotoptions/pie-datalabels-overflow-wrap
               *         Long labels are wrapped
               *
               * @type      {Highcharts.CSSObject}
               * @apioption plotOptions.pie.dataLabels.style
               */
              x: 0
            },
            /**
             * If the total sum of the pie's values is 0, the series is represented
             * as an empty circle . The `fillColor` option defines the color of that
             * circle. Use [pie.borderWidth](#plotOptions.pie.borderWidth) to set
             * the border thickness.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-emptyseries/
             *         Empty pie series
             *
             * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @private
             */
            fillColor: void 0,
            /**
             * The end angle of the pie in degrees where 0 is top and 90 is right.
             * Defaults to `startAngle` plus 360.
             *
             * @sample {highcharts} highcharts/demo/pie-semi-circle/
             *         Semi-circle donut
             *
             * @type      {number}
             * @since     1.3.6
             * @product   highcharts highmaps
             * @apioption plotOptions.pie.endAngle
             */
            /**
             * Thickness describing the ring size for a donut type chart,
             * overriding [innerSize](#plotOptions.pie.innerSize).
             *
             * @type      {number}
             * @default   undefined
             * @product   highcharts
             * @since 10.1.0
             * @apioption plotOptions.pie.thickness
             * @private
             */
            /**
             * Equivalent to [chart.ignoreHiddenSeries](#chart.ignoreHiddenSeries),
             * this option tells whether the series shall be redrawn as if the
             * hidden point were `null`.
             *
             * The default value changed from `false` to `true` with Highcharts
             * 3.0.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-ignorehiddenpoint/
             *         True, the hiddden point is ignored
             *
             * @since   2.3.0
             * @product highcharts highmaps
             *
             * @private
             */
            ignoreHiddenPoint: true,
            /**
             * @ignore-option
             *
             * @private
             */
            inactiveOtherPoints: true,
            /**
             * The size of the inner diameter for the pie. A size greater than 0
             * renders a donut chart. Can be a percentage or pixel value.
             * Percentages are relative to the pie size. Pixel values are given as
             * integers. Setting overridden by thickness.
             *
             *
             * Note: in Highcharts < 4.1.2, the percentage was relative to the plot
             * area, not the pie size.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-innersize-80px/
             *         80px inner size
             * @sample {highcharts} highcharts/plotoptions/pie-innersize-50percent/
             *         50% of the plot area
             * @sample {highcharts} highcharts/demo/3d-pie-donut/
             *         3D donut
             *
             * @type      {number|string}
             * @default   0
             * @since     2.0
             * @product   highcharts highmaps
             * @apioption plotOptions.pie.innerSize
             */
            /**
             * @ignore-option
             *
             * @private
             */
            legendType: "point",
            /**
             * @ignore-option
             *
             * @private
             */
            marker: null,
            /**
             * The minimum size for a pie in response to auto margins. The pie will
             * try to shrink to make room for data labels in side the plot area,
             *  but only to this size.
             *
             * @type      {number|string}
             * @default   80
             * @since     3.0
             * @product   highcharts highmaps
             * @apioption plotOptions.pie.minSize
             */
            /**
             * The diameter of the pie relative to the plot area. Can be a
             * percentage or pixel value. Pixel values are given as integers. The
             * default behaviour (as of 3.0) is to scale to the plot area and give
             * room for data labels within the plot area.
             * [slicedOffset](#plotOptions.pie.slicedOffset) is also included in the
             * default size calculation. As a consequence, the size of the pie may
             * vary when points are updated and data labels more around. In that
             * case it is best to set a fixed value, for example `"75%"`.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-size/
             *         Smaller pie
             *
             * @type    {number|string|null}
             * @product highcharts highmaps
             *
             * @private
             */
            size: null,
            /**
             * Whether to display this particular series or series type in the
             * legend. Since 2.1, pies are not shown in the legend by default.
             *
             * @sample {highcharts} highcharts/plotoptions/series-showinlegend/
             *         One series in the legend, one hidden
             *
             * @product highcharts highmaps
             *
             * @private
             */
            showInLegend: false,
            /**
             * If a point is sliced, moved out from the center, how many pixels
             * should it be moved?.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-slicedoffset-20/
             *         20px offset
             *
             * @product highcharts highmaps
             *
             * @private
             */
            slicedOffset: 10,
            /**
             * The start angle of the pie slices in degrees where 0 is top and 90
             * right.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-startangle-90/
             *         Start from right
             *
             * @type      {number}
             * @default   0
             * @since     2.3.4
             * @product   highcharts highmaps
             * @apioption plotOptions.pie.startAngle
             */
            /**
             * Sticky tracking of mouse events. When true, the `mouseOut` event
             * on a series isn't triggered until the mouse moves over another
             * series, or out of the plot area. When false, the `mouseOut` event on
             * a series is triggered when the mouse leaves the area around the
             * series'  graph or markers. This also implies the tooltip. When
             * `stickyTracking` is false and `tooltip.shared` is false, the tooltip
             * will be hidden when moving the mouse between series.
             *
             * @product highcharts highmaps
             *
             * @private
             */
            stickyTracking: false,
            tooltip: {
              followPointer: true
            },
            /**
             * The color of the border surrounding each slice. When `null`, the
             * border takes the same color as the slice fill. This can be used
             * together with a `borderWidth` to fill drawing gaps created by
             * antialiazing artefacts in borderless pies.
             *
             * In styled mode, the border stroke is given in the `.highcharts-point`
             * class.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-bordercolor-black/
             *         Black border
             *
             * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @default #ffffff
             * @product highcharts highmaps
             *
             * @private
             */
            borderColor: "#ffffff",
            /**
             * The width of the border surrounding each slice.
             *
             * When setting the border width to 0, there may be small gaps between
             * the slices due to SVG antialiasing artefacts. To work around this,
             * keep the border width at 0.5 or 1, but set the `borderColor` to
             * `null` instead.
             *
             * In styled mode, the border stroke width is given in the
             * `.highcharts-point` class.
             *
             * @sample {highcharts} highcharts/plotoptions/pie-borderwidth/
             *         3px border
             *
             * @product highcharts highmaps
             *
             * @private
             */
            borderWidth: 1,
            /**
             * @ignore-option
             * @private
             */
            lineWidth: void 0,
            states: {
              /**
               * @extends   plotOptions.series.states.hover
               * @excluding marker, lineWidth, lineWidthPlus
               * @product   highcharts highmaps
               */
              hover: {
                /**
                 * How much to brighten the point on interaction. Requires the
                 * main color to be defined in hex or rgb(a) format.
                 *
                 * In styled mode, the hover brightness is by default replaced
                 * by a fill-opacity given in the `.highcharts-point-hover`
                 * class.
                 *
                 * @sample {highcharts} highcharts/plotoptions/pie-states-hover-brightness/
                 *         Brightened by 0.5
                 *
                 * @product highcharts highmaps
                 */
                brightness: 0.1
              }
            }
          };
          "";
          return PieSeriesDefaults;
        });
        _registerModule(_modules, "Series/Pie/PieSeries.js", [_modules["Series/CenteredUtilities.js"], _modules["Series/Column/ColumnSeries.js"], _modules["Core/Globals.js"], _modules["Core/Legend/LegendSymbol.js"], _modules["Series/Pie/PiePoint.js"], _modules["Series/Pie/PieSeriesDefaults.js"], _modules["Core/Series/Series.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Renderer/SVG/Symbols.js"], _modules["Core/Utilities.js"]], function(CU, ColumnSeries, H, LegendSymbol, PiePoint, PieSeriesDefaults, Series, SeriesRegistry, Symbols, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var getStartAndEndRadians = CU.getStartAndEndRadians;
          var noop2 = H.noop;
          var clamp = U.clamp, extend2 = U.extend, fireEvent = U.fireEvent, merge = U.merge, pick = U.pick, relativeLength = U.relativeLength;
          var PieSeries = (
            /** @class */
            function(_super) {
              __extends(PieSeries2, _super);
              function PieSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.center = void 0;
                _this.data = void 0;
                _this.maxLabelDistance = void 0;
                _this.options = void 0;
                _this.points = void 0;
                return _this;
              }
              PieSeries2.prototype.animate = function(init3) {
                var series = this, points = series.points, startAngleRad = series.startAngleRad;
                if (!init3) {
                  points.forEach(function(point) {
                    var graphic = point.graphic, args = point.shapeArgs;
                    if (graphic && args) {
                      graphic.attr({
                        // animate from inner radius (#779)
                        r: pick(point.startR, series.center && series.center[3] / 2),
                        start: startAngleRad,
                        end: startAngleRad
                      });
                      graphic.animate({
                        r: args.r,
                        start: args.start,
                        end: args.end
                      }, series.options.animation);
                    }
                  });
                }
              };
              PieSeries2.prototype.drawEmpty = function() {
                var start2 = this.startAngleRad, end = this.endAngleRad, options = this.options;
                var centerX, centerY;
                if (this.total === 0 && this.center) {
                  centerX = this.center[0];
                  centerY = this.center[1];
                  if (!this.graph) {
                    this.graph = this.chart.renderer.arc(centerX, centerY, this.center[1] / 2, 0, start2, end).addClass("highcharts-empty-series").add(this.group);
                  }
                  this.graph.attr({
                    d: Symbols.arc(centerX, centerY, this.center[2] / 2, 0, {
                      start: start2,
                      end,
                      innerR: this.center[3] / 2
                    })
                  });
                  if (!this.chart.styledMode) {
                    this.graph.attr({
                      "stroke-width": options.borderWidth,
                      fill: options.fillColor || "none",
                      stroke: options.color || "#cccccc"
                      /* Palette.neutralColor20 */
                    });
                  }
                } else if (this.graph) {
                  this.graph = this.graph.destroy();
                }
              };
              PieSeries2.prototype.drawPoints = function() {
                var renderer = this.chart.renderer;
                this.points.forEach(function(point) {
                  if (point.graphic && point.hasNewShapeType()) {
                    point.graphic = point.graphic.destroy();
                  }
                  if (!point.graphic) {
                    point.graphic = renderer[point.shapeType](point.shapeArgs).add(point.series.group);
                    point.delayedRendering = true;
                  }
                });
              };
              PieSeries2.prototype.generatePoints = function() {
                _super.prototype.generatePoints.call(this);
                this.updateTotals();
              };
              PieSeries2.prototype.getX = function(y, left, point) {
                var center = this.center, radius = this.radii ? this.radii[point.index] || 0 : center[2] / 2;
                var angle = Math.asin(clamp((y - center[1]) / (radius + point.labelDistance), -1, 1));
                var x = center[0] + (left ? -1 : 1) * (Math.cos(angle) * (radius + point.labelDistance)) + (point.labelDistance > 0 ? (left ? -1 : 1) * this.options.dataLabels.padding : 0);
                return x;
              };
              PieSeries2.prototype.hasData = function() {
                return !!this.processedXData.length;
              };
              PieSeries2.prototype.redrawPoints = function() {
                var series = this, chart = series.chart, renderer = chart.renderer, shadow = series.options.shadow;
                var groupTranslation, graphic, pointAttr, shapeArgs;
                this.drawEmpty();
                if (shadow && !series.shadowGroup && !chart.styledMode) {
                  series.shadowGroup = renderer.g("shadow").attr({ zIndex: -1 }).add(series.group);
                }
                series.points.forEach(function(point) {
                  var animateTo = {};
                  graphic = point.graphic;
                  if (!point.isNull && graphic) {
                    var shadowGroup = void 0;
                    shapeArgs = point.shapeArgs;
                    groupTranslation = point.getTranslate();
                    if (!chart.styledMode) {
                      shadowGroup = point.shadowGroup;
                      if (shadow && !shadowGroup) {
                        shadowGroup = point.shadowGroup = renderer.g("shadow").add(series.shadowGroup);
                      }
                      if (shadowGroup) {
                        shadowGroup.attr(groupTranslation);
                      }
                      pointAttr = series.pointAttribs(point, point.selected && "select");
                    }
                    if (!point.delayedRendering) {
                      graphic.setRadialReference(series.center);
                      if (!chart.styledMode) {
                        merge(true, animateTo, pointAttr);
                      }
                      merge(true, animateTo, shapeArgs, groupTranslation);
                      graphic.animate(animateTo);
                    } else {
                      graphic.setRadialReference(series.center).attr(shapeArgs).attr(groupTranslation);
                      if (!chart.styledMode) {
                        graphic.attr(pointAttr).attr({ "stroke-linejoin": "round" }).shadow(shadow, shadowGroup);
                      }
                      point.delayedRendering = false;
                    }
                    graphic.attr({
                      visibility: point.visible ? "inherit" : "hidden"
                    });
                    graphic.addClass(point.getClassName(), true);
                  } else if (graphic) {
                    point.graphic = graphic.destroy();
                  }
                });
              };
              PieSeries2.prototype.sortByAngle = function(points, sign) {
                points.sort(function(a, b) {
                  return typeof a.angle !== "undefined" && (b.angle - a.angle) * sign;
                });
              };
              PieSeries2.prototype.translate = function(positions) {
                fireEvent(this, "translate");
                this.generatePoints();
                var series = this, precision = 1e3, options = series.options, slicedOffset = options.slicedOffset, connectorOffset = slicedOffset + (options.borderWidth || 0), radians = getStartAndEndRadians(
                  options.startAngle,
                  options.endAngle
                ), startAngleRad = series.startAngleRad = radians.start, endAngleRad = series.endAngleRad = radians.end, circ = endAngleRad - startAngleRad, points = series.points, labelDistance = options.dataLabels.distance, ignoreHiddenPoint = options.ignoreHiddenPoint, len = points.length;
                var finalConnectorOffset, start2, end, angle, radiusX, radiusY, i, point, cumulative = 0;
                if (!positions) {
                  series.center = positions = series.getCenter();
                }
                for (i = 0; i < len; i++) {
                  point = points[i];
                  start2 = startAngleRad + cumulative * circ;
                  if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {
                    cumulative += point.percentage / 100;
                  }
                  end = startAngleRad + cumulative * circ;
                  var shapeArgs = {
                    x: positions[0],
                    y: positions[1],
                    r: positions[2] / 2,
                    innerR: positions[3] / 2,
                    start: Math.round(start2 * precision) / precision,
                    end: Math.round(end * precision) / precision
                  };
                  point.shapeType = "arc";
                  point.shapeArgs = shapeArgs;
                  point.labelDistance = pick(point.options.dataLabels && point.options.dataLabels.distance, labelDistance);
                  point.labelDistance = relativeLength(point.labelDistance, shapeArgs.r);
                  series.maxLabelDistance = Math.max(series.maxLabelDistance || 0, point.labelDistance);
                  angle = (end + start2) / 2;
                  if (angle > 1.5 * Math.PI) {
                    angle -= 2 * Math.PI;
                  } else if (angle < -Math.PI / 2) {
                    angle += 2 * Math.PI;
                  }
                  point.slicedTranslation = {
                    translateX: Math.round(Math.cos(angle) * slicedOffset),
                    translateY: Math.round(Math.sin(angle) * slicedOffset)
                  };
                  radiusX = Math.cos(angle) * positions[2] / 2;
                  radiusY = Math.sin(angle) * positions[2] / 2;
                  point.tooltipPos = [
                    positions[0] + radiusX * 0.7,
                    positions[1] + radiusY * 0.7
                  ];
                  point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ? 1 : 0;
                  point.angle = angle;
                  finalConnectorOffset = Math.min(connectorOffset, point.labelDistance / 5);
                  point.labelPosition = {
                    natural: {
                      // initial position of the data label - it's utilized for
                      // finding the final position for the label
                      x: positions[0] + radiusX + Math.cos(angle) * point.labelDistance,
                      y: positions[1] + radiusY + Math.sin(angle) * point.labelDistance
                    },
                    "final": {
                      // used for generating connector path -
                      // initialized later in drawDataLabels function
                      // x: undefined,
                      // y: undefined
                    },
                    // left - pie on the left side of the data label
                    // right - pie on the right side of the data label
                    // center - data label overlaps the pie
                    alignment: point.labelDistance < 0 ? "center" : point.half ? "right" : "left",
                    connectorPosition: {
                      breakAt: {
                        x: positions[0] + radiusX + Math.cos(angle) * finalConnectorOffset,
                        y: positions[1] + radiusY + Math.sin(angle) * finalConnectorOffset
                      },
                      touchingSliceAt: {
                        x: positions[0] + radiusX,
                        y: positions[1] + radiusY
                      }
                    }
                  };
                }
                fireEvent(series, "afterTranslate");
              };
              PieSeries2.prototype.updateTotals = function() {
                var points = this.points, len = points.length, ignoreHiddenPoint = this.options.ignoreHiddenPoint;
                var i, point, total = 0;
                for (i = 0; i < len; i++) {
                  point = points[i];
                  if (point.isValid() && (!ignoreHiddenPoint || point.visible)) {
                    total += point.y;
                  }
                }
                this.total = total;
                for (i = 0; i < len; i++) {
                  point = points[i];
                  point.percentage = total > 0 && (point.visible || !ignoreHiddenPoint) ? point.y / total * 100 : 0;
                  point.total = total;
                }
              };
              PieSeries2.defaultOptions = merge(Series.defaultOptions, PieSeriesDefaults);
              return PieSeries2;
            }(Series)
          );
          extend2(PieSeries.prototype, {
            axisTypes: [],
            directTouch: true,
            drawGraph: void 0,
            drawLegendSymbol: LegendSymbol.drawRectangle,
            drawTracker: ColumnSeries.prototype.drawTracker,
            getCenter: CU.getCenter,
            getSymbol: noop2,
            isCartesian: false,
            noSharedTooltip: true,
            pointAttribs: ColumnSeries.prototype.pointAttribs,
            pointClass: PiePoint,
            requireSorting: false,
            searchPoint: noop2,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          SeriesRegistry.registerSeriesType("pie", PieSeries);
          return PieSeries;
        });
        _registerModule(_modules, "Series/Pie/PieDataLabel.js", [_modules["Core/Series/DataLabel.js"], _modules["Core/Globals.js"], _modules["Core/Renderer/RendererUtilities.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(DataLabel, H, R, SeriesRegistry, U) {
          var noop2 = H.noop;
          var distribute = R.distribute;
          var Series = SeriesRegistry.series;
          var arrayMax = U.arrayMax, clamp = U.clamp, defined = U.defined, merge = U.merge, pick = U.pick, relativeLength = U.relativeLength;
          var ColumnDataLabel;
          (function(ColumnDataLabel2) {
            var composedClasses = [];
            var dataLabelPositioners = {
              // Based on the value computed in Highcharts' distribute algorithm.
              radialDistributionY: function(point) {
                return point.top + point.distributeBox.pos;
              },
              // get the x - use the natural x position for labels near the
              // top and bottom, to prevent the top and botton slice
              // connectors from touching each other on either side
              // Based on the value computed in Highcharts' distribute algorithm.
              radialDistributionX: function(series, point, y, naturalY) {
                return series.getX(y < point.top + 2 || y > point.bottom - 2 ? naturalY : y, point.half, point);
              },
              // dataLabels.distance determines the x position of the label
              justify: function(point, radius, seriesCenter) {
                return seriesCenter[0] + (point.half ? -1 : 1) * (radius + point.labelDistance);
              },
              // Left edges of the left-half labels touch the left edge of the plot
              // area. Right edges of the right-half labels touch the right edge of
              // the plot area.
              alignToPlotEdges: function(dataLabel, half, plotWidth, plotLeft) {
                var dataLabelWidth = dataLabel.getBBox().width;
                return half ? dataLabelWidth + plotLeft : plotWidth - dataLabelWidth - plotLeft;
              },
              // Connectors of each side end in the same x position. Labels are
              // aligned to them. Left edge of the widest left-half label touches the
              // left edge of the plot area. Right edge of the widest right-half label
              // touches the right edge of the plot area.
              alignToConnectors: function(points, half, plotWidth, plotLeft) {
                var maxDataLabelWidth = 0, dataLabelWidth;
                points.forEach(function(point) {
                  dataLabelWidth = point.dataLabel.getBBox().width;
                  if (dataLabelWidth > maxDataLabelWidth) {
                    maxDataLabelWidth = dataLabelWidth;
                  }
                });
                return half ? maxDataLabelWidth + plotLeft : plotWidth - maxDataLabelWidth - plotLeft;
              }
            };
            function compose(PieSeriesClass) {
              DataLabel.compose(Series);
              if (composedClasses.indexOf(PieSeriesClass) === -1) {
                composedClasses.push(PieSeriesClass);
                var pieProto = PieSeriesClass.prototype;
                pieProto.dataLabelPositioners = dataLabelPositioners;
                pieProto.alignDataLabel = noop2;
                pieProto.drawDataLabels = drawDataLabels;
                pieProto.placeDataLabels = placeDataLabels;
                pieProto.verifyDataLabelOverflow = verifyDataLabelOverflow;
              }
            }
            ColumnDataLabel2.compose = compose;
            function drawDataLabels() {
              var series = this, data = series.data, chart = series.chart, options = series.options.dataLabels || {}, connectorPadding = options.connectorPadding, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, plotLeft = chart.plotLeft, maxWidth = Math.round(chart.chartWidth / 3), seriesCenter = series.center, radius = seriesCenter[2] / 2, centerY = seriesCenter[1], halves = [
                [],
                []
                // left
              ], overflow = [0, 0, 0, 0], dataLabelPositioners2 = series.dataLabelPositioners;
              var point, connectorWidth, connector, dataLabel, dataLabelWidth, labelPosition, labelHeight, x, y, visibility, j, pointDataLabelsOptions;
              if (!series.visible || !options.enabled && !series._hasPointLabels) {
                return;
              }
              data.forEach(function(point2) {
                if (point2.dataLabel && point2.visible && point2.dataLabel.shortened) {
                  point2.dataLabel.attr({
                    width: "auto"
                  }).css({
                    width: "auto",
                    textOverflow: "clip"
                  });
                  point2.dataLabel.shortened = false;
                }
              });
              Series.prototype.drawDataLabels.apply(series);
              data.forEach(function(point2) {
                if (point2.dataLabel) {
                  if (point2.visible) {
                    halves[point2.half].push(point2);
                    point2.dataLabel._pos = null;
                    if (!defined(options.style.width) && !defined(point2.options.dataLabels && point2.options.dataLabels.style && point2.options.dataLabels.style.width)) {
                      if (point2.dataLabel.getBBox().width > maxWidth) {
                        point2.dataLabel.css({
                          // Use a fraction of the maxWidth to avoid
                          // wrapping close to the end of the string.
                          width: Math.round(maxWidth * 0.7) + "px"
                        });
                        point2.dataLabel.shortened = true;
                      }
                    }
                  } else {
                    point2.dataLabel = point2.dataLabel.destroy();
                    if (point2.dataLabels && point2.dataLabels.length === 1) {
                      delete point2.dataLabels;
                    }
                  }
                }
              });
              halves.forEach(function(points, i) {
                var length = points.length, positions = [];
                var top, bottom, naturalY, sideOverflow, size, distributionLength;
                if (!length) {
                  return;
                }
                series.sortByAngle(points, i - 0.5);
                if (series.maxLabelDistance > 0) {
                  top = Math.max(0, centerY - radius - series.maxLabelDistance);
                  bottom = Math.min(centerY + radius + series.maxLabelDistance, chart.plotHeight);
                  points.forEach(function(point2) {
                    if (point2.labelDistance > 0 && point2.dataLabel) {
                      point2.top = Math.max(0, centerY - radius - point2.labelDistance);
                      point2.bottom = Math.min(centerY + radius + point2.labelDistance, chart.plotHeight);
                      size = point2.dataLabel.getBBox().height || 21;
                      point2.distributeBox = {
                        target: point2.labelPosition.natural.y - point2.top + size / 2,
                        size,
                        rank: point2.y
                      };
                      positions.push(point2.distributeBox);
                    }
                  });
                  distributionLength = bottom + size - top;
                  distribute(positions, distributionLength, distributionLength / 5);
                }
                for (j = 0; j < length; j++) {
                  point = points[j];
                  labelPosition = point.labelPosition;
                  dataLabel = point.dataLabel;
                  visibility = point.visible === false ? "hidden" : "inherit";
                  naturalY = labelPosition.natural.y;
                  y = naturalY;
                  if (positions && defined(point.distributeBox)) {
                    if (typeof point.distributeBox.pos === "undefined") {
                      visibility = "hidden";
                    } else {
                      labelHeight = point.distributeBox.size;
                      y = dataLabelPositioners2.radialDistributionY(point);
                    }
                  }
                  delete point.positionIndex;
                  if (options.justify) {
                    x = dataLabelPositioners2.justify(point, radius, seriesCenter);
                  } else {
                    switch (options.alignTo) {
                      case "connectors":
                        x = dataLabelPositioners2.alignToConnectors(points, i, plotWidth, plotLeft);
                        break;
                      case "plotEdges":
                        x = dataLabelPositioners2.alignToPlotEdges(dataLabel, i, plotWidth, plotLeft);
                        break;
                      default:
                        x = dataLabelPositioners2.radialDistributionX(series, point, y, naturalY);
                    }
                  }
                  dataLabel._attr = {
                    visibility,
                    align: labelPosition.alignment
                  };
                  pointDataLabelsOptions = point.options.dataLabels || {};
                  dataLabel._pos = {
                    x: x + pick(pointDataLabelsOptions.x, options.x) + // (#12985)
                    ({
                      left: connectorPadding,
                      right: -connectorPadding
                    }[labelPosition.alignment] || 0),
                    // 10 is for the baseline (label vs text)
                    y: y + pick(pointDataLabelsOptions.y, options.y) - // (#12985)
                    10
                  };
                  labelPosition.final.x = x;
                  labelPosition.final.y = y;
                  if (pick(options.crop, true)) {
                    dataLabelWidth = dataLabel.getBBox().width;
                    sideOverflow = null;
                    if (x - dataLabelWidth < connectorPadding && i === 1) {
                      sideOverflow = Math.round(dataLabelWidth - x + connectorPadding);
                      overflow[3] = Math.max(sideOverflow, overflow[3]);
                    } else if (x + dataLabelWidth > plotWidth - connectorPadding && i === 0) {
                      sideOverflow = Math.round(x + dataLabelWidth - plotWidth + connectorPadding);
                      overflow[1] = Math.max(sideOverflow, overflow[1]);
                    }
                    if (y - labelHeight / 2 < 0) {
                      overflow[0] = Math.max(Math.round(-y + labelHeight / 2), overflow[0]);
                    } else if (y + labelHeight / 2 > plotHeight) {
                      overflow[2] = Math.max(Math.round(y + labelHeight / 2 - plotHeight), overflow[2]);
                    }
                    dataLabel.sideOverflow = sideOverflow;
                  }
                }
              });
              if (arrayMax(overflow) === 0 || this.verifyDataLabelOverflow(overflow)) {
                this.placeDataLabels();
                this.points.forEach(function(point2) {
                  pointDataLabelsOptions = merge(options, point2.options.dataLabels);
                  connectorWidth = pick(pointDataLabelsOptions.connectorWidth, 1);
                  if (connectorWidth) {
                    var isNew = void 0;
                    connector = point2.connector;
                    dataLabel = point2.dataLabel;
                    if (dataLabel && dataLabel._pos && point2.visible && point2.labelDistance > 0) {
                      visibility = dataLabel._attr.visibility;
                      isNew = !connector;
                      if (isNew) {
                        point2.connector = connector = chart.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + point2.colorIndex + (point2.className ? " " + point2.className : "")).add(series.dataLabelsGroup);
                        if (!chart.styledMode) {
                          connector.attr({
                            "stroke-width": connectorWidth,
                            "stroke": pointDataLabelsOptions.connectorColor || point2.color || "#666666"
                          });
                        }
                      }
                      connector[isNew ? "attr" : "animate"]({
                        d: point2.getConnectorPath()
                      });
                      connector.attr("visibility", visibility);
                    } else if (connector) {
                      point2.connector = connector.destroy();
                    }
                  }
                });
              }
            }
            function placeDataLabels() {
              this.points.forEach(function(point) {
                var dataLabel = point.dataLabel, _pos;
                if (dataLabel && point.visible) {
                  _pos = dataLabel._pos;
                  if (_pos) {
                    if (dataLabel.sideOverflow) {
                      dataLabel._attr.width = Math.max(dataLabel.getBBox().width - dataLabel.sideOverflow, 0);
                      dataLabel.css({
                        width: dataLabel._attr.width + "px",
                        textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis"
                      });
                      dataLabel.shortened = true;
                    }
                    dataLabel.attr(dataLabel._attr);
                    dataLabel[dataLabel.moved ? "animate" : "attr"](_pos);
                    dataLabel.moved = true;
                  } else if (dataLabel) {
                    dataLabel.attr({ y: -9999 });
                  }
                }
                delete point.distributeBox;
              }, this);
            }
            function verifyDataLabelOverflow(overflow) {
              var center = this.center, options = this.options, centerOption = options.center, minSize = options.minSize || 80, newSize = minSize, ret = options.size !== null;
              if (!ret) {
                if (centerOption[0] !== null) {
                  newSize = Math.max(center[2] - Math.max(overflow[1], overflow[3]), minSize);
                } else {
                  newSize = Math.max(
                    // horizontal overflow
                    center[2] - overflow[1] - overflow[3],
                    minSize
                  );
                  center[0] += (overflow[3] - overflow[1]) / 2;
                }
                if (centerOption[1] !== null) {
                  newSize = clamp(newSize, minSize, center[2] - Math.max(overflow[0], overflow[2]));
                } else {
                  newSize = clamp(
                    newSize,
                    minSize,
                    // vertical overflow
                    center[2] - overflow[0] - overflow[2]
                  );
                  center[1] += (overflow[0] - overflow[2]) / 2;
                }
                if (newSize < center[2]) {
                  center[2] = newSize;
                  center[3] = Math.min(
                    // #3632
                    options.thickness ? Math.max(0, newSize - options.thickness * 2) : Math.max(0, relativeLength(options.innerSize || 0, newSize)),
                    newSize
                  );
                  this.translate(center);
                  if (this.drawDataLabels) {
                    this.drawDataLabels();
                  }
                } else {
                  ret = true;
                }
              }
              return ret;
            }
          })(ColumnDataLabel || (ColumnDataLabel = {}));
          return ColumnDataLabel;
        });
        _registerModule(_modules, "Extensions/OverlappingDataLabels.js", [_modules["Core/Chart/Chart.js"], _modules["Core/Utilities.js"]], function(Chart, U) {
          var addEvent = U.addEvent, fireEvent = U.fireEvent, isArray = U.isArray, isNumber = U.isNumber, objectEach = U.objectEach, pick = U.pick;
          addEvent(Chart, "render", function collectAndHide() {
            var chart = this, labels = [];
            (this.labelCollectors || []).forEach(function(collector) {
              labels = labels.concat(collector());
            });
            (this.yAxis || []).forEach(function(yAxis) {
              if (yAxis.stacking && yAxis.options.stackLabels && !yAxis.options.stackLabels.allowOverlap) {
                objectEach(yAxis.stacking.stacks, function(stack) {
                  objectEach(stack, function(stackItem) {
                    if (stackItem.label) {
                      labels.push(stackItem.label);
                    }
                  });
                });
              }
            });
            (this.series || []).forEach(function(series) {
              var dlOptions = series.options.dataLabels;
              if (series.visible && !(dlOptions.enabled === false && !series._hasPointLabels)) {
                var push = function(points) {
                  return points.forEach(function(point) {
                    if (point.visible) {
                      var dataLabels = isArray(point.dataLabels) ? point.dataLabels : point.dataLabel ? [point.dataLabel] : [];
                      dataLabels.forEach(function(label) {
                        var options = label.options;
                        label.labelrank = pick(options.labelrank, point.labelrank, point.shapeArgs && point.shapeArgs.height);
                        if (!options.allowOverlap) {
                          labels.push(label);
                        } else {
                          label.oldOpacity = label.opacity;
                          label.newOpacity = 1;
                          hideOrShow(label, chart);
                        }
                      });
                    }
                  });
                };
                push(series.nodes || []);
                push(series.points);
              }
            });
            this.hideOverlappingLabels(labels);
          });
          Chart.prototype.hideOverlappingLabels = function(labels) {
            var chart = this, len = labels.length, ren = chart.renderer, label, i, j, label1, label2, box1, box2, isLabelAffected = false, isIntersectRect = function(box12, box22) {
              return !(box22.x >= box12.x + box12.width || box22.x + box22.width <= box12.x || box22.y >= box12.y + box12.height || box22.y + box22.height <= box12.y);
            }, getAbsoluteBox = function(label3) {
              var pos, parent, bBox, padding = label3.box ? 0 : label3.padding || 0, lineHeightCorrection = 0, xOffset = 0, boxWidth, alignValue;
              if (label3 && (!label3.alignAttr || label3.placed)) {
                pos = label3.alignAttr || {
                  x: label3.attr("x"),
                  y: label3.attr("y")
                };
                parent = label3.parentGroup;
                if (!label3.width) {
                  bBox = label3.getBBox();
                  label3.width = bBox.width;
                  label3.height = bBox.height;
                  lineHeightCorrection = ren.fontMetrics(null, label3.element).h;
                }
                boxWidth = label3.width - 2 * padding;
                alignValue = {
                  left: "0",
                  center: "0.5",
                  right: "1"
                }[label3.alignValue];
                if (alignValue) {
                  xOffset = +alignValue * boxWidth;
                } else if (isNumber(label3.x) && Math.round(label3.x) !== label3.translateX) {
                  xOffset = label3.x - label3.translateX;
                }
                return {
                  x: pos.x + (parent.translateX || 0) + padding - (xOffset || 0),
                  y: pos.y + (parent.translateY || 0) + padding - lineHeightCorrection,
                  width: label3.width - 2 * padding,
                  height: label3.height - 2 * padding
                };
              }
            };
            for (i = 0; i < len; i++) {
              label = labels[i];
              if (label) {
                label.oldOpacity = label.opacity;
                label.newOpacity = 1;
                label.absoluteBox = getAbsoluteBox(label);
              }
            }
            labels.sort(function(a, b) {
              return (b.labelrank || 0) - (a.labelrank || 0);
            });
            for (i = 0; i < len; i++) {
              label1 = labels[i];
              box1 = label1 && label1.absoluteBox;
              for (j = i + 1; j < len; ++j) {
                label2 = labels[j];
                box2 = label2 && label2.absoluteBox;
                if (box1 && box2 && label1 !== label2 && // #6465, polar chart with connectEnds
                label1.newOpacity !== 0 && label2.newOpacity !== 0 && // #15863 dataLabels are no longer hidden by translation
                label1.visibility !== "hidden" && label2.visibility !== "hidden") {
                  if (isIntersectRect(box1, box2)) {
                    (label1.labelrank < label2.labelrank ? label1 : label2).newOpacity = 0;
                  }
                }
              }
            }
            labels.forEach(function(label3) {
              if (hideOrShow(label3, chart)) {
                isLabelAffected = true;
              }
            });
            if (isLabelAffected) {
              fireEvent(chart, "afterHideAllOverlappingLabels");
            }
          };
          function hideOrShow(label, chart) {
            var complete, newOpacity, isLabelAffected = false;
            if (label) {
              newOpacity = label.newOpacity;
              if (label.oldOpacity !== newOpacity) {
                if (label.alignAttr && label.placed) {
                  label[newOpacity ? "removeClass" : "addClass"]("highcharts-data-label-hidden");
                  complete = function() {
                    if (!chart.styledMode) {
                      label.css({
                        pointerEvents: newOpacity ? "auto" : "none"
                      });
                    }
                  };
                  isLabelAffected = true;
                  label.alignAttr.opacity = newOpacity;
                  label[label.isOld ? "animate" : "attr"](label.alignAttr, null, complete);
                  fireEvent(chart, "afterHideOverlappingLabel");
                } else {
                  label.attr({
                    opacity: newOpacity
                  });
                }
              }
              label.isOld = true;
            }
            return isLabelAffected;
          }
        });
        _registerModule(_modules, "Core/Responsive.js", [_modules["Core/Utilities.js"]], function(U) {
          var extend2 = U.extend, find2 = U.find, isArray = U.isArray, isObject = U.isObject, merge = U.merge, objectEach = U.objectEach, pick = U.pick, splat = U.splat, uniqueKey = U.uniqueKey;
          var Responsive;
          (function(Responsive2) {
            var composedClasses = [];
            function compose(ChartClass) {
              if (composedClasses.indexOf(ChartClass) === -1) {
                composedClasses.push(ChartClass);
                extend2(ChartClass.prototype, Additions.prototype);
              }
              return ChartClass;
            }
            Responsive2.compose = compose;
            var Additions = (
              /** @class */
              function() {
                function Additions2() {
                }
                Additions2.prototype.currentOptions = function(options) {
                  var chart = this, ret = {};
                  function getCurrent(options2, curr, ret2, depth) {
                    var i;
                    objectEach(options2, function(val, key) {
                      if (!depth && chart.collectionsWithUpdate.indexOf(key) > -1 && curr[key]) {
                        val = splat(val);
                        ret2[key] = [];
                        for (i = 0; i < Math.max(val.length, curr[key].length); i++) {
                          if (curr[key][i]) {
                            if (val[i] === void 0) {
                              ret2[key][i] = curr[key][i];
                            } else {
                              ret2[key][i] = {};
                              getCurrent(val[i], curr[key][i], ret2[key][i], depth + 1);
                            }
                          }
                        }
                      } else if (isObject(val)) {
                        ret2[key] = isArray(val) ? [] : {};
                        getCurrent(val, curr[key] || {}, ret2[key], depth + 1);
                      } else if (typeof curr[key] === "undefined") {
                        ret2[key] = null;
                      } else {
                        ret2[key] = curr[key];
                      }
                    });
                  }
                  getCurrent(options, this.options, ret, 0);
                  return ret;
                };
                Additions2.prototype.matchResponsiveRule = function(rule, matches) {
                  var condition = rule.condition, fn = condition.callback || function() {
                    return this.chartWidth <= pick(
                      condition.maxWidth,
                      Number.MAX_VALUE
                    ) && this.chartHeight <= pick(
                      condition.maxHeight,
                      Number.MAX_VALUE
                    ) && this.chartWidth >= pick(condition.minWidth, 0) && this.chartHeight >= pick(condition.minHeight, 0);
                  };
                  if (fn.call(this)) {
                    matches.push(rule._id);
                  }
                };
                Additions2.prototype.setResponsive = function(redraw, reset) {
                  var _this = this;
                  var options = this.options.responsive, currentResponsive = this.currentResponsive;
                  var ruleIds = [], undoOptions;
                  if (!reset && options && options.rules) {
                    options.rules.forEach(function(rule) {
                      if (typeof rule._id === "undefined") {
                        rule._id = uniqueKey();
                      }
                      _this.matchResponsiveRule(
                        rule,
                        ruleIds
                        /* , redraw */
                      );
                    }, this);
                  }
                  var mergedOptions = merge.apply(
                    void 0,
                    ruleIds.map(function(ruleId) {
                      return find2(
                        (options || {}).rules || [],
                        function(rule) {
                          return rule._id === ruleId;
                        }
                      );
                    }).map(function(rule) {
                      return rule && rule.chartOptions;
                    })
                  );
                  mergedOptions.isResponsiveOptions = true;
                  ruleIds = ruleIds.toString() || void 0;
                  var currentRuleIds = currentResponsive && currentResponsive.ruleIds;
                  if (ruleIds !== currentRuleIds) {
                    if (currentResponsive) {
                      this.update(currentResponsive.undoOptions, redraw, true);
                    }
                    if (ruleIds) {
                      undoOptions = this.currentOptions(mergedOptions);
                      undoOptions.isResponsiveOptions = true;
                      this.currentResponsive = {
                        ruleIds,
                        mergedOptions,
                        undoOptions
                      };
                      this.update(mergedOptions, redraw, true);
                    } else {
                      this.currentResponsive = void 0;
                    }
                  }
                };
                return Additions2;
              }()
            );
          })(Responsive || (Responsive = {}));
          "";
          "";
          return Responsive;
        });
        _registerModule(_modules, "masters/highcharts.src.js", [_modules["Core/Globals.js"], _modules["Core/Utilities.js"], _modules["Core/Defaults.js"], _modules["Core/Animation/Fx.js"], _modules["Core/Animation/AnimationUtilities.js"], _modules["Core/Renderer/HTML/AST.js"], _modules["Core/FormatUtilities.js"], _modules["Core/Renderer/RendererUtilities.js"], _modules["Core/Renderer/SVG/SVGElement.js"], _modules["Core/Renderer/SVG/SVGRenderer.js"], _modules["Core/Renderer/HTML/HTMLElement.js"], _modules["Core/Renderer/HTML/HTMLRenderer.js"], _modules["Core/Axis/Axis.js"], _modules["Core/Axis/DateTimeAxis.js"], _modules["Core/Axis/LogarithmicAxis.js"], _modules["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"], _modules["Core/Axis/Tick.js"], _modules["Core/Tooltip.js"], _modules["Core/Series/Point.js"], _modules["Core/Pointer.js"], _modules["Core/MSPointer.js"], _modules["Core/Legend/Legend.js"], _modules["Core/Chart/Chart.js"], _modules["Core/Axis/Stacking/StackingAxis.js"], _modules["Core/Axis/Stacking/StackItem.js"], _modules["Core/Series/Series.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Series/Column/ColumnSeries.js"], _modules["Series/Column/ColumnDataLabel.js"], _modules["Series/Pie/PieSeries.js"], _modules["Series/Pie/PieDataLabel.js"], _modules["Core/Series/DataLabel.js"], _modules["Core/Responsive.js"], _modules["Core/Color/Color.js"], _modules["Core/Time.js"]], function(Highcharts3, Utilities, Defaults, Fx, Animation, AST, FormatUtilities, RendererUtilities, SVGElement, SVGRenderer, HTMLElement, HTMLRenderer, Axis, DateTimeAxis, LogarithmicAxis, PlotLineOrBand, Tick, Tooltip, Point, Pointer, MSPointer, Legend, Chart, StackingAxis, StackItem, Series, SeriesRegistry, ColumnSeries, ColumnDataLabel, PieSeries, PieDataLabel, DataLabel, Responsive, Color2, Time) {
          var G = Highcharts3;
          G.animate = Animation.animate;
          G.animObject = Animation.animObject;
          G.getDeferredAnimation = Animation.getDeferredAnimation;
          G.setAnimation = Animation.setAnimation;
          G.stop = Animation.stop;
          G.timers = Fx.timers;
          G.AST = AST;
          G.Axis = Axis;
          G.Chart = Chart;
          G.chart = Chart.chart;
          G.Fx = Fx;
          G.Legend = Legend;
          G.PlotLineOrBand = PlotLineOrBand;
          G.Point = Point;
          G.Pointer = MSPointer.isRequired() ? MSPointer : Pointer;
          G.Series = Series;
          G.StackItem = StackItem;
          G.SVGElement = SVGElement;
          G.SVGRenderer = SVGRenderer;
          G.Tick = Tick;
          G.Time = Time;
          G.Tooltip = Tooltip;
          G.Color = Color2;
          G.color = Color2.parse;
          HTMLRenderer.compose(SVGRenderer);
          HTMLElement.compose(SVGElement);
          G.defaultOptions = Defaults.defaultOptions;
          G.getOptions = Defaults.getOptions;
          G.time = Defaults.defaultTime;
          G.setOptions = Defaults.setOptions;
          G.dateFormat = FormatUtilities.dateFormat;
          G.format = FormatUtilities.format;
          G.numberFormat = FormatUtilities.numberFormat;
          G.addEvent = Utilities.addEvent;
          G.arrayMax = Utilities.arrayMax;
          G.arrayMin = Utilities.arrayMin;
          G.attr = Utilities.attr;
          G.clearTimeout = Utilities.clearTimeout;
          G.correctFloat = Utilities.correctFloat;
          G.createElement = Utilities.createElement;
          G.css = Utilities.css;
          G.defined = Utilities.defined;
          G.destroyObjectProperties = Utilities.destroyObjectProperties;
          G.discardElement = Utilities.discardElement;
          G.distribute = RendererUtilities.distribute;
          G.erase = Utilities.erase;
          G.error = Utilities.error;
          G.extend = Utilities.extend;
          G.extendClass = Utilities.extendClass;
          G.find = Utilities.find;
          G.fireEvent = Utilities.fireEvent;
          G.getMagnitude = Utilities.getMagnitude;
          G.getStyle = Utilities.getStyle;
          G.inArray = Utilities.inArray;
          G.isArray = Utilities.isArray;
          G.isClass = Utilities.isClass;
          G.isDOMElement = Utilities.isDOMElement;
          G.isFunction = Utilities.isFunction;
          G.isNumber = Utilities.isNumber;
          G.isObject = Utilities.isObject;
          G.isString = Utilities.isString;
          G.keys = Utilities.keys;
          G.merge = Utilities.merge;
          G.normalizeTickInterval = Utilities.normalizeTickInterval;
          G.objectEach = Utilities.objectEach;
          G.offset = Utilities.offset;
          G.pad = Utilities.pad;
          G.pick = Utilities.pick;
          G.pInt = Utilities.pInt;
          G.relativeLength = Utilities.relativeLength;
          G.removeEvent = Utilities.removeEvent;
          G.seriesType = SeriesRegistry.seriesType;
          G.splat = Utilities.splat;
          G.stableSort = Utilities.stableSort;
          G.syncTimeout = Utilities.syncTimeout;
          G.timeUnits = Utilities.timeUnits;
          G.uniqueKey = Utilities.uniqueKey;
          G.useSerialIds = Utilities.useSerialIds;
          G.wrap = Utilities.wrap;
          ColumnDataLabel.compose(ColumnSeries);
          DataLabel.compose(Series);
          DateTimeAxis.compose(Axis);
          LogarithmicAxis.compose(Axis);
          PieDataLabel.compose(PieSeries);
          PlotLineOrBand.compose(Axis);
          Responsive.compose(Chart);
          StackingAxis.compose(Axis, Chart, Series);
          return G;
        });
        _modules["masters/highcharts.src.js"]._modules = _modules;
        return _modules["masters/highcharts.src.js"];
      });
    }
  });

  // node_modules/.pnpm/highcharts@10.3.3/node_modules/highcharts/highcharts-more.src.js
  var require_highcharts_more_src = __commonJS({
    "node_modules/.pnpm/highcharts@10.3.3/node_modules/highcharts/highcharts-more.src.js"(exports, module) {
      (function(factory) {
        if (typeof module === "object" && module.exports) {
          factory["default"] = factory;
          module.exports = factory;
        } else if (typeof define === "function" && define.amd) {
          define("highcharts/highcharts-more", ["highcharts"], function(Highcharts3) {
            factory(Highcharts3);
            factory.Highcharts = Highcharts3;
            return factory;
          });
        } else {
          factory(typeof Highcharts !== "undefined" ? Highcharts : void 0);
        }
      })(function(Highcharts3) {
        "use strict";
        var _modules = Highcharts3 ? Highcharts3._modules : {};
        function _registerModule(obj, path, args, fn) {
          if (!obj.hasOwnProperty(path)) {
            obj[path] = fn.apply(null, args);
            if (typeof CustomEvent === "function") {
              window.dispatchEvent(
                new CustomEvent(
                  "HighchartsModuleLoaded",
                  {
                    detail: { path, module: obj[path] }
                  }
                )
              );
            }
          }
        }
        _registerModule(_modules, "Extensions/Pane.js", [_modules["Core/Chart/Chart.js"], _modules["Series/CenteredUtilities.js"], _modules["Core/Globals.js"], _modules["Core/Pointer.js"], _modules["Core/Utilities.js"]], function(Chart, CU, H, Pointer, U) {
          var addEvent = U.addEvent, correctFloat = U.correctFloat, defined = U.defined, extend2 = U.extend, merge = U.merge, pick = U.pick, splat = U.splat;
          Chart.prototype.collectionsWithUpdate.push("pane");
          var Pane = (
            /** @class */
            function() {
              function Pane2(options, chart) {
                this.background = void 0;
                this.center = void 0;
                this.chart = void 0;
                this.options = void 0;
                this.coll = "pane";
                this.defaultOptions = {
                  /**
                   * The end angle of the polar X axis or gauge value axis, given in
                   * degrees where 0 is north. Defaults to [startAngle](#pane.startAngle)
                   * + 360.
                   *
                   * @sample {highcharts} highcharts/demo/gauge-vu-meter/
                   *         VU-meter with custom start and end angle
                   *
                   * @type      {number}
                   * @since     2.3.0
                   * @product   highcharts
                   * @apioption pane.endAngle
                   */
                  /**
                   * The center of a polar chart or angular gauge, given as an array
                   * of [x, y] positions. Positions can be given as integers that
                   * transform to pixels, or as percentages of the plot area size.
                   *
                   * @sample {highcharts} highcharts/demo/gauge-vu-meter/
                   *         Two gauges with different center
                   *
                   * @type    {Array<string|number>}
                   * @default ["50%", "50%"]
                   * @since   2.3.0
                   * @product highcharts
                   */
                  center: ["50%", "50%"],
                  /**
                   * The size of the pane, either as a number defining pixels, or a
                   * percentage defining a percentage of the available plot area (the
                   * smallest of the plot height or plot width).
                   *
                   * @sample {highcharts} highcharts/demo/gauge-vu-meter/
                   *         Smaller size
                   *
                   * @type    {number|string}
                   * @product highcharts
                   */
                  size: "85%",
                  /**
                   * The inner size of the pane, either as a number defining pixels, or a
                   * percentage defining a percentage of the pane's size.
                   *
                   * @sample {highcharts} highcharts/series-polar/column-inverted-inner
                   *         The inner size set to 20%
                   *
                   * @type    {number|string}
                   * @product highcharts
                   */
                  innerSize: "0%",
                  /**
                   * The start angle of the polar X axis or gauge axis, given in degrees
                   * where 0 is north. Defaults to 0.
                   *
                   * @sample {highcharts} highcharts/demo/gauge-vu-meter/
                   *         VU-meter with custom start and end angle
                   *
                   * @since   2.3.0
                   * @product highcharts
                   */
                  startAngle: 0
                };
                this.defaultBackgroundOptions = {
                  /**
                   * The class name for this background.
                   *
                   * @sample {highcharts} highcharts/css/pane/
                   *         Panes styled by CSS
                   * @sample {highstock} highcharts/css/pane/
                   *         Panes styled by CSS
                   * @sample {highmaps} highcharts/css/pane/
                   *         Panes styled by CSS
                   *
                   * @type      {string}
                   * @default   highcharts-pane
                   * @since     5.0.0
                   * @apioption pane.background.className
                   */
                  /**
                   * The shape of the pane background. When `solid`, the background
                   * is circular. When `arc`, the background extends only from the min
                   * to the max of the value axis.
                   *
                   * @type    {Highcharts.PaneBackgroundShapeValue}
                   * @since   2.3.0
                   * @product highcharts
                   */
                  shape: "circle",
                  /**
                   * The pixel border width of the pane background.
                   *
                   * @since 2.3.0
                   * @product highcharts
                   */
                  borderWidth: 1,
                  /**
                   * The pane background border color.
                   *
                   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                   * @since   2.3.0
                   * @product highcharts
                   */
                  borderColor: "#cccccc",
                  /**
                   * The background color or gradient for the pane.
                   *
                   * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                   * @default { linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 }, stops: [[0, #ffffff], [1, #e6e6e6]] }
                   * @since   2.3.0
                   * @product highcharts
                   */
                  backgroundColor: {
                    /** @ignore-option */
                    linearGradient: { x1: 0, y1: 0, x2: 0, y2: 1 },
                    /** @ignore-option */
                    stops: [
                      [
                        0,
                        "#ffffff"
                        /* Palette.backgroundColor */
                      ],
                      [
                        1,
                        "#e6e6e6"
                        /* Palette.neutralColor10 */
                      ]
                    ]
                  },
                  /** @ignore-option */
                  from: -Number.MAX_VALUE,
                  /**
                   * The inner radius of the pane background. Can be either numeric
                   * (pixels) or a percentage string.
                   *
                   * @type    {number|string}
                   * @since   2.3.0
                   * @product highcharts
                   */
                  innerRadius: 0,
                  /** @ignore-option */
                  to: Number.MAX_VALUE,
                  /**
                   * The outer radius of the circular pane background. Can be either
                   * numeric (pixels) or a percentage string.
                   *
                   * @type     {number|string}
                   * @since    2.3.0
                   * @product  highcharts
                   */
                  outerRadius: "105%"
                };
                this.init(options, chart);
              }
              Pane2.prototype.init = function(options, chart) {
                this.chart = chart;
                this.background = [];
                chart.pane.push(this);
                this.setOptions(options);
              };
              Pane2.prototype.setOptions = function(options) {
                this.options = options = merge(this.defaultOptions, this.chart.angular ? { background: {} } : void 0, options);
              };
              Pane2.prototype.render = function() {
                var options = this.options, backgroundOption = this.options.background, renderer = this.chart.renderer, len, i;
                if (!this.group) {
                  this.group = renderer.g("pane-group").attr({ zIndex: options.zIndex || 0 }).add();
                }
                this.updateCenter();
                if (backgroundOption) {
                  backgroundOption = splat(backgroundOption);
                  len = Math.max(backgroundOption.length, this.background.length || 0);
                  for (i = 0; i < len; i++) {
                    if (backgroundOption[i] && this.axis) {
                      this.renderBackground(merge(this.defaultBackgroundOptions, backgroundOption[i]), i);
                    } else if (this.background[i]) {
                      this.background[i] = this.background[i].destroy();
                      this.background.splice(i, 1);
                    }
                  }
                }
              };
              Pane2.prototype.renderBackground = function(backgroundOptions, i) {
                var method = "animate", attribs = {
                  "class": "highcharts-pane " + (backgroundOptions.className || "")
                };
                if (!this.chart.styledMode) {
                  extend2(attribs, {
                    "fill": backgroundOptions.backgroundColor,
                    "stroke": backgroundOptions.borderColor,
                    "stroke-width": backgroundOptions.borderWidth
                  });
                }
                if (!this.background[i]) {
                  this.background[i] = this.chart.renderer.path().add(this.group);
                  method = "attr";
                }
                this.background[i][method]({
                  "d": this.axis.getPlotBandPath(backgroundOptions.from, backgroundOptions.to, backgroundOptions)
                }).attr(attribs);
              };
              Pane2.prototype.updateCenter = function(axis) {
                this.center = (axis || this.axis || {}).center = CU.getCenter.call(this);
              };
              Pane2.prototype.update = function(options, redraw) {
                merge(true, this.options, options);
                this.setOptions(this.options);
                this.render();
                this.chart.axes.forEach(function(axis) {
                  if (axis.pane === this) {
                    axis.pane = null;
                    axis.update({}, redraw);
                  }
                }, this);
              };
              return Pane2;
            }()
          );
          function isInsidePane(x, y, center, startAngle, endAngle) {
            var insideSlice = true;
            var cx = center[0], cy = center[1];
            var distance = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(y - cy, 2));
            if (defined(startAngle) && defined(endAngle)) {
              var angle = Math.atan2(
                correctFloat(y - cy, 8),
                correctFloat(x - cx, 8)
              );
              if (endAngle !== startAngle) {
                if (startAngle > endAngle) {
                  insideSlice = angle >= startAngle && angle <= Math.PI || angle <= endAngle && angle >= -Math.PI;
                } else {
                  insideSlice = angle >= startAngle && angle <= correctFloat(endAngle, 8);
                }
              }
            }
            return distance <= Math.ceil(center[2] / 2) && insideSlice;
          }
          Chart.prototype.getHoverPane = function(eventArgs) {
            var chart = this;
            var hoverPane;
            if (eventArgs) {
              chart.pane.forEach(function(pane) {
                var x = eventArgs.chartX - chart.plotLeft, y = eventArgs.chartY - chart.plotTop;
                if (isInsidePane(x, y, pane.center)) {
                  hoverPane = pane;
                }
              });
            }
            return hoverPane;
          };
          addEvent(Chart, "afterIsInsidePlot", function(e) {
            var _a;
            var chart = this;
            if (chart.polar) {
              if (e.options.inverted) {
                _a = [e.y, e.x], e.x = _a[0], e.y = _a[1];
              }
              e.isInsidePlot = chart.pane.some(function(pane) {
                return isInsidePane(e.x, e.y, pane.center, pane.axis && pane.axis.normalizedStartAngleRad, pane.axis && pane.axis.normalizedEndAngleRad);
              });
            }
          });
          addEvent(Pointer, "beforeGetHoverData", function(eventArgs) {
            var chart = this.chart;
            if (chart.polar) {
              chart.hoverPane = chart.getHoverPane(eventArgs);
              eventArgs.filter = function(s) {
                return s.visible && !(!eventArgs.shared && s.directTouch) && // #3821
                pick(s.options.enableMouseTracking, true) && (!chart.hoverPane || s.xAxis.pane === chart.hoverPane);
              };
            } else {
              chart.hoverPane = void 0;
            }
          });
          addEvent(Pointer, "afterGetHoverData", function(eventArgs) {
            var chart = this.chart;
            if (eventArgs.hoverPoint && eventArgs.hoverPoint.plotX && eventArgs.hoverPoint.plotY && chart.hoverPane && !isInsidePane(eventArgs.hoverPoint.plotX, eventArgs.hoverPoint.plotY, chart.hoverPane.center)) {
              eventArgs.hoverPoint = void 0;
            }
          });
          H.Pane = Pane;
          return H.Pane;
        });
        _registerModule(_modules, "Series/AreaRange/AreaRangePoint.js", [_modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var _a = SeriesRegistry.seriesTypes.area.prototype, AreaPoint = _a.pointClass, areaProto = _a.pointClass.prototype;
          var defined = U.defined, isNumber = U.isNumber;
          var AreaRangePoint = (
            /** @class */
            function(_super) {
              __extends(AreaRangePoint2, _super);
              function AreaRangePoint2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.high = void 0;
                _this.low = void 0;
                _this.options = void 0;
                _this.plotX = void 0;
                _this.series = void 0;
                return _this;
              }
              AreaRangePoint2.prototype.setState = function() {
                var prevState = this.state, series = this.series, isPolar = series.chart.polar;
                if (!defined(this.plotHigh)) {
                  this.plotHigh = series.yAxis.toPixels(this.high, true);
                }
                if (!defined(this.plotLow)) {
                  this.plotLow = this.plotY = series.yAxis.toPixels(this.low, true);
                }
                if (series.stateMarkerGraphic) {
                  series.lowerStateMarkerGraphic = series.stateMarkerGraphic;
                  series.stateMarkerGraphic = series.upperStateMarkerGraphic;
                }
                this.graphic = this.graphics && this.graphics[1];
                this.plotY = this.plotHigh;
                if (isPolar && isNumber(this.plotHighX)) {
                  this.plotX = this.plotHighX;
                }
                areaProto.setState.apply(this, arguments);
                this.state = prevState;
                this.plotY = this.plotLow;
                this.graphic = this.graphics && this.graphics[0];
                if (isPolar && isNumber(this.plotLowX)) {
                  this.plotX = this.plotLowX;
                }
                if (series.stateMarkerGraphic) {
                  series.upperStateMarkerGraphic = series.stateMarkerGraphic;
                  series.stateMarkerGraphic = series.lowerStateMarkerGraphic;
                  series.lowerStateMarkerGraphic = void 0;
                }
                areaProto.setState.apply(this, arguments);
              };
              AreaRangePoint2.prototype.haloPath = function() {
                var isPolar = this.series.chart.polar;
                var path = [];
                this.plotY = this.plotLow;
                if (isPolar && isNumber(this.plotLowX)) {
                  this.plotX = this.plotLowX;
                }
                if (this.isInside) {
                  path = areaProto.haloPath.apply(this, arguments);
                }
                this.plotY = this.plotHigh;
                if (isPolar && isNumber(this.plotHighX)) {
                  this.plotX = this.plotHighX;
                }
                if (this.isTopInside) {
                  path = path.concat(areaProto.haloPath.apply(this, arguments));
                }
                return path;
              };
              AreaRangePoint2.prototype.isValid = function() {
                return isNumber(this.low) && isNumber(this.high);
              };
              return AreaRangePoint2;
            }(AreaPoint)
          );
          return AreaRangePoint;
        });
        _registerModule(_modules, "Series/AreaRange/AreaRangeSeries.js", [_modules["Series/AreaRange/AreaRangePoint.js"], _modules["Core/Globals.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(AreaRangePoint, H, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var noop2 = H.noop;
          var _a = SeriesRegistry.seriesTypes, AreaSeries = _a.area, areaProto = _a.area.prototype, columnProto = _a.column.prototype;
          var addEvent = U.addEvent, defined = U.defined, extend2 = U.extend, isArray = U.isArray, isNumber = U.isNumber, pick = U.pick, merge = U.merge;
          var areaRangeSeriesOptions = {
            /**
             * @see [fillColor](#plotOptions.arearange.fillColor)
             * @see [fillOpacity](#plotOptions.arearange.fillOpacity)
             *
             * @apioption plotOptions.arearange.color
             */
            /**
             * @default   low
             * @apioption plotOptions.arearange.colorKey
             */
            /**
             * @see [color](#plotOptions.arearange.color)
             * @see [fillOpacity](#plotOptions.arearange.fillOpacity)
             *
             * @apioption plotOptions.arearange.fillColor
             */
            /**
             * @see [color](#plotOptions.arearange.color)
             * @see [fillColor](#plotOptions.arearange.fillColor)
             *
             * @default   {highcharts} 0.75
             * @default   {highstock} 0.75
             * @apioption plotOptions.arearange.fillOpacity
             */
            /**
                 * Whether to apply a drop shadow to the graph line. Since 2.3 the
                 * shadow can be an object configuration containing `color`,
            `offsetX`,
                 * `offsetY`,
            `opacity` and `width`.
                 *
                 * @type      {boolean|Highcharts.ShadowOptionsObject}
                 * @product   highcharts
                 * @apioption plotOptions.arearange.shadow
                 */
            /**
             * Pixel width of the arearange graph line.
             *
             * @since 2.3.0
             *
             * @private
             */
            lineWidth: 1,
            /**
             * @type {number|null}
             */
            threshold: null,
            tooltip: {
              pointFormat: '<span style="color:{series.color}">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
            },
            /**
             * Whether the whole area or just the line should respond to mouseover
             * tooltips and other mouse or touch events.
             *
             * @since 2.3.0
             *
             * @private
             */
            trackByArea: true,
            /**
                 * Extended data labels for range series types. Range series data
                 * labels use no `x` and `y` options. Instead,
            they have `xLow`,
                 * `xHigh`,
            `yLow` and `yHigh` options to allow the higher and lower
                 * data label sets individually.
                 *
                 * @declare Highcharts.SeriesAreaRangeDataLabelsOptionsObject
                 * @exclude x,
            y
                 * @since   2.3.0
                 * @product highcharts highstock
                 *
                 * @private
                 */
            dataLabels: {
              align: void 0,
              verticalAlign: void 0,
              /**
               * X offset of the lower data labels relative to the point value.
               *
               * @sample highcharts/plotoptions/arearange-datalabels/
               *         Data labels on range series
               * @sample highcharts/plotoptions/arearange-datalabels/
               *         Data labels on range series
               */
              xLow: 0,
              /**
               * X offset of the higher data labels relative to the point value.
               *
               * @sample highcharts/plotoptions/arearange-datalabels/
               *         Data labels on range series
               */
              xHigh: 0,
              /**
               * Y offset of the lower data labels relative to the point value.
               *
               * @sample highcharts/plotoptions/arearange-datalabels/
               *         Data labels on range series
               */
              yLow: 0,
              /**
               * Y offset of the higher data labels relative to the point value.
               *
               * @sample highcharts/plotoptions/arearange-datalabels/
               *         Data labels on range series
               */
              yHigh: 0
            }
          };
          var AreaRangeSeries = (
            /** @class */
            function(_super) {
              __extends(AreaRangeSeries2, _super);
              function AreaRangeSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.data = void 0;
                _this.options = void 0;
                _this.points = void 0;
                _this.lowerStateMarkerGraphic = void 0;
                _this.xAxis = void 0;
                return _this;
              }
              AreaRangeSeries2.prototype.toYData = function(point) {
                return [point.low, point.high];
              };
              AreaRangeSeries2.prototype.highToXY = function(point) {
                var chart = this.chart, xy = this.xAxis.postTranslate(
                  point.rectPlotX || 0,
                  this.yAxis.len - (point.plotHigh || 0)
                );
                point.plotHighX = xy.x - chart.plotLeft;
                point.plotHigh = xy.y - chart.plotTop;
                point.plotLowX = point.plotX;
              };
              AreaRangeSeries2.prototype.getGraphPath = function(points) {
                var highPoints = [], highAreaPoints = [], getGraphPath = areaProto.getGraphPath, options = this.options, polar = this.chart.polar, connectEnds = polar && options.connectEnds !== false, connectNulls = options.connectNulls;
                var i, point, pointShim, step = options.step;
                points = points || this.points;
                i = points.length;
                while (i--) {
                  point = points[i];
                  var highAreaPoint = polar ? {
                    plotX: point.rectPlotX,
                    plotY: point.yBottom,
                    doCurve: false
                    // #5186, gaps in areasplinerange fill
                  } : {
                    plotX: point.plotX,
                    plotY: point.plotY,
                    doCurve: false
                    // #5186, gaps in areasplinerange fill
                  };
                  if (!point.isNull && !connectEnds && !connectNulls && (!points[i + 1] || points[i + 1].isNull)) {
                    highAreaPoints.push(highAreaPoint);
                  }
                  pointShim = {
                    polarPlotY: point.polarPlotY,
                    rectPlotX: point.rectPlotX,
                    yBottom: point.yBottom,
                    // plotHighX is for polar charts
                    plotX: pick(point.plotHighX, point.plotX),
                    plotY: point.plotHigh,
                    isNull: point.isNull
                  };
                  highAreaPoints.push(pointShim);
                  highPoints.push(pointShim);
                  if (!point.isNull && !connectEnds && !connectNulls && (!points[i - 1] || points[i - 1].isNull)) {
                    highAreaPoints.push(highAreaPoint);
                  }
                }
                var lowerPath = getGraphPath.call(
                  this,
                  points
                );
                if (step) {
                  if (step === true) {
                    step = "left";
                  }
                  options.step = {
                    left: "right",
                    center: "center",
                    right: "left"
                  }[step];
                }
                var higherPath = getGraphPath.call(
                  this,
                  highPoints
                );
                var higherAreaPath = getGraphPath.call(
                  this,
                  highAreaPoints
                );
                options.step = step;
                var linePath = [].concat(
                  lowerPath,
                  higherPath
                );
                if (!this.chart.polar && higherAreaPath[0] && higherAreaPath[0][0] === "M") {
                  higherAreaPath[0] = [
                    "L",
                    higherAreaPath[0][1],
                    higherAreaPath[0][2]
                  ];
                }
                this.graphPath = linePath;
                this.areaPath = lowerPath.concat(higherAreaPath);
                linePath.isArea = true;
                linePath.xMap = lowerPath.xMap;
                this.areaPath.xMap = lowerPath.xMap;
                return linePath;
              };
              AreaRangeSeries2.prototype.drawDataLabels = function() {
                var data = this.points, length = data.length, originalDataLabels = [], dataLabelOptions = this.options.dataLabels, inverted = this.chart.inverted;
                var i, point, up, upperDataLabelOptions, lowerDataLabelOptions;
                if (dataLabelOptions) {
                  if (isArray(dataLabelOptions)) {
                    upperDataLabelOptions = dataLabelOptions[0] || {
                      enabled: false
                    };
                    lowerDataLabelOptions = dataLabelOptions[1] || {
                      enabled: false
                    };
                  } else {
                    upperDataLabelOptions = extend2({}, dataLabelOptions);
                    upperDataLabelOptions.x = dataLabelOptions.xHigh;
                    upperDataLabelOptions.y = dataLabelOptions.yHigh;
                    lowerDataLabelOptions = extend2({}, dataLabelOptions);
                    lowerDataLabelOptions.x = dataLabelOptions.xLow;
                    lowerDataLabelOptions.y = dataLabelOptions.yLow;
                  }
                  if (upperDataLabelOptions.enabled || this._hasPointLabels) {
                    i = length;
                    while (i--) {
                      point = data[i];
                      if (point) {
                        var _a2 = point.plotHigh, plotHigh = _a2 === void 0 ? 0 : _a2, _b = point.plotLow, plotLow = _b === void 0 ? 0 : _b;
                        up = upperDataLabelOptions.inside ? plotHigh < plotLow : plotHigh > plotLow;
                        point.y = point.high;
                        point._plotY = point.plotY;
                        point.plotY = plotHigh;
                        originalDataLabels[i] = point.dataLabel;
                        point.dataLabel = point.dataLabelUpper;
                        point.below = up;
                        if (inverted) {
                          if (!upperDataLabelOptions.align) {
                            upperDataLabelOptions.align = up ? "right" : "left";
                          }
                        } else {
                          if (!upperDataLabelOptions.verticalAlign) {
                            upperDataLabelOptions.verticalAlign = up ? "top" : "bottom";
                          }
                        }
                      }
                    }
                    this.options.dataLabels = upperDataLabelOptions;
                    if (areaProto.drawDataLabels) {
                      areaProto.drawDataLabels.apply(this, arguments);
                    }
                    i = length;
                    while (i--) {
                      point = data[i];
                      if (point) {
                        point.dataLabelUpper = point.dataLabel;
                        point.dataLabel = originalDataLabels[i];
                        delete point.dataLabels;
                        point.y = point.low;
                        point.plotY = point._plotY;
                      }
                    }
                  }
                  if (lowerDataLabelOptions.enabled || this._hasPointLabels) {
                    i = length;
                    while (i--) {
                      point = data[i];
                      if (point) {
                        var _c = point.plotHigh, plotHigh = _c === void 0 ? 0 : _c, _d = point.plotLow, plotLow = _d === void 0 ? 0 : _d;
                        up = lowerDataLabelOptions.inside ? plotHigh < plotLow : plotHigh > plotLow;
                        point.below = !up;
                        if (inverted) {
                          if (!lowerDataLabelOptions.align) {
                            lowerDataLabelOptions.align = up ? "left" : "right";
                          }
                        } else {
                          if (!lowerDataLabelOptions.verticalAlign) {
                            lowerDataLabelOptions.verticalAlign = up ? "bottom" : "top";
                          }
                        }
                      }
                    }
                    this.options.dataLabels = lowerDataLabelOptions;
                    if (areaProto.drawDataLabels) {
                      areaProto.drawDataLabels.apply(this, arguments);
                    }
                  }
                  if (upperDataLabelOptions.enabled) {
                    i = length;
                    while (i--) {
                      point = data[i];
                      if (point) {
                        point.dataLabels = [
                          point.dataLabelUpper,
                          point.dataLabel
                        ].filter(function(label) {
                          return !!label;
                        });
                      }
                    }
                  }
                  this.options.dataLabels = dataLabelOptions;
                }
              };
              AreaRangeSeries2.prototype.alignDataLabel = function() {
                columnProto.alignDataLabel.apply(this, arguments);
              };
              AreaRangeSeries2.prototype.drawPoints = function() {
                var series = this, pointLength = series.points.length;
                var i, point;
                areaProto.drawPoints.apply(series, arguments);
                i = 0;
                while (i < pointLength) {
                  point = series.points[i];
                  point.graphics = point.graphics || [];
                  point.origProps = {
                    plotY: point.plotY,
                    plotX: point.plotX,
                    isInside: point.isInside,
                    negative: point.negative,
                    zone: point.zone,
                    y: point.y
                  };
                  if (point.graphic || point.graphics[0]) {
                    point.graphics[0] = point.graphic;
                  }
                  point.graphic = point.graphics[1];
                  point.plotY = point.plotHigh;
                  if (defined(point.plotHighX)) {
                    point.plotX = point.plotHighX;
                  }
                  point.y = pick(point.high, point.origProps.y);
                  point.negative = point.y < (series.options.threshold || 0);
                  if (series.zones.length) {
                    point.zone = point.getZone();
                  }
                  if (!series.chart.polar) {
                    point.isInside = point.isTopInside = typeof point.plotY !== "undefined" && point.plotY >= 0 && point.plotY <= series.yAxis.len && // #3519
                    point.plotX >= 0 && point.plotX <= series.xAxis.len;
                  }
                  i++;
                }
                areaProto.drawPoints.apply(series, arguments);
                i = 0;
                while (i < pointLength) {
                  point = series.points[i];
                  point.graphics = point.graphics || [];
                  if (point.graphic || point.graphics[1]) {
                    point.graphics[1] = point.graphic;
                  }
                  point.graphic = point.graphics[0];
                  if (point.origProps) {
                    extend2(point, point.origProps);
                    delete point.origProps;
                  }
                  i++;
                }
              };
              AreaRangeSeries2.defaultOptions = merge(AreaSeries.defaultOptions, areaRangeSeriesOptions);
              return AreaRangeSeries2;
            }(AreaSeries)
          );
          addEvent(AreaRangeSeries, "afterTranslate", function() {
            var _this = this;
            if (this.pointArrayMap.join(",") === "low,high") {
              this.points.forEach(function(point) {
                var high = point.high, plotY = point.plotY;
                if (point.isNull) {
                  point.plotY = void 0;
                } else {
                  point.plotLow = plotY;
                  point.plotHigh = isNumber(high) ? _this.yAxis.translate(_this.dataModify ? _this.dataModify.modifyValue(high) : high, false, true, void 0, true) : void 0;
                  if (_this.dataModify) {
                    point.yBottom = point.plotHigh;
                  }
                }
              });
            }
          }, { order: 0 });
          addEvent(AreaRangeSeries, "afterTranslate", function() {
            var _this = this;
            var inverted = this.chart.inverted;
            this.points.forEach(function(point) {
              if (_this.chart.polar) {
                _this.highToXY(point);
                point.plotLow = point.plotY;
                point.tooltipPos = [
                  ((point.plotHighX || 0) + (point.plotLowX || 0)) / 2,
                  ((point.plotHigh || 0) + (point.plotLow || 0)) / 2
                ];
              } else {
                var tooltipPos = point.pos(
                  false,
                  point.plotLow
                ), posHigh = point.pos(
                  false,
                  point.plotHigh
                );
                if (tooltipPos && posHigh) {
                  tooltipPos[0] = (tooltipPos[0] + posHigh[0]) / 2;
                  tooltipPos[1] = (tooltipPos[1] + posHigh[1]) / 2;
                }
                point.tooltipPos = tooltipPos;
              }
            });
          }, { order: 3 });
          extend2(AreaRangeSeries.prototype, {
            deferTranslatePolar: true,
            pointArrayMap: ["low", "high"],
            pointClass: AreaRangePoint,
            pointValKey: "low",
            setStackedPoints: noop2
          });
          SeriesRegistry.registerSeriesType("arearange", AreaRangeSeries);
          "";
          return AreaRangeSeries;
        });
        _registerModule(_modules, "Series/AreaSplineRange/AreaSplineRangeSeries.js", [_modules["Series/AreaRange/AreaRangeSeries.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(AreaRangeSeries, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var splineProto = SeriesRegistry.seriesTypes.spline.prototype;
          var merge = U.merge, extend2 = U.extend;
          var AreaSplineRangeSeries = (
            /** @class */
            function(_super) {
              __extends(AreaSplineRangeSeries2, _super);
              function AreaSplineRangeSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.options = void 0;
                _this.data = void 0;
                _this.points = void 0;
                return _this;
              }
              AreaSplineRangeSeries2.defaultOptions = merge(AreaRangeSeries.defaultOptions);
              return AreaSplineRangeSeries2;
            }(AreaRangeSeries)
          );
          extend2(AreaSplineRangeSeries.prototype, {
            getPointSpline: splineProto.getPointSpline
          });
          SeriesRegistry.registerSeriesType("areasplinerange", AreaSplineRangeSeries);
          "";
          return AreaSplineRangeSeries;
        });
        _registerModule(_modules, "Series/BoxPlot/BoxPlotSeries.js", [_modules["Series/Column/ColumnSeries.js"], _modules["Core/Globals.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(ColumnSeries, H, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var noop2 = H.noop;
          var extend2 = U.extend, merge = U.merge, pick = U.pick;
          var BoxPlotSeries = (
            /** @class */
            function(_super) {
              __extends(BoxPlotSeries2, _super);
              function BoxPlotSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.data = void 0;
                _this.options = void 0;
                _this.points = void 0;
                return _this;
              }
              BoxPlotSeries2.prototype.pointAttribs = function() {
                return {};
              };
              BoxPlotSeries2.prototype.translate = function() {
                var series = this, yAxis = series.yAxis, pointArrayMap = series.pointArrayMap;
                _super.prototype.translate.apply(series);
                series.points.forEach(function(point) {
                  pointArrayMap.forEach(function(key) {
                    if (point[key] !== null) {
                      point[key + "Plot"] = yAxis.translate(point[key], 0, 1, 0, 1);
                    }
                  });
                  point.plotHigh = point.highPlot;
                });
              };
              BoxPlotSeries2.prototype.drawPoints = function() {
                var series = this, points = series.points, options = series.options, chart = series.chart, renderer = chart.renderer, q1Plot, q3Plot, highPlot, lowPlot, medianPlot, medianPath, crispCorr, crispX = 0, boxPath, width, left, right, halfWidth, doQuartiles = series.doQuartiles !== false, pointWiskerLength, whiskerLength = series.options.whiskerLength;
                points.forEach(function(point) {
                  var graphic = point.graphic, verb = graphic ? "animate" : "attr", shapeArgs = point.shapeArgs, boxAttr = {}, stemAttr = {}, whiskersAttr = {}, medianAttr = {}, color2 = point.color || series.color;
                  if (typeof point.plotY !== "undefined") {
                    width = Math.round(shapeArgs.width);
                    left = Math.floor(shapeArgs.x);
                    right = left + width;
                    halfWidth = Math.round(width / 2);
                    q1Plot = Math.floor(doQuartiles ? point.q1Plot : point.lowPlot);
                    q3Plot = Math.floor(doQuartiles ? point.q3Plot : point.lowPlot);
                    highPlot = Math.floor(point.highPlot);
                    lowPlot = Math.floor(point.lowPlot);
                    if (!graphic) {
                      point.graphic = graphic = renderer.g("point").add(series.group);
                      point.stem = renderer.path().addClass("highcharts-boxplot-stem").add(graphic);
                      if (whiskerLength) {
                        point.whiskers = renderer.path().addClass("highcharts-boxplot-whisker").add(graphic);
                      }
                      if (doQuartiles) {
                        point.box = renderer.path(boxPath).addClass("highcharts-boxplot-box").add(graphic);
                      }
                      point.medianShape = renderer.path(medianPath).addClass("highcharts-boxplot-median").add(graphic);
                    }
                    if (!chart.styledMode) {
                      stemAttr.stroke = point.stemColor || options.stemColor || color2;
                      stemAttr["stroke-width"] = pick(point.stemWidth, options.stemWidth, options.lineWidth);
                      stemAttr.dashstyle = point.stemDashStyle || options.stemDashStyle || options.dashStyle;
                      point.stem.attr(stemAttr);
                      if (whiskerLength) {
                        whiskersAttr.stroke = point.whiskerColor || options.whiskerColor || color2;
                        whiskersAttr["stroke-width"] = pick(point.whiskerWidth, options.whiskerWidth, options.lineWidth);
                        whiskersAttr.dashstyle = point.whiskerDashStyle || options.whiskerDashStyle || options.dashStyle;
                        point.whiskers.attr(whiskersAttr);
                      }
                      if (doQuartiles) {
                        boxAttr.fill = point.fillColor || options.fillColor || color2;
                        boxAttr.stroke = options.lineColor || color2;
                        boxAttr["stroke-width"] = options.lineWidth || 0;
                        boxAttr.dashstyle = point.boxDashStyle || options.boxDashStyle || options.dashStyle;
                        point.box.attr(boxAttr);
                      }
                      medianAttr.stroke = point.medianColor || options.medianColor || color2;
                      medianAttr["stroke-width"] = pick(point.medianWidth, options.medianWidth, options.lineWidth);
                      medianAttr.dashstyle = point.medianDashStyle || options.medianDashStyle || options.dashStyle;
                      point.medianShape.attr(medianAttr);
                    }
                    var d = void 0;
                    crispCorr = point.stem.strokeWidth() % 2 / 2;
                    crispX = left + halfWidth + crispCorr;
                    d = [
                      // stem up
                      ["M", crispX, q3Plot],
                      ["L", crispX, highPlot],
                      // stem down
                      ["M", crispX, q1Plot],
                      ["L", crispX, lowPlot]
                    ];
                    point.stem[verb]({ d });
                    if (doQuartiles) {
                      crispCorr = point.box.strokeWidth() % 2 / 2;
                      q1Plot = Math.floor(q1Plot) + crispCorr;
                      q3Plot = Math.floor(q3Plot) + crispCorr;
                      left += crispCorr;
                      right += crispCorr;
                      d = [
                        ["M", left, q3Plot],
                        ["L", left, q1Plot],
                        ["L", right, q1Plot],
                        ["L", right, q3Plot],
                        ["L", left, q3Plot],
                        ["Z"]
                      ];
                      point.box[verb]({ d });
                    }
                    if (whiskerLength) {
                      crispCorr = point.whiskers.strokeWidth() % 2 / 2;
                      highPlot = highPlot + crispCorr;
                      lowPlot = lowPlot + crispCorr;
                      pointWiskerLength = /%$/.test(whiskerLength) ? halfWidth * parseFloat(whiskerLength) / 100 : whiskerLength / 2;
                      d = [
                        // High whisker
                        ["M", crispX - pointWiskerLength, highPlot],
                        ["L", crispX + pointWiskerLength, highPlot],
                        // Low whisker
                        ["M", crispX - pointWiskerLength, lowPlot],
                        ["L", crispX + pointWiskerLength, lowPlot]
                      ];
                      point.whiskers[verb]({ d });
                    }
                    medianPlot = Math.round(point.medianPlot);
                    crispCorr = point.medianShape.strokeWidth() % 2 / 2;
                    medianPlot = medianPlot + crispCorr;
                    d = [
                      ["M", left, medianPlot],
                      ["L", right, medianPlot]
                    ];
                    point.medianShape[verb]({ d });
                  }
                });
              };
              BoxPlotSeries2.prototype.toYData = function(point) {
                return [point.low, point.q1, point.median, point.q3, point.high];
              };
              BoxPlotSeries2.defaultOptions = merge(ColumnSeries.defaultOptions, {
                /**
                 * @type {number|null}
                 */
                threshold: null,
                tooltip: {
                  pointFormat: '<span style="color:{point.color}">\u25CF</span> <b>{series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'
                },
                /**
                 * The length of the whiskers, the horizontal lines marking low and
                 * high values. It can be a numerical pixel value, or a percentage
                 * value of the box width. Set `0` to disable whiskers.
                 *
                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
                 *         True by default
                 *
                 * @type    {number|string}
                 * @since   3.0
                 * @product highcharts
                 */
                whiskerLength: "50%",
                /**
                 * The fill color of the box.
                 *
                 * In styled mode, the fill color can be set with the
                 * `.highcharts-boxplot-box` class.
                 *
                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
                 *         Box plot styling
                 *
                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @default #ffffff
                 * @since   3.0
                 * @product highcharts
                 */
                fillColor: "#ffffff",
                /**
                 * The width of the line surrounding the box. If any of
                 * [stemWidth](#plotOptions.boxplot.stemWidth),
                 * [medianWidth](#plotOptions.boxplot.medianWidth)
                 * or [whiskerWidth](#plotOptions.boxplot.whiskerWidth) are `null`,
                 * the lineWidth also applies to these lines.
                 *
                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
                 *         Box plot styling
                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
                 *         Error bar styling
                 *
                 * @since   3.0
                 * @product highcharts
                 */
                lineWidth: 1,
                /**
                 * The color of the median line. If `undefined`, the general series
                 * color applies.
                 *
                 * In styled mode, the median stroke width can be set with the
                 * `.highcharts-boxplot-median` class.
                 *
                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
                 *         Box plot styling
                 * @sample {highcharts} highcharts/css/boxplot/
                 *         Box plot in styled mode
                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
                 *         Error bar styling
                 *
                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject}
                 * @since     3.0
                 * @product   highcharts
                 * @apioption plotOptions.boxplot.medianColor
                 */
                /**
                 * The pixel width of the median line. If `null`, the
                 * [lineWidth](#plotOptions.boxplot.lineWidth) is used.
                 *
                 * In styled mode, the median stroke width can be set with the
                 * `.highcharts-boxplot-median` class.
                 *
                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
                 *         Box plot styling
                 * @sample {highcharts} highcharts/css/boxplot/
                 *         Box plot in styled mode
                 *
                 * @type    {number|null}
                 * @since   3.0
                 * @product highcharts
                 */
                medianWidth: 2,
                /*
                // States are not working and are removed from docs.
                // Refer to: #2340
                states: {
                    hover: {
                        brightness: -0.3
                    }
                },
                */
                /**
                 * The color of the stem, the vertical line extending from the box to
                 * the whiskers. If `undefined`, the series color is used.
                 *
                 * In styled mode, the stem stroke can be set with the
                 * `.highcharts-boxplot-stem` class.
                 *
                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
                 *         Box plot styling
                 * @sample {highcharts} highcharts/css/boxplot/
                 *         Box plot in styled mode
                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
                 *         Error bar styling
                 *
                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @since     3.0
                 * @product   highcharts
                 * @apioption plotOptions.boxplot.stemColor
                 */
                /**
                 * The dash style of the box.
                 *
                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
                 *         Box plot styling
                 * @sample {highcharts} highcharts/css/boxplot/
                 *         Box plot in styled mode
                 *
                 * @type      {Highcharts.DashStyleValue}
                 * @default   Solid
                 * @since 8.1.0
                 * @product   highcharts
                 * @apioption plotOptions.boxplot.boxDashStyle
                 */
                /**
                 * The dash style of the median.
                 *
                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
                 *         Box plot styling
                 * @sample {highcharts} highcharts/css/boxplot/
                 *         Box plot in styled mode
                 *
                 * @type      {Highcharts.DashStyleValue}
                 * @default   Solid
                 * @since 8.1.0
                 * @product   highcharts
                 * @apioption plotOptions.boxplot.medianDashStyle
                 */
                /**
                 * The dash style of the stem, the vertical line extending from the
                 * box to the whiskers.
                 *
                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
                 *         Box plot styling
                 * @sample {highcharts} highcharts/css/boxplot/
                 *         Box plot in styled mode
                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
                 *         Error bar styling
                 *
                 * @type      {Highcharts.DashStyleValue}
                 * @default   Solid
                 * @since     3.0
                 * @product   highcharts
                 * @apioption plotOptions.boxplot.stemDashStyle
                 */
                /**
                 * The dash style of the whiskers.
                 *
                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
                 *         Box plot styling
                 * @sample {highcharts} highcharts/css/boxplot/
                 *         Box plot in styled mode
                 *
                 * @type      {Highcharts.DashStyleValue}
                 * @default   Solid
                 * @since 8.1.0
                 * @product   highcharts
                 * @apioption plotOptions.boxplot.whiskerDashStyle
                 */
                /**
                 * The width of the stem, the vertical line extending from the box to
                 * the whiskers. If `undefined`, the width is inherited from the
                 * [lineWidth](#plotOptions.boxplot.lineWidth) option.
                 *
                 * In styled mode, the stem stroke width can be set with the
                 * `.highcharts-boxplot-stem` class.
                 *
                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
                 *         Box plot styling
                 * @sample {highcharts} highcharts/css/boxplot/
                 *         Box plot in styled mode
                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
                 *         Error bar styling
                 *
                 * @type      {number}
                 * @since     3.0
                 * @product   highcharts
                 * @apioption plotOptions.boxplot.stemWidth
                 */
                /**
                 * @default   high
                 * @apioption plotOptions.boxplot.colorKey
                 */
                /**
                 * The color of the whiskers, the horizontal lines marking low and high
                 * values. When `undefined`, the general series color is used.
                 *
                 * In styled mode, the whisker stroke can be set with the
                 * `.highcharts-boxplot-whisker` class .
                 *
                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
                 *         Box plot styling
                 * @sample {highcharts} highcharts/css/boxplot/
                 *         Box plot in styled mode
                 *
                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @since     3.0
                 * @product   highcharts
                 * @apioption plotOptions.boxplot.whiskerColor
                 */
                /**
                 * The line width of the whiskers, the horizontal lines marking low and
                 * high values. When `undefined`, the general
                 * [lineWidth](#plotOptions.boxplot.lineWidth) applies.
                 *
                 * In styled mode, the whisker stroke width can be set with the
                 * `.highcharts-boxplot-whisker` class.
                 *
                 * @sample {highcharts} highcharts/plotoptions/box-plot-styling/
                 *         Box plot styling
                 * @sample {highcharts} highcharts/css/boxplot/
                 *         Box plot in styled mode
                 *
                 * @since   3.0
                 * @product highcharts
                 */
                whiskerWidth: 2
              });
              return BoxPlotSeries2;
            }(ColumnSeries)
          );
          extend2(BoxPlotSeries.prototype, {
            // array point configs are mapped to this
            pointArrayMap: ["low", "q1", "median", "q3", "high"],
            // defines the top of the tracker
            pointValKey: "high",
            // Disable data labels for box plot
            drawDataLabels: noop2,
            setStackedPoints: noop2
            // #3890
          });
          SeriesRegistry.registerSeriesType("boxplot", BoxPlotSeries);
          "";
          return BoxPlotSeries;
        });
        _registerModule(_modules, "Series/Bubble/BubbleLegendDefaults.js", [], function() {
          var BubbleLegendDefaults = {
            /**
                 * The color of the ranges borders,
            can be also defined for an
                 * individual range.
                 *
                 * @sample highcharts/bubble-legend/similartoseries/
                 *         Similar look to the bubble series
                 * @sample highcharts/bubble-legend/bordercolor/
                 *         Individual bubble border color
                 *
                 * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 */
            borderColor: void 0,
            /**
                 * The width of the ranges borders in pixels,
            can be also
                 * defined for an individual range.
                 */
            borderWidth: 2,
            /**
             * An additional class name to apply to the bubble legend'
             * circle graphical elements. This option does not replace
             * default class names of the graphical element.
             *
             * @sample {highcharts} highcharts/css/bubble-legend/
             *         Styling by CSS
             *
             * @type {string}
             */
            className: void 0,
            /**
                 * The main color of the bubble legend. Applies to ranges,
            if
                 * individual color is not defined.
                 *
                 * @sample highcharts/bubble-legend/similartoseries/
                 *         Similar look to the bubble series
                 * @sample highcharts/bubble-legend/color/
                 *         Individual bubble color
                 *
                 * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 */
            color: void 0,
            /**
             * An additional class name to apply to the bubble legend's
             * connector graphical elements. This option does not replace
             * default class names of the graphical element.
             *
             * @sample {highcharts} highcharts/css/bubble-legend/
             *         Styling by CSS
             *
             * @type {string}
             */
            connectorClassName: void 0,
            /**
                 * The color of the connector,
            can be also defined
                 * for an individual range.
                 *
                 * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 */
            connectorColor: void 0,
            /**
                 * The length of the connectors in pixels. If labels are
                 * centered,
            the distance is reduced to 0.
                 *
                 * @sample highcharts/bubble-legend/connectorandlabels/
                 *         Increased connector length
                 */
            connectorDistance: 60,
            /**
             * The width of the connectors in pixels.
             *
             * @sample highcharts/bubble-legend/connectorandlabels/
             *         Increased connector width
             */
            connectorWidth: 1,
            /**
             * Enable or disable the bubble legend.
             */
            enabled: false,
            /**
             * Options for the bubble legend labels.
             */
            labels: {
              /**
               * An additional class name to apply to the bubble legend
               * label graphical elements. This option does not replace
               * default class names of the graphical element.
               *
               * @sample {highcharts} highcharts/css/bubble-legend/
               *         Styling by CSS
               *
               * @type {string}
               */
              className: void 0,
              /**
               * Whether to allow data labels to overlap.
               */
              allowOverlap: false,
              /**
               * A format string for the bubble legend labels. Available
               * variables are the same as for `formatter`.
               *
               * @sample highcharts/bubble-legend/format/
               *         Add a unit
               *
               * @type {string}
               */
              format: "",
              /**
               * Available `this` properties are:
               *
               * - `this.value`: The bubble value.
               *
               * - `this.radius`: The radius of the bubble range.
               *
               * - `this.center`: The center y position of the range.
               *
               * @type {Highcharts.FormatterCallbackFunction<Highcharts.BubbleLegendFormatterContextObject>}
               */
              formatter: void 0,
              /**
                       * The alignment of the labels compared to the bubble
                       * legend. Can be one of `left`,
              `center` or `right`.
                       *
                       * @sample highcharts/bubble-legend/connectorandlabels/
                       *         Labels on left
                       *
                       * @type {Highcharts.AlignValue}
                       */
              align: "right",
              /**
               * CSS styles for the labels.
               *
               * @type {Highcharts.CSSObject}
               */
              style: {
                /** @ignore-option */
                fontSize: "10px",
                /** @ignore-option */
                color: "#000000"
                /* Palette.neutralColor100 */
              },
              /**
               * The x position offset of the label relative to the
               * connector.
               */
              x: 0,
              /**
               * The y position offset of the label relative to the
               * connector.
               */
              y: 0
            },
            /**
                 * Miximum bubble legend range size. If values for ranges are
                 * not specified,
            the `minSize` and the `maxSize` are calculated
                 * from bubble series.
                 */
            maxSize: 60,
            /**
                 * Minimum bubble legend range size. If values for ranges are
                 * not specified,
            the `minSize` and the `maxSize` are calculated
                 * from bubble series.
                 */
            minSize: 10,
            /**
             * The position of the bubble legend in the legend.
             * @sample highcharts/bubble-legend/connectorandlabels/
             *         Bubble legend as last item in legend
             */
            legendIndex: 0,
            /**
             * Options for specific range. One range consists of bubble,
             * label and connector.
             *
             * @sample highcharts/bubble-legend/ranges/
             *         Manually defined ranges
             * @sample highcharts/bubble-legend/autoranges/
             *         Auto calculated ranges
             *
             * @type {Array<*>}
             */
            ranges: {
              /**
                       * Range size value,
              similar to bubble Z data.
                       * @type {number}
                       */
              value: void 0,
              /**
               * The color of the border for individual range.
               * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               */
              borderColor: void 0,
              /**
               * The color of the bubble for individual range.
               * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               */
              color: void 0,
              /**
               * The color of the connector for individual range.
               * @type {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
               */
              connectorColor: void 0
            },
            /**
                 * Whether the bubble legend range value should be represented
                 * by the area or the width of the bubble. The default,
            area,
                 * corresponds best to the human perception of the size of each
                 * bubble.
                 *
                 * @sample highcharts/bubble-legend/ranges/
                 *         Size by width
                 *
                 * @type {Highcharts.BubbleSizeByValue}
                 */
            sizeBy: "area",
            /**
                 * When this is true,
            the absolute value of z determines the
                 * size of the bubble. This means that with the default
                 * zThreshold of 0,
            a bubble of value -1 will have the same size
                 * as a bubble of value 1,
            while a bubble of value 0 will have a
                 * smaller size according to minSize.
                 */
            sizeByAbsoluteValue: false,
            /**
             * Define the visual z index of the bubble legend.
             */
            zIndex: 1,
            /**
                 * Ranges with with lower value than zThreshold,
            are skipped.
                 */
            zThreshold: 0
          };
          return BubbleLegendDefaults;
        });
        _registerModule(_modules, "Series/Bubble/BubbleLegendItem.js", [_modules["Core/Color/Color.js"], _modules["Core/FormatUtilities.js"], _modules["Core/Globals.js"], _modules["Core/Utilities.js"]], function(Color2, F, H, U) {
          var color2 = Color2.parse;
          var noop2 = H.noop;
          var arrayMax = U.arrayMax, arrayMin = U.arrayMin, isNumber = U.isNumber, merge = U.merge, pick = U.pick, stableSort = U.stableSort;
          var BubbleLegendItem = (
            /** @class */
            function() {
              function BubbleLegendItem2(options, legend) {
                this.chart = void 0;
                this.fontMetrics = void 0;
                this.legend = void 0;
                this.maxLabel = void 0;
                this.movementX = void 0;
                this.ranges = void 0;
                this.selected = void 0;
                this.visible = void 0;
                this.symbols = void 0;
                this.options = void 0;
                this.setState = noop2;
                this.init(options, legend);
              }
              BubbleLegendItem2.prototype.init = function(options, legend) {
                this.options = options;
                this.visible = true;
                this.chart = legend.chart;
                this.legend = legend;
              };
              BubbleLegendItem2.prototype.addToLegend = function(items) {
                items.splice(this.options.legendIndex, 0, this);
              };
              BubbleLegendItem2.prototype.drawLegendSymbol = function(legend) {
                var chart = this.chart, itemDistance = pick(legend.options.itemDistance, 20), legendItem = this.legendItem || {}, options = this.options, ranges = options.ranges, connectorDistance = options.connectorDistance;
                var connectorSpace;
                this.fontMetrics = chart.renderer.fontMetrics(options.labels.style.fontSize);
                if (!ranges || !ranges.length || !isNumber(ranges[0].value)) {
                  legend.options.bubbleLegend.autoRanges = true;
                  return;
                }
                stableSort(ranges, function(a, b) {
                  return b.value - a.value;
                });
                this.ranges = ranges;
                this.setOptions();
                this.render();
                var maxLabel = this.getMaxLabelSize(), radius = this.ranges[0].radius, size = radius * 2;
                connectorSpace = connectorDistance - radius + maxLabel.width;
                connectorSpace = connectorSpace > 0 ? connectorSpace : 0;
                this.maxLabel = maxLabel;
                this.movementX = options.labels.align === "left" ? connectorSpace : 0;
                legendItem.labelWidth = size + connectorSpace + itemDistance;
                legendItem.labelHeight = size + this.fontMetrics.h / 2;
              };
              BubbleLegendItem2.prototype.setOptions = function() {
                var ranges = this.ranges, options = this.options, series = this.chart.series[options.seriesIndex], baseline = this.legend.baseline, bubbleAttribs = {
                  zIndex: options.zIndex,
                  "stroke-width": options.borderWidth
                }, connectorAttribs = {
                  zIndex: options.zIndex,
                  "stroke-width": options.connectorWidth
                }, labelAttribs = {
                  align: this.legend.options.rtl || options.labels.align === "left" ? "right" : "left",
                  zIndex: options.zIndex
                }, fillOpacity = series.options.marker.fillOpacity, styledMode = this.chart.styledMode;
                ranges.forEach(function(range, i) {
                  if (!styledMode) {
                    bubbleAttribs.stroke = pick(range.borderColor, options.borderColor, series.color);
                    bubbleAttribs.fill = pick(range.color, options.color, fillOpacity !== 1 ? color2(series.color).setOpacity(fillOpacity).get("rgba") : series.color);
                    connectorAttribs.stroke = pick(range.connectorColor, options.connectorColor, series.color);
                  }
                  ranges[i].radius = this.getRangeRadius(range.value);
                  ranges[i] = merge(ranges[i], {
                    center: ranges[0].radius - ranges[i].radius + baseline
                  });
                  if (!styledMode) {
                    merge(true, ranges[i], {
                      bubbleAttribs: merge(bubbleAttribs),
                      connectorAttribs: merge(connectorAttribs),
                      labelAttribs
                    });
                  }
                }, this);
              };
              BubbleLegendItem2.prototype.getRangeRadius = function(value) {
                var options = this.options, seriesIndex = this.options.seriesIndex, bubbleSeries = this.chart.series[seriesIndex], zMax = options.ranges[0].value, zMin = options.ranges[options.ranges.length - 1].value, minSize = options.minSize, maxSize = options.maxSize;
                return bubbleSeries.getRadius.call(this, zMin, zMax, minSize, maxSize, value);
              };
              BubbleLegendItem2.prototype.render = function() {
                var legendItem = this.legendItem || {}, renderer = this.chart.renderer, zThreshold = this.options.zThreshold;
                if (!this.symbols) {
                  this.symbols = {
                    connectors: [],
                    bubbleItems: [],
                    labels: []
                  };
                }
                legendItem.symbol = renderer.g("bubble-legend");
                legendItem.label = renderer.g("bubble-legend-item");
                legendItem.symbol.translateX = 0;
                legendItem.symbol.translateY = 0;
                for (var _i = 0, _a = this.ranges; _i < _a.length; _i++) {
                  var range = _a[_i];
                  if (range.value >= zThreshold) {
                    this.renderRange(range);
                  }
                }
                legendItem.symbol.add(legendItem.label);
                legendItem.label.add(legendItem.group);
                this.hideOverlappingLabels();
              };
              BubbleLegendItem2.prototype.renderRange = function(range) {
                var mainRange = this.ranges[0], legend = this.legend, options = this.options, labelsOptions = options.labels, chart = this.chart, bubbleSeries = chart.series[options.seriesIndex], renderer = chart.renderer, symbols = this.symbols, labels = symbols.labels, elementCenter = range.center, absoluteRadius = Math.abs(range.radius), connectorDistance = options.connectorDistance || 0, labelsAlign = labelsOptions.align, rtl = legend.options.rtl, borderWidth = options.borderWidth, connectorWidth = options.connectorWidth, posX = mainRange.radius || 0, posY = elementCenter - absoluteRadius - borderWidth / 2 + connectorWidth / 2, fontMetrics = this.fontMetrics, labelMovement = fontMetrics.f / 2 - (fontMetrics.h - fontMetrics.f) / 2, crispMovement = (posY % 1 ? 1 : 0.5) - (connectorWidth % 2 ? 0 : 0.5), styledMode = renderer.styledMode;
                var connectorLength = rtl || labelsAlign === "left" ? -connectorDistance : connectorDistance;
                if (labelsAlign === "center") {
                  connectorLength = 0;
                  options.connectorDistance = 0;
                  range.labelAttribs.align = "center";
                }
                var labelY = posY + options.labels.y, labelX = posX + connectorLength + options.labels.x;
                symbols.bubbleItems.push(renderer.circle(posX, elementCenter + crispMovement, absoluteRadius).attr(styledMode ? {} : range.bubbleAttribs).addClass((styledMode ? "highcharts-color-" + bubbleSeries.colorIndex + " " : "") + "highcharts-bubble-legend-symbol " + (options.className || "")).add(this.legendItem.symbol));
                symbols.connectors.push(renderer.path(renderer.crispLine([
                  ["M", posX, posY],
                  ["L", posX + connectorLength, posY]
                ], options.connectorWidth)).attr(styledMode ? {} : range.connectorAttribs).addClass((styledMode ? "highcharts-color-" + this.options.seriesIndex + " " : "") + "highcharts-bubble-legend-connectors " + (options.connectorClassName || "")).add(this.legendItem.symbol));
                var label = renderer.text(
                  this.formatLabel(range),
                  labelX,
                  labelY + labelMovement
                ).attr(styledMode ? {} : range.labelAttribs).css(styledMode ? {} : labelsOptions.style).addClass("highcharts-bubble-legend-labels " + (options.labels.className || "")).add(this.legendItem.symbol);
                labels.push(label);
                label.placed = true;
                label.alignAttr = {
                  x: labelX,
                  y: labelY + labelMovement
                };
              };
              BubbleLegendItem2.prototype.getMaxLabelSize = function() {
                var labels = this.symbols.labels;
                var maxLabel, labelSize;
                labels.forEach(function(label) {
                  labelSize = label.getBBox(true);
                  if (maxLabel) {
                    maxLabel = labelSize.width > maxLabel.width ? labelSize : maxLabel;
                  } else {
                    maxLabel = labelSize;
                  }
                });
                return maxLabel || {};
              };
              BubbleLegendItem2.prototype.formatLabel = function(range) {
                var options = this.options, formatter = options.labels.formatter, format3 = options.labels.format;
                var numberFormatter = this.chart.numberFormatter;
                return format3 ? F.format(format3, range) : formatter ? formatter.call(range) : numberFormatter(range.value, 1);
              };
              BubbleLegendItem2.prototype.hideOverlappingLabels = function() {
                var chart = this.chart, allowOverlap = this.options.labels.allowOverlap, symbols = this.symbols;
                if (!allowOverlap && symbols) {
                  chart.hideOverlappingLabels(symbols.labels);
                  symbols.labels.forEach(function(label, index) {
                    if (!label.newOpacity) {
                      symbols.connectors[index].hide();
                    } else if (label.newOpacity !== label.oldOpacity) {
                      symbols.connectors[index].show();
                    }
                  });
                }
              };
              BubbleLegendItem2.prototype.getRanges = function() {
                var bubbleLegend = this.legend.bubbleLegend, series = bubbleLegend.chart.series, rangesOptions = bubbleLegend.options.ranges;
                var ranges, zData, minZ = Number.MAX_VALUE, maxZ = -Number.MAX_VALUE;
                series.forEach(function(s) {
                  if (s.isBubble && !s.ignoreSeries) {
                    zData = s.zData.filter(isNumber);
                    if (zData.length) {
                      minZ = pick(s.options.zMin, Math.min(minZ, Math.max(arrayMin(zData), s.options.displayNegative === false ? s.options.zThreshold : -Number.MAX_VALUE)));
                      maxZ = pick(s.options.zMax, Math.max(maxZ, arrayMax(zData)));
                    }
                  }
                });
                if (minZ === maxZ) {
                  ranges = [{ value: maxZ }];
                } else {
                  ranges = [
                    { value: minZ },
                    { value: (minZ + maxZ) / 2 },
                    { value: maxZ, autoRanges: true }
                  ];
                }
                if (rangesOptions.length && rangesOptions[0].radius) {
                  ranges.reverse();
                }
                ranges.forEach(function(range, i) {
                  if (rangesOptions && rangesOptions[i]) {
                    ranges[i] = merge(rangesOptions[i], range);
                  }
                });
                return ranges;
              };
              BubbleLegendItem2.prototype.predictBubbleSizes = function() {
                var chart = this.chart, fontMetrics = this.fontMetrics, legendOptions = chart.legend.options, floating = legendOptions.floating, horizontal = legendOptions.layout === "horizontal", lastLineHeight = horizontal ? chart.legend.lastLineHeight : 0, plotSizeX = chart.plotSizeX, plotSizeY = chart.plotSizeY, bubbleSeries = chart.series[this.options.seriesIndex], pxSizes = bubbleSeries.getPxExtremes(), minSize = Math.ceil(pxSizes.minPxSize), maxPxSize = Math.ceil(pxSizes.maxPxSize), plotSize = Math.min(
                  plotSizeY,
                  plotSizeX
                );
                var calculatedSize, maxSize = bubbleSeries.options.maxSize;
                if (floating || !/%$/.test(maxSize)) {
                  calculatedSize = maxPxSize;
                } else {
                  maxSize = parseFloat(maxSize);
                  calculatedSize = (plotSize + lastLineHeight - fontMetrics.h / 2) * maxSize / 100 / (maxSize / 100 + 1);
                  if (horizontal && plotSizeY - calculatedSize >= plotSizeX || !horizontal && plotSizeX - calculatedSize >= plotSizeY) {
                    calculatedSize = maxPxSize;
                  }
                }
                return [minSize, Math.ceil(calculatedSize)];
              };
              BubbleLegendItem2.prototype.updateRanges = function(min2, max2) {
                var bubbleLegendOptions = this.legend.options.bubbleLegend;
                bubbleLegendOptions.minSize = min2;
                bubbleLegendOptions.maxSize = max2;
                bubbleLegendOptions.ranges = this.getRanges();
              };
              BubbleLegendItem2.prototype.correctSizes = function() {
                var legend = this.legend, chart = this.chart, bubbleSeries = chart.series[this.options.seriesIndex], pxSizes = bubbleSeries.getPxExtremes(), bubbleSeriesSize = pxSizes.maxPxSize, bubbleLegendSize = this.options.maxSize;
                if (Math.abs(Math.ceil(bubbleSeriesSize) - bubbleLegendSize) > 1) {
                  this.updateRanges(this.options.minSize, pxSizes.maxPxSize);
                  legend.render();
                }
              };
              return BubbleLegendItem2;
            }()
          );
          "";
          return BubbleLegendItem;
        });
        _registerModule(_modules, "Series/Bubble/BubbleLegendComposition.js", [_modules["Series/Bubble/BubbleLegendDefaults.js"], _modules["Series/Bubble/BubbleLegendItem.js"], _modules["Core/Defaults.js"], _modules["Core/Utilities.js"]], function(BubbleLegendDefaults, BubbleLegendItem, D, U) {
          var setOptions = D.setOptions;
          var addEvent = U.addEvent, objectEach = U.objectEach, wrap = U.wrap;
          var composedClasses = [];
          function chartDrawChartBox(proceed, options, callback) {
            var chart = this, legend = chart.legend, bubbleSeries = getVisibleBubbleSeriesIndex(chart) >= 0;
            var bubbleLegendOptions, bubbleSizes, legendItem;
            if (legend && legend.options.enabled && legend.bubbleLegend && legend.options.bubbleLegend.autoRanges && bubbleSeries) {
              bubbleLegendOptions = legend.bubbleLegend.options;
              bubbleSizes = legend.bubbleLegend.predictBubbleSizes();
              legend.bubbleLegend.updateRanges(bubbleSizes[0], bubbleSizes[1]);
              if (!bubbleLegendOptions.placed) {
                legend.group.placed = false;
                legend.allItems.forEach(function(item) {
                  legendItem = item.legendItem || {};
                  if (legendItem.group) {
                    legendItem.group.translateY = null;
                  }
                });
              }
              legend.render();
              chart.getMargins();
              chart.axes.forEach(function(axis) {
                if (axis.visible) {
                  axis.render();
                }
                if (!bubbleLegendOptions.placed) {
                  axis.setScale();
                  axis.updateNames();
                  objectEach(axis.ticks, function(tick) {
                    tick.isNew = true;
                    tick.isNewLabel = true;
                  });
                }
              });
              bubbleLegendOptions.placed = true;
              chart.getMargins();
              proceed.call(chart, options, callback);
              legend.bubbleLegend.correctSizes();
              retranslateItems(legend, getLinesHeights(legend));
            } else {
              proceed.call(chart, options, callback);
              if (legend && legend.options.enabled && legend.bubbleLegend) {
                legend.render();
                retranslateItems(legend, getLinesHeights(legend));
              }
            }
          }
          function compose(ChartClass, LegendClass, SeriesClass) {
            if (composedClasses.indexOf(ChartClass) === -1) {
              composedClasses.push(ChartClass);
              setOptions({
                // Set default bubble legend options
                legend: {
                  bubbleLegend: BubbleLegendDefaults
                }
              });
              wrap(ChartClass.prototype, "drawChartBox", chartDrawChartBox);
            }
            if (composedClasses.indexOf(LegendClass) === -1) {
              composedClasses.push(LegendClass);
              addEvent(LegendClass, "afterGetAllItems", onLegendAfterGetAllItems);
            }
            if (composedClasses.indexOf(SeriesClass) === -1) {
              composedClasses.push(SeriesClass);
              addEvent(SeriesClass, "legendItemClick", onSeriesLegendItemClick);
            }
          }
          function getVisibleBubbleSeriesIndex(chart) {
            var series = chart.series;
            var i = 0;
            while (i < series.length) {
              if (series[i] && series[i].isBubble && series[i].visible && series[i].zData.length) {
                return i;
              }
              i++;
            }
            return -1;
          }
          function getLinesHeights(legend) {
            var items = legend.allItems, lines = [], length = items.length;
            var lastLine, legendItem, legendItem2, i = 0, j = 0;
            for (i = 0; i < length; i++) {
              legendItem = items[i].legendItem || {};
              legendItem2 = (items[i + 1] || {}).legendItem || {};
              if (legendItem.labelHeight) {
                items[i].itemHeight = legendItem.labelHeight;
              }
              if (
                // Line break
                items[i] === items[length - 1] || legendItem.y !== legendItem2.y
              ) {
                lines.push({ height: 0 });
                lastLine = lines[lines.length - 1];
                for (j; j <= i; j++) {
                  if (items[j].itemHeight > lastLine.height) {
                    lastLine.height = items[j].itemHeight;
                  }
                }
                lastLine.step = i;
              }
            }
            return lines;
          }
          function onLegendAfterGetAllItems(e) {
            var legend = this, bubbleLegend = legend.bubbleLegend, legendOptions = legend.options, options = legendOptions.bubbleLegend, bubbleSeriesIndex = getVisibleBubbleSeriesIndex(legend.chart);
            if (bubbleLegend && bubbleLegend.ranges && bubbleLegend.ranges.length) {
              if (options.ranges.length) {
                options.autoRanges = !!options.ranges[0].autoRanges;
              }
              legend.destroyItem(bubbleLegend);
            }
            if (bubbleSeriesIndex >= 0 && legendOptions.enabled && options.enabled) {
              options.seriesIndex = bubbleSeriesIndex;
              legend.bubbleLegend = new BubbleLegendItem(options, legend);
              legend.bubbleLegend.addToLegend(e.allItems);
            }
          }
          function onSeriesLegendItemClick() {
            var series = this, chart = series.chart, visible = series.visible, legend = series.chart.legend;
            var status;
            if (legend && legend.bubbleLegend) {
              series.visible = !visible;
              series.ignoreSeries = visible;
              status = getVisibleBubbleSeriesIndex(chart) >= 0;
              if (legend.bubbleLegend.visible !== status) {
                legend.update({
                  bubbleLegend: { enabled: status }
                });
                legend.bubbleLegend.visible = status;
              }
              series.visible = visible;
            }
          }
          function retranslateItems(legend, lines) {
            var items = legend.allItems, rtl = legend.options.rtl;
            var orgTranslateX, orgTranslateY, movementX, legendItem, actualLine = 0;
            items.forEach(function(item, index) {
              legendItem = item.legendItem || {};
              if (!legendItem.group) {
                return;
              }
              orgTranslateX = legendItem.group.translateX || 0;
              orgTranslateY = legendItem.y || 0;
              movementX = item.movementX;
              if (movementX || rtl && item.ranges) {
                movementX = rtl ? orgTranslateX - item.options.maxSize / 2 : orgTranslateX + movementX;
                legendItem.group.attr({ translateX: movementX });
              }
              if (index > lines[actualLine].step) {
                actualLine++;
              }
              legendItem.group.attr({
                translateY: Math.round(orgTranslateY + lines[actualLine].height / 2)
              });
              legendItem.y = orgTranslateY + lines[actualLine].height / 2;
            });
          }
          var BubbleLegendComposition = {
            compose
          };
          return BubbleLegendComposition;
        });
        _registerModule(_modules, "Series/Bubble/BubblePoint.js", [_modules["Core/Series/Point.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(Point, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var ScatterPoint = SeriesRegistry.seriesTypes.scatter.prototype.pointClass;
          var extend2 = U.extend;
          var BubblePoint = (
            /** @class */
            function(_super) {
              __extends(BubblePoint2, _super);
              function BubblePoint2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.options = void 0;
                _this.series = void 0;
                return _this;
              }
              BubblePoint2.prototype.haloPath = function(size) {
                return Point.prototype.haloPath.call(
                  this,
                  // #6067
                  size === 0 ? 0 : (this.marker ? this.marker.radius || 0 : 0) + size
                );
              };
              return BubblePoint2;
            }(ScatterPoint)
          );
          extend2(BubblePoint.prototype, {
            ttBelow: false
          });
          return BubblePoint;
        });
        _registerModule(_modules, "Series/Bubble/BubbleSeries.js", [_modules["Series/Bubble/BubbleLegendComposition.js"], _modules["Series/Bubble/BubblePoint.js"], _modules["Core/Color/Color.js"], _modules["Core/Globals.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(BubbleLegendComposition, BubblePoint, Color2, H, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var color2 = Color2.parse;
          var noop2 = H.noop;
          var Series = SeriesRegistry.series, _a = SeriesRegistry.seriesTypes, columnProto = _a.column.prototype, ScatterSeries = _a.scatter;
          var addEvent = U.addEvent, arrayMax = U.arrayMax, arrayMin = U.arrayMin, clamp = U.clamp, extend2 = U.extend, isNumber = U.isNumber, merge = U.merge, pick = U.pick;
          var composedClasses = [];
          function axisBeforePadding() {
            var _this = this;
            var axisLength = this.len, chart = this.chart, isXAxis = this.isXAxis, dataKey = isXAxis ? "xData" : "yData", min2 = this.min, range = this.max - min2;
            var pxMin = 0, pxMax = axisLength, transA = axisLength / range, hasActiveSeries;
            this.series.forEach(function(series) {
              if (series.bubblePadding && (series.visible || !chart.options.chart.ignoreHiddenSeries)) {
                _this.allowZoomOutside = true;
                hasActiveSeries = true;
                var data = series[dataKey];
                if (isXAxis) {
                  (series.onPoint || series).getRadii(0, 0, series);
                  if (series.onPoint) {
                    series.radii = series.onPoint.radii;
                  }
                }
                if (range > 0) {
                  var i = data.length;
                  while (i--) {
                    if (isNumber(data[i]) && _this.dataMin <= data[i] && data[i] <= _this.max) {
                      var radius = series.radii && series.radii[i] || 0;
                      pxMin = Math.min((data[i] - min2) * transA - radius, pxMin);
                      pxMax = Math.max((data[i] - min2) * transA + radius, pxMax);
                    }
                  }
                }
              }
            });
            if (hasActiveSeries && range > 0 && !this.logarithmic) {
              pxMax -= axisLength;
              transA *= (axisLength + Math.max(0, pxMin) - // #8901
              Math.min(pxMax, axisLength)) / axisLength;
              [
                ["min", "userMin", pxMin],
                ["max", "userMax", pxMax]
              ].forEach(function(keys) {
                if (typeof pick(_this.options[keys[0]], _this[keys[1]]) === "undefined") {
                  _this[keys[0]] += keys[2] / transA;
                }
              });
            }
          }
          var BubbleSeries = (
            /** @class */
            function(_super) {
              __extends(BubbleSeries2, _super);
              function BubbleSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.data = void 0;
                _this.maxPxSize = void 0;
                _this.minPxSize = void 0;
                _this.options = void 0;
                _this.points = void 0;
                _this.radii = void 0;
                _this.yData = void 0;
                _this.zData = void 0;
                return _this;
              }
              BubbleSeries2.compose = function(AxisClass, ChartClass, LegendClass, SeriesClass) {
                BubbleLegendComposition.compose(ChartClass, LegendClass, SeriesClass);
                if (composedClasses.indexOf(AxisClass) === -1) {
                  composedClasses.push(AxisClass);
                  AxisClass.prototype.beforePadding = axisBeforePadding;
                }
              };
              BubbleSeries2.prototype.animate = function(init3) {
                if (!init3 && this.points.length < this.options.animationLimit) {
                  this.points.forEach(function(point) {
                    var graphic = point.graphic;
                    if (graphic && graphic.width) {
                      if (!this.hasRendered) {
                        graphic.attr({
                          x: point.plotX,
                          y: point.plotY,
                          width: 1,
                          height: 1
                        });
                      }
                      graphic.animate(this.markerAttribs(point), this.options.animation);
                    }
                  }, this);
                }
              };
              BubbleSeries2.prototype.getRadii = function() {
                var _this = this;
                var zData = this.zData, yData = this.yData, radii = [];
                var len, i, value, zExtremes = this.chart.bubbleZExtremes;
                var _a2 = this.getPxExtremes(), minPxSize = _a2.minPxSize, maxPxSize = _a2.maxPxSize;
                if (!zExtremes) {
                  var zMin_1 = Number.MAX_VALUE;
                  var zMax_1 = -Number.MAX_VALUE;
                  var valid_1;
                  this.chart.series.forEach(function(otherSeries) {
                    if (otherSeries.bubblePadding && (otherSeries.visible || !_this.chart.options.chart.ignoreHiddenSeries)) {
                      var zExtremes_1 = (otherSeries.onPoint || otherSeries).getZExtremes();
                      if (zExtremes_1) {
                        zMin_1 = Math.min(zMin_1 || zExtremes_1.zMin, zExtremes_1.zMin);
                        zMax_1 = Math.max(zMax_1 || zExtremes_1.zMax, zExtremes_1.zMax);
                        valid_1 = true;
                      }
                    }
                  });
                  if (valid_1) {
                    zExtremes = { zMin: zMin_1, zMax: zMax_1 };
                    this.chart.bubbleZExtremes = zExtremes;
                  } else {
                    zExtremes = { zMin: 0, zMax: 0 };
                  }
                }
                for (i = 0, len = zData.length; i < len; i++) {
                  value = zData[i];
                  radii.push(this.getRadius(zExtremes.zMin, zExtremes.zMax, minPxSize, maxPxSize, value, yData && yData[i]));
                }
                this.radii = radii;
              };
              BubbleSeries2.prototype.getRadius = function(zMin, zMax, minSize, maxSize, value, yValue) {
                var options = this.options, sizeByArea = options.sizeBy !== "width", zThreshold = options.zThreshold;
                var zRange = zMax - zMin, pos = 0.5;
                if (yValue === null || value === null) {
                  return null;
                }
                if (isNumber(value)) {
                  if (options.sizeByAbsoluteValue) {
                    value = Math.abs(value - zThreshold);
                    zMax = zRange = Math.max(zMax - zThreshold, Math.abs(zMin - zThreshold));
                    zMin = 0;
                  }
                  if (value < zMin) {
                    return minSize / 2 - 1;
                  }
                  if (zRange > 0) {
                    pos = (value - zMin) / zRange;
                  }
                }
                if (sizeByArea && pos >= 0) {
                  pos = Math.sqrt(pos);
                }
                return Math.ceil(minSize + pos * (maxSize - minSize)) / 2;
              };
              BubbleSeries2.prototype.hasData = function() {
                return !!this.processedXData.length;
              };
              BubbleSeries2.prototype.pointAttribs = function(point, state) {
                var markerOptions = this.options.marker, fillOpacity = markerOptions.fillOpacity, attr = Series.prototype.pointAttribs.call(
                  this,
                  point,
                  state
                );
                if (fillOpacity !== 1) {
                  attr.fill = color2(attr.fill).setOpacity(fillOpacity).get("rgba");
                }
                return attr;
              };
              BubbleSeries2.prototype.translate = function() {
                _super.prototype.translate.call(this);
                this.getRadii();
                this.translateBubble();
              };
              BubbleSeries2.prototype.translateBubble = function() {
                var _a2 = this, data = _a2.data, radii = _a2.radii;
                var minPxSize = this.getPxExtremes().minPxSize;
                var i = data.length;
                while (i--) {
                  var point = data[i];
                  var radius = radii ? radii[i] : 0;
                  if (isNumber(radius) && radius >= minPxSize / 2) {
                    point.marker = extend2(point.marker, {
                      radius,
                      width: 2 * radius,
                      height: 2 * radius
                    });
                    point.dlBox = {
                      x: point.plotX - radius,
                      y: point.plotY - radius,
                      width: 2 * radius,
                      height: 2 * radius
                    };
                  } else {
                    point.shapeArgs = point.plotY = point.dlBox = void 0;
                    point.isInside = false;
                  }
                }
              };
              BubbleSeries2.prototype.getPxExtremes = function() {
                var smallestSize = Math.min(
                  this.chart.plotWidth,
                  this.chart.plotHeight
                );
                var getPxSize = function(length) {
                  var isPercent;
                  if (typeof length === "string") {
                    isPercent = /%$/.test(length);
                    length = parseInt(length, 10);
                  }
                  return isPercent ? smallestSize * length / 100 : length;
                };
                var minPxSize = getPxSize(pick(this.options.minSize, 8));
                var maxPxSize = Math.max(
                  getPxSize(pick(this.options.maxSize, "20%")),
                  minPxSize
                );
                return { minPxSize, maxPxSize };
              };
              BubbleSeries2.prototype.getZExtremes = function() {
                var options = this.options, zData = (this.zData || []).filter(isNumber);
                if (zData.length) {
                  var zMin = pick(
                    options.zMin,
                    clamp(
                      arrayMin(zData),
                      options.displayNegative === false ? options.zThreshold || 0 : -Number.MAX_VALUE,
                      Number.MAX_VALUE
                    )
                  );
                  var zMax = pick(
                    options.zMax,
                    arrayMax(zData)
                  );
                  if (isNumber(zMin) && isNumber(zMax)) {
                    return { zMin, zMax };
                  }
                }
              };
              BubbleSeries2.defaultOptions = merge(ScatterSeries.defaultOptions, {
                dataLabels: {
                  formatter: function() {
                    var numberFormatter = this.series.chart.numberFormatter;
                    var z = this.point.z;
                    return isNumber(z) ? numberFormatter(z, -1) : "";
                  },
                  inside: true,
                  verticalAlign: "middle"
                },
                /**
                 * If there are more points in the series than the `animationLimit`, the
                 * animation won't run. Animation affects overall performance and
                 * doesn't work well with heavy data series.
                 *
                 * @since 6.1.0
                 */
                animationLimit: 250,
                /**
                 * Whether to display negative sized bubbles. The threshold is given
                 * by the [zThreshold](#plotOptions.bubble.zThreshold) option, and negative
                 * bubbles can be visualized by setting
                 * [negativeColor](#plotOptions.bubble.negativeColor).
                 *
                 * @sample {highcharts} highcharts/plotoptions/bubble-negative/
                 *         Negative bubbles
                 *
                 * @type      {boolean}
                 * @default   true
                 * @since     3.0
                 * @apioption plotOptions.bubble.displayNegative
                 */
                /**
                 * @extends   plotOptions.series.marker
                 * @excluding enabled, enabledThreshold, height, radius, width
                 */
                marker: {
                  lineColor: null,
                  lineWidth: 1,
                  /**
                   * The fill opacity of the bubble markers.
                   */
                  fillOpacity: 0.5,
                  /**
                   * In bubble charts, the radius is overridden and determined based
                   * on the point's data value.
                   *
                   * @ignore-option
                   */
                  radius: null,
                  states: {
                    hover: {
                      radiusPlus: 0
                    }
                  },
                  /**
                   * A predefined shape or symbol for the marker. Possible values are
                   * "circle", "square", "diamond", "triangle" and "triangle-down".
                   *
                   * Additionally, the URL to a graphic can be given on the form
                   * `url(graphic.png)`. Note that for the image to be applied to
                   * exported charts, its URL needs to be accessible by the export
                   * server.
                   *
                   * Custom callbacks for symbol path generation can also be added to
                   * `Highcharts.SVGRenderer.prototype.symbols`. The callback is then
                   * used by its method name, as shown in the demo.
                   *
                   * @sample {highcharts} highcharts/plotoptions/bubble-symbol/
                   *         Bubble chart with various symbols
                   * @sample {highcharts} highcharts/plotoptions/series-marker-symbol/
                   *         General chart with predefined, graphic and custom markers
                   *
                   * @type  {Highcharts.SymbolKeyValue|string}
                   * @since 5.0.11
                   */
                  symbol: "circle"
                },
                /**
                 * Minimum bubble size. Bubbles will automatically size between the
                 * `minSize` and `maxSize` to reflect the `z` value of each bubble.
                 * Can be either pixels (when no unit is given), or a percentage of
                 * the smallest one of the plot width and height.
                 *
                 * @sample {highcharts} highcharts/plotoptions/bubble-size/
                 *         Bubble size
                 *
                 * @type    {number|string}
                 * @since   3.0
                 * @product highcharts highstock
                 */
                minSize: 8,
                /**
                 * Maximum bubble size. Bubbles will automatically size between the
                 * `minSize` and `maxSize` to reflect the `z` value of each bubble.
                 * Can be either pixels (when no unit is given), or a percentage of
                 * the smallest one of the plot width and height.
                 *
                 * @sample {highcharts} highcharts/plotoptions/bubble-size/
                 *         Bubble size
                 *
                 * @type    {number|string}
                 * @since   3.0
                 * @product highcharts highstock
                 */
                maxSize: "20%",
                /**
                 * When a point's Z value is below the
                 * [zThreshold](#plotOptions.bubble.zThreshold)
                 * setting, this color is used.
                 *
                 * @sample {highcharts} highcharts/plotoptions/bubble-negative/
                 *         Negative bubbles
                 *
                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @since     3.0
                 * @product   highcharts
                 * @apioption plotOptions.bubble.negativeColor
                 */
                /**
                 * Whether the bubble's value should be represented by the area or the
                 * width of the bubble. The default, `area`, corresponds best to the
                 * human perception of the size of each bubble.
                 *
                 * @sample {highcharts} highcharts/plotoptions/bubble-sizeby/
                 *         Comparison of area and size
                 *
                 * @type       {Highcharts.BubbleSizeByValue}
                 * @default    area
                 * @since      3.0.7
                 * @apioption  plotOptions.bubble.sizeBy
                 */
                /**
                 * When this is true, the absolute value of z determines the size of
                 * the bubble. This means that with the default `zThreshold` of 0, a
                 * bubble of value -1 will have the same size as a bubble of value 1,
                 * while a bubble of value 0 will have a smaller size according to
                 * `minSize`.
                 *
                 * @sample    {highcharts} highcharts/plotoptions/bubble-sizebyabsolutevalue/
                 *            Size by absolute value, various thresholds
                 *
                 * @type      {boolean}
                 * @default   false
                 * @since     4.1.9
                 * @product   highcharts
                 * @apioption plotOptions.bubble.sizeByAbsoluteValue
                 */
                /**
                 * When this is true, the series will not cause the Y axis to cross
                 * the zero plane (or [threshold](#plotOptions.series.threshold) option)
                 * unless the data actually crosses the plane.
                 *
                 * For example, if `softThreshold` is `false`, a series of 0, 1, 2,
                 * 3 will make the Y axis show negative values according to the
                 * `minPadding` option. If `softThreshold` is `true`, the Y axis starts
                 * at 0.
                 *
                 * @since   4.1.9
                 * @product highcharts
                 */
                softThreshold: false,
                states: {
                  hover: {
                    halo: {
                      size: 5
                    }
                  }
                },
                tooltip: {
                  pointFormat: "({point.x}, {point.y}), Size: {point.z}"
                },
                turboThreshold: 0,
                /**
                 * The minimum for the Z value range. Defaults to the highest Z value
                 * in the data.
                 *
                 * @see [zMin](#plotOptions.bubble.zMin)
                 *
                 * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/
                 *         Z has a possible range of 0-100
                 *
                 * @type      {number}
                 * @since     4.0.3
                 * @product   highcharts
                 * @apioption plotOptions.bubble.zMax
                 */
                /**
                 * @default   z
                 * @apioption plotOptions.bubble.colorKey
                 */
                /**
                 * The minimum for the Z value range. Defaults to the lowest Z value
                 * in the data.
                 *
                 * @see [zMax](#plotOptions.bubble.zMax)
                 *
                 * @sample {highcharts} highcharts/plotoptions/bubble-zmin-zmax/
                 *         Z has a possible range of 0-100
                 *
                 * @type      {number}
                 * @since     4.0.3
                 * @product   highcharts
                 * @apioption plotOptions.bubble.zMin
                 */
                /**
                 * When [displayNegative](#plotOptions.bubble.displayNegative) is `false`,
                 * bubbles with lower Z values are skipped. When `displayNegative`
                 * is `true` and a [negativeColor](#plotOptions.bubble.negativeColor)
                 * is given, points with lower Z is colored.
                 *
                 * @sample {highcharts} highcharts/plotoptions/bubble-negative/
                 *         Negative bubbles
                 *
                 * @since   3.0
                 * @product highcharts
                 */
                zThreshold: 0,
                zoneAxis: "z"
              });
              return BubbleSeries2;
            }(ScatterSeries)
          );
          extend2(BubbleSeries.prototype, {
            alignDataLabel: columnProto.alignDataLabel,
            applyZones: noop2,
            bubblePadding: true,
            buildKDTree: noop2,
            directTouch: true,
            isBubble: true,
            pointArrayMap: ["y", "z"],
            pointClass: BubblePoint,
            parallelArrays: ["x", "y", "z"],
            trackerGroups: ["group", "dataLabelsGroup"],
            specialGroup: "group",
            zoneAxis: "z"
          });
          addEvent(BubbleSeries, "updatedData", function(e) {
            delete e.target.chart.bubbleZExtremes;
          });
          addEvent(BubbleSeries, "remove", function(e) {
            delete e.target.chart.bubbleZExtremes;
          });
          SeriesRegistry.registerSeriesType("bubble", BubbleSeries);
          "";
          "";
          return BubbleSeries;
        });
        _registerModule(_modules, "Series/ColumnRange/ColumnRangePoint.js", [_modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var _a = SeriesRegistry.seriesTypes, columnProto = _a.column.prototype.pointClass.prototype, AreaRangePoint = _a.arearange.prototype.pointClass;
          var extend2 = U.extend, isNumber = U.isNumber;
          var ColumnRangePoint = (
            /** @class */
            function(_super) {
              __extends(ColumnRangePoint2, _super);
              function ColumnRangePoint2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.options = void 0;
                _this.series = void 0;
                return _this;
              }
              ColumnRangePoint2.prototype.isValid = function() {
                return isNumber(this.low);
              };
              return ColumnRangePoint2;
            }(AreaRangePoint)
          );
          extend2(ColumnRangePoint.prototype, {
            setState: columnProto.setState
          });
          return ColumnRangePoint;
        });
        _registerModule(_modules, "Series/ColumnRange/ColumnRangeSeries.js", [_modules["Series/ColumnRange/ColumnRangePoint.js"], _modules["Core/Globals.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(ColumnRangePoint, H, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var noop2 = H.noop;
          var _a = SeriesRegistry.seriesTypes, AreaRangeSeries = _a.arearange, ColumnSeries = _a.column, columnProto = _a.column.prototype;
          var clamp = U.clamp, extend2 = U.extend, isNumber = U.isNumber, merge = U.merge, pick = U.pick;
          var columnRangeOptions = {
            /**
                 * Extended data labels for range series types. Range series data labels
                 * have no `x` and `y` options. Instead,
            they have `xLow`,
            `xHigh`,
                 * `yLow` and `yHigh` options to allow the higher and lower data label
                 * sets individually.
                 *
                 * @declare   Highcharts.SeriesAreaRangeDataLabelsOptionsObject
                 * @extends   plotOptions.arearange.dataLabels
                 * @since     2.3.0
                 * @product   highcharts highstock
                 * @apioption plotOptions.columnrange.dataLabels
                 */
            pointRange: null,
            /** @ignore-option */
            marker: null,
            states: {
              hover: {
                /** @ignore-option */
                halo: false
              }
            }
          };
          var ColumnRangeSeries = (
            /** @class */
            function(_super) {
              __extends(ColumnRangeSeries2, _super);
              function ColumnRangeSeries2() {
                return _super !== null && _super.apply(this, arguments) || this;
              }
              ColumnRangeSeries2.prototype.setOptions = function() {
                merge(true, arguments[0], { stacking: void 0 });
                return AreaRangeSeries.prototype.setOptions.apply(this, arguments);
              };
              ColumnRangeSeries2.prototype.translate = function() {
                var _this = this;
                var yAxis = this.yAxis, xAxis = this.xAxis, startAngleRad = xAxis.startAngleRad, chart = this.chart, isRadial = this.xAxis.isRadial, safeDistance = Math.max(
                  chart.chartWidth,
                  chart.chartHeight
                ) + 999;
                var height, heightDifference, start2, plotHigh, y;
                function safeBounds(pixelPos) {
                  return clamp(pixelPos, -safeDistance, safeDistance);
                }
                columnProto.translate.apply(this);
                this.points.forEach(function(point) {
                  var shapeArgs = point.shapeArgs || {}, minPointLength = _this.options.minPointLength, plotY = point.plotY, plotHigh2 = yAxis.translate(point.high, 0, 1, 0, 1);
                  if (isNumber(plotHigh2) && isNumber(plotY)) {
                    point.plotHigh = safeBounds(plotHigh2);
                    point.plotLow = safeBounds(plotY);
                    y = point.plotHigh;
                    height = pick(point.rectPlotY, point.plotY) - point.plotHigh;
                    if (Math.abs(height) < minPointLength) {
                      heightDifference = minPointLength - height;
                      height += heightDifference;
                      y -= heightDifference / 2;
                    } else if (height < 0) {
                      height *= -1;
                      y -= height;
                    }
                    if (isRadial && _this.polar) {
                      start2 = point.barX + startAngleRad;
                      point.shapeType = "arc";
                      point.shapeArgs = _this.polar.arc(y + height, y, start2, start2 + point.pointWidth);
                    } else {
                      shapeArgs.height = height;
                      shapeArgs.y = y;
                      var _a2 = shapeArgs.x, x = _a2 === void 0 ? 0 : _a2, _b = shapeArgs.width, width = _b === void 0 ? 0 : _b;
                      point.tooltipPos = chart.inverted ? [
                        yAxis.len + yAxis.pos - chart.plotLeft - y - height / 2,
                        xAxis.len + xAxis.pos - chart.plotTop - x - width / 2,
                        height
                      ] : [
                        xAxis.left - chart.plotLeft + x + width / 2,
                        yAxis.pos - chart.plotTop + y + height / 2,
                        height
                      ];
                    }
                  }
                });
              };
              ColumnRangeSeries2.prototype.pointAttribs = function() {
                return columnProto.pointAttribs.apply(this, arguments);
              };
              ColumnRangeSeries2.prototype.translate3dPoints = function() {
                return columnProto.translate3dPoints.apply(this, arguments);
              };
              ColumnRangeSeries2.prototype.translate3dShapes = function() {
                return columnProto.translate3dShapes.apply(this, arguments);
              };
              ColumnRangeSeries2.defaultOptions = merge(ColumnSeries.defaultOptions, AreaRangeSeries.defaultOptions, columnRangeOptions);
              return ColumnRangeSeries2;
            }(AreaRangeSeries)
          );
          extend2(ColumnRangeSeries.prototype, {
            directTouch: true,
            pointClass: ColumnRangePoint,
            trackerGroups: ["group", "dataLabelsGroup"],
            adjustForMissingColumns: columnProto.adjustForMissingColumns,
            animate: columnProto.animate,
            crispCol: columnProto.crispCol,
            drawGraph: noop2,
            drawPoints: columnProto.drawPoints,
            getSymbol: noop2,
            drawTracker: columnProto.drawTracker,
            getColumnMetrics: columnProto.getColumnMetrics
            // pointAttribs: columnProto.pointAttribs,
            // polarArc: columnProto.polarArc
            // translate3dPoints: columnProto.translate3dPoints,
            // translate3dShapes: columnProto.translate3dShapes
          });
          SeriesRegistry.registerSeriesType("columnrange", ColumnRangeSeries);
          "";
          return ColumnRangeSeries;
        });
        _registerModule(_modules, "Series/ColumnPyramid/ColumnPyramidSeries.js", [_modules["Series/Column/ColumnSeries.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(ColumnSeries, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var colProto = ColumnSeries.prototype;
          var clamp = U.clamp, extend2 = U.extend, merge = U.merge, pick = U.pick;
          var ColumnPyramidSeries = (
            /** @class */
            function(_super) {
              __extends(ColumnPyramidSeries2, _super);
              function ColumnPyramidSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.data = void 0;
                _this.options = void 0;
                _this.points = void 0;
                return _this;
              }
              ColumnPyramidSeries2.prototype.translate = function() {
                var series = this, chart = series.chart, options = series.options, dense = series.dense = series.closestPointRange * series.xAxis.transA < 2, borderWidth = series.borderWidth = pick(
                  options.borderWidth,
                  dense ? 0 : 1
                  // #3635
                ), yAxis = series.yAxis, threshold = options.threshold, translatedThreshold = series.translatedThreshold = yAxis.getThreshold(threshold), minPointLength = pick(options.minPointLength, 5), metrics = series.getColumnMetrics(), pointWidth = metrics.width, seriesBarW = series.barW = Math.max(pointWidth, 1 + 2 * borderWidth), pointXOffset = series.pointXOffset = metrics.offset;
                if (chart.inverted) {
                  translatedThreshold -= 0.5;
                }
                if (options.pointPadding) {
                  seriesBarW = Math.ceil(seriesBarW);
                }
                colProto.translate.apply(series);
                series.points.forEach(function(point) {
                  var yBottom = pick(
                    point.yBottom,
                    translatedThreshold
                  ), safeDistance = 999 + Math.abs(yBottom), plotY = clamp(
                    point.plotY,
                    -safeDistance,
                    yAxis.len + safeDistance
                  ), barX = point.plotX + pointXOffset, barW = seriesBarW / 2, barY = Math.min(
                    plotY,
                    yBottom
                  ), barH = Math.max(
                    plotY,
                    yBottom
                  ) - barY, stackTotal, stackHeight, topPointY, topXwidth, bottomXwidth, invBarPos, x1, x2, x3, x4, y1, y2;
                  point.barX = barX;
                  point.pointWidth = pointWidth;
                  point.tooltipPos = chart.inverted ? [
                    yAxis.len + yAxis.pos - chart.plotLeft - plotY,
                    series.xAxis.len - barX - barW,
                    barH
                  ] : [
                    barX + barW,
                    plotY + yAxis.pos - chart.plotTop,
                    barH
                  ];
                  stackTotal = threshold + (point.total || point.y);
                  if (options.stacking === "percent") {
                    stackTotal = threshold + (point.y < 0) ? -100 : 100;
                  }
                  topPointY = yAxis.toPixels(stackTotal, true);
                  stackHeight = chart.plotHeight - topPointY - (chart.plotHeight - translatedThreshold);
                  topXwidth = stackHeight ? barW * (barY - topPointY) / stackHeight : 0;
                  bottomXwidth = stackHeight ? barW * (barY + barH - topPointY) / stackHeight : 0;
                  x1 = barX - topXwidth + barW;
                  x2 = barX + topXwidth + barW;
                  x3 = barX + bottomXwidth + barW;
                  x4 = barX - bottomXwidth + barW;
                  y1 = barY - minPointLength;
                  y2 = barY + barH;
                  if (point.y < 0) {
                    y1 = barY;
                    y2 = barY + barH + minPointLength;
                  }
                  if (chart.inverted) {
                    invBarPos = yAxis.width - barY;
                    stackHeight = topPointY - (yAxis.width - translatedThreshold);
                    topXwidth = barW * (topPointY - invBarPos) / stackHeight;
                    bottomXwidth = barW * (topPointY - (invBarPos - barH)) / stackHeight;
                    x1 = barX + barW + topXwidth;
                    x2 = x1 - 2 * topXwidth;
                    x3 = barX - bottomXwidth + barW;
                    x4 = barX + bottomXwidth + barW;
                    y1 = barY;
                    y2 = barY + barH - minPointLength;
                    if (point.y < 0) {
                      y2 = barY + barH + minPointLength;
                    }
                  }
                  point.shapeType = "path";
                  point.shapeArgs = {
                    // args for datalabels positioning
                    x: x1,
                    y: y1,
                    width: x2 - x1,
                    height: barH,
                    // path of pyramid
                    d: [
                      ["M", x1, y1],
                      ["L", x2, y1],
                      ["L", x3, y2],
                      ["L", x4, y2],
                      ["Z"]
                    ]
                  };
                });
              };
              ColumnPyramidSeries2.defaultOptions = merge(ColumnSeries.defaultOptions, {
                // Nothing here
              });
              return ColumnPyramidSeries2;
            }(ColumnSeries)
          );
          SeriesRegistry.registerSeriesType("columnpyramid", ColumnPyramidSeries);
          "";
          return ColumnPyramidSeries;
        });
        _registerModule(_modules, "Series/ErrorBar/ErrorBarSeriesDefaults.js", [], function() {
          var ErrorBarSeriesDefaults = {
            /**
             * The main color of the bars. This can be overridden by
             * [stemColor](#plotOptions.errorbar.stemColor) and
             * [whiskerColor](#plotOptions.errorbar.whiskerColor) individually.
             *
             * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
             *         Error bar styling
             *
             * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
             * @default #000000
             * @since   3.0
             * @product highcharts
             */
            color: "#000000",
            grouping: false,
            /**
                 * The parent series of the error bar. The default value links it to
                 * the previous series. Otherwise,
            use the id of the parent series.
                 *
                 * @since   3.0
                 * @product highcharts
                 */
            linkedTo: ":previous",
            tooltip: {
              pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'
            },
            /**
                 * The line width of the whiskers,
            the horizontal lines marking
                 * low and high values. When `null`,
            the general
                 * [lineWidth](#plotOptions.errorbar.lineWidth) applies.
                 *
                 * @sample {highcharts} highcharts/plotoptions/error-bar-styling/
                 *         Error bar styling
                 *
                 * @type    {number}
                 * @since   3.0
                 * @product highcharts
                 */
            whiskerWidth: null
          };
          "";
          return ErrorBarSeriesDefaults;
        });
        _registerModule(_modules, "Series/ErrorBar/ErrorBarSeries.js", [_modules["Series/BoxPlot/BoxPlotSeries.js"], _modules["Series/Column/ColumnSeries.js"], _modules["Series/ErrorBar/ErrorBarSeriesDefaults.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(BoxPlotSeries, ColumnSeries, ErrorBarSeriesDefaults, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var AreaRangeSeries = SeriesRegistry.seriesTypes.arearange;
          var addEvent = U.addEvent, merge = U.merge, extend2 = U.extend;
          var ErrorBarSeries = (
            /** @class */
            function(_super) {
              __extends(ErrorBarSeries2, _super);
              function ErrorBarSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.data = void 0;
                _this.options = void 0;
                _this.points = void 0;
                return _this;
              }
              ErrorBarSeries2.prototype.getColumnMetrics = function() {
                return this.linkedParent && this.linkedParent.columnMetrics || ColumnSeries.prototype.getColumnMetrics.call(this);
              };
              ErrorBarSeries2.prototype.drawDataLabels = function() {
                var valKey = this.pointValKey;
                if (AreaRangeSeries) {
                  AreaRangeSeries.prototype.drawDataLabels.call(this);
                  this.data.forEach(function(point) {
                    point.y = point[valKey];
                  });
                }
              };
              ErrorBarSeries2.prototype.toYData = function(point) {
                return [point.low, point.high];
              };
              ErrorBarSeries2.defaultOptions = merge(BoxPlotSeries.defaultOptions, ErrorBarSeriesDefaults);
              return ErrorBarSeries2;
            }(BoxPlotSeries)
          );
          addEvent(ErrorBarSeries, "afterTranslate", function() {
            this.points.forEach(function(point) {
              point.plotLow = point.plotY;
            });
          }, { order: 0 });
          extend2(ErrorBarSeries.prototype, {
            // pointClass: ErrorBarPoint, // just a declaration
            pointArrayMap: ["low", "high"],
            pointValKey: "high",
            doQuartiles: false
          });
          SeriesRegistry.registerSeriesType("errorbar", ErrorBarSeries);
          return ErrorBarSeries;
        });
        _registerModule(_modules, "Series/Gauge/GaugePoint.js", [_modules["Core/Series/SeriesRegistry.js"]], function(SeriesRegistry) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var Point = SeriesRegistry.series.prototype.pointClass;
          var GaugePoint = (
            /** @class */
            function(_super) {
              __extends(GaugePoint2, _super);
              function GaugePoint2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.options = void 0;
                _this.series = void 0;
                _this.shapeArgs = void 0;
                return _this;
              }
              GaugePoint2.prototype.setState = function(state) {
                this.state = state;
              };
              return GaugePoint2;
            }(Point)
          );
          return GaugePoint;
        });
        _registerModule(_modules, "Series/Gauge/GaugeSeries.js", [_modules["Series/Gauge/GaugePoint.js"], _modules["Core/Globals.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(GaugePoint, H, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var noop2 = H.noop;
          var Series = SeriesRegistry.series, ColumnSeries = SeriesRegistry.seriesTypes.column;
          var clamp = U.clamp, isNumber = U.isNumber, extend2 = U.extend, merge = U.merge, pick = U.pick, pInt = U.pInt;
          var GaugeSeries = (
            /** @class */
            function(_super) {
              __extends(GaugeSeries2, _super);
              function GaugeSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.data = void 0;
                _this.points = void 0;
                _this.options = void 0;
                _this.yAxis = void 0;
                return _this;
              }
              GaugeSeries2.prototype.translate = function() {
                var series = this, yAxis = series.yAxis, options = series.options, center = yAxis.center;
                series.generatePoints();
                series.points.forEach(function(point) {
                  var dialOptions = merge(
                    options.dial,
                    point.dial
                  ), radius = pInt(dialOptions.radius) * center[2] / 200, baseLength = pInt(dialOptions.baseLength) * radius / 100, rearLength = pInt(dialOptions.rearLength) * radius / 100, baseWidth = dialOptions.baseWidth, topWidth = dialOptions.topWidth;
                  var overshoot = options.overshoot, rotation = yAxis.startAngleRad + yAxis.translate(
                    point.y,
                    void 0,
                    void 0,
                    void 0,
                    true
                  );
                  if (isNumber(overshoot) || options.wrap === false) {
                    overshoot = isNumber(overshoot) ? overshoot / 180 * Math.PI : 0;
                    rotation = clamp(rotation, yAxis.startAngleRad - overshoot, yAxis.endAngleRad + overshoot);
                  }
                  rotation = rotation * 180 / Math.PI;
                  point.shapeType = "path";
                  var d = dialOptions.path || [
                    ["M", -rearLength, -baseWidth / 2],
                    [
                      "L",
                      baseLength,
                      -baseWidth / 2
                    ],
                    [
                      "L",
                      radius,
                      -topWidth / 2
                    ],
                    [
                      "L",
                      radius,
                      topWidth / 2
                    ],
                    [
                      "L",
                      baseLength,
                      baseWidth / 2
                    ],
                    [
                      "L",
                      -rearLength,
                      baseWidth / 2
                    ],
                    ["Z"]
                  ];
                  point.shapeArgs = {
                    d,
                    translateX: center[0],
                    translateY: center[1],
                    rotation
                  };
                  point.plotX = center[0];
                  point.plotY = center[1];
                });
              };
              GaugeSeries2.prototype.drawPoints = function() {
                var series = this, chart = series.chart, center = series.yAxis.center, pivot = series.pivot, options = series.options, pivotOptions = options.pivot, renderer = chart.renderer;
                series.points.forEach(function(point) {
                  var graphic = point.graphic, shapeArgs = point.shapeArgs, d = shapeArgs.d, dialOptions = merge(
                    options.dial,
                    point.dial
                  );
                  if (graphic) {
                    graphic.animate(shapeArgs);
                    shapeArgs.d = d;
                  } else {
                    point.graphic = renderer[point.shapeType](shapeArgs).attr({
                      // required by VML when animation is false
                      rotation: shapeArgs.rotation,
                      zIndex: 1
                    }).addClass("highcharts-dial").add(series.group);
                  }
                  if (!chart.styledMode) {
                    point.graphic[graphic ? "animate" : "attr"]({
                      stroke: dialOptions.borderColor,
                      "stroke-width": dialOptions.borderWidth,
                      fill: dialOptions.backgroundColor
                    });
                  }
                });
                if (pivot) {
                  pivot.animate({
                    translateX: center[0],
                    translateY: center[1]
                  });
                } else if (pivotOptions) {
                  series.pivot = renderer.circle(0, 0, pivotOptions.radius).attr({
                    zIndex: 2
                  }).addClass("highcharts-pivot").translate(center[0], center[1]).add(series.group);
                  if (!chart.styledMode) {
                    series.pivot.attr({
                      fill: pivotOptions.backgroundColor,
                      stroke: pivotOptions.borderColor,
                      "stroke-width": pivotOptions.borderWidth
                    });
                  }
                }
              };
              GaugeSeries2.prototype.animate = function(init3) {
                var series = this;
                if (!init3) {
                  series.points.forEach(function(point) {
                    var graphic = point.graphic;
                    if (graphic) {
                      graphic.attr({
                        rotation: series.yAxis.startAngleRad * 180 / Math.PI
                      });
                      graphic.animate({
                        rotation: point.shapeArgs.rotation
                      }, series.options.animation);
                    }
                  });
                }
              };
              GaugeSeries2.prototype.render = function() {
                this.group = this.plotGroup("group", "series", this.visible ? "inherit" : "hidden", this.options.zIndex, this.chart.seriesGroup);
                Series.prototype.render.call(this);
                this.group.clip(this.chart.clipRect);
              };
              GaugeSeries2.prototype.setData = function(data, redraw) {
                Series.prototype.setData.call(this, data, false);
                this.processData();
                this.generatePoints();
                if (pick(redraw, true)) {
                  this.chart.redraw();
                }
              };
              GaugeSeries2.prototype.hasData = function() {
                return !!this.points.length;
              };
              GaugeSeries2.defaultOptions = merge(Series.defaultOptions, {
                /**
                 * When this option is `true`, the dial will wrap around the axes.
                 * For instance, in a full-range gauge going from 0 to 360, a value
                 * of 400 will point to 40\. When `wrap` is `false`, the dial stops
                 * at 360.
                 *
                 * @see [overshoot](#plotOptions.gauge.overshoot)
                 *
                 * @type      {boolean}
                 * @default   true
                 * @since     3.0
                 * @product   highcharts
                 * @apioption plotOptions.gauge.wrap
                 */
                /**
                 * Data labels for the gauge. For gauges, the data labels are
                 * enabled by default and shown in a bordered box below the point.
                 *
                 * @since   2.3.0
                 * @product highcharts
                 */
                dataLabels: {
                  borderColor: "#cccccc",
                  borderRadius: 3,
                  borderWidth: 1,
                  crop: false,
                  defer: false,
                  enabled: true,
                  verticalAlign: "top",
                  y: 15,
                  zIndex: 2
                },
                /**
                 * Options for the dial or arrow pointer of the gauge.
                 *
                 * In styled mode, the dial is styled with the
                 * `.highcharts-gauge-series .highcharts-dial` rule.
                 *
                 * @sample {highcharts} highcharts/css/gauge/
                 *         Styled mode
                 *
                 * @type    {*}
                 * @since   2.3.0
                 * @product highcharts
                 */
                dial: {
                  /**
                   * The background or fill color of the gauge's dial.
                   *
                   * @sample {highcharts} highcharts/plotoptions/gauge-dial/
                   *         Dial options demonstrated
                   *
                   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                   * @default   #000000
                   * @since     2.3.0
                   * @product   highcharts
                   * @apioption plotOptions.gauge.dial.backgroundColor
                   */
                  backgroundColor: "#000000",
                  /**
                   * The length of the dial's base part, relative to the total
                   * radius or length of the dial.
                   *
                   * @sample {highcharts} highcharts/plotoptions/gauge-dial/
                   *         Dial options demonstrated
                   *
                   * @type      {string}
                   * @default   70%
                   * @since     2.3.0
                   * @product   highcharts
                   * @apioption plotOptions.gauge.dial.baseLength
                   */
                  baseLength: "70%",
                  /**
                   * The pixel width of the base of the gauge dial. The base is
                   * the part closest to the pivot, defined by baseLength.
                   *
                   * @sample {highcharts} highcharts/plotoptions/gauge-dial/
                   *         Dial options demonstrated
                   *
                   * @type      {number}
                   * @default   3
                   * @since     2.3.0
                   * @product   highcharts
                   * @apioption plotOptions.gauge.dial.baseWidth
                   */
                  baseWidth: 3,
                  /**
                   * The border color or stroke of the gauge's dial. By default,
                   * the borderWidth is 0, so this must be set in addition to a
                   * custom border color.
                   *
                   * @sample {highcharts} highcharts/plotoptions/gauge-dial/
                   *         Dial options demonstrated
                   *
                   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                   * @default   #cccccc
                   * @since     2.3.0
                   * @product   highcharts
                   * @apioption plotOptions.gauge.dial.borderColor
                   */
                  borderColor: "#cccccc",
                  /**
                   * The width of the gauge dial border in pixels.
                   *
                   * @sample {highcharts} highcharts/plotoptions/gauge-dial/
                   *         Dial options demonstrated
                   *
                   * @type      {number}
                   * @default   0
                   * @since     2.3.0
                   * @product   highcharts
                   * @apioption plotOptions.gauge.dial.borderWidth
                   */
                  borderWidth: 0,
                  /**
                   * An array with an SVG path for the custom dial.
                   *
                   * @sample {highcharts} highcharts/plotoptions/gauge-path/
                   *         Dial options demonstrated
                   *
                   * @type      {Highcharts.SVGPathArray}
                   * @since 10.2.0
                   * @product   highcharts
                   * @apioption plotOptions.gauge.dial.path
                   */
                  /**
                   * The radius or length of the dial, in percentages relative to
                   * the radius of the gauge itself.
                   *
                   * @sample {highcharts} highcharts/plotoptions/gauge-dial/
                   *         Dial options demonstrated
                   *
                   * @type      {string}
                   * @default   80%
                   * @since     2.3.0
                   * @product   highcharts
                   * @apioption plotOptions.gauge.dial.radius
                   */
                  radius: "80%",
                  /**
                   * The length of the dial's rear end, the part that extends out
                   * on the other side of the pivot. Relative to the dial's
                   * length.
                   *
                   * @sample {highcharts} highcharts/plotoptions/gauge-dial/
                   *         Dial options demonstrated
                   *
                   * @type      {string}
                   * @default   10%
                   * @since     2.3.0
                   * @product   highcharts
                   * @apioption plotOptions.gauge.dial.rearLength
                   */
                  rearLength: "10%",
                  /**
                   * The width of the top of the dial, closest to the perimeter.
                   * The pivot narrows in from the base to the top.
                   *
                   * @sample {highcharts} highcharts/plotoptions/gauge-dial/
                   *         Dial options demonstrated
                   *
                   * @type      {number}
                   * @default   1
                   * @since     2.3.0
                   * @product   highcharts
                   * @apioption plotOptions.gauge.dial.topWidth
                   */
                  topWidth: 1
                },
                /**
                 * Allow the dial to overshoot the end of the perimeter axis by
                 * this many degrees. Say if the gauge axis goes from 0 to 60, a
                 * value of 100, or 1000, will show 5 degrees beyond the end of the
                 * axis when this option is set to 5.
                 *
                 * @see [wrap](#plotOptions.gauge.wrap)
                 *
                 * @sample {highcharts} highcharts/plotoptions/gauge-overshoot/
                 *         Allow 5 degrees overshoot
                 *
                 * @type      {number}
                 * @since     3.0.10
                 * @product   highcharts
                 * @apioption plotOptions.gauge.overshoot
                 */
                /**
                 * Options for the pivot or the center point of the gauge.
                 *
                 * In styled mode, the pivot is styled with the
                 * `.highcharts-gauge-series .highcharts-pivot` rule.
                 *
                 * @sample {highcharts} highcharts/css/gauge/
                 *         Styled mode
                 *
                 * @type    {*}
                 * @since   2.3.0
                 * @product highcharts
                 */
                pivot: {
                  /**
                   * The pixel radius of the pivot.
                   *
                   * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
                   *         Pivot options demonstrated
                   *
                   * @type      {number}
                   * @default   5
                   * @since     2.3.0
                   * @product   highcharts
                   * @apioption plotOptions.gauge.pivot.radius
                   */
                  radius: 5,
                  /**
                   * The border or stroke width of the pivot.
                   *
                   * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
                   *         Pivot options demonstrated
                   *
                   * @type      {number}
                   * @default   0
                   * @since     2.3.0
                   * @product   highcharts
                   * @apioption plotOptions.gauge.pivot.borderWidth
                   */
                  borderWidth: 0,
                  /**
                   * The border or stroke color of the pivot. In able to change
                   * this, the borderWidth must also be set to something other
                   * than the default 0.
                   *
                   * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
                   *         Pivot options demonstrated
                   *
                   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                   * @default   #cccccc
                   * @since     2.3.0
                   * @product   highcharts
                   * @apioption plotOptions.gauge.pivot.borderColor
                   */
                  borderColor: "#cccccc",
                  /**
                   * The background color or fill of the pivot.
                   *
                   * @sample {highcharts} highcharts/plotoptions/gauge-pivot/
                   *         Pivot options demonstrated
                   *
                   * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                   * @default   #000000
                   * @since     2.3.0
                   * @product   highcharts
                   * @apioption plotOptions.gauge.pivot.backgroundColor
                   */
                  backgroundColor: "#000000"
                  /* Palette.neutralColor100 */
                },
                tooltip: {
                  headerFormat: ""
                },
                /**
                 * Whether to display this particular series or series type in the
                 * legend. Defaults to false for gauge series.
                 *
                 * @since   2.3.0
                 * @product highcharts
                 */
                showInLegend: false
                // Prototype members
              });
              return GaugeSeries2;
            }(Series)
          );
          extend2(GaugeSeries.prototype, {
            // chart.angular will be set to true when a gauge series is present,
            // and this will be used on the axes
            angular: true,
            directTouch: true,
            drawGraph: noop2,
            drawTracker: ColumnSeries.prototype.drawTracker,
            fixedBox: true,
            forceDL: true,
            noSharedTooltip: true,
            pointClass: GaugePoint,
            trackerGroups: ["group", "dataLabelsGroup"]
          });
          SeriesRegistry.registerSeriesType("gauge", GaugeSeries);
          "";
          return GaugeSeries;
        });
        _registerModule(_modules, "Series/DragNodesComposition.js", [_modules["Core/Utilities.js"]], function(U) {
          var addEvent = U.addEvent;
          var composedClasses = [];
          function compose(ChartClass) {
            if (composedClasses.indexOf(ChartClass) === -1) {
              composedClasses.push(ChartClass);
              addEvent(ChartClass, "load", onChartLoad);
            }
          }
          function onChartLoad() {
            var chart = this;
            var mousedownUnbinder, mousemoveUnbinder, mouseupUnbinder;
            if (chart.container) {
              mousedownUnbinder = addEvent(chart.container, "mousedown", function(event) {
                var point = chart.hoverPoint;
                if (point && point.series && point.series.hasDraggableNodes && point.series.options.draggable) {
                  point.series.onMouseDown(point, event);
                  mousemoveUnbinder = addEvent(chart.container, "mousemove", function(e) {
                    return point && point.series && point.series.onMouseMove(point, e);
                  });
                  mouseupUnbinder = addEvent(chart.container.ownerDocument, "mouseup", function(e) {
                    mousemoveUnbinder();
                    mouseupUnbinder();
                    return point && point.series && point.series.onMouseUp(point, e);
                  });
                }
              });
            }
            addEvent(chart, "destroy", function() {
              mousedownUnbinder();
            });
          }
          function onMouseDown(point, event) {
            var normalizedEvent = this.chart.pointer.normalize(event);
            point.fixedPosition = {
              chartX: normalizedEvent.chartX,
              chartY: normalizedEvent.chartY,
              plotX: point.plotX,
              plotY: point.plotY
            };
            point.inDragMode = true;
          }
          function onMouseMove(point, event) {
            if (point.fixedPosition && point.inDragMode) {
              var series = this, chart = series.chart, normalizedEvent = chart.pointer.normalize(event), diffX = point.fixedPosition.chartX - normalizedEvent.chartX, diffY = point.fixedPosition.chartY - normalizedEvent.chartY, graphLayoutsLookup = chart.graphLayoutsLookup;
              var newPlotX = void 0, newPlotY = void 0;
              if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {
                newPlotX = point.fixedPosition.plotX - diffX;
                newPlotY = point.fixedPosition.plotY - diffY;
                if (chart.isInsidePlot(newPlotX, newPlotY)) {
                  point.plotX = newPlotX;
                  point.plotY = newPlotY;
                  point.hasDragged = true;
                  this.redrawHalo(point);
                  graphLayoutsLookup.forEach(function(layout) {
                    layout.restartSimulation();
                  });
                }
              }
            }
          }
          function onMouseUp(point, _event) {
            if (point.fixedPosition) {
              if (point.hasDragged) {
                if (this.layout.enableSimulation) {
                  this.layout.start();
                } else {
                  this.chart.redraw();
                }
              }
              point.inDragMode = point.hasDragged = false;
              if (!this.options.fixedDraggable) {
                delete point.fixedPosition;
              }
            }
          }
          function redrawHalo(point) {
            if (point && this.halo) {
              this.halo.attr({
                d: point.haloPath(this.options.states.hover.halo.size)
              });
            }
          }
          var DragNodesComposition = {
            compose,
            onMouseDown,
            onMouseMove,
            onMouseUp,
            redrawHalo
          };
          return DragNodesComposition;
        });
        _registerModule(_modules, "Series/GraphLayoutComposition.js", [_modules["Core/Animation/AnimationUtilities.js"], _modules["Core/Utilities.js"]], function(A, U) {
          var setAnimation = A.setAnimation;
          var addEvent = U.addEvent;
          var composedClasses = [];
          var integrations = {};
          var layouts = {};
          function compose(ChartClass) {
            if (composedClasses.indexOf(ChartClass)) {
              composedClasses.push(ChartClass);
              addEvent(ChartClass, "afterPrint", onChartAfterPrint);
              addEvent(ChartClass, "beforePrint", onChartBeforePrint);
              addEvent(ChartClass, "predraw", onChartPredraw);
              addEvent(ChartClass, "render", onChartRender);
            }
          }
          function onChartAfterPrint() {
            if (this.graphLayoutsLookup) {
              this.graphLayoutsLookup.forEach(function(layout) {
                layout.updateSimulation();
              });
              this.redraw();
            }
          }
          function onChartBeforePrint() {
            if (this.graphLayoutsLookup) {
              this.graphLayoutsLookup.forEach(function(layout) {
                layout.updateSimulation(false);
              });
              this.redraw();
            }
          }
          function onChartPredraw() {
            if (this.graphLayoutsLookup) {
              this.graphLayoutsLookup.forEach(function(layout) {
                layout.stop();
              });
            }
          }
          function onChartRender() {
            var systemsStable, afterRender = false;
            var layoutStep = function(layout) {
              if (layout.maxIterations-- && isFinite(layout.temperature) && !layout.isStable() && !layout.enableSimulation) {
                if (layout.beforeStep) {
                  layout.beforeStep();
                }
                layout.step();
                systemsStable = false;
                afterRender = true;
              }
            };
            if (this.graphLayoutsLookup) {
              setAnimation(false, this);
              this.graphLayoutsLookup.forEach(function(layout) {
                return layout.start();
              });
              while (!systemsStable) {
                systemsStable = true;
                this.graphLayoutsLookup.forEach(layoutStep);
              }
              if (afterRender) {
                this.series.forEach(function(series) {
                  if (series && series.layout) {
                    series.render();
                  }
                });
              }
            }
          }
          var GraphLayoutComposition = {
            compose,
            integrations,
            layouts
          };
          return GraphLayoutComposition;
        });
        _registerModule(_modules, "Series/PackedBubble/PackedBubblePoint.js", [_modules["Core/Chart/Chart.js"], _modules["Core/Series/Point.js"], _modules["Core/Series/SeriesRegistry.js"]], function(Chart, Point, SeriesRegistry) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var BubblePoint = SeriesRegistry.seriesTypes.bubble.prototype.pointClass;
          var PackedBubblePoint = (
            /** @class */
            function(_super) {
              __extends(PackedBubblePoint2, _super);
              function PackedBubblePoint2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.degree = NaN;
                _this.mass = NaN;
                _this.radius = NaN;
                _this.options = void 0;
                _this.series = void 0;
                _this.value = null;
                return _this;
              }
              PackedBubblePoint2.prototype.destroy = function() {
                if (this.series.layout) {
                  this.series.layout.removeElementFromCollection(this, this.series.layout.nodes);
                }
                return Point.prototype.destroy.apply(this, arguments);
              };
              PackedBubblePoint2.prototype.firePointEvent = function() {
                var point = this, series = this.series, seriesOptions = series.options;
                if (this.isParentNode && seriesOptions.parentNode) {
                  var temp = seriesOptions.allowPointSelect;
                  seriesOptions.allowPointSelect = seriesOptions.parentNode.allowPointSelect;
                  Point.prototype.firePointEvent.apply(this, arguments);
                  seriesOptions.allowPointSelect = temp;
                } else {
                  Point.prototype.firePointEvent.apply(this, arguments);
                }
              };
              PackedBubblePoint2.prototype.select = function() {
                var point = this, series = this.series, chart = series.chart;
                if (point.isParentNode) {
                  chart.getSelectedPoints = chart.getSelectedParentNodes;
                  Point.prototype.select.apply(this, arguments);
                  chart.getSelectedPoints = Chart.prototype.getSelectedPoints;
                } else {
                  Point.prototype.select.apply(this, arguments);
                }
              };
              return PackedBubblePoint2;
            }(BubblePoint)
          );
          return PackedBubblePoint;
        });
        _registerModule(_modules, "Series/PackedBubble/PackedBubbleSeriesDefaults.js", [_modules["Core/Utilities.js"]], function(U) {
          var isNumber = U.isNumber;
          var PackedBubbleSeriesDefaults = {
            /**
                 * Minimum bubble size. Bubbles will automatically size between the
                 * `minSize` and `maxSize` to reflect the value of each bubble.
                 * Can be either pixels (when no unit is given),
            or a percentage of
                 * the smallest one of the plot width and height,
            divided by the square
                 * root of total number of points.
                 *
                 * @sample highcharts/plotoptions/bubble-size/
                 *         Bubble size
                 *
                 * @type {number|string}
                 *
                 * @private
                 */
            minSize: "10%",
            /**
                 * Maximum bubble size. Bubbles will automatically size between the
                 * `minSize` and `maxSize` to reflect the value of each bubble.
                 * Can be either pixels (when no unit is given),
            or a percentage of
                 * the smallest one of the plot width and height,
            divided by the square
                 * root of total number of points.
                 *
                 * @sample highcharts/plotoptions/bubble-size/
                 *         Bubble size
                 *
                 * @type {number|string}
                 *
                 * @private
                 */
            maxSize: "50%",
            sizeBy: "area",
            zoneAxis: "y",
            crisp: false,
            tooltip: {
              pointFormat: "Value: {point.value}"
            },
            /**
             * Flag to determine if nodes are draggable or not. Available for
             * graph with useSimulation set to true only.
             *
             * @since 7.1.0
             *
             * @private
             */
            draggable: true,
            /**
                 * An option is giving a possibility to choose between using simulation
                 * for calculating bubble positions. These reflects in both animation
                 * and final position of bubbles. Simulation is also adding options to
                 * the series graph based on used layout. In case of big data sets,
            with
                 * any performance issues,
            it is possible to disable animation and pack
                 * bubble in a simple circular way.
                 *
                 * @sample highcharts/series-packedbubble/spiral/
                 *         useSimulation set to false
                 *
                 * @since 7.1.0
                 *
                 * @private
                 */
            useSimulation: true,
            /**
             * Series options for parent nodes.
             *
             * @since 8.1.1
             *
             * @private
             */
            parentNode: {
              /**
               * Allow this series' parent nodes to be selected
               * by clicking on the graph.
               *
               * @since 8.1.1
               */
              allowPointSelect: false
            },
            /**
            /**
             *
             * @declare Highcharts.SeriesPackedBubbleDataLabelsOptionsObject
             *
             * @private
             */
            dataLabels: {
              /**
                       * The
                       * [format string](https://www.highcharts.com/docs/chart-concepts/labels-and-string-formatting)
                       * specifying what to show for _node_ in the networkgraph. In v7.0
                       * defaults to `{key}`,
              since v7.1 defaults to `undefined` and
                       * `formatter` is used instead.
                       *
                       * @type      {string}
                       * @since     7.0.0
                       * @apioption plotOptions.packedbubble.dataLabels.format
                       */
              // eslint-disable-next-line valid-jsdoc
              /**
                       * Callback JavaScript function to format the data label for a node.
                       * Note that if a `format` is defined,
              the format takes precedence
                       * and the formatter is ignored.
                       *
                       * @type  {Highcharts.SeriesPackedBubbleDataLabelsFormatterCallbackFunction}
                       * @since 7.0.0
                       */
              formatter: function() {
                var numberFormatter = this.series.chart.numberFormatter;
                var value = this.point.value;
                return isNumber(value) ? numberFormatter(value, -1) : "";
              },
              /**
               * @type      {string}
               * @since     7.1.0
               * @apioption plotOptions.packedbubble.dataLabels.parentNodeFormat
               */
              // eslint-disable-next-line valid-jsdoc
              /**
               * @type  {Highcharts.SeriesPackedBubbleDataLabelsFormatterCallbackFunction}
               * @since 7.1.0
               */
              parentNodeFormatter: function() {
                return this.name;
              },
              /**
               * @sample {highcharts} highcharts/series-packedbubble/packed-dashboard
               *         Dashboard with dataLabels on parentNodes
               *
               * @declare Highcharts.SeriesPackedBubbleDataLabelsTextPathOptionsObject
               * @since   7.1.0
               */
              parentNodeTextPath: {
                /**
                 * Presentation attributes for the text path.
                 *
                 * @type      {Highcharts.SVGAttributes}
                 * @since     7.1.0
                 * @apioption plotOptions.packedbubble.dataLabels.attributes
                 */
                /**
                 * Enable or disable `textPath` option for link's or marker's
                 * data labels.
                 *
                 * @since 7.1.0
                 */
                enabled: true
              },
              /**
               * Options for a _node_ label text which should follow marker's
               * shape.
               *
               * **Note:** Only SVG-based renderer supports this option.
               *
               * @extends   plotOptions.series.dataLabels.textPath
               * @apioption plotOptions.packedbubble.dataLabels.textPath
               */
              padding: 0,
              style: {
                transition: "opacity 2000ms"
              }
            },
            /**
             * Options for layout algorithm when simulation is enabled. Inside there
             * are options to change the speed, padding, initial bubbles positions
             * and more.
             *
             * @extends   plotOptions.networkgraph.layoutAlgorithm
             * @excluding approximation, attractiveForce, repulsiveForce, theta
             * @since     7.1.0
             *
             * @private
             */
            layoutAlgorithm: {
              /**
               * Initial layout algorithm for positioning nodes. Can be one of
               * the built-in options ("circle", "random") or a function where
               * positions should be set on each node (`this.nodes`) as
               * `node.plotX` and `node.plotY`.
               *
               * @sample highcharts/series-networkgraph/initial-positions/
               *         Initial positions with callback
               *
               * @type {"circle"|"random"|Function}
               */
              initialPositions: "circle",
              /**
               * @sample highcharts/series-packedbubble/initial-radius/
               *         Initial radius set to 200
               *
               * @extends   plotOptions.networkgraph.layoutAlgorithm.initialPositionRadius
               * @excluding states
               */
              initialPositionRadius: 20,
              /**
               * The distance between two bubbles, when the algorithm starts to
               * treat two bubbles as overlapping. The `bubblePadding` is also the
               * expected distance between all the bubbles on simulation end.
               */
              bubblePadding: 5,
              /**
               * Whether bubbles should interact with their parentNode to keep
               * them inside.
               */
              parentNodeLimit: false,
              /**
               * Whether series should interact with each other or not. When
               * `parentNodeLimit` is set to true, thi option should be set to
               * false to avoid sticking points in wrong series parentNode.
               */
              seriesInteraction: true,
              /**
               * In case of split series, this option allows user to drag and
               * drop points between series, for changing point related series.
               *
               * @sample highcharts/series-packedbubble/packed-dashboard/
               *         Example of drag'n drop bubbles for bubble kanban
               */
              dragBetweenSeries: false,
              /**
               * Layout algorithm options for parent nodes.
               *
               * @extends   plotOptions.networkgraph.layoutAlgorithm
               * @excluding approximation, attractiveForce, enableSimulation,
               *            repulsiveForce, theta
               */
              parentNodeOptions: {
                maxIterations: 400,
                gravitationalConstant: 0.03,
                maxSpeed: 50,
                initialPositionRadius: 100,
                seriesInteraction: true,
                /**
                 * Styling options for parentNodes markers. Similar to
                 * line.marker options.
                 *
                 * @sample highcharts/series-packedbubble/parentnode-style/
                 *         Bubble size
                 *
                 * @extends   plotOptions.series.marker
                 * @excluding states
                 */
                marker: {
                  fillColor: null,
                  fillOpacity: 1,
                  lineWidth: null,
                  lineColor: null,
                  symbol: "circle"
                }
              },
              enableSimulation: true,
              /**
               * Type of the algorithm used when positioning bubbles.
               * @ignore-option
               */
              type: "packedbubble",
              /**
               * Integration type. Integration determines how forces are applied
               * on particles. The `packedbubble` integration is based on
               * the networkgraph `verlet` integration, where the new position
               * is based on a previous position without velocity:
               * `newPosition += previousPosition - newPosition`.
               *
               * @sample highcharts/series-networkgraph/forces/
               *
               * @ignore-option
               */
              integration: "packedbubble",
              maxIterations: 1e3,
              /**
               * Whether to split series into individual groups or to mix all
               * series together.
               *
               * @since   7.1.0
               * @default false
               */
              splitSeries: false,
              /**
               * Max speed that node can get in one iteration. In terms of
               * simulation, it's a maximum translation (in pixels) that a node
               * can move (in both, x and y, dimensions). While `friction` is
               * applied on all nodes, max speed is applied only for nodes that
               * move very fast, for example small or disconnected ones.
               *
               * @see [layoutAlgorithm.integration](#series.networkgraph.layoutAlgorithm.integration)
               *
               * @see [layoutAlgorithm.friction](#series.networkgraph.layoutAlgorithm.friction)
               */
              maxSpeed: 5,
              gravitationalConstant: 0.01,
              friction: -0.981
            }
          };
          "";
          return PackedBubbleSeriesDefaults;
        });
        _registerModule(_modules, "Series/Networkgraph/VerletIntegration.js", [], function() {
          function attractive(link, force, distanceXY) {
            var massFactor = link.getMass(), translatedX = -distanceXY.x * force * this.diffTemperature, translatedY = -distanceXY.y * force * this.diffTemperature;
            if (!link.fromNode.fixedPosition) {
              link.fromNode.plotX -= translatedX * massFactor.fromNode / link.fromNode.degree;
              link.fromNode.plotY -= translatedY * massFactor.fromNode / link.fromNode.degree;
            }
            if (!link.toNode.fixedPosition) {
              link.toNode.plotX += translatedX * massFactor.toNode / link.toNode.degree;
              link.toNode.plotY += translatedY * massFactor.toNode / link.toNode.degree;
            }
          }
          function attractiveForceFunction(d, k) {
            return (k - d) / d;
          }
          function barycenter() {
            var gravitationalConstant = this.options.gravitationalConstant, xFactor = this.barycenter.xFactor, yFactor = this.barycenter.yFactor;
            xFactor = (xFactor - (this.box.left + this.box.width) / 2) * gravitationalConstant;
            yFactor = (yFactor - (this.box.top + this.box.height) / 2) * gravitationalConstant;
            this.nodes.forEach(function(node) {
              if (!node.fixedPosition) {
                node.plotX -= xFactor / node.mass / node.degree;
                node.plotY -= yFactor / node.mass / node.degree;
              }
            });
          }
          function getK(layout) {
            return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.5);
          }
          function integrate(layout, node) {
            var friction = -layout.options.friction, maxSpeed = layout.options.maxSpeed, prevX = node.prevX, prevY = node.prevY, diffX = (node.plotX + node.dispX - prevX) * friction, diffY = (node.plotY + node.dispY - prevY) * friction, abs = Math.abs, signX = abs(diffX) / (diffX || 1), signY = abs(diffY) / (diffY || 1);
            diffX = signX * Math.min(maxSpeed, Math.abs(diffX));
            diffY = signY * Math.min(maxSpeed, Math.abs(diffY));
            node.prevX = node.plotX + node.dispX;
            node.prevY = node.plotY + node.dispY;
            node.plotX += diffX;
            node.plotY += diffY;
            node.temperature = layout.vectorLength({
              x: diffX,
              y: diffY
            });
          }
          function repulsive(node, force, distanceXY) {
            var factor = force * this.diffTemperature / node.mass / node.degree;
            if (!node.fixedPosition) {
              node.plotX += distanceXY.x * factor;
              node.plotY += distanceXY.y * factor;
            }
          }
          function repulsiveForceFunction(d, k) {
            return (k - d) / d * (k > d ? 1 : 0);
          }
          var VerletIntegration = {
            attractive,
            attractiveForceFunction,
            barycenter,
            getK,
            integrate,
            repulsive,
            repulsiveForceFunction
          };
          return VerletIntegration;
        });
        _registerModule(_modules, "Series/PackedBubble/PackedBubbleIntegration.js", [_modules["Core/Globals.js"], _modules["Series/Networkgraph/VerletIntegration.js"]], function(H, VerletIntegration) {
          var noop2 = H.noop;
          function barycenter() {
            var layout = this, gravitationalConstant = layout.options.gravitationalConstant, box = layout.box, nodes = layout.nodes;
            var centerX, centerY;
            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
              var node = nodes_1[_i];
              if (layout.options.splitSeries && !node.isParentNode) {
                centerX = node.series.parentNode.plotX;
                centerY = node.series.parentNode.plotY;
              } else {
                centerX = box.width / 2;
                centerY = box.height / 2;
              }
              if (!node.fixedPosition) {
                node.plotX -= (node.plotX - centerX) * gravitationalConstant / (node.mass * Math.sqrt(nodes.length));
                node.plotY -= (node.plotY - centerY) * gravitationalConstant / (node.mass * Math.sqrt(nodes.length));
              }
            }
          }
          function repulsive(node, force, distanceXY, repNode) {
            var factor = force * this.diffTemperature / node.mass / node.degree, x = distanceXY.x * factor, y = distanceXY.y * factor;
            if (!node.fixedPosition) {
              node.plotX += x;
              node.plotY += y;
            }
            if (!repNode.fixedPosition) {
              repNode.plotX -= x;
              repNode.plotY -= y;
            }
          }
          function repulsiveForceFunction(d, k, node, repNode) {
            return Math.min(d, (node.marker.radius + repNode.marker.radius) / 2);
          }
          var PackedBubbleIntegration = {
            barycenter,
            getK: noop2,
            integrate: VerletIntegration.integrate,
            repulsive,
            repulsiveForceFunction
          };
          return PackedBubbleIntegration;
        });
        _registerModule(_modules, "Series/Networkgraph/EulerIntegration.js", [], function() {
          function attractive(link, force, distanceXY, distanceR) {
            var massFactor = link.getMass(), translatedX = distanceXY.x / distanceR * force, translatedY = distanceXY.y / distanceR * force;
            if (!link.fromNode.fixedPosition) {
              link.fromNode.dispX -= translatedX * massFactor.fromNode / link.fromNode.degree;
              link.fromNode.dispY -= translatedY * massFactor.fromNode / link.fromNode.degree;
            }
            if (!link.toNode.fixedPosition) {
              link.toNode.dispX += translatedX * massFactor.toNode / link.toNode.degree;
              link.toNode.dispY += translatedY * massFactor.toNode / link.toNode.degree;
            }
          }
          function attractiveForceFunction(d, k) {
            return d * d / k;
          }
          function barycenter() {
            var gravitationalConstant = this.options.gravitationalConstant, xFactor = this.barycenter.xFactor, yFactor = this.barycenter.yFactor;
            this.nodes.forEach(function(node) {
              if (!node.fixedPosition) {
                var degree = node.getDegree(), phi = degree * (1 + degree / 2);
                node.dispX += (xFactor - node.plotX) * gravitationalConstant * phi / node.degree;
                node.dispY += (yFactor - node.plotY) * gravitationalConstant * phi / node.degree;
              }
            });
          }
          function getK(layout) {
            return Math.pow(layout.box.width * layout.box.height / layout.nodes.length, 0.3);
          }
          function integrate(layout, node) {
            var distanceR;
            node.dispX += node.dispX * layout.options.friction;
            node.dispY += node.dispY * layout.options.friction;
            distanceR = node.temperature = layout.vectorLength({
              x: node.dispX,
              y: node.dispY
            });
            if (distanceR !== 0) {
              node.plotX += node.dispX / distanceR * Math.min(Math.abs(node.dispX), layout.temperature);
              node.plotY += node.dispY / distanceR * Math.min(Math.abs(node.dispY), layout.temperature);
            }
          }
          function repulsive(node, force, distanceXY, distanceR) {
            node.dispX += distanceXY.x / distanceR * force / node.degree;
            node.dispY += distanceXY.y / distanceR * force / node.degree;
          }
          function repulsiveForceFunction(d, k) {
            return k * k / d;
          }
          var EulerIntegration = {
            attractive,
            attractiveForceFunction,
            barycenter,
            getK,
            integrate,
            repulsive,
            repulsiveForceFunction
          };
          return EulerIntegration;
        });
        _registerModule(_modules, "Series/Networkgraph/QuadTreeNode.js", [], function() {
          var QuadTreeNode = (
            /** @class */
            function() {
              function QuadTreeNode2(box) {
                this.body = false;
                this.isEmpty = false;
                this.isInternal = false;
                this.nodes = [];
                this.box = box;
                this.boxSize = Math.min(box.width, box.height);
              }
              QuadTreeNode2.prototype.divideBox = function() {
                var halfWidth = this.box.width / 2, halfHeight = this.box.height / 2;
                this.nodes[0] = new QuadTreeNode2({
                  left: this.box.left,
                  top: this.box.top,
                  width: halfWidth,
                  height: halfHeight
                });
                this.nodes[1] = new QuadTreeNode2({
                  left: this.box.left + halfWidth,
                  top: this.box.top,
                  width: halfWidth,
                  height: halfHeight
                });
                this.nodes[2] = new QuadTreeNode2({
                  left: this.box.left + halfWidth,
                  top: this.box.top + halfHeight,
                  width: halfWidth,
                  height: halfHeight
                });
                this.nodes[3] = new QuadTreeNode2({
                  left: this.box.left,
                  top: this.box.top + halfHeight,
                  width: halfWidth,
                  height: halfHeight
                });
              };
              QuadTreeNode2.prototype.getBoxPosition = function(point) {
                var left = point.plotX < this.box.left + this.box.width / 2, top = point.plotY < this.box.top + this.box.height / 2;
                var index;
                if (left) {
                  if (top) {
                    index = 0;
                  } else {
                    index = 3;
                  }
                } else {
                  if (top) {
                    index = 1;
                  } else {
                    index = 2;
                  }
                }
                return index;
              };
              QuadTreeNode2.prototype.insert = function(point, depth) {
                var newQuadTreeNode;
                if (this.isInternal) {
                  this.nodes[this.getBoxPosition(point)].insert(point, depth - 1);
                } else {
                  this.isEmpty = false;
                  if (!this.body) {
                    this.isInternal = false;
                    this.body = point;
                  } else {
                    if (depth) {
                      this.isInternal = true;
                      this.divideBox();
                      if (this.body !== true) {
                        this.nodes[this.getBoxPosition(this.body)].insert(this.body, depth - 1);
                        this.body = true;
                      }
                      this.nodes[this.getBoxPosition(point)].insert(point, depth - 1);
                    } else {
                      newQuadTreeNode = new QuadTreeNode2({
                        top: point.plotX || NaN,
                        left: point.plotY || NaN,
                        // Width/height below 1px
                        width: 0.1,
                        height: 0.1
                      });
                      newQuadTreeNode.body = point;
                      newQuadTreeNode.isInternal = false;
                      this.nodes.push(newQuadTreeNode);
                    }
                  }
                }
              };
              QuadTreeNode2.prototype.updateMassAndCenter = function() {
                var mass = 0, plotX = 0, plotY = 0;
                if (this.isInternal) {
                  for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {
                    var pointMass = _a[_i];
                    if (!pointMass.isEmpty) {
                      mass += pointMass.mass;
                      plotX += pointMass.plotX * pointMass.mass;
                      plotY += pointMass.plotY * pointMass.mass;
                    }
                  }
                  plotX /= mass;
                  plotY /= mass;
                } else if (this.body) {
                  mass = this.body.mass;
                  plotX = this.body.plotX;
                  plotY = this.body.plotY;
                }
                this.mass = mass;
                this.plotX = plotX;
                this.plotY = plotY;
              };
              return QuadTreeNode2;
            }()
          );
          return QuadTreeNode;
        });
        _registerModule(_modules, "Series/Networkgraph/QuadTree.js", [_modules["Series/Networkgraph/QuadTreeNode.js"]], function(QuadTreeNode) {
          var QuadTree = (
            /** @class */
            function() {
              function QuadTree2(x, y, width, height) {
                this.box = {
                  left: x,
                  top: y,
                  width,
                  height
                };
                this.maxDepth = 25;
                this.root = new QuadTreeNode(this.box);
                this.root.isInternal = true;
                this.root.isRoot = true;
                this.root.divideBox();
              }
              QuadTree2.prototype.calculateMassAndCenter = function() {
                this.visitNodeRecursive(null, null, function(node) {
                  node.updateMassAndCenter();
                });
              };
              QuadTree2.prototype.insertNodes = function(points) {
                for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {
                  var point = points_1[_i];
                  this.root.insert(point, this.maxDepth);
                }
              };
              QuadTree2.prototype.visitNodeRecursive = function(node, beforeCallback, afterCallback) {
                var goFurther;
                if (!node) {
                  node = this.root;
                }
                if (node === this.root && beforeCallback) {
                  goFurther = beforeCallback(node);
                }
                if (goFurther === false) {
                  return;
                }
                for (var _i = 0, _a = node.nodes; _i < _a.length; _i++) {
                  var qtNode = _a[_i];
                  if (qtNode.isInternal) {
                    if (beforeCallback) {
                      goFurther = beforeCallback(qtNode);
                    }
                    if (goFurther === false) {
                      continue;
                    }
                    this.visitNodeRecursive(qtNode, beforeCallback, afterCallback);
                  } else if (qtNode.body) {
                    if (beforeCallback) {
                      beforeCallback(qtNode.body);
                    }
                  }
                  if (afterCallback) {
                    afterCallback(qtNode);
                  }
                }
                if (node === this.root && afterCallback) {
                  afterCallback(node);
                }
              };
              return QuadTree2;
            }()
          );
          return QuadTree;
        });
        _registerModule(_modules, "Series/Networkgraph/ReingoldFruchtermanLayout.js", [_modules["Series/Networkgraph/EulerIntegration.js"], _modules["Core/Globals.js"], _modules["Series/GraphLayoutComposition.js"], _modules["Series/Networkgraph/QuadTree.js"], _modules["Core/Utilities.js"], _modules["Series/Networkgraph/VerletIntegration.js"]], function(EulerIntegration, H, GraphLayout, QuadTree, U, VerletIntegration) {
          var win = H.win;
          var clamp = U.clamp, defined = U.defined, isFunction = U.isFunction, pick = U.pick;
          var ReingoldFruchtermanLayout = (
            /** @class */
            function() {
              function ReingoldFruchtermanLayout2() {
                this.attractiveForce = void 0;
                this.box = {};
                this.currentStep = 0;
                this.initialRendering = true;
                this.integration = void 0;
                this.links = [];
                this.nodes = [];
                this.options = void 0;
                this.quadTree = void 0;
                this.repulsiveForce = void 0;
                this.series = [];
                this.simulation = false;
              }
              ReingoldFruchtermanLayout2.compose = function(ChartClass) {
                GraphLayout.compose(ChartClass);
                GraphLayout.integrations.euler = EulerIntegration;
                GraphLayout.integrations.verlet = VerletIntegration;
                GraphLayout.layouts["reingold-fruchterman"] = ReingoldFruchtermanLayout2;
              };
              ReingoldFruchtermanLayout2.prototype.init = function(options) {
                this.options = options;
                this.nodes = [];
                this.links = [];
                this.series = [];
                this.box = {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
                this.setInitialRendering(true);
                this.integration = GraphLayout.integrations[options.integration];
                this.enableSimulation = options.enableSimulation;
                this.attractiveForce = pick(options.attractiveForce, this.integration.attractiveForceFunction);
                this.repulsiveForce = pick(options.repulsiveForce, this.integration.repulsiveForceFunction);
                this.approximation = options.approximation;
              };
              ReingoldFruchtermanLayout2.prototype.updateSimulation = function(enable) {
                this.enableSimulation = pick(enable, this.options.enableSimulation);
              };
              ReingoldFruchtermanLayout2.prototype.start = function() {
                var layout = this, series = this.series, options = this.options;
                layout.currentStep = 0;
                layout.forces = series[0] && series[0].forces || [];
                layout.chart = series[0] && series[0].chart;
                if (layout.initialRendering) {
                  layout.initPositions();
                  series.forEach(function(s) {
                    s.finishedAnimating = true;
                    s.render();
                  });
                }
                layout.setK();
                layout.resetSimulation(options);
                if (layout.enableSimulation) {
                  layout.step();
                }
              };
              ReingoldFruchtermanLayout2.prototype.step = function() {
                var _this = this;
                var anyLayout = this, allSeries = this.series;
                this.currentStep++;
                if (this.approximation === "barnes-hut") {
                  this.createQuadTree();
                  this.quadTree.calculateMassAndCenter();
                }
                for (var _i = 0, _a = this.forces || []; _i < _a.length; _i++) {
                  var forceName = _a[_i];
                  anyLayout[forceName + "Forces"](this.temperature);
                }
                this.applyLimits();
                this.temperature = this.coolDown(this.startTemperature, this.diffTemperature, this.currentStep);
                this.prevSystemTemperature = this.systemTemperature;
                this.systemTemperature = this.getSystemTemperature();
                if (this.enableSimulation) {
                  for (var _b = 0, allSeries_1 = allSeries; _b < allSeries_1.length; _b++) {
                    var series = allSeries_1[_b];
                    if (series.chart) {
                      series.render();
                    }
                  }
                  if (this.maxIterations-- && isFinite(this.temperature) && !this.isStable()) {
                    if (this.simulation) {
                      win.cancelAnimationFrame(this.simulation);
                    }
                    this.simulation = win.requestAnimationFrame(function() {
                      return _this.step();
                    });
                  } else {
                    this.simulation = false;
                  }
                }
              };
              ReingoldFruchtermanLayout2.prototype.stop = function() {
                if (this.simulation) {
                  win.cancelAnimationFrame(this.simulation);
                }
              };
              ReingoldFruchtermanLayout2.prototype.setArea = function(x, y, w, h3) {
                this.box = {
                  left: x,
                  top: y,
                  width: w,
                  height: h3
                };
              };
              ReingoldFruchtermanLayout2.prototype.setK = function() {
                this.k = this.options.linkLength || this.integration.getK(this);
              };
              ReingoldFruchtermanLayout2.prototype.addElementsToCollection = function(elements, collection) {
                for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
                  var element = elements_1[_i];
                  if (collection.indexOf(element) === -1) {
                    collection.push(element);
                  }
                }
              };
              ReingoldFruchtermanLayout2.prototype.removeElementFromCollection = function(element, collection) {
                var index = collection.indexOf(element);
                if (index !== -1) {
                  collection.splice(index, 1);
                }
              };
              ReingoldFruchtermanLayout2.prototype.clear = function() {
                this.nodes.length = 0;
                this.links.length = 0;
                this.series.length = 0;
                this.resetSimulation();
              };
              ReingoldFruchtermanLayout2.prototype.resetSimulation = function() {
                this.forcedStop = false;
                this.systemTemperature = 0;
                this.setMaxIterations();
                this.setTemperature();
                this.setDiffTemperature();
              };
              ReingoldFruchtermanLayout2.prototype.restartSimulation = function() {
                if (!this.simulation) {
                  this.setInitialRendering(false);
                  if (!this.enableSimulation) {
                    this.setMaxIterations(1);
                  } else {
                    this.start();
                  }
                  if (this.chart) {
                    this.chart.redraw();
                  }
                  this.setInitialRendering(true);
                } else {
                  this.resetSimulation();
                }
              };
              ReingoldFruchtermanLayout2.prototype.setMaxIterations = function(maxIterations) {
                this.maxIterations = pick(maxIterations, this.options.maxIterations);
              };
              ReingoldFruchtermanLayout2.prototype.setTemperature = function() {
                this.temperature = this.startTemperature = Math.sqrt(this.nodes.length);
              };
              ReingoldFruchtermanLayout2.prototype.setDiffTemperature = function() {
                this.diffTemperature = this.startTemperature / (this.options.maxIterations + 1);
              };
              ReingoldFruchtermanLayout2.prototype.setInitialRendering = function(enable) {
                this.initialRendering = enable;
              };
              ReingoldFruchtermanLayout2.prototype.createQuadTree = function() {
                this.quadTree = new QuadTree(this.box.left, this.box.top, this.box.width, this.box.height);
                this.quadTree.insertNodes(this.nodes);
              };
              ReingoldFruchtermanLayout2.prototype.initPositions = function() {
                var initialPositions = this.options.initialPositions;
                if (isFunction(initialPositions)) {
                  initialPositions.call(this);
                  for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {
                    var node = _a[_i];
                    if (!defined(node.prevX)) {
                      node.prevX = node.plotX;
                    }
                    if (!defined(node.prevY)) {
                      node.prevY = node.plotY;
                    }
                    node.dispX = 0;
                    node.dispY = 0;
                  }
                } else if (initialPositions === "circle") {
                  this.setCircularPositions();
                } else {
                  this.setRandomPositions();
                }
              };
              ReingoldFruchtermanLayout2.prototype.setCircularPositions = function() {
                var box = this.box, nodes = this.nodes, nodesLength = nodes.length + 1, angle = 2 * Math.PI / nodesLength, rootNodes = nodes.filter(function(node2) {
                  return node2.linksTo.length === 0;
                }), visitedNodes = {}, radius = this.options.initialPositionRadius, addToNodes = function(node2) {
                  for (var _i2 = 0, _a2 = node2.linksFrom || []; _i2 < _a2.length; _i2++) {
                    var link = _a2[_i2];
                    if (!visitedNodes[link.toNode.id]) {
                      visitedNodes[link.toNode.id] = true;
                      sortedNodes.push(link.toNode);
                      addToNodes(link.toNode);
                    }
                  }
                };
                var sortedNodes = [];
                for (var _i = 0, rootNodes_1 = rootNodes; _i < rootNodes_1.length; _i++) {
                  var rootNode = rootNodes_1[_i];
                  sortedNodes.push(rootNode);
                  addToNodes(rootNode);
                }
                if (!sortedNodes.length) {
                  sortedNodes = nodes;
                } else {
                  for (var _a = 0, nodes_1 = nodes; _a < nodes_1.length; _a++) {
                    var node_1 = nodes_1[_a];
                    if (sortedNodes.indexOf(node_1) === -1) {
                      sortedNodes.push(node_1);
                    }
                  }
                }
                var node;
                for (var i = 0, iEnd = sortedNodes.length; i < iEnd; ++i) {
                  node = sortedNodes[i];
                  node.plotX = node.prevX = pick(node.plotX, box.width / 2 + radius * Math.cos(i * angle));
                  node.plotY = node.prevY = pick(node.plotY, box.height / 2 + radius * Math.sin(i * angle));
                  node.dispX = 0;
                  node.dispY = 0;
                }
              };
              ReingoldFruchtermanLayout2.prototype.setRandomPositions = function() {
                var box = this.box, nodes = this.nodes, nodesLength = nodes.length + 1, unrandom = function(n) {
                  var rand = n * n / Math.PI;
                  rand = rand - Math.floor(rand);
                  return rand;
                };
                var node;
                for (var i = 0, iEnd = nodes.length; i < iEnd; ++i) {
                  node = nodes[i];
                  node.plotX = node.prevX = pick(node.plotX, box.width * unrandom(i));
                  node.plotY = node.prevY = pick(node.plotY, box.height * unrandom(nodesLength + i));
                  node.dispX = 0;
                  node.dispY = 0;
                }
              };
              ReingoldFruchtermanLayout2.prototype.force = function(name) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                  args[_i - 1] = arguments[_i];
                }
                this.integration[name].apply(this, args);
              };
              ReingoldFruchtermanLayout2.prototype.barycenterForces = function() {
                this.getBarycenter();
                this.force("barycenter");
              };
              ReingoldFruchtermanLayout2.prototype.getBarycenter = function() {
                var systemMass = 0, cx = 0, cy = 0;
                for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {
                  var node = _a[_i];
                  cx += node.plotX * node.mass;
                  cy += node.plotY * node.mass;
                  systemMass += node.mass;
                }
                this.barycenter = {
                  x: cx,
                  y: cy,
                  xFactor: cx / systemMass,
                  yFactor: cy / systemMass
                };
                return this.barycenter;
              };
              ReingoldFruchtermanLayout2.prototype.barnesHutApproximation = function(node, quadNode) {
                var distanceXY = this.getDistXY(
                  node,
                  quadNode
                ), distanceR = this.vectorLength(distanceXY);
                var goDeeper, force;
                if (node !== quadNode && distanceR !== 0) {
                  if (quadNode.isInternal) {
                    if (quadNode.boxSize / distanceR < this.options.theta && distanceR !== 0) {
                      force = this.repulsiveForce(distanceR, this.k);
                      this.force("repulsive", node, force * quadNode.mass, distanceXY, distanceR);
                      goDeeper = false;
                    } else {
                      goDeeper = true;
                    }
                  } else {
                    force = this.repulsiveForce(distanceR, this.k);
                    this.force("repulsive", node, force * quadNode.mass, distanceXY, distanceR);
                  }
                }
                return goDeeper;
              };
              ReingoldFruchtermanLayout2.prototype.repulsiveForces = function() {
                var _this = this;
                if (this.approximation === "barnes-hut") {
                  var _loop_1 = function(node2) {
                    this_1.quadTree.visitNodeRecursive(
                      null,
                      function(quadNode) {
                        return _this.barnesHutApproximation(
                          node2,
                          quadNode
                        );
                      }
                    );
                  };
                  var this_1 = this;
                  for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {
                    var node = _a[_i];
                    _loop_1(node);
                  }
                } else {
                  var force = void 0, distanceR = void 0, distanceXY = void 0;
                  for (var _b = 0, _c = this.nodes; _b < _c.length; _b++) {
                    var node = _c[_b];
                    for (var _d = 0, _e = this.nodes; _d < _e.length; _d++) {
                      var repNode = _e[_d];
                      if (
                        // Node cannot repulse itself:
                        node !== repNode && // Only close nodes affect each other:
                        // layout.getDistR(node, repNode) < 2 * k &&
                        // Not dragged:
                        !node.fixedPosition
                      ) {
                        distanceXY = this.getDistXY(node, repNode);
                        distanceR = this.vectorLength(distanceXY);
                        if (distanceR !== 0) {
                          force = this.repulsiveForce(distanceR, this.k);
                          this.force("repulsive", node, force * repNode.mass, distanceXY, distanceR);
                        }
                      }
                    }
                  }
                }
              };
              ReingoldFruchtermanLayout2.prototype.attractiveForces = function() {
                var distanceXY, distanceR, force;
                for (var _i = 0, _a = this.links; _i < _a.length; _i++) {
                  var link = _a[_i];
                  if (link.fromNode && link.toNode) {
                    distanceXY = this.getDistXY(link.fromNode, link.toNode);
                    distanceR = this.vectorLength(distanceXY);
                    if (distanceR !== 0) {
                      force = this.attractiveForce(distanceR, this.k);
                      this.force("attractive", link, force, distanceXY, distanceR);
                    }
                  }
                }
              };
              ReingoldFruchtermanLayout2.prototype.applyLimits = function() {
                var nodes = this.nodes;
                for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
                  var node = nodes_2[_i];
                  if (node.fixedPosition) {
                    return;
                  }
                  this.integration.integrate(this, node);
                  this.applyLimitBox(node, this.box);
                  node.dispX = 0;
                  node.dispY = 0;
                }
              };
              ReingoldFruchtermanLayout2.prototype.applyLimitBox = function(node, box) {
                var radius = node.radius;
                node.plotX = clamp(node.plotX, box.left + radius, box.width - radius);
                node.plotY = clamp(node.plotY, box.top + radius, box.height - radius);
              };
              ReingoldFruchtermanLayout2.prototype.coolDown = function(temperature, temperatureStep, currentStep) {
                return temperature - temperatureStep * currentStep;
              };
              ReingoldFruchtermanLayout2.prototype.isStable = function() {
                return Math.abs(this.systemTemperature - this.prevSystemTemperature) < 1e-5 || this.temperature <= 0;
              };
              ReingoldFruchtermanLayout2.prototype.getSystemTemperature = function() {
                var value = 0;
                for (var _i = 0, _a = this.nodes; _i < _a.length; _i++) {
                  var node = _a[_i];
                  value += node.temperature;
                }
                return value;
              };
              ReingoldFruchtermanLayout2.prototype.vectorLength = function(vector) {
                return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
              };
              ReingoldFruchtermanLayout2.prototype.getDistR = function(nodeA, nodeB) {
                var distance = this.getDistXY(
                  nodeA,
                  nodeB
                );
                return this.vectorLength(distance);
              };
              ReingoldFruchtermanLayout2.prototype.getDistXY = function(nodeA, nodeB) {
                var xDist = nodeA.plotX - nodeB.plotX, yDist = nodeA.plotY - nodeB.plotY;
                return {
                  x: xDist,
                  y: yDist,
                  absX: Math.abs(xDist),
                  absY: Math.abs(yDist)
                };
              };
              return ReingoldFruchtermanLayout2;
            }()
          );
          return ReingoldFruchtermanLayout;
        });
        _registerModule(_modules, "Series/PackedBubble/PackedBubbleLayout.js", [_modules["Series/GraphLayoutComposition.js"], _modules["Series/PackedBubble/PackedBubbleIntegration.js"], _modules["Series/Networkgraph/ReingoldFruchtermanLayout.js"], _modules["Core/Utilities.js"]], function(GraphLayout, PackedBubbleIntegration, ReingoldFruchtermanLayout, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var addEvent = U.addEvent, pick = U.pick;
          var composedClasses = [];
          function chartGetSelectedParentNodes() {
            var allSeries = this.series, selectedParentsNodes = [];
            allSeries.forEach(function(series) {
              if (series.parentNode && series.parentNode.selected) {
                selectedParentsNodes.push(series.parentNode);
              }
            });
            return selectedParentsNodes;
          }
          function onChartBeforeRedraw() {
            if (this.allDataPoints) {
              delete this.allDataPoints;
            }
          }
          var PackedBubbleLayout = (
            /** @class */
            function(_super) {
              __extends(PackedBubbleLayout2, _super);
              function PackedBubbleLayout2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.index = NaN;
                _this.nodes = [];
                _this.options = void 0;
                _this.series = [];
                return _this;
              }
              PackedBubbleLayout2.compose = function(ChartClass) {
                ReingoldFruchtermanLayout.compose(ChartClass);
                GraphLayout.integrations.packedbubble = PackedBubbleIntegration;
                GraphLayout.layouts.packedbubble = PackedBubbleLayout2;
                if (composedClasses.indexOf(ChartClass) === -1) {
                  composedClasses.push(ChartClass);
                  addEvent(ChartClass, "beforeRedraw", onChartBeforeRedraw);
                  var chartProto = ChartClass.prototype;
                  chartProto.getSelectedParentNodes = chartGetSelectedParentNodes;
                }
              };
              PackedBubbleLayout2.prototype.beforeStep = function() {
                if (this.options.marker) {
                  this.series.forEach(function(series) {
                    if (series) {
                      series.calculateParentRadius();
                    }
                  });
                }
              };
              PackedBubbleLayout2.prototype.isStable = function() {
                var tempDiff = Math.abs(this.prevSystemTemperature - this.systemTemperature);
                var upScaledTemperature = 10 * this.systemTemperature / Math.sqrt(this.nodes.length);
                return Math.abs(upScaledTemperature) < 1 && tempDiff < 1e-5 || this.temperature <= 0;
              };
              PackedBubbleLayout2.prototype.setCircularPositions = function() {
                var layout = this, box = layout.box, nodes = layout.nodes, nodesLength = nodes.length + 1, angle = 2 * Math.PI / nodesLength, radius = layout.options.initialPositionRadius;
                var centerX, centerY, index = 0;
                for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                  var node = nodes_1[_i];
                  if (layout.options.splitSeries && !node.isParentNode) {
                    centerX = node.series.parentNode.plotX;
                    centerY = node.series.parentNode.plotY;
                  } else {
                    centerX = box.width / 2;
                    centerY = box.height / 2;
                  }
                  node.plotX = node.prevX = pick(node.plotX, centerX + radius * Math.cos(node.index || index * angle));
                  node.plotY = node.prevY = pick(node.plotY, centerY + radius * Math.sin(node.index || index * angle));
                  node.dispX = 0;
                  node.dispY = 0;
                  index++;
                }
              };
              PackedBubbleLayout2.prototype.repulsiveForces = function() {
                var layout = this, bubblePadding = layout.options.bubblePadding;
                var force, distanceR, distanceXY;
                layout.nodes.forEach(function(node) {
                  node.degree = node.mass;
                  node.neighbours = 0;
                  layout.nodes.forEach(function(repNode) {
                    force = 0;
                    if (
                      // Node cannot repulse itself:
                      node !== repNode && // Only close nodes affect each other:
                      // Not dragged:
                      !node.fixedPosition && (layout.options.seriesInteraction || node.series === repNode.series)
                    ) {
                      distanceXY = layout.getDistXY(node, repNode);
                      distanceR = layout.vectorLength(distanceXY) - (node.marker.radius + repNode.marker.radius + bubblePadding);
                      if (distanceR < 0) {
                        node.degree += 0.01;
                        node.neighbours++;
                        force = layout.repulsiveForce(-distanceR / Math.sqrt(node.neighbours), layout.k, node, repNode);
                      }
                      layout.force("repulsive", node, force * repNode.mass, distanceXY, repNode, distanceR);
                    }
                  });
                });
              };
              PackedBubbleLayout2.prototype.applyLimitBox = function(node, box) {
                var layout = this, factor = 0.01;
                var distanceXY, distanceR;
                if (layout.options.splitSeries && !node.isParentNode && layout.options.parentNodeLimit) {
                  distanceXY = layout.getDistXY(node, node.series.parentNode);
                  distanceR = node.series.parentNodeRadius - node.marker.radius - layout.vectorLength(distanceXY);
                  if (distanceR < 0 && distanceR > -2 * node.marker.radius) {
                    node.plotX -= distanceXY.x * factor;
                    node.plotY -= distanceXY.y * factor;
                  }
                }
                _super.prototype.applyLimitBox.call(this, node, box);
              };
              return PackedBubbleLayout2;
            }(ReingoldFruchtermanLayout)
          );
          GraphLayout.layouts.packedbubble = PackedBubbleLayout;
          return PackedBubbleLayout;
        });
        _registerModule(_modules, "Series/PackedBubble/PackedBubbleSeries.js", [_modules["Core/Color/Color.js"], _modules["Series/DragNodesComposition.js"], _modules["Series/GraphLayoutComposition.js"], _modules["Core/Globals.js"], _modules["Series/PackedBubble/PackedBubblePoint.js"], _modules["Series/PackedBubble/PackedBubbleSeriesDefaults.js"], _modules["Series/PackedBubble/PackedBubbleLayout.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(Color2, DragNodesComposition, GraphLayout, H, PackedBubblePoint, PackedBubbleSeriesDefaults, PackedBubbleLayout, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var color2 = Color2.parse;
          var noop2 = H.noop;
          var seriesProto = SeriesRegistry.series.prototype, BubbleSeries = SeriesRegistry.seriesTypes.bubble;
          var addEvent = U.addEvent, clamp = U.clamp, defined = U.defined, extend2 = U.extend, fireEvent = U.fireEvent, isArray = U.isArray, isNumber = U.isNumber, merge = U.merge, pick = U.pick;
          var PackedBubbleSeries = (
            /** @class */
            function(_super) {
              __extends(PackedBubbleSeries2, _super);
              function PackedBubbleSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.chart = void 0;
                _this.data = void 0;
                _this.layout = void 0;
                _this.options = void 0;
                _this.parentNodeMass = 0;
                _this.points = void 0;
                _this.xData = void 0;
                return _this;
              }
              PackedBubbleSeries2.compose = function(AxisClass, ChartClass, LegendClass, SeriesClass) {
                BubbleSeries.compose(AxisClass, ChartClass, LegendClass, SeriesClass);
                DragNodesComposition.compose(ChartClass);
                PackedBubbleLayout.compose(ChartClass);
              };
              PackedBubbleSeries2.prototype.accumulateAllPoints = function() {
                var chart = this.chart, allDataPoints = [];
                var yData;
                for (var _i = 0, _a = chart.series; _i < _a.length; _i++) {
                  var series = _a[_i];
                  if (series.is("packedbubble") && // #13574
                  series.visible || !chart.options.chart.ignoreHiddenSeries) {
                    yData = series.yData || [];
                    for (var j = 0; j < yData.length; j++) {
                      allDataPoints.push([
                        null,
                        null,
                        yData[j],
                        series.index,
                        j,
                        {
                          id: j,
                          marker: {
                            radius: 0
                          }
                        }
                      ]);
                    }
                  }
                }
                return allDataPoints;
              };
              PackedBubbleSeries2.prototype.addLayout = function() {
                var layoutOptions = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {}, layoutType = layoutOptions.type || "packedbubble", chartOptions = this.chart.options.chart;
                var graphLayoutsStorage = this.chart.graphLayoutsStorage, graphLayoutsLookup = this.chart.graphLayoutsLookup, layout;
                if (!graphLayoutsStorage) {
                  this.chart.graphLayoutsStorage = graphLayoutsStorage = {};
                  this.chart.graphLayoutsLookup = graphLayoutsLookup = [];
                }
                layout = graphLayoutsStorage[layoutType];
                if (!layout) {
                  layoutOptions.enableSimulation = !defined(chartOptions.forExport) ? layoutOptions.enableSimulation : !chartOptions.forExport;
                  graphLayoutsStorage[layoutType] = layout = new GraphLayout.layouts[layoutType]();
                  layout.init(layoutOptions);
                  graphLayoutsLookup.splice(layout.index, 0, layout);
                }
                this.layout = layout;
                this.points.forEach(function(node) {
                  node.mass = 2;
                  node.degree = 1;
                  node.collisionNmb = 1;
                });
                layout.setArea(0, 0, this.chart.plotWidth, this.chart.plotHeight);
                layout.addElementsToCollection([this], layout.series);
                layout.addElementsToCollection(this.points, layout.nodes);
              };
              PackedBubbleSeries2.prototype.addSeriesLayout = function() {
                var layoutOptions = this.options.layoutAlgorithm = this.options.layoutAlgorithm || {}, layoutType = layoutOptions.type || "packedbubble", graphLayoutsStorage = this.chart.graphLayoutsStorage, graphLayoutsLookup = this.chart.graphLayoutsLookup, parentNodeOptions = merge(
                  layoutOptions,
                  layoutOptions.parentNodeOptions,
                  {
                    enableSimulation: this.layout.options.enableSimulation
                  }
                );
                var seriesLayout = graphLayoutsStorage[layoutType + "-series"];
                if (!seriesLayout) {
                  graphLayoutsStorage[layoutType + "-series"] = seriesLayout = new GraphLayout.layouts[layoutType]();
                  seriesLayout.init(parentNodeOptions);
                  graphLayoutsLookup.splice(seriesLayout.index, 0, seriesLayout);
                }
                this.parentNodeLayout = seriesLayout;
                this.createParentNodes();
              };
              PackedBubbleSeries2.prototype.calculateParentRadius = function() {
                var bBox = this.seriesBox(), parentPadding = 20, minParentRadius = 20;
                this.parentNodeRadius = clamp(Math.sqrt(2 * this.parentNodeMass / Math.PI) + parentPadding, minParentRadius, bBox ? Math.max(Math.sqrt(Math.pow(bBox.width, 2) + Math.pow(bBox.height, 2)) / 2 + parentPadding, minParentRadius) : Math.sqrt(2 * this.parentNodeMass / Math.PI) + parentPadding);
                if (this.parentNode) {
                  this.parentNode.marker.radius = this.parentNode.radius = this.parentNodeRadius;
                }
              };
              PackedBubbleSeries2.prototype.calculateZExtremes = function() {
                var chart = this.chart, allSeries = chart.series;
                var zMin = this.options.zMin, zMax = this.options.zMax, valMin = Infinity, valMax = -Infinity;
                if (zMin && zMax) {
                  return [zMin, zMax];
                }
                allSeries.forEach(function(series) {
                  series.yData.forEach(function(y) {
                    if (defined(y)) {
                      if (y > valMax) {
                        valMax = y;
                      }
                      if (y < valMin) {
                        valMin = y;
                      }
                    }
                  });
                });
                zMin = pick(zMin, valMin);
                zMax = pick(zMax, valMax);
                return [zMin, zMax];
              };
              PackedBubbleSeries2.prototype.checkOverlap = function(bubble1, bubble2) {
                var diffX = bubble1[0] - bubble2[0], diffY = bubble1[1] - bubble2[1], sumRad = bubble1[2] + bubble2[2];
                return Math.sqrt(diffX * diffX + diffY * diffY) - Math.abs(sumRad) < -1e-3;
              };
              PackedBubbleSeries2.prototype.createParentNodes = function() {
                var _this = this;
                var PackedBubblePoint2 = this.pointClass, chart = this.chart, parentNodeLayout = this.parentNodeLayout, layoutOptions = this.layout.options;
                var nodeAdded, parentNode = this.parentNode, parentMarkerOptions = {
                  radius: this.parentNodeRadius,
                  lineColor: this.color,
                  fillColor: color2(this.color).brighten(0.4).get()
                };
                if (layoutOptions.parentNodeOptions) {
                  parentMarkerOptions = merge(layoutOptions.parentNodeOptions.marker || {}, parentMarkerOptions);
                }
                this.parentNodeMass = 0;
                this.points.forEach(function(p) {
                  _this.parentNodeMass += Math.PI * Math.pow(p.marker.radius, 2);
                });
                this.calculateParentRadius();
                parentNodeLayout.nodes.forEach(function(node) {
                  if (node.seriesIndex === _this.index) {
                    nodeAdded = true;
                  }
                });
                parentNodeLayout.setArea(0, 0, chart.plotWidth, chart.plotHeight);
                if (!nodeAdded) {
                  if (!parentNode) {
                    parentNode = new PackedBubblePoint2().init(this, {
                      mass: this.parentNodeRadius / 2,
                      marker: parentMarkerOptions,
                      dataLabels: {
                        inside: false
                      },
                      states: {
                        normal: {
                          marker: parentMarkerOptions
                        },
                        hover: {
                          marker: parentMarkerOptions
                        }
                      },
                      dataLabelOnNull: true,
                      degree: this.parentNodeRadius,
                      isParentNode: true,
                      seriesIndex: this.index
                    });
                  }
                  if (this.parentNode) {
                    parentNode.plotX = this.parentNode.plotX;
                    parentNode.plotY = this.parentNode.plotY;
                  }
                  this.parentNode = parentNode;
                  parentNodeLayout.addElementsToCollection([this], parentNodeLayout.series);
                  parentNodeLayout.addElementsToCollection([parentNode], parentNodeLayout.nodes);
                }
              };
              PackedBubbleSeries2.prototype.deferLayout = function() {
                var layoutOptions = this.options.layoutAlgorithm;
                if (!this.visible) {
                  return;
                }
                this.addLayout();
                if (layoutOptions.splitSeries) {
                  this.addSeriesLayout();
                }
              };
              PackedBubbleSeries2.prototype.destroy = function() {
                var _this = this;
                if (this.chart.graphLayoutsLookup) {
                  this.chart.graphLayoutsLookup.forEach(function(layout) {
                    layout.removeElementFromCollection(_this, layout.series);
                  }, this);
                }
                if (this.parentNode && this.parentNodeLayout) {
                  this.parentNodeLayout.removeElementFromCollection(this.parentNode, this.parentNodeLayout.nodes);
                  if (this.parentNode.dataLabel) {
                    this.parentNode.dataLabel = this.parentNode.dataLabel.destroy();
                  }
                }
                seriesProto.destroy.apply(this, arguments);
              };
              PackedBubbleSeries2.prototype.drawDataLabels = function() {
                seriesProto.drawDataLabels.call(this, this.points);
                if (this.parentNode) {
                  this.parentNode.formatPrefix = "parentNode";
                  seriesProto.drawDataLabels.call(this, [this.parentNode]);
                }
              };
              PackedBubbleSeries2.prototype.drawGraph = function() {
                if (!this.layout || !this.layout.options.splitSeries) {
                  return;
                }
                var chart = this.chart, nodeMarker = this.layout.options.parentNodeOptions.marker, parentOptions = {
                  fill: nodeMarker.fillColor || color2(this.color).brighten(0.4).get(),
                  opacity: nodeMarker.fillOpacity,
                  stroke: nodeMarker.lineColor || this.color,
                  "stroke-width": pick(
                    nodeMarker.lineWidth,
                    this.options.lineWidth
                  )
                };
                var parentAttribs = {};
                if (!this.parentNodesGroup) {
                  this.parentNodesGroup = this.plotGroup("parentNodesGroup", "parentNode", this.visible ? "inherit" : "hidden", 0.1, chart.seriesGroup);
                  this.group.attr({
                    zIndex: 2
                  });
                }
                this.calculateParentRadius();
                parentAttribs = merge({
                  x: this.parentNode.plotX - this.parentNodeRadius,
                  y: this.parentNode.plotY - this.parentNodeRadius,
                  width: this.parentNodeRadius * 2,
                  height: this.parentNodeRadius * 2
                }, parentOptions);
                if (!this.parentNode.graphic) {
                  this.graph = this.parentNode.graphic = chart.renderer.symbol(parentOptions.symbol).add(this.parentNodesGroup);
                }
                this.parentNode.graphic.attr(parentAttribs);
              };
              PackedBubbleSeries2.prototype.drawTracker = function() {
                var parentNode = this.parentNode;
                var dataLabels;
                _super.prototype.drawTracker.call(this);
                if (parentNode) {
                  dataLabels = isArray(parentNode.dataLabels) ? parentNode.dataLabels : parentNode.dataLabel ? [parentNode.dataLabel] : [];
                  if (parentNode.graphic) {
                    parentNode.graphic.element.point = parentNode;
                  }
                  dataLabels.forEach(function(dataLabel) {
                    if (dataLabel.div) {
                      dataLabel.div.point = parentNode;
                    } else {
                      dataLabel.element.point = parentNode;
                    }
                  });
                }
              };
              PackedBubbleSeries2.prototype.getPointRadius = function() {
                var _this = this;
                var chart = this.chart, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, seriesOptions = this.options, useSimulation = seriesOptions.useSimulation, smallestSize = Math.min(
                  plotWidth,
                  plotHeight
                ), extremes = {}, radii = [], allDataPoints = chart.allDataPoints || [], allDataPointsLength = allDataPoints.length;
                var minSize, maxSize, value, radius;
                ["minSize", "maxSize"].forEach(function(prop) {
                  var length = parseInt(seriesOptions[prop], 10), isPercent = /%$/.test(seriesOptions[prop]);
                  extremes[prop] = isPercent ? smallestSize * length / 100 : length * Math.sqrt(allDataPointsLength);
                });
                chart.minRadius = minSize = extremes.minSize / Math.sqrt(allDataPointsLength);
                chart.maxRadius = maxSize = extremes.maxSize / Math.sqrt(allDataPointsLength);
                var zExtremes = useSimulation ? this.calculateZExtremes() : [
                  minSize,
                  maxSize
                ];
                allDataPoints.forEach(function(point, i) {
                  value = useSimulation ? clamp(point[2], zExtremes[0], zExtremes[1]) : point[2];
                  radius = _this.getRadius(zExtremes[0], zExtremes[1], minSize, maxSize, value);
                  if (radius === 0) {
                    radius = null;
                  }
                  allDataPoints[i][2] = radius;
                  radii.push(radius);
                });
                this.radii = radii;
              };
              PackedBubbleSeries2.prototype.init = function() {
                seriesProto.init.apply(this, arguments);
                this.eventsToUnbind.push(addEvent(this, "updatedData", function() {
                  var _this = this;
                  this.chart.series.forEach(function(s) {
                    if (s.type === _this.type) {
                      s.isDirty = true;
                    }
                  }, this);
                }));
                return this;
              };
              PackedBubbleSeries2.prototype.onMouseUp = function(dnPoint) {
                var point = dnPoint;
                if (point.fixedPosition && !point.removed) {
                  var layout_1 = this.layout, parentNodeLayout = this.parentNodeLayout;
                  var distanceXY_1, distanceR_1;
                  if (parentNodeLayout && layout_1.options.dragBetweenSeries) {
                    parentNodeLayout.nodes.forEach(function(node) {
                      if (point && point.marker && node !== point.series.parentNode) {
                        distanceXY_1 = layout_1.getDistXY(point, node);
                        distanceR_1 = layout_1.vectorLength(distanceXY_1) - node.marker.radius - point.marker.radius;
                        if (distanceR_1 < 0) {
                          node.series.addPoint(merge(point.options, {
                            plotX: point.plotX,
                            plotY: point.plotY
                          }), false);
                          layout_1.removeElementFromCollection(point, layout_1.nodes);
                          point.remove();
                        }
                      }
                    });
                  }
                  DragNodesComposition.onMouseUp.apply(this, arguments);
                }
              };
              PackedBubbleSeries2.prototype.placeBubbles = function(allDataPoints) {
                var checkOverlap = this.checkOverlap, positionBubble = this.positionBubble, bubblePos = [];
                var stage = 1, j = 0, k = 0, calculatedBubble, arr = [], i;
                var sortedArr = allDataPoints.sort(function(a, b) {
                  return b[2] - a[2];
                });
                if (sortedArr.length) {
                  bubblePos.push([
                    [
                      0,
                      0,
                      sortedArr[0][2],
                      sortedArr[0][3],
                      sortedArr[0][4]
                    ]
                    // point index
                  ]);
                  if (sortedArr.length > 1) {
                    bubblePos.push([
                      [
                        0,
                        0 - sortedArr[1][2] - sortedArr[0][2],
                        // move bubble above first one
                        sortedArr[1][2],
                        sortedArr[1][3],
                        sortedArr[1][4]
                      ]
                    ]);
                    for (i = 2; i < sortedArr.length; i++) {
                      sortedArr[i][2] = sortedArr[i][2] || 1;
                      calculatedBubble = positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]);
                      if (checkOverlap(calculatedBubble, bubblePos[stage][0])) {
                        bubblePos.push([]);
                        k = 0;
                        bubblePos[stage + 1].push(positionBubble(bubblePos[stage][j], bubblePos[stage][0], sortedArr[i]));
                        stage++;
                        j = 0;
                      } else if (stage > 1 && bubblePos[stage - 1][k + 1] && checkOverlap(calculatedBubble, bubblePos[stage - 1][k + 1])) {
                        k++;
                        bubblePos[stage].push(positionBubble(bubblePos[stage][j], bubblePos[stage - 1][k], sortedArr[i]));
                        j++;
                      } else {
                        j++;
                        bubblePos[stage].push(calculatedBubble);
                      }
                    }
                  }
                  this.chart.stages = bubblePos;
                  this.chart.rawPositions = [].concat.apply([], bubblePos);
                  this.resizeRadius();
                  arr = this.chart.rawPositions;
                }
                return arr;
              };
              PackedBubbleSeries2.prototype.pointAttribs = function(point, state) {
                var options = this.options, hasParentMarker = point && point.isParentNode;
                var markerOptions = options.marker;
                if (hasParentMarker && options.layoutAlgorithm && options.layoutAlgorithm.parentNodeOptions) {
                  markerOptions = options.layoutAlgorithm.parentNodeOptions.marker;
                }
                var fillOpacity = markerOptions.fillOpacity, attr = seriesProto.pointAttribs.call(
                  this,
                  point,
                  state
                );
                if (fillOpacity !== 1) {
                  attr["fill-opacity"] = fillOpacity;
                }
                return attr;
              };
              PackedBubbleSeries2.prototype.positionBubble = function(lastBubble, newOrigin, nextBubble) {
                var sqrt = Math.sqrt, asin = Math.asin, acos = Math.acos, pow = Math.pow, abs = Math.abs, distance = sqrt(
                  // dist between lastBubble and newOrigin
                  pow(lastBubble[0] - newOrigin[0], 2) + pow(lastBubble[1] - newOrigin[1], 2)
                ), alfa = acos(
                  // from cosinus theorem: alfa is an angle used for
                  // calculating correct position
                  (pow(distance, 2) + pow(nextBubble[2] + newOrigin[2], 2) - pow(nextBubble[2] + lastBubble[2], 2)) / (2 * (nextBubble[2] + newOrigin[2]) * distance)
                ), beta = asin(
                  // from sinus theorem.
                  abs(lastBubble[0] - newOrigin[0]) / distance
                ), gamma2 = lastBubble[1] - newOrigin[1] < 0 ? 0 : Math.PI, delta = (lastBubble[0] - newOrigin[0]) * (lastBubble[1] - newOrigin[1]) < 0 ? 1 : -1, finalAngle = gamma2 + alfa + beta * delta, cosA = Math.cos(finalAngle), sinA = Math.sin(finalAngle), posX = newOrigin[0] + (newOrigin[2] + nextBubble[2]) * sinA, posY = newOrigin[1] - (newOrigin[2] + nextBubble[2]) * cosA;
                return [
                  posX,
                  posY,
                  nextBubble[2],
                  nextBubble[3],
                  nextBubble[4]
                ];
              };
              PackedBubbleSeries2.prototype.render = function() {
                var dataLabels = [];
                seriesProto.render.apply(this, arguments);
                if (!this.options.dataLabels.allowOverlap) {
                  this.data.forEach(function(point) {
                    if (isArray(point.dataLabels)) {
                      point.dataLabels.forEach(function(dataLabel) {
                        dataLabels.push(dataLabel);
                      });
                    }
                  });
                  if (this.options.useSimulation) {
                    this.chart.hideOverlappingLabels(dataLabels);
                  }
                }
              };
              PackedBubbleSeries2.prototype.resizeRadius = function() {
                var chart = this.chart, positions = chart.rawPositions, min2 = Math.min, max2 = Math.max, plotLeft = chart.plotLeft, plotTop = chart.plotTop, chartHeight = chart.plotHeight, chartWidth = chart.plotWidth;
                var minX, maxX, minY, maxY, radius;
                minX = minY = Number.POSITIVE_INFINITY;
                maxX = maxY = Number.NEGATIVE_INFINITY;
                for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
                  var position = positions_1[_i];
                  radius = position[2];
                  minX = min2(minX, position[0] - radius);
                  maxX = max2(maxX, position[0] + radius);
                  minY = min2(minY, position[1] - radius);
                  maxY = max2(maxY, position[1] + radius);
                }
                var bBox = [
                  maxX - minX,
                  maxY - minY
                ], spaceRatio = [
                  (chartWidth - plotLeft) / bBox[0],
                  (chartHeight - plotTop) / bBox[1]
                ], smallerDimension = min2.apply(
                  [],
                  spaceRatio
                );
                if (Math.abs(smallerDimension - 1) > 1e-10) {
                  for (var _a = 0, positions_2 = positions; _a < positions_2.length; _a++) {
                    var position = positions_2[_a];
                    position[2] *= smallerDimension;
                  }
                  this.placeBubbles(positions);
                } else {
                  chart.diffY = chartHeight / 2 + plotTop - minY - (maxY - minY) / 2;
                  chart.diffX = chartWidth / 2 + plotLeft - minX - (maxX - minX) / 2;
                }
              };
              PackedBubbleSeries2.prototype.seriesBox = function() {
                var chart = this.chart, data = this.data, max2 = Math.max, min2 = Math.min, bBox = [
                  chart.plotLeft,
                  chart.plotLeft + chart.plotWidth,
                  chart.plotTop,
                  chart.plotTop + chart.plotHeight
                ];
                var radius;
                data.forEach(function(p) {
                  if (defined(p.plotX) && defined(p.plotY) && p.marker.radius) {
                    radius = p.marker.radius;
                    bBox[0] = min2(bBox[0], p.plotX - radius);
                    bBox[1] = max2(bBox[1], p.plotX + radius);
                    bBox[2] = min2(bBox[2], p.plotY - radius);
                    bBox[3] = max2(bBox[3], p.plotY + radius);
                  }
                });
                return isNumber(bBox.width / bBox.height) ? bBox : null;
              };
              PackedBubbleSeries2.prototype.setVisible = function() {
                var series = this;
                seriesProto.setVisible.apply(series, arguments);
                if (series.parentNodeLayout && series.graph) {
                  if (series.visible) {
                    series.graph.show();
                    if (series.parentNode.dataLabel) {
                      series.parentNode.dataLabel.show();
                    }
                  } else {
                    series.graph.hide();
                    series.parentNodeLayout.removeElementFromCollection(series.parentNode, series.parentNodeLayout.nodes);
                    if (series.parentNode.dataLabel) {
                      series.parentNode.dataLabel.hide();
                    }
                  }
                } else if (series.layout) {
                  if (series.visible) {
                    series.layout.addElementsToCollection(series.points, series.layout.nodes);
                  } else {
                    series.points.forEach(function(node) {
                      series.layout.removeElementFromCollection(node, series.layout.nodes);
                    });
                  }
                }
              };
              PackedBubbleSeries2.prototype.translate = function() {
                var chart = this.chart, data = this.data, index = this.index, useSimulation = this.options.useSimulation;
                var point, radius, positions;
                this.processedXData = this.xData;
                this.generatePoints();
                if (!defined(chart.allDataPoints)) {
                  chart.allDataPoints = this.accumulateAllPoints();
                  this.getPointRadius();
                }
                if (useSimulation) {
                  positions = chart.allDataPoints;
                } else {
                  positions = this.placeBubbles(chart.allDataPoints);
                  this.options.draggable = false;
                }
                for (var _i = 0, positions_3 = positions; _i < positions_3.length; _i++) {
                  var position = positions_3[_i];
                  if (position[3] === index) {
                    point = data[position[4]];
                    radius = pick(position[2], void 0);
                    if (!useSimulation) {
                      point.plotX = position[0] - chart.plotLeft + chart.diffX;
                      point.plotY = position[1] - chart.plotTop + chart.diffY;
                    }
                    if (isNumber(radius)) {
                      point.marker = extend2(point.marker, {
                        radius,
                        width: 2 * radius,
                        height: 2 * radius
                      });
                      point.radius = radius;
                    }
                  }
                }
                if (useSimulation) {
                  this.deferLayout();
                }
                fireEvent(this, "afterTranslate");
              };
              PackedBubbleSeries2.defaultOptions = merge(BubbleSeries.defaultOptions, PackedBubbleSeriesDefaults);
              return PackedBubbleSeries2;
            }(BubbleSeries)
          );
          extend2(PackedBubbleSeries.prototype, {
            pointClass: PackedBubblePoint,
            axisTypes: [],
            directTouch: true,
            forces: ["barycenter", "repulsive"],
            hasDraggableNodes: true,
            isCartesian: false,
            noSharedTooltip: true,
            pointArrayMap: ["value"],
            pointValKey: "value",
            requireSorting: false,
            trackerGroups: ["group", "dataLabelsGroup", "parentNodesGroup"],
            alignDataLabel: seriesProto.alignDataLabel,
            indexateNodes: noop2,
            onMouseDown: DragNodesComposition.onMouseDown,
            onMouseMove: DragNodesComposition.onMouseMove,
            redrawHalo: DragNodesComposition.redrawHalo,
            searchPoint: noop2
            // solving #12287
          });
          SeriesRegistry.registerSeriesType("packedbubble", PackedBubbleSeries);
          "";
          return PackedBubbleSeries;
        });
        _registerModule(_modules, "Series/Polygon/PolygonSeries.js", [_modules["Core/Globals.js"], _modules["Core/Legend/LegendSymbol.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"]], function(H, LegendSymbol, SeriesRegistry, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var noop2 = H.noop;
          var Series = SeriesRegistry.series, _a = SeriesRegistry.seriesTypes, AreaSeries = _a.area, LineSeries = _a.line, ScatterSeries = _a.scatter;
          var extend2 = U.extend, merge = U.merge;
          var PolygonSeries = (
            /** @class */
            function(_super) {
              __extends(PolygonSeries2, _super);
              function PolygonSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.data = void 0;
                _this.options = void 0;
                _this.points = void 0;
                return _this;
              }
              PolygonSeries2.prototype.getGraphPath = function() {
                var graphPath = LineSeries.prototype.getGraphPath.call(this), i = graphPath.length + 1;
                while (i--) {
                  if ((i === graphPath.length || graphPath[i][0] === "M") && i > 0) {
                    graphPath.splice(i, 0, ["Z"]);
                  }
                }
                this.areaPath = graphPath;
                return graphPath;
              };
              PolygonSeries2.prototype.drawGraph = function() {
                this.options.fillColor = this.color;
                AreaSeries.prototype.drawGraph.call(this);
              };
              PolygonSeries2.defaultOptions = merge(ScatterSeries.defaultOptions, {
                marker: {
                  enabled: false,
                  states: {
                    hover: {
                      enabled: false
                    }
                  }
                },
                stickyTracking: false,
                tooltip: {
                  followPointer: true,
                  pointFormat: ""
                },
                trackByArea: true
              });
              return PolygonSeries2;
            }(ScatterSeries)
          );
          extend2(PolygonSeries.prototype, {
            type: "polygon",
            drawLegendSymbol: LegendSymbol.drawRectangle,
            drawTracker: Series.prototype.drawTracker,
            setStackedPoints: noop2
            // No stacking points on polygons (#5310)
          });
          SeriesRegistry.registerSeriesType("polygon", PolygonSeries);
          "";
          return PolygonSeries;
        });
        _registerModule(_modules, "Core/Axis/WaterfallAxis.js", [_modules["Core/Axis/Stacking/StackItem.js"], _modules["Core/Utilities.js"]], function(StackItem, U) {
          var addEvent = U.addEvent, objectEach = U.objectEach;
          var WaterfallAxis;
          (function(WaterfallAxis2) {
            var Composition = (
              /** @class */
              function() {
                function Composition2(axis) {
                  this.axis = axis;
                  this.stacks = {
                    changed: false
                  };
                }
                Composition2.prototype.renderStackTotals = function() {
                  var yAxis = this.axis, waterfallStacks = yAxis.waterfall.stacks, stackTotalGroup = yAxis.stacking && yAxis.stacking.stackTotalGroup, dummyStackItem = new StackItem(
                    yAxis,
                    yAxis.options.stackLabels || {},
                    false,
                    0,
                    void 0
                  );
                  this.dummyStackItem = dummyStackItem;
                  if (stackTotalGroup) {
                    objectEach(waterfallStacks, function(type) {
                      objectEach(type, function(stackItem, key) {
                        dummyStackItem.total = stackItem.stackTotal;
                        dummyStackItem.x = +key;
                        if (stackItem.label) {
                          dummyStackItem.label = stackItem.label;
                        }
                        StackItem.prototype.render.call(dummyStackItem, stackTotalGroup);
                        stackItem.label = dummyStackItem.label;
                        delete dummyStackItem.label;
                      });
                    });
                  }
                  dummyStackItem.total = null;
                };
                return Composition2;
              }()
            );
            WaterfallAxis2.Composition = Composition;
            function compose(AxisClass, ChartClass) {
              addEvent(AxisClass, "init", onInit);
              addEvent(AxisClass, "afterBuildStacks", onAfterBuildStacks);
              addEvent(AxisClass, "afterRender", onAfterRender);
              addEvent(ChartClass, "beforeRedraw", onBeforeRedraw);
            }
            WaterfallAxis2.compose = compose;
            function onAfterBuildStacks() {
              var axis = this;
              var stacks = axis.waterfall.stacks;
              if (stacks) {
                stacks.changed = false;
                delete stacks.alreadyChanged;
              }
            }
            function onAfterRender() {
              var axis = this;
              var stackLabelOptions = axis.options.stackLabels;
              if (stackLabelOptions && stackLabelOptions.enabled && axis.waterfall.stacks) {
                axis.waterfall.renderStackTotals();
              }
            }
            function onBeforeRedraw() {
              var axes = this.axes, series = this.series, i = series.length;
              while (i--) {
                if (series[i].options.stacking) {
                  axes.forEach(function(axis) {
                    if (!axis.isXAxis) {
                      axis.waterfall.stacks.changed = true;
                    }
                  });
                  i = 0;
                }
              }
            }
            function onInit() {
              var axis = this;
              if (!axis.waterfall) {
                axis.waterfall = new Composition(axis);
              }
            }
          })(WaterfallAxis || (WaterfallAxis = {}));
          return WaterfallAxis;
        });
        _registerModule(_modules, "Series/Waterfall/WaterfallPoint.js", [_modules["Series/Column/ColumnSeries.js"], _modules["Core/Series/Point.js"], _modules["Core/Utilities.js"]], function(ColumnSeries, Point, U) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var isNumber = U.isNumber;
          var WaterfallPoint = (
            /** @class */
            function(_super) {
              __extends(WaterfallPoint2, _super);
              function WaterfallPoint2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.options = void 0;
                _this.series = void 0;
                return _this;
              }
              WaterfallPoint2.prototype.getClassName = function() {
                var className = Point.prototype.getClassName.call(this);
                if (this.isSum) {
                  className += " highcharts-sum";
                } else if (this.isIntermediateSum) {
                  className += " highcharts-intermediate-sum";
                }
                return className;
              };
              WaterfallPoint2.prototype.isValid = function() {
                return isNumber(this.y) || this.isSum || Boolean(this.isIntermediateSum);
              };
              return WaterfallPoint2;
            }(ColumnSeries.prototype.pointClass)
          );
          return WaterfallPoint;
        });
        _registerModule(_modules, "Series/Waterfall/WaterfallSeries.js", [_modules["Core/Axis/Axis.js"], _modules["Core/Chart/Chart.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Core/Utilities.js"], _modules["Core/Axis/WaterfallAxis.js"], _modules["Series/Waterfall/WaterfallPoint.js"]], function(Axis, Chart, SeriesRegistry, U, WaterfallAxis, WaterfallPoint) {
          var __extends = this && this.__extends || function() {
            var extendStatics = function(d, b) {
              extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (b2.hasOwnProperty(p))
                    d2[p] = b2[p];
              };
              return extendStatics(d, b);
            };
            return function(d, b) {
              extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          }();
          var _a = SeriesRegistry.seriesTypes, ColumnSeries = _a.column, LineSeries = _a.line;
          var arrayMax = U.arrayMax, arrayMin = U.arrayMin, correctFloat = U.correctFloat, extend2 = U.extend, isNumber = U.isNumber, merge = U.merge, objectEach = U.objectEach, pick = U.pick;
          function ownProp(obj, key) {
            return Object.hasOwnProperty.call(obj, key);
          }
          var WaterfallSeries = (
            /** @class */
            function(_super) {
              __extends(WaterfallSeries2, _super);
              function WaterfallSeries2() {
                var _this = _super !== null && _super.apply(
                  this,
                  arguments
                ) || this;
                _this.chart = void 0;
                _this.data = void 0;
                _this.options = void 0;
                _this.points = void 0;
                _this.stackedYNeg = void 0;
                _this.stackedYPos = void 0;
                _this.stackKey = void 0;
                _this.xData = void 0;
                _this.yAxis = void 0;
                _this.yData = void 0;
                return _this;
              }
              WaterfallSeries2.prototype.generatePoints = function() {
                ColumnSeries.prototype.generatePoints.apply(this);
                for (var i = 0, len = this.points.length; i < len; i++) {
                  var point = this.points[i], y = this.processedYData[i];
                  if (isNumber(y) && (point.isIntermediateSum || point.isSum)) {
                    point.y = correctFloat(y);
                  }
                }
              };
              WaterfallSeries2.prototype.translate = function() {
                var series = this, options = series.options, yAxis = series.yAxis, minPointLength = pick(options.minPointLength, 5), halfMinPointLength = minPointLength / 2, threshold = options.threshold || 0, stacking = options.stacking, actualStack = yAxis.waterfall.stacks[series.stackKey];
                var previousIntermediate = threshold, previousY = threshold, y, total, yPos, hPos;
                ColumnSeries.prototype.translate.apply(series);
                var points = series.points;
                for (var i = 0; i < points.length; i++) {
                  var point = points[i], yValue = series.processedYData[i], shapeArgs = point.shapeArgs;
                  if (!shapeArgs || !isNumber(yValue)) {
                    continue;
                  }
                  var range = [
                    0,
                    yValue
                  ], pointY = point.y;
                  if (stacking) {
                    if (actualStack) {
                      var actualStackX = actualStack[i];
                      if (stacking === "overlap") {
                        total = actualStackX.stackState[actualStackX.stateIndex--];
                        y = pointY >= 0 ? total : total - pointY;
                        if (ownProp(actualStackX, "absolutePos")) {
                          delete actualStackX.absolutePos;
                        }
                        if (ownProp(actualStackX, "absoluteNeg")) {
                          delete actualStackX.absoluteNeg;
                        }
                      } else {
                        if (pointY >= 0) {
                          total = actualStackX.threshold + actualStackX.posTotal;
                          actualStackX.posTotal -= pointY;
                          y = total;
                        } else {
                          total = actualStackX.threshold + actualStackX.negTotal;
                          actualStackX.negTotal -= pointY;
                          y = total - pointY;
                        }
                        if (!actualStackX.posTotal) {
                          if (isNumber(actualStackX.absolutePos) && ownProp(actualStackX, "absolutePos")) {
                            actualStackX.posTotal = actualStackX.absolutePos;
                            delete actualStackX.absolutePos;
                          }
                        }
                        if (!actualStackX.negTotal) {
                          if (isNumber(actualStackX.absoluteNeg) && ownProp(actualStackX, "absoluteNeg")) {
                            actualStackX.negTotal = actualStackX.absoluteNeg;
                            delete actualStackX.absoluteNeg;
                          }
                        }
                      }
                      if (!point.isSum) {
                        actualStackX.connectorThreshold = actualStackX.threshold + actualStackX.stackTotal;
                      }
                      if (yAxis.reversed) {
                        yPos = pointY >= 0 ? y - pointY : y + pointY;
                        hPos = y;
                      } else {
                        yPos = y;
                        hPos = y - pointY;
                      }
                      point.below = yPos <= threshold;
                      shapeArgs.y = yAxis.translate(yPos, false, true, false, true);
                      shapeArgs.height = Math.abs(shapeArgs.y - yAxis.translate(hPos, false, true, false, true));
                      var dummyStackItem = yAxis.waterfall.dummyStackItem;
                      if (dummyStackItem) {
                        dummyStackItem.x = i;
                        dummyStackItem.label = actualStack[i].label;
                        dummyStackItem.setOffset(series.pointXOffset || 0, series.barW || 0, series.stackedYNeg[i], series.stackedYPos[i], void 0, this.xAxis);
                      }
                    }
                  } else {
                    y = Math.max(previousY, previousY + pointY) + range[0];
                    shapeArgs.y = yAxis.translate(y, false, true, false, true);
                    if (point.isSum) {
                      shapeArgs.y = yAxis.translate(range[1], false, true, false, true);
                      shapeArgs.height = Math.min(yAxis.translate(range[0], false, true, false, true), yAxis.len) - shapeArgs.y;
                      point.below = range[1] <= threshold;
                    } else if (point.isIntermediateSum) {
                      if (pointY >= 0) {
                        yPos = range[1] + previousIntermediate;
                        hPos = previousIntermediate;
                      } else {
                        yPos = previousIntermediate;
                        hPos = range[1] + previousIntermediate;
                      }
                      if (yAxis.reversed) {
                        yPos ^= hPos;
                        hPos ^= yPos;
                        yPos ^= hPos;
                      }
                      shapeArgs.y = yAxis.translate(yPos, false, true, false, true);
                      shapeArgs.height = Math.abs(shapeArgs.y - Math.min(yAxis.translate(hPos, false, true, false, true), yAxis.len));
                      previousIntermediate += range[1];
                      point.below = yPos <= threshold;
                    } else {
                      shapeArgs.height = yValue > 0 ? yAxis.translate(previousY, false, true, false, true) - shapeArgs.y : yAxis.translate(previousY, false, true, false, true) - yAxis.translate(previousY - yValue, false, true, false, true);
                      previousY += yValue;
                      point.below = previousY < threshold;
                    }
                    if (shapeArgs.height < 0) {
                      shapeArgs.y += shapeArgs.height;
                      shapeArgs.height *= -1;
                    }
                  }
                  point.plotY = shapeArgs.y = Math.round(shapeArgs.y || 0) - series.borderWidth % 2 / 2;
                  shapeArgs.height = Math.max(Math.round(shapeArgs.height || 0), 1e-3);
                  point.yBottom = shapeArgs.y + shapeArgs.height;
                  if (shapeArgs.height <= minPointLength && !point.isNull) {
                    shapeArgs.height = minPointLength;
                    shapeArgs.y -= halfMinPointLength;
                    point.plotY = shapeArgs.y;
                    if (point.y < 0) {
                      point.minPointLengthOffset = -halfMinPointLength;
                    } else {
                      point.minPointLengthOffset = halfMinPointLength;
                    }
                  } else {
                    if (point.isNull) {
                      shapeArgs.width = 0;
                    }
                    point.minPointLengthOffset = 0;
                  }
                  var tooltipY = point.plotY + (point.negative ? shapeArgs.height : 0);
                  if (point.below) {
                    point.plotY += shapeArgs.height;
                  }
                  if (point.tooltipPos) {
                    if (series.chart.inverted) {
                      point.tooltipPos[0] = yAxis.len - tooltipY;
                    } else {
                      point.tooltipPos[1] = tooltipY;
                    }
                  }
                  point.isInside = this.isPointInside(point);
                }
              };
              WaterfallSeries2.prototype.processData = function(force) {
                var series = this, options = series.options, yData = series.yData, points = options.data, point, dataLength = yData.length, threshold = options.threshold || 0, subSum, sum2, dataMin, dataMax, y, i;
                sum2 = subSum = dataMin = dataMax = 0;
                for (i = 0; i < dataLength; i++) {
                  y = yData[i];
                  point = points && points[i] ? points[i] : {};
                  if (y === "sum" || point.isSum) {
                    yData[i] = correctFloat(sum2);
                  } else if (y === "intermediateSum" || point.isIntermediateSum) {
                    yData[i] = correctFloat(subSum);
                    subSum = 0;
                  } else {
                    sum2 += y;
                    subSum += y;
                  }
                  dataMin = Math.min(sum2, dataMin);
                  dataMax = Math.max(sum2, dataMax);
                }
                _super.prototype.processData.call(this, force);
                if (!options.stacking) {
                  series.dataMin = dataMin + threshold;
                  series.dataMax = dataMax;
                }
                return;
              };
              WaterfallSeries2.prototype.toYData = function(pt) {
                if (pt.isSum) {
                  return "sum";
                }
                if (pt.isIntermediateSum) {
                  return "intermediateSum";
                }
                return pt.y;
              };
              WaterfallSeries2.prototype.updateParallelArrays = function(point, i) {
                _super.prototype.updateParallelArrays.call(this, point, i);
                if (this.yData[0] === "sum" || this.yData[0] === "intermediateSum") {
                  this.yData[0] = null;
                }
              };
              WaterfallSeries2.prototype.pointAttribs = function(point, state) {
                var upColor = this.options.upColor;
                if (upColor && !point.options.color) {
                  point.color = point.y > 0 ? upColor : void 0;
                }
                var attr = ColumnSeries.prototype.pointAttribs.call(
                  this,
                  point,
                  state
                );
                delete attr.dashstyle;
                return attr;
              };
              WaterfallSeries2.prototype.getGraphPath = function() {
                return [["M", 0, 0]];
              };
              WaterfallSeries2.prototype.getCrispPath = function() {
                var data = this.data, yAxis = this.yAxis, length = data.length, graphNormalizer = Math.round(this.graph.strokeWidth()) % 2 / 2, borderNormalizer = Math.round(this.borderWidth) % 2 / 2, reversedXAxis = this.xAxis.reversed, reversedYAxis = this.yAxis.reversed, stacking = this.options.stacking, path = [], connectorThreshold, prevStack, prevStackX, prevPoint, yPos, isPos, prevArgs, pointArgs, i;
                for (i = 1; i < length; i++) {
                  pointArgs = data[i].shapeArgs;
                  prevPoint = data[i - 1];
                  prevArgs = data[i - 1].shapeArgs;
                  prevStack = yAxis.waterfall.stacks[this.stackKey];
                  isPos = prevPoint.y > 0 ? -prevArgs.height : 0;
                  if (prevStack && prevArgs && pointArgs) {
                    prevStackX = prevStack[i - 1];
                    if (stacking) {
                      connectorThreshold = prevStackX.connectorThreshold;
                      yPos = Math.round(yAxis.translate(connectorThreshold, false, true, false, true) + (reversedYAxis ? isPos : 0)) - graphNormalizer;
                    } else {
                      yPos = prevArgs.y + prevPoint.minPointLengthOffset + borderNormalizer - graphNormalizer;
                    }
                    path.push([
                      "M",
                      (prevArgs.x || 0) + (reversedXAxis ? 0 : prevArgs.width || 0),
                      yPos
                    ], [
                      "L",
                      (pointArgs.x || 0) + (reversedXAxis ? pointArgs.width || 0 : 0),
                      yPos
                    ]);
                  }
                  if (prevArgs && path.length && (!stacking && prevPoint.y < 0 && !reversedYAxis || prevPoint.y > 0 && reversedYAxis)) {
                    var nextLast = path[path.length - 2];
                    if (nextLast && typeof nextLast[2] === "number") {
                      nextLast[2] += prevArgs.height || 0;
                    }
                    var last2 = path[path.length - 1];
                    if (last2 && typeof last2[2] === "number") {
                      last2[2] += prevArgs.height || 0;
                    }
                  }
                }
                return path;
              };
              WaterfallSeries2.prototype.drawGraph = function() {
                LineSeries.prototype.drawGraph.call(this);
                if (this.graph) {
                  this.graph.attr({
                    d: this.getCrispPath()
                  });
                }
              };
              WaterfallSeries2.prototype.setStackedPoints = function() {
                var series = this, options = series.options, waterfallStacks = series.yAxis.waterfall.stacks, seriesThreshold = options.threshold || 0, stackThreshold = seriesThreshold, interSum = stackThreshold, stackKey = series.stackKey, xData = series.xData, xLength = xData.length, actualStackX, totalYVal, actualSum, prevSum, statesLen, posTotal, negTotal, xPoint, yVal, x, alreadyChanged, changed;
                function calculateStackState(firstS, nextS, sInx, sOff) {
                  if (actualStackX) {
                    if (!statesLen) {
                      actualStackX.stackState[0] = firstS;
                      statesLen = actualStackX.stackState.length;
                    } else {
                      for (sInx; sInx < statesLen; sInx++) {
                        actualStackX.stackState[sInx] += sOff;
                      }
                    }
                    actualStackX.stackState.push(actualStackX.stackState[statesLen - 1] + nextS);
                  }
                }
                series.yAxis.stacking.usePercentage = false;
                totalYVal = actualSum = prevSum = stackThreshold;
                if (series.visible || !series.chart.options.chart.ignoreHiddenSeries) {
                  changed = waterfallStacks.changed;
                  alreadyChanged = waterfallStacks.alreadyChanged;
                  if (alreadyChanged && alreadyChanged.indexOf(stackKey) < 0) {
                    changed = true;
                  }
                  if (!waterfallStacks[stackKey]) {
                    waterfallStacks[stackKey] = {};
                  }
                  var actualStack = waterfallStacks[stackKey];
                  if (actualStack) {
                    for (var i = 0; i < xLength; i++) {
                      x = xData[i];
                      if (!actualStack[x] || changed) {
                        actualStack[x] = {
                          negTotal: 0,
                          posTotal: 0,
                          stackTotal: 0,
                          threshold: 0,
                          stateIndex: 0,
                          stackState: [],
                          label: changed && actualStack[x] ? actualStack[x].label : void 0
                        };
                      }
                      actualStackX = actualStack[x];
                      yVal = series.yData[i];
                      if (yVal >= 0) {
                        actualStackX.posTotal += yVal;
                      } else {
                        actualStackX.negTotal += yVal;
                      }
                      xPoint = options.data[i];
                      posTotal = actualStackX.absolutePos = actualStackX.posTotal;
                      negTotal = actualStackX.absoluteNeg = actualStackX.negTotal;
                      actualStackX.stackTotal = posTotal + negTotal;
                      statesLen = actualStackX.stackState.length;
                      if (xPoint && xPoint.isIntermediateSum) {
                        calculateStackState(prevSum, actualSum, 0, prevSum);
                        prevSum = actualSum;
                        actualSum = seriesThreshold;
                        stackThreshold ^= interSum;
                        interSum ^= stackThreshold;
                        stackThreshold ^= interSum;
                      } else if (xPoint && xPoint.isSum) {
                        calculateStackState(seriesThreshold, totalYVal, statesLen, 0);
                        stackThreshold = seriesThreshold;
                      } else {
                        calculateStackState(stackThreshold, yVal, 0, totalYVal);
                        if (xPoint) {
                          totalYVal += yVal;
                          actualSum += yVal;
                        }
                      }
                      actualStackX.stateIndex++;
                      actualStackX.threshold = stackThreshold;
                      stackThreshold += actualStackX.stackTotal;
                    }
                  }
                  waterfallStacks.changed = false;
                  if (!waterfallStacks.alreadyChanged) {
                    waterfallStacks.alreadyChanged = [];
                  }
                  waterfallStacks.alreadyChanged.push(stackKey);
                }
              };
              WaterfallSeries2.prototype.getExtremes = function() {
                var stacking = this.options.stacking, yAxis, waterfallStacks, stackedYNeg, stackedYPos;
                if (stacking) {
                  yAxis = this.yAxis;
                  waterfallStacks = yAxis.waterfall.stacks;
                  stackedYNeg = this.stackedYNeg = [];
                  stackedYPos = this.stackedYPos = [];
                  if (stacking === "overlap") {
                    objectEach(waterfallStacks[this.stackKey], function(stackX) {
                      stackedYNeg.push(arrayMin(stackX.stackState));
                      stackedYPos.push(arrayMax(stackX.stackState));
                    });
                  } else {
                    objectEach(waterfallStacks[this.stackKey], function(stackX) {
                      stackedYNeg.push(stackX.negTotal + stackX.threshold);
                      stackedYPos.push(stackX.posTotal + stackX.threshold);
                    });
                  }
                  return {
                    dataMin: arrayMin(stackedYNeg),
                    dataMax: arrayMax(stackedYPos)
                  };
                }
                return {
                  dataMin: this.dataMin,
                  dataMax: this.dataMax
                };
              };
              WaterfallSeries2.defaultOptions = merge(ColumnSeries.defaultOptions, {
                /**
                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @apioption plotOptions.waterfall.color
                 */
                /**
                 * The color used specifically for positive point columns. When not
                 * specified, the general series color is used.
                 *
                 * In styled mode, the waterfall colors can be set with the
                 * `.highcharts-point-negative`, `.highcharts-sum` and
                 * `.highcharts-intermediate-sum` classes.
                 *
                 * @sample {highcharts} highcharts/demo/waterfall/
                 *         Waterfall
                 *
                 * @type      {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @product   highcharts
                 * @apioption plotOptions.waterfall.upColor
                 */
                dataLabels: {
                  inside: true
                },
                /**
                 * The width of the line connecting waterfall columns.
                 *
                 * @product highcharts
                 */
                lineWidth: 1,
                /**
                 * The color of the line that connects columns in a waterfall series.
                 *
                 * In styled mode, the stroke can be set with the `.highcharts-graph`
                 * class.
                 *
                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @since   3.0
                 * @product highcharts
                 */
                lineColor: "#333333",
                /**
                 * A name for the dash style to use for the line connecting the columns
                 * of the waterfall series. Possible values: Dash, DashDot, Dot,
                 * LongDash, LongDashDot, LongDashDotDot, ShortDash, ShortDashDot,
                 * ShortDashDotDot, ShortDot, Solid
                 *
                 * In styled mode, the stroke dash-array can be set with the
                 * `.highcharts-graph` class.
                 *
                 * @type    {Highcharts.DashStyleValue}
                 * @since   3.0
                 * @product highcharts
                 */
                dashStyle: "Dot",
                /**
                 * The color of the border of each waterfall column.
                 *
                 * In styled mode, the border stroke can be set with the
                 * `.highcharts-point` class.
                 *
                 * @type    {Highcharts.ColorString|Highcharts.GradientColorObject|Highcharts.PatternObject}
                 * @since   3.0
                 * @product highcharts
                 */
                borderColor: "#333333",
                states: {
                  hover: {
                    lineWidthPlus: 0
                    // #3126
                  }
                }
              });
              return WaterfallSeries2;
            }(ColumnSeries)
          );
          extend2(WaterfallSeries.prototype, {
            getZonesGraphs: LineSeries.prototype.getZonesGraphs,
            pointValKey: "y",
            // Property needed to prevent lines between the columns from disappearing
            // when negativeColor is used.
            showLine: true,
            pointClass: WaterfallPoint
          });
          SeriesRegistry.registerSeriesType("waterfall", WaterfallSeries);
          WaterfallAxis.compose(Axis, Chart);
          "";
          return WaterfallSeries;
        });
        _registerModule(_modules, "Core/Axis/RadialAxis.js", [_modules["Core/Axis/AxisDefaults.js"], _modules["Core/Defaults.js"], _modules["Core/Globals.js"], _modules["Core/Utilities.js"]], function(AxisDefaults, D, H, U) {
          var defaultOptions = D.defaultOptions;
          var noop2 = H.noop;
          var addEvent = U.addEvent, correctFloat = U.correctFloat, defined = U.defined, extend2 = U.extend, fireEvent = U.fireEvent, merge = U.merge, pick = U.pick, relativeLength = U.relativeLength, wrap = U.wrap;
          var RadialAxis;
          (function(RadialAxis2) {
            var composedClasses = [];
            var defaultCircularOptions = {
              gridLineWidth: 1,
              labels: {
                align: void 0,
                distance: 15,
                x: 0,
                y: void 0,
                style: {
                  textOverflow: "none"
                  // wrap lines by default (#7248)
                }
              },
              maxPadding: 0,
              minPadding: 0,
              showLastLabel: false,
              tickLength: 0
            };
            var defaultRadialGaugeOptions = {
              labels: {
                align: "center",
                x: 0,
                y: void 0
                // auto
              },
              minorGridLineWidth: 0,
              minorTickInterval: "auto",
              minorTickLength: 10,
              minorTickPosition: "inside",
              minorTickWidth: 1,
              tickLength: 10,
              tickPosition: "inside",
              tickWidth: 2,
              title: {
                rotation: 0
              },
              zIndex: 2
              // behind dials, points in the series group
            };
            var defaultRadialOptions = {
              /**
               * In a polar chart, this is the angle of the Y axis in degrees, where
               * 0 is up and 90 is right. The angle determines the position of the
               * axis line and the labels, though the coordinate system is unaffected.
               * Since v8.0.0 this option is also applicable for X axis (inverted
               * polar).
               *
               * @sample {highcharts} highcharts/xaxis/angle/
               *         Custom X axis' angle on inverted polar chart
               * @sample {highcharts} highcharts/yaxis/angle/
               *         Dual axis polar chart
               *
               * @type      {number}
               * @default   0
               * @since     4.2.7
               * @product   highcharts
               * @apioption xAxis.angle
               */
              /**
               * Polar charts only. Whether the grid lines should draw as a polygon
               * with straight lines between categories, or as circles. Can be either
               * `circle` or `polygon`. Since v8.0.0 this option is also applicable
               * for X axis (inverted polar).
               *
               * @sample {highcharts} highcharts/demo/polar-spider/
               *         Polygon grid lines
               * @sample {highcharts} highcharts/xaxis/gridlineinterpolation/
               *         Circle and polygon on inverted polar
               * @sample {highcharts} highcharts/yaxis/gridlineinterpolation/
               *         Circle and polygon
               *
               * @type       {string}
               * @product    highcharts
               * @validvalue ["circle", "polygon"]
               * @apioption  xAxis.gridLineInterpolation
               */
              gridLineInterpolation: "circle",
              gridLineWidth: 1,
              labels: {
                align: "right",
                x: -3,
                y: -2
              },
              showLastLabel: false,
              title: {
                x: 4,
                text: null,
                rotation: 90
              }
            };
            function beforeSetTickPositions() {
              this.autoConnect = this.isCircular && typeof pick(this.userMax, this.options.max) === "undefined" && correctFloat(this.endAngleRad - this.startAngleRad) === correctFloat(2 * Math.PI);
              if (!this.isCircular && this.chart.inverted) {
                this.max++;
              }
              if (this.autoConnect) {
                this.max += this.categories && 1 || this.pointRange || this.closestPointRange || 0;
              }
            }
            function compose(AxisClass, TickClass) {
              if (composedClasses.indexOf(AxisClass) === -1) {
                composedClasses.push(AxisClass);
                addEvent(AxisClass, "afterInit", onAxisAfterInit);
                addEvent(AxisClass, "autoLabelAlign", onAxisAutoLabelAlign);
                addEvent(AxisClass, "destroy", onAxisDestroy);
                addEvent(AxisClass, "init", onAxisInit);
                addEvent(AxisClass, "initialAxisTranslation", onAxisInitialAxisTranslation);
              }
              if (composedClasses.indexOf(TickClass) === -1) {
                composedClasses.push(TickClass);
                addEvent(TickClass, "afterGetLabelPosition", onTickAfterGetLabelPosition);
                addEvent(TickClass, "afterGetPosition", onTickAfterGetPosition);
                wrap(TickClass.prototype, "getMarkPath", wrapTickGetMarkPath);
              }
              return AxisClass;
            }
            RadialAxis2.compose = compose;
            function createLabelCollector() {
              var _this = this;
              return function() {
                if (_this.isRadial && _this.tickPositions && // undocumented option for now, but working
                _this.options.labels && _this.options.labels.allowOverlap !== true) {
                  return _this.tickPositions.map(function(pos) {
                    return _this.ticks[pos] && _this.ticks[pos].label;
                  }).filter(function(label) {
                    return Boolean(label);
                  });
                }
              };
            }
            function createLabelCollectorHidden() {
              return noop2;
            }
            function getCrosshairPosition(options, x1, y1) {
              var center = this.pane.center;
              var value = options.value, shapeArgs, end, x2, y2;
              if (this.isCircular) {
                if (!defined(value)) {
                  x2 = options.chartX || 0;
                  y2 = options.chartY || 0;
                  value = this.translate(Math.atan2(y2 - y1, x2 - x1) - this.startAngleRad, true);
                } else if (options.point) {
                  shapeArgs = options.point.shapeArgs || {};
                  if (shapeArgs.start) {
                    value = this.chart.inverted ? this.translate(options.point.rectPlotY, true) : options.point.x;
                  }
                }
                end = this.getPosition(value);
                x2 = end.x;
                y2 = end.y;
              } else {
                if (!defined(value)) {
                  x2 = options.chartX;
                  y2 = options.chartY;
                }
                if (defined(x2) && defined(y2)) {
                  y1 = center[1] + this.chart.plotTop;
                  value = this.translate(Math.min(Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)), center[2] / 2) - center[3] / 2, true);
                }
              }
              return [value, x2 || 0, y2 || 0];
            }
            function getLinePath(_lineWidth, radius, innerRadius) {
              var center = this.pane.center, chart = this.chart, left = this.left || 0, top = this.top || 0;
              var end, r = pick(
                radius,
                center[2] / 2 - this.offset
              ), path;
              if (typeof innerRadius === "undefined") {
                innerRadius = this.horiz ? 0 : this.center && -this.center[3] / 2;
              }
              if (innerRadius) {
                r += innerRadius;
              }
              if (this.isCircular || typeof radius !== "undefined") {
                path = this.chart.renderer.symbols.arc(left + center[0], top + center[1], r, r, {
                  start: this.startAngleRad,
                  end: this.endAngleRad,
                  open: true,
                  innerR: 0
                });
                path.xBounds = [left + center[0]];
                path.yBounds = [top + center[1] - r];
              } else {
                end = this.postTranslate(this.angleRad, r);
                path = [
                  [
                    "M",
                    this.center[0] + chart.plotLeft,
                    this.center[1] + chart.plotTop
                  ],
                  ["L", end.x, end.y]
                ];
              }
              return path;
            }
            function getOffset() {
              var axisProto = this.constructor.prototype;
              axisProto.getOffset.call(this);
              this.chart.axisOffset[this.side] = 0;
            }
            function getPlotBandPath(from, to, options) {
              var chart = this.chart, radiusToPixels = function(radius) {
                if (typeof radius === "string") {
                  var r = parseInt(radius, 10);
                  if (percentRegex.test(radius)) {
                    r = r * fullRadius / 100;
                  }
                  return r;
                }
                return radius;
              }, center = this.center, startAngleRad = this.startAngleRad, fullRadius = center[2] / 2, offset = Math.min(this.offset, 0), left = this.left || 0, top = this.top || 0, percentRegex = /%$/, isCircular = this.isCircular;
              var start2, end, angle, xOnPerimeter, open, path, outerRadius = pick(
                radiusToPixels(options.outerRadius),
                fullRadius
              ), innerRadius = radiusToPixels(options.innerRadius), thickness = pick(radiusToPixels(options.thickness), 10);
              if (this.options.gridLineInterpolation === "polygon") {
                path = this.getPlotLinePath({ value: from }).concat(this.getPlotLinePath({ value: to, reverse: true }));
              } else {
                from = Math.max(from, this.min);
                to = Math.min(to, this.max);
                var transFrom = this.translate(from), transTo = this.translate(to);
                if (!isCircular) {
                  outerRadius = transFrom || 0;
                  innerRadius = transTo || 0;
                }
                if (options.shape === "circle" || !isCircular) {
                  start2 = -Math.PI / 2;
                  end = Math.PI * 1.5;
                  open = true;
                } else {
                  start2 = startAngleRad + (transFrom || 0);
                  end = startAngleRad + (transTo || 0);
                }
                outerRadius -= offset;
                thickness -= offset;
                path = chart.renderer.symbols.arc(left + center[0], top + center[1], outerRadius, outerRadius, {
                  // Math is for reversed yAxis (#3606)
                  start: Math.min(start2, end),
                  end: Math.max(start2, end),
                  innerR: pick(innerRadius, outerRadius - thickness),
                  open
                });
                if (isCircular) {
                  angle = (end + start2) / 2;
                  xOnPerimeter = left + center[0] + center[2] / 2 * Math.cos(angle);
                  path.xBounds = angle > -Math.PI / 2 && angle < Math.PI / 2 ? (
                    // Right hemisphere
                    [xOnPerimeter, chart.plotWidth]
                  ) : (
                    // Left hemisphere
                    [0, xOnPerimeter]
                  );
                  path.yBounds = [
                    top + center[1] + center[2] / 2 * Math.sin(angle)
                  ];
                  path.yBounds[0] += angle > -Math.PI && angle < 0 || angle > Math.PI ? -10 : 10;
                }
              }
              return path;
            }
            function getPlotLinePath(options) {
              var _this = this;
              var center = this.pane.center, chart = this.chart, inverted = chart.inverted, reverse = options.reverse, background = this.pane.options.background ? this.pane.options.background[0] || this.pane.options.background : {}, innerRadius = background.innerRadius || "0%", outerRadius = background.outerRadius || "100%", x1 = center[0] + chart.plotLeft, y1 = center[1] + chart.plotTop, height = this.height, isCrosshair = options.isCrosshair, paneInnerR = center[3] / 2;
              var value = options.value, innerRatio, distance, a, b, otherAxis, xy, tickPositions, crossPos, path;
              var end = this.getPosition(value);
              var x2 = end.x, y2 = end.y;
              if (isCrosshair) {
                crossPos = this.getCrosshairPosition(options, x1, y1);
                value = crossPos[0];
                x2 = crossPos[1];
                y2 = crossPos[2];
              }
              if (this.isCircular) {
                distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                a = typeof innerRadius === "string" ? relativeLength(innerRadius, 1) : innerRadius / distance;
                b = typeof outerRadius === "string" ? relativeLength(outerRadius, 1) : outerRadius / distance;
                if (center && paneInnerR) {
                  innerRatio = paneInnerR / distance;
                  if (a < innerRatio) {
                    a = innerRatio;
                  }
                  if (b < innerRatio) {
                    b = innerRatio;
                  }
                }
                path = [
                  ["M", x1 + a * (x2 - x1), y1 - a * (y1 - y2)],
                  ["L", x2 - (1 - b) * (x2 - x1), y2 + (1 - b) * (y1 - y2)]
                ];
              } else {
                value = this.translate(value);
                if (value) {
                  if (value < 0 || value > height) {
                    value = 0;
                  }
                }
                if (this.options.gridLineInterpolation === "circle") {
                  path = this.getLinePath(0, value, paneInnerR);
                } else {
                  path = [];
                  chart[inverted ? "yAxis" : "xAxis"].forEach(function(a2) {
                    if (a2.pane === _this.pane) {
                      otherAxis = a2;
                    }
                  });
                  if (otherAxis) {
                    tickPositions = otherAxis.tickPositions;
                    if (otherAxis.autoConnect) {
                      tickPositions = tickPositions.concat([tickPositions[0]]);
                    }
                    if (reverse) {
                      tickPositions = tickPositions.slice().reverse();
                    }
                    if (value) {
                      value += paneInnerR;
                    }
                    for (var i = 0; i < tickPositions.length; i++) {
                      xy = otherAxis.getPosition(tickPositions[i], value);
                      path.push(i ? ["L", xy.x, xy.y] : ["M", xy.x, xy.y]);
                    }
                  }
                }
              }
              return path;
            }
            function getPosition(value, length) {
              var translatedVal = this.translate(value);
              return this.postTranslate(
                this.isCircular ? translatedVal : this.angleRad,
                // #2848
                // In case when translatedVal is negative, the 0 value must be
                // used instead, in order to deal with lines and labels that
                // fall out of the visible range near the center of a pane
                pick(this.isCircular ? length : translatedVal < 0 ? 0 : translatedVal, this.center[2] / 2) - this.offset
              );
            }
            function getTitlePosition() {
              var center = this.center, chart = this.chart, titleOptions = this.options.title;
              return {
                x: chart.plotLeft + center[0] + (titleOptions.x || 0),
                y: chart.plotTop + center[1] - {
                  high: 0.5,
                  middle: 0.25,
                  low: 0
                }[titleOptions.align] * center[2] + (titleOptions.y || 0)
              };
            }
            function modify(axis) {
              axis.beforeSetTickPositions = beforeSetTickPositions;
              axis.createLabelCollector = createLabelCollector;
              axis.getCrosshairPosition = getCrosshairPosition;
              axis.getLinePath = getLinePath;
              axis.getOffset = getOffset;
              axis.getPlotBandPath = getPlotBandPath;
              axis.getPlotLinePath = getPlotLinePath;
              axis.getPosition = getPosition;
              axis.getTitlePosition = getTitlePosition;
              axis.postTranslate = postTranslate;
              axis.setAxisSize = setAxisSize;
              axis.setAxisTranslation = setAxisTranslation;
              axis.setOptions = setOptions;
            }
            function modifyAsHidden(radialAxis) {
              radialAxis.isHidden = true;
              radialAxis.createLabelCollector = createLabelCollectorHidden;
              radialAxis.getOffset = noop2;
              radialAxis.redraw = renderHidden;
              radialAxis.render = renderHidden;
              radialAxis.setScale = noop2;
              radialAxis.setCategories = noop2;
              radialAxis.setTitle = noop2;
            }
            function onAxisAfterInit() {
              var chart = this.chart, options = this.options, isHidden = chart.angular && this.isXAxis, pane = this.pane, paneOptions = pane && pane.options;
              if (!isHidden && pane && (chart.angular || chart.polar)) {
                var fullCircle = Math.PI * 2, start2 = (pick(paneOptions.startAngle, 0) - 90) * Math.PI / 180, end = (pick(
                  paneOptions.endAngle,
                  pick(paneOptions.startAngle, 0) + 360
                ) - 90) * Math.PI / 180;
                this.angleRad = (options.angle || 0) * Math.PI / 180;
                this.startAngleRad = start2;
                this.endAngleRad = end;
                this.offset = options.offset || 0;
                var normalizedStart = (start2 % fullCircle + fullCircle) % fullCircle, normalizedEnd = (end % fullCircle + fullCircle) % fullCircle;
                if (normalizedStart > Math.PI) {
                  normalizedStart -= fullCircle;
                }
                if (normalizedEnd > Math.PI) {
                  normalizedEnd -= fullCircle;
                }
                this.normalizedStartAngleRad = normalizedStart;
                this.normalizedEndAngleRad = normalizedEnd;
              }
            }
            function onAxisAutoLabelAlign(e) {
              if (this.isRadial) {
                e.align = void 0;
                e.preventDefault();
              }
            }
            function onAxisDestroy() {
              if (this.chart && this.chart.labelCollectors) {
                var index = this.labelCollector ? this.chart.labelCollectors.indexOf(this.labelCollector) : -1;
                if (index >= 0) {
                  this.chart.labelCollectors.splice(index, 1);
                }
              }
            }
            function onAxisInit(e) {
              var chart = this.chart, inverted = chart.inverted, angular = chart.angular, polar = chart.polar, isX = this.isXAxis, coll = this.coll, isHidden = angular && isX, chartOptions = chart.options, paneIndex = e.userOptions.pane || 0, pane = this.pane = chart.pane && chart.pane[paneIndex];
              var isCircular;
              if (coll === "colorAxis") {
                this.isRadial = false;
                return;
              }
              if (angular) {
                if (isHidden) {
                  modifyAsHidden(this);
                } else {
                  modify(this);
                }
                isCircular = !isX;
                if (isCircular) {
                  this.defaultPolarOptions = defaultRadialGaugeOptions;
                }
              } else if (polar) {
                modify(this);
                isCircular = this.horiz;
                this.defaultPolarOptions = isCircular ? defaultCircularOptions : merge(coll === "xAxis" ? AxisDefaults.defaultXAxisOptions : AxisDefaults.defaultYAxisOptions, defaultRadialOptions);
                if (inverted && coll === "yAxis") {
                  this.defaultPolarOptions.stackLabels = AxisDefaults.defaultYAxisOptions.stackLabels;
                  this.defaultPolarOptions.reversedStacks = true;
                }
              }
              if (angular || polar) {
                this.isRadial = true;
                if (!this.labelCollector) {
                  this.labelCollector = this.createLabelCollector();
                }
                if (this.labelCollector) {
                  chart.labelCollectors.push(this.labelCollector);
                }
              } else {
                this.isRadial = false;
              }
              if (pane && isCircular) {
                pane.axis = this;
              }
              this.isCircular = isCircular;
            }
            function onAxisInitialAxisTranslation() {
              if (this.isRadial) {
                this.beforeSetTickPositions();
              }
            }
            function onTickAfterGetLabelPosition(e) {
              var label = this.label;
              if (!label) {
                return;
              }
              var axis = this.axis, labelBBox = label.getBBox(), labelOptions = axis.options.labels, angle = (axis.translate(this.pos) + axis.startAngleRad + Math.PI / 2) / Math.PI * 180 % 360, correctAngle = Math.round(angle), labelYPosCorrection = !defined(labelOptions.y) ? -labelBBox.height * 0.3 : 0;
              var optionsY = labelOptions.y, ret, centerSlot = 20, align = labelOptions.align, labelDir = "end", reducedAngle1 = correctAngle < 0 ? correctAngle + 360 : correctAngle, reducedAngle2 = reducedAngle1, translateY = 0, translateX = 0;
              if (axis.isRadial) {
                ret = axis.getPosition(this.pos, axis.center[2] / 2 + relativeLength(pick(labelOptions.distance, -25), axis.center[2] / 2, -axis.center[2] / 2));
                if (labelOptions.rotation === "auto") {
                  label.attr({
                    rotation: angle
                  });
                } else if (!defined(optionsY)) {
                  optionsY = axis.chart.renderer.fontMetrics(label.styles && label.styles.fontSize).b - labelBBox.height / 2;
                }
                if (!defined(align)) {
                  if (axis.isCircular) {
                    if (labelBBox.width > axis.len * axis.tickInterval / (axis.max - axis.min)) {
                      centerSlot = 0;
                    }
                    if (angle > centerSlot && angle < 180 - centerSlot) {
                      align = "left";
                    } else if (angle > 180 + centerSlot && angle < 360 - centerSlot) {
                      align = "right";
                    } else {
                      align = "center";
                    }
                  } else {
                    align = "center";
                  }
                  label.attr({
                    align
                  });
                }
                if (align === "auto" && axis.tickPositions.length === 2 && axis.isCircular) {
                  if (reducedAngle1 > 90 && reducedAngle1 < 180) {
                    reducedAngle1 = 180 - reducedAngle1;
                  } else if (reducedAngle1 > 270 && reducedAngle1 <= 360) {
                    reducedAngle1 = 540 - reducedAngle1;
                  }
                  if (reducedAngle2 > 180 && reducedAngle2 <= 360) {
                    reducedAngle2 = 360 - reducedAngle2;
                  }
                  if (axis.pane.options.startAngle === correctAngle || axis.pane.options.startAngle === correctAngle + 360 || axis.pane.options.startAngle === correctAngle - 360) {
                    labelDir = "start";
                  }
                  if (correctAngle >= -90 && correctAngle <= 90 || correctAngle >= -360 && correctAngle <= -270 || correctAngle >= 270 && correctAngle <= 360) {
                    align = labelDir === "start" ? "right" : "left";
                  } else {
                    align = labelDir === "start" ? "left" : "right";
                  }
                  if (reducedAngle2 > 70 && reducedAngle2 < 110) {
                    align = "center";
                  }
                  if (reducedAngle1 < 15 || reducedAngle1 >= 180 && reducedAngle1 < 195) {
                    translateY = labelBBox.height * 0.3;
                  } else if (reducedAngle1 >= 15 && reducedAngle1 <= 35) {
                    translateY = labelDir === "start" ? 0 : labelBBox.height * 0.75;
                  } else if (reducedAngle1 >= 195 && reducedAngle1 <= 215) {
                    translateY = labelDir === "start" ? labelBBox.height * 0.75 : 0;
                  } else if (reducedAngle1 > 35 && reducedAngle1 <= 90) {
                    translateY = labelDir === "start" ? -labelBBox.height * 0.25 : labelBBox.height;
                  } else if (reducedAngle1 > 215 && reducedAngle1 <= 270) {
                    translateY = labelDir === "start" ? labelBBox.height : -labelBBox.height * 0.25;
                  }
                  if (reducedAngle2 < 15) {
                    translateX = labelDir === "start" ? -labelBBox.height * 0.15 : labelBBox.height * 0.15;
                  } else if (reducedAngle2 > 165 && reducedAngle2 <= 180) {
                    translateX = labelDir === "start" ? labelBBox.height * 0.15 : -labelBBox.height * 0.15;
                  }
                  label.attr({ align });
                  label.translate(translateX, translateY + labelYPosCorrection);
                }
                e.pos.x = ret.x + (labelOptions.x || 0);
                e.pos.y = ret.y + (optionsY || 0);
              }
            }
            function onTickAfterGetPosition(e) {
              if (this.axis.getPosition) {
                extend2(e.pos, this.axis.getPosition(this.pos));
              }
            }
            function postTranslate(angle, radius) {
              var chart = this.chart, center = this.center;
              angle = this.startAngleRad + angle;
              return {
                x: chart.plotLeft + center[0] + Math.cos(angle) * radius,
                y: chart.plotTop + center[1] + Math.sin(angle) * radius
              };
            }
            function renderHidden() {
              this.isDirty = false;
            }
            function setAxisSize() {
              var axisProto = this.constructor.prototype;
              var center, start2;
              axisProto.setAxisSize.call(this);
              if (this.isRadial) {
                this.pane.updateCenter(this);
                center = this.center = this.pane.center.slice();
                if (this.isCircular) {
                  this.sector = this.endAngleRad - this.startAngleRad;
                } else {
                  start2 = this.postTranslate(this.angleRad, center[3] / 2);
                  center[0] = start2.x - this.chart.plotLeft;
                  center[1] = start2.y - this.chart.plotTop;
                }
                this.len = this.width = this.height = (center[2] - center[3]) * pick(this.sector, 1) / 2;
              }
            }
            function setAxisTranslation() {
              var axisProto = this.constructor.prototype;
              axisProto.setAxisTranslation.call(this);
              if (this.center) {
                if (this.isCircular) {
                  this.transA = (this.endAngleRad - this.startAngleRad) / (this.max - this.min || 1);
                } else {
                  this.transA = (this.center[2] - this.center[3]) / 2 / (this.max - this.min || 1);
                }
                if (this.isXAxis) {
                  this.minPixelPadding = this.transA * this.minPointOffset;
                } else {
                  this.minPixelPadding = 0;
                }
              }
            }
            function setOptions(userOptions) {
              var options = this.options = merge(
                this.constructor.defaultOptions,
                this.defaultPolarOptions,
                defaultOptions[this.coll],
                // #16112
                userOptions
              );
              if (!options.plotBands) {
                options.plotBands = [];
              }
              fireEvent(this, "afterSetOptions");
            }
            function wrapTickGetMarkPath(proceed, x, y, tickLength, tickWidth, horiz, renderer) {
              var axis = this.axis;
              var endPoint, ret;
              if (axis.isRadial) {
                endPoint = axis.getPosition(this.pos, axis.center[2] / 2 + tickLength);
                ret = [
                  "M",
                  x,
                  y,
                  "L",
                  endPoint.x,
                  endPoint.y
                ];
              } else {
                ret = proceed.call(this, x, y, tickLength, tickWidth, horiz, renderer);
              }
              return ret;
            }
          })(RadialAxis || (RadialAxis = {}));
          return RadialAxis;
        });
        _registerModule(_modules, "Series/PolarComposition.js", [_modules["Core/Animation/AnimationUtilities.js"], _modules["Core/Globals.js"], _modules["Extensions/Pane.js"], _modules["Core/Axis/RadialAxis.js"], _modules["Core/Utilities.js"]], function(A, H, Pane, RadialAxis, U) {
          var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
            if (pack || arguments.length === 2)
              for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                  if (!ar)
                    ar = Array.prototype.slice.call(
                      from,
                      0,
                      i
                    );
                  ar[i] = from[i];
                }
              }
            return to.concat(ar || Array.prototype.slice.call(from));
          };
          var animObject = A.animObject;
          var addEvent = U.addEvent, defined = U.defined, find2 = U.find, isNumber = U.isNumber, pick = U.pick, splat = U.splat, uniqueKey = U.uniqueKey, wrap = U.wrap;
          var composedClasses = [];
          function clipCircle(renderer, x, y, r, innerR) {
            var id2 = uniqueKey(), clipPath = renderer.createElement("clipPath").attr({
              id: id2
            }).add(renderer.defs), wrapper = innerR ? renderer.arc(
              x,
              y,
              r,
              innerR,
              0,
              2 * Math.PI
            ).add(clipPath) : renderer.circle(
              x,
              y,
              r
            ).add(clipPath);
            wrapper.id = id2;
            wrapper.clipPath = clipPath;
            return wrapper;
          }
          function findAlignments(angle, options) {
            var align, verticalAlign;
            if (options.align === null) {
              if (angle > 20 && angle < 160) {
                align = "left";
              } else if (angle > 200 && angle < 340) {
                align = "right";
              } else {
                align = "center";
              }
              options.align = align;
            }
            if (options.verticalAlign === null) {
              if (angle < 45 || angle > 315) {
                verticalAlign = "bottom";
              } else if (angle > 135 && angle < 225) {
                verticalAlign = "top";
              } else {
                verticalAlign = "middle";
              }
              options.verticalAlign = verticalAlign;
            }
            return options;
          }
          function getConnectors(segment, index, calculateNeighbours, connectEnds) {
            var smoothing = 1.5, denom = smoothing + 1, addedNumber = connectEnds ? 1 : 0;
            var i, leftContX, leftContY, rightContX, rightContY, jointAngle;
            if (index >= 0 && index <= segment.length - 1) {
              i = index;
            } else if (index < 0) {
              i = segment.length - 1 + index;
            } else {
              i = 0;
            }
            var prevPointInd = i - 1 < 0 ? segment.length - (1 + addedNumber) : i - 1, nextPointInd = i + 1 > segment.length - 1 ? addedNumber : i + 1, previousPoint = segment[prevPointInd], nextPoint = segment[nextPointInd], previousX = previousPoint.plotX, previousY = previousPoint.plotY, nextX = nextPoint.plotX, nextY = nextPoint.plotY, plotX = segment[i].plotX, plotY = segment[i].plotY;
            leftContX = (smoothing * plotX + previousX) / denom;
            leftContY = (smoothing * plotY + previousY) / denom;
            rightContX = (smoothing * plotX + nextX) / denom;
            rightContY = (smoothing * plotY + nextY) / denom;
            var dLControlPoint = Math.sqrt(Math.pow(leftContX - plotX, 2) + Math.pow(leftContY - plotY, 2)), dRControlPoint = Math.sqrt(Math.pow(rightContX - plotX, 2) + Math.pow(rightContY - plotY, 2)), leftContAngle = Math.atan2(
              leftContY - plotY,
              leftContX - plotX
            ), rightContAngle = Math.atan2(
              rightContY - plotY,
              rightContX - plotX
            );
            jointAngle = Math.PI / 2 + (leftContAngle + rightContAngle) / 2;
            if (Math.abs(leftContAngle - jointAngle) > Math.PI / 2) {
              jointAngle -= Math.PI;
            }
            leftContX = plotX + Math.cos(jointAngle) * dLControlPoint;
            leftContY = plotY + Math.sin(jointAngle) * dLControlPoint;
            rightContX = plotX + Math.cos(Math.PI + jointAngle) * dRControlPoint;
            rightContY = plotY + Math.sin(Math.PI + jointAngle) * dRControlPoint;
            var ret = {
              rightContX,
              rightContY,
              leftContX,
              leftContY,
              plotX,
              plotY
            };
            if (calculateNeighbours) {
              ret.prevPointCont = getConnectors(segment, prevPointInd, false, connectEnds);
            }
            return ret;
          }
          function onChartAfterDrawChartBox() {
            (this.pane || []).forEach(function(pane) {
              pane.render();
            });
          }
          function onChartAfterInit(event) {
            var xAxis = event.args[0].xAxis, yAxis = event.args[0].yAxis, chart = event.args[0].chart;
            if (xAxis && yAxis) {
              if (yAxis.gridLineInterpolation === "polygon") {
                xAxis.startOnTick = true;
                xAxis.endOnTick = true;
              } else if (xAxis.gridLineInterpolation === "polygon" && chart.inverted) {
                yAxis.startOnTick = true;
                yAxis.endOnTick = true;
              }
            }
          }
          function onChartGetAxes() {
            var _this = this;
            if (!this.pane) {
              this.pane = [];
            }
            this.options.pane = splat(this.options.pane);
            this.options.pane.forEach(function(paneOptions) {
              new Pane(
                // eslint-disable-line no-new
                paneOptions,
                _this
              );
            }, this);
          }
          function onPointerGetSelectionBox(event) {
            var marker = event.args.marker, xAxis = this.chart.xAxis[0], yAxis = this.chart.yAxis[0], inverted = this.chart.inverted, radialAxis = inverted ? yAxis : xAxis, linearAxis = inverted ? xAxis : yAxis;
            if (this.chart.polar) {
              event.preventDefault();
              var start2 = (marker.attr ? marker.attr("start") : marker.start) - radialAxis.startAngleRad;
              var r = marker.attr ? marker.attr("r") : marker.r;
              var end = (marker.attr ? marker.attr("end") : marker.end) - radialAxis.startAngleRad;
              var innerR = marker.attr ? marker.attr("innerR") : marker.innerR;
              event.result.x = start2 + radialAxis.pos;
              event.result.width = end - start2;
              event.result.y = linearAxis.len + linearAxis.pos - innerR;
              event.result.height = innerR - r;
            }
          }
          function onPointerGetSelectionMarkerAttrs(event) {
            var chart = this.chart;
            if (chart.polar && chart.hoverPane && chart.hoverPane.axis) {
              event.preventDefault();
              var center = chart.hoverPane.center, mouseDownX = this.mouseDownX || 0, mouseDownY = this.mouseDownY || 0, chartY = event.args.chartY, chartX = event.args.chartX, fullCircle = Math.PI * 2, startAngleRad = chart.hoverPane.axis.startAngleRad, endAngleRad = chart.hoverPane.axis.endAngleRad, linearAxis = chart.inverted ? chart.xAxis[0] : chart.yAxis[0], attrs = {};
              var shapeType = "arc";
              attrs.x = center[0] + chart.plotLeft;
              attrs.y = center[1] + chart.plotTop;
              if (this.zoomHor) {
                var paneRadRange = startAngleRad > 0 ? endAngleRad - startAngleRad : Math.abs(startAngleRad) + Math.abs(endAngleRad);
                var startAngle = Math.atan2(
                  mouseDownY - chart.plotTop - center[1],
                  mouseDownX - chart.plotLeft - center[0]
                ) - startAngleRad, endAngle = Math.atan2(
                  chartY - chart.plotTop - center[1],
                  chartX - chart.plotLeft - center[0]
                ) - startAngleRad;
                attrs.r = center[2] / 2;
                attrs.innerR = center[3] / 2;
                if (startAngle <= 0) {
                  startAngle += fullCircle;
                }
                if (endAngle <= 0) {
                  endAngle += fullCircle;
                }
                if (endAngle < startAngle) {
                  endAngle = [startAngle, startAngle = endAngle][0];
                }
                if (paneRadRange < fullCircle) {
                  var swapAngle = endAngleRad + (fullCircle - paneRadRange) / 2;
                  if (startAngleRad + endAngle > swapAngle) {
                    endAngle = startAngle;
                    startAngle = startAngleRad <= 0 ? startAngleRad : 0;
                  }
                }
                var start2 = attrs.start = Math.max(
                  startAngle + startAngleRad,
                  startAngleRad
                ), end = attrs.end = Math.min(
                  endAngle + startAngleRad,
                  endAngleRad
                );
                if (linearAxis.options.gridLineInterpolation === "polygon") {
                  var radialAxis = chart.hoverPane.axis, tickInterval = radialAxis.tickInterval, min2 = start2 - radialAxis.startAngleRad + radialAxis.pos, max2 = end - start2;
                  var path = linearAxis.getPlotLinePath({
                    value: linearAxis.max
                  }), pathStart = radialAxis.toValue(min2), pathEnd = radialAxis.toValue(min2 + max2);
                  if (pathStart < radialAxis.getExtremes().min) {
                    var _a = radialAxis.getExtremes(), min_1 = _a.min, max_1 = _a.max;
                    pathStart = max_1 - (min_1 - pathStart);
                  }
                  if (pathEnd < radialAxis.getExtremes().min) {
                    var _b = radialAxis.getExtremes(), min_2 = _b.min, max_2 = _b.max;
                    pathEnd = max_2 - (min_2 - pathEnd);
                  }
                  if (pathEnd < pathStart) {
                    pathEnd = [pathStart, pathStart = pathEnd][0];
                  }
                  path = trimPath(path, pathStart, pathEnd, radialAxis);
                  path.push([
                    "L",
                    center[0] + chart.plotLeft,
                    chart.plotTop + center[1]
                  ]);
                  attrs.d = path;
                  shapeType = "path";
                }
              }
              if (this.zoomVert) {
                var linearAxis_1 = chart.inverted ? chart.xAxis[0] : chart.yAxis[0];
                var innerR = Math.sqrt(Math.pow(mouseDownX - chart.plotLeft - center[0], 2) + Math.pow(mouseDownY - chart.plotTop - center[1], 2)), r = Math.sqrt(Math.pow(chartX - chart.plotLeft - center[0], 2) + Math.pow(chartY - chart.plotTop - center[1], 2));
                if (r < innerR) {
                  innerR = [r, r = innerR][0];
                }
                if (r > center[2] / 2) {
                  r = center[2] / 2;
                }
                if (innerR < center[3] / 2) {
                  innerR = center[3] / 2;
                }
                if (!this.zoomHor) {
                  attrs.start = startAngleRad;
                  attrs.end = endAngleRad;
                }
                attrs.r = r;
                attrs.innerR = innerR;
                if (linearAxis_1.options.gridLineInterpolation === "polygon") {
                  var end = linearAxis_1.toValue(linearAxis_1.len + linearAxis_1.pos - innerR), start2 = linearAxis_1.toValue(linearAxis_1.len + linearAxis_1.pos - r), path = linearAxis_1.getPlotLinePath({
                    value: start2
                  }).concat(linearAxis_1.getPlotLinePath({
                    value: end,
                    reverse: true
                  }));
                  attrs.d = path;
                  shapeType = "path";
                }
              }
              if (this.zoomHor && this.zoomVert && linearAxis.options.gridLineInterpolation === "polygon") {
                var radialAxis = chart.hoverPane.axis, start2 = attrs.start || 0, end = attrs.end || 0, min2 = start2 - radialAxis.startAngleRad + radialAxis.pos, max2 = end - start2, pathStart = radialAxis.toValue(min2), pathEnd = radialAxis.toValue(min2 + max2);
                if (attrs.d instanceof Array) {
                  var innerPath = attrs.d.slice(
                    0,
                    attrs.d.length / 2
                  ), outerPath = attrs.d.slice(
                    attrs.d.length / 2,
                    attrs.d.length
                  );
                  outerPath = __spreadArray([], outerPath, true).reverse();
                  var radialAxis_1 = chart.hoverPane.axis;
                  innerPath = trimPath(innerPath, pathStart, pathEnd, radialAxis_1);
                  outerPath = trimPath(outerPath, pathStart, pathEnd, radialAxis_1);
                  if (outerPath) {
                    outerPath[0][0] = "L";
                  }
                  outerPath = __spreadArray([], outerPath, true).reverse();
                  attrs.d = innerPath.concat(outerPath);
                  shapeType = "path";
                }
              }
              event.attrs = attrs;
              event.shapeType = shapeType;
            }
          }
          function onSeriesAfterInit() {
            var chart = this.chart;
            if (chart.polar) {
              this.polar = new PolarAdditions(this);
              if (chart.inverted) {
                this.isRadialSeries = true;
                if (this.is("column")) {
                  this.isRadialBar = true;
                }
              }
            }
          }
          function onSeriesAfterTranslate() {
            if (this.chart.polar && this.xAxis) {
              var series = this, chart_1 = series.chart;
              series.kdByAngle = chart_1.tooltip && chart_1.tooltip.shared;
              if (series.kdByAngle) {
                series.searchPoint = searchPointByAngle;
              } else {
                series.options.findNearestPointBy = "xy";
              }
              var points = series.points;
              var i = points.length;
              while (i--) {
                if (!series.preventPostTranslate) {
                  series.polar.toXY(points[i]);
                }
                if (!chart_1.hasParallelCoordinates && !series.yAxis.reversed) {
                  if (pick(points[i].y, Number.MIN_VALUE) < series.yAxis.min || points[i].x < series.xAxis.min || points[i].x > series.xAxis.max) {
                    points[i].isNull = true;
                    points[i].plotY = NaN;
                  } else {
                    points[i].isNull = points[i].isValid && !points[i].isValid();
                  }
                }
              }
              if (!this.hasClipCircleSetter) {
                this.hasClipCircleSetter = !!series.eventsToUnbind.push(addEvent(series, "afterRender", function() {
                  var circ;
                  if (chart_1.polar) {
                    circ = this.yAxis.pane.center;
                    if (!this.clipCircle) {
                      this.clipCircle = clipCircle(chart_1.renderer, circ[0], circ[1], circ[2] / 2, circ[3] / 2);
                    } else {
                      this.clipCircle.animate({
                        x: circ[0],
                        y: circ[1],
                        r: circ[2] / 2,
                        innerR: circ[3] / 2
                      });
                    }
                    this.group.clip(this.clipCircle);
                    this.setClip = H.noop;
                  }
                }));
              }
            }
          }
          function searchPointByAngle(e) {
            var series = this, chart = series.chart, xAxis = series.xAxis, center = xAxis.pane && xAxis.pane.center, plotX = e.chartX - (center && center[0] || 0) - chart.plotLeft, plotY = e.chartY - (center && center[1] || 0) - chart.plotTop;
            return series.searchKDTree({
              clientX: 180 + Math.atan2(plotX, plotY) * (-180 / Math.PI)
            });
          }
          function trimPath(path, start2, end, radialAxis) {
            var tickInterval = radialAxis.tickInterval, ticks = radialAxis.tickPositions;
            var lastTick = find2(
              ticks,
              function(tick) {
                return tick >= end;
              }
            ), firstTick = find2(
              __spreadArray(
                [],
                ticks,
                true
              ).reverse(),
              function(tick) {
                return tick <= start2;
              }
            );
            if (!defined(lastTick)) {
              lastTick = ticks[ticks.length - 1];
            }
            if (!defined(firstTick)) {
              firstTick = ticks[0];
              lastTick += tickInterval;
              path[0][0] = "L";
              path.unshift(path[path.length - 3]);
            }
            path = path.slice(ticks.indexOf(firstTick), ticks.indexOf(lastTick) + 1);
            path[0][0] = "M";
            return path;
          }
          function wrapChartGet(proceed, id2) {
            return find2(this.pane || [], function(pane) {
              return pane.options.id === id2;
            }) || proceed.call(this, id2);
          }
          function wrapColumnSeriesAlignDataLabel(proceed, point, dataLabel, options, alignTo, isNew) {
            var chart = this.chart, inside = pick(options.inside, !!this.options.stacking);
            var angle, shapeArgs, labelPos;
            if (chart.polar) {
              angle = point.rectPlotX / Math.PI * 180;
              if (!chart.inverted) {
                options = findAlignments(angle, options);
              } else {
                this.forceDL = chart.isInsidePlot(point.plotX, point.plotY);
                if (inside && point.shapeArgs) {
                  shapeArgs = point.shapeArgs;
                  labelPos = this.yAxis.postTranslate(
                    // angle
                    ((shapeArgs.start || 0) + (shapeArgs.end || 0)) / 2 - this.xAxis.startAngleRad,
                    // radius
                    point.barX + point.pointWidth / 2
                  );
                  alignTo = {
                    x: labelPos.x - chart.plotLeft,
                    y: labelPos.y - chart.plotTop
                  };
                } else if (point.tooltipPos) {
                  alignTo = {
                    x: point.tooltipPos[0],
                    y: point.tooltipPos[1]
                  };
                }
                options.align = pick(options.align, "center");
                options.verticalAlign = pick(options.verticalAlign, "middle");
              }
              Object.getPrototypeOf(Object.getPrototypeOf(this)).alignDataLabel.call(this, point, dataLabel, options, alignTo, isNew);
              if (this.isRadialBar && point.shapeArgs && point.shapeArgs.start === point.shapeArgs.end) {
                dataLabel.hide();
              } else {
                dataLabel.show();
              }
            } else {
              proceed.call(this, point, dataLabel, options, alignTo, isNew);
            }
          }
          function wrapColumnSeriesTranslate(proceed) {
            var series = this, options = series.options, stacking = options.stacking, chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis, reversed = yAxis.reversed, center = yAxis.center, startAngleRad = xAxis.startAngleRad, endAngleRad = xAxis.endAngleRad, visibleRange = endAngleRad - startAngleRad;
            var threshold = options.threshold, thresholdAngleRad = 0, points, point, i, yMin, yMax, start2 = 0, end = 0, tooltipPos, pointX, pointY, stackValues, stack, barX, innerR, r;
            series.preventPostTranslate = true;
            proceed.call(series);
            if (xAxis.isRadial) {
              points = series.points;
              i = points.length;
              yMin = yAxis.translate(yAxis.min);
              yMax = yAxis.translate(yAxis.max);
              threshold = options.threshold || 0;
              if (chart.inverted) {
                if (isNumber(threshold)) {
                  thresholdAngleRad = yAxis.translate(threshold);
                  if (defined(thresholdAngleRad)) {
                    if (thresholdAngleRad < 0) {
                      thresholdAngleRad = 0;
                    } else if (thresholdAngleRad > visibleRange) {
                      thresholdAngleRad = visibleRange;
                    }
                    series.translatedThreshold = thresholdAngleRad + startAngleRad;
                  }
                }
              }
              while (i--) {
                point = points[i];
                barX = point.barX;
                pointX = point.x;
                pointY = point.y;
                point.shapeType = "arc";
                if (chart.inverted) {
                  point.plotY = yAxis.translate(pointY);
                  if (stacking && yAxis.stacking) {
                    stack = yAxis.stacking.stacks[(pointY < 0 ? "-" : "") + series.stackKey];
                    if (series.visible && stack && stack[pointX]) {
                      if (!point.isNull) {
                        stackValues = stack[pointX].points[series.getStackIndicator(void 0, pointX, series.index).key];
                        start2 = yAxis.translate(stackValues[0]);
                        end = yAxis.translate(stackValues[1]);
                        if (defined(start2)) {
                          start2 = U.clamp(start2, 0, visibleRange);
                        }
                      }
                    }
                  } else {
                    start2 = thresholdAngleRad;
                    end = point.plotY;
                  }
                  if (start2 > end) {
                    end = [start2, start2 = end][0];
                  }
                  if (!reversed) {
                    if (start2 < yMin) {
                      start2 = yMin;
                    } else if (end > yMax) {
                      end = yMax;
                    } else if (end < yMin || start2 > yMax) {
                      start2 = end = 0;
                    }
                  } else {
                    if (end > yMin) {
                      end = yMin;
                    } else if (start2 < yMax) {
                      start2 = yMax;
                    } else if (start2 > yMin || end < yMax) {
                      start2 = end = visibleRange;
                    }
                  }
                  if (yAxis.min > yAxis.max) {
                    start2 = end = reversed ? visibleRange : 0;
                  }
                  start2 += startAngleRad;
                  end += startAngleRad;
                  if (center) {
                    point.barX = barX += center[3] / 2;
                  }
                  innerR = Math.max(barX, 0);
                  r = Math.max(barX + point.pointWidth, 0);
                  point.shapeArgs = {
                    x: center && center[0],
                    y: center && center[1],
                    r,
                    innerR,
                    start: start2,
                    end
                  };
                  point.opacity = start2 === end ? 0 : void 0;
                  point.plotY = (defined(series.translatedThreshold) && (start2 < series.translatedThreshold ? start2 : end)) - startAngleRad;
                } else {
                  start2 = barX + startAngleRad;
                  point.shapeArgs = series.polar.arc(point.yBottom, point.plotY, start2, start2 + point.pointWidth);
                }
                series.polar.toXY(point);
                if (chart.inverted) {
                  tooltipPos = yAxis.postTranslate(point.rectPlotY, barX + point.pointWidth / 2);
                  point.tooltipPos = [
                    tooltipPos.x - chart.plotLeft,
                    tooltipPos.y - chart.plotTop
                  ];
                } else {
                  point.tooltipPos = [point.plotX, point.plotY];
                }
                if (center) {
                  point.ttBelow = point.plotY > center[1];
                }
              }
            }
          }
          function wrapLineSeriesGetGraphPath(proceed, points) {
            var series = this;
            var firstValid, popLastPoint;
            if (this.chart.polar) {
              points = points || this.points;
              for (var i = 0; i < points.length; i++) {
                if (!points[i].isNull) {
                  firstValid = i;
                  break;
                }
              }
              if (this.options.connectEnds !== false && typeof firstValid !== "undefined") {
                this.connectEnds = true;
                points.splice(points.length, 0, points[firstValid]);
                popLastPoint = true;
              }
              points.forEach(function(point) {
                if (typeof point.polarPlotY === "undefined") {
                  series.polar.toXY(point);
                }
              });
            }
            var ret = proceed.apply(
              this,
              [].slice.call(arguments, 1)
            );
            if (popLastPoint) {
              points.pop();
            }
            return ret;
          }
          function wrapPointerGetCoordinates(proceed, e) {
            var chart = this.chart;
            var ret = {
              xAxis: [],
              yAxis: []
            };
            if (chart.polar) {
              chart.axes.forEach(function(axis) {
                if (axis.coll === "colorAxis") {
                  return;
                }
                var isXAxis = axis.isXAxis, center = axis.center, x = e.chartX - center[0] - chart.plotLeft, y = e.chartY - center[1] - chart.plotTop;
                ret[isXAxis ? "xAxis" : "yAxis"].push({
                  axis,
                  value: axis.translate(isXAxis ? Math.PI - Math.atan2(x, y) : (
                    // angle
                    // distance from center
                    Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))
                  ), true)
                });
              });
            } else {
              ret = proceed.call(this, e);
            }
            return ret;
          }
          function wrapPointerPinch(proceed, e) {
            if (this.chart.polar) {
              return;
            }
            proceed.call(this, e);
          }
          function wrapSeriesAnimate(proceed, init3) {
            var series = this, chart = this.chart, group = this.group, markerGroup = this.markerGroup, center = this.xAxis && this.xAxis.center, plotLeft = chart.plotLeft, plotTop = chart.plotTop;
            var animation = this.options.animation, attribs, paneInnerR, graphic, shapeArgs, r, innerR;
            if (chart.polar) {
              if (series.isRadialBar) {
                if (!init3) {
                  series.startAngleRad = pick(series.translatedThreshold, series.xAxis.startAngleRad);
                  H.seriesTypes.pie.prototype.animate.call(series, init3);
                }
              } else {
                if (chart.renderer.isSVG) {
                  animation = animObject(animation);
                  if (series.is("column")) {
                    if (!init3) {
                      paneInnerR = center[3] / 2;
                      series.points.forEach(function(point) {
                        graphic = point.graphic;
                        shapeArgs = point.shapeArgs;
                        r = shapeArgs && shapeArgs.r;
                        innerR = shapeArgs && shapeArgs.innerR;
                        if (graphic && shapeArgs) {
                          graphic.attr({
                            r: paneInnerR,
                            innerR: paneInnerR
                          });
                          graphic.animate({
                            r,
                            innerR
                          }, series.options.animation);
                        }
                      });
                    }
                  } else {
                    if (init3) {
                      attribs = {
                        translateX: center[0] + plotLeft,
                        translateY: center[1] + plotTop,
                        scaleX: 1e-3,
                        scaleY: 1e-3
                      };
                      group.attr(attribs);
                      if (markerGroup) {
                        markerGroup.attr(attribs);
                      }
                    } else {
                      attribs = {
                        translateX: plotLeft,
                        translateY: plotTop,
                        scaleX: 1,
                        scaleY: 1
                      };
                      group.animate(attribs, animation);
                      if (markerGroup) {
                        markerGroup.animate(attribs, animation);
                      }
                    }
                  }
                }
              }
            } else {
              proceed.call(this, init3);
            }
          }
          function wrapSplineSeriesGetPointSpline(proceed, segment, point, i) {
            var ret, connectors;
            if (this.chart.polar) {
              if (!i) {
                ret = ["M", point.plotX, point.plotY];
              } else {
                connectors = getConnectors(segment, i, true, this.connectEnds);
                var rightContX = connectors.prevPointCont && connectors.prevPointCont.rightContX;
                var rightContY = connectors.prevPointCont && connectors.prevPointCont.rightContY;
                ret = [
                  "C",
                  isNumber(rightContX) ? rightContX : connectors.plotX,
                  isNumber(rightContY) ? rightContY : connectors.plotY,
                  isNumber(connectors.leftContX) ? connectors.leftContX : connectors.plotX,
                  isNumber(connectors.leftContY) ? connectors.leftContY : connectors.plotY,
                  connectors.plotX,
                  connectors.plotY
                ];
              }
            } else {
              ret = proceed.call(this, segment, point, i);
            }
            return ret;
          }
          var PolarAdditions = (
            /** @class */
            function() {
              function PolarAdditions2(series) {
                this.series = series;
              }
              PolarAdditions2.compose = function(AxisClass, ChartClass, PointerClass, SeriesClass, TickClass, AreaSplineRangeSeriesClass, ColumnSeriesClass, LineSeriesClass, SplineSeriesClass) {
                RadialAxis.compose(AxisClass, TickClass);
                if (composedClasses.indexOf(ChartClass) === -1) {
                  composedClasses.push(ChartClass);
                  addEvent(ChartClass, "afterDrawChartBox", onChartAfterDrawChartBox);
                  addEvent(ChartClass, "getAxes", onChartGetAxes);
                  addEvent(ChartClass, "init", onChartAfterInit);
                  var chartProto = ChartClass.prototype;
                  wrap(chartProto, "get", wrapChartGet);
                }
                if (composedClasses.indexOf(PointerClass) === -1) {
                  composedClasses.push(PointerClass);
                  var pointerProto = PointerClass.prototype;
                  wrap(pointerProto, "getCoordinates", wrapPointerGetCoordinates);
                  wrap(pointerProto, "pinch", wrapPointerPinch);
                  addEvent(PointerClass, "getSelectionMarkerAttrs", onPointerGetSelectionMarkerAttrs);
                  addEvent(PointerClass, "getSelectionBox", onPointerGetSelectionBox);
                }
                if (composedClasses.indexOf(SeriesClass) === -1) {
                  composedClasses.push(SeriesClass);
                  addEvent(SeriesClass, "afterInit", onSeriesAfterInit);
                  addEvent(
                    SeriesClass,
                    "afterTranslate",
                    onSeriesAfterTranslate,
                    { order: 2 }
                    // Run after translation of ||-coords
                  );
                  var seriesProto = SeriesClass.prototype;
                  wrap(seriesProto, "animate", wrapSeriesAnimate);
                }
                if (ColumnSeriesClass && composedClasses.indexOf(ColumnSeriesClass) === -1) {
                  composedClasses.push(ColumnSeriesClass);
                  var columnProto = ColumnSeriesClass.prototype;
                  wrap(columnProto, "alignDataLabel", wrapColumnSeriesAlignDataLabel);
                  wrap(columnProto, "animate", wrapSeriesAnimate);
                  wrap(columnProto, "translate", wrapColumnSeriesTranslate);
                }
                if (LineSeriesClass && composedClasses.indexOf(LineSeriesClass) === -1) {
                  composedClasses.push(LineSeriesClass);
                  var lineProto = LineSeriesClass.prototype;
                  wrap(lineProto, "getGraphPath", wrapLineSeriesGetGraphPath);
                }
                if (SplineSeriesClass && composedClasses.indexOf(SplineSeriesClass) === -1) {
                  composedClasses.push(SplineSeriesClass);
                  var splineProto = SplineSeriesClass.prototype;
                  wrap(splineProto, "getPointSpline", wrapSplineSeriesGetPointSpline);
                  if (AreaSplineRangeSeriesClass && composedClasses.indexOf(AreaSplineRangeSeriesClass) === -1) {
                    composedClasses.push(AreaSplineRangeSeriesClass);
                    var areaSplineRangeProto = AreaSplineRangeSeriesClass.prototype;
                    areaSplineRangeProto.getPointSpline = splineProto.getPointSpline;
                  }
                }
              };
              PolarAdditions2.prototype.arc = function(low, high, start2, end) {
                var series = this.series, center = series.xAxis.center, len = series.yAxis.len, paneInnerR = center[3] / 2;
                var r = len - high + paneInnerR, innerR = len - pick(
                  low,
                  len
                ) + paneInnerR;
                if (series.yAxis.reversed) {
                  if (r < 0) {
                    r = paneInnerR;
                  }
                  if (innerR < 0) {
                    innerR = paneInnerR;
                  }
                }
                return {
                  x: center[0],
                  y: center[1],
                  r,
                  innerR,
                  start: start2,
                  end
                };
              };
              PolarAdditions2.prototype.toXY = function(point) {
                var series = this.series, chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis, plotX = point.plotX, inverted = chart.inverted, pointY = point.y;
                var plotY = point.plotY, radius = inverted ? plotX : yAxis.len - plotY, clientX;
                if (inverted && series && !series.isRadialBar) {
                  point.plotY = plotY = isNumber(pointY) ? yAxis.translate(pointY) : 0;
                }
                point.rectPlotX = plotX;
                point.rectPlotY = plotY;
                if (yAxis.center) {
                  radius += yAxis.center[3] / 2;
                }
                if (isNumber(plotY)) {
                  var xy = inverted ? yAxis.postTranslate(
                    plotY,
                    radius
                  ) : xAxis.postTranslate(
                    plotX,
                    radius
                  );
                  point.plotX = point.polarPlotX = xy.x - chart.plotLeft;
                  point.plotY = point.polarPlotY = xy.y - chart.plotTop;
                }
                if (series.kdByAngle) {
                  clientX = (plotX / Math.PI * 180 + xAxis.pane.options.startAngle) % 360;
                  if (clientX < 0) {
                    clientX += 360;
                  }
                  point.clientX = clientX;
                } else {
                  point.clientX = point.plotX;
                }
              };
              return PolarAdditions2;
            }()
          );
          return PolarAdditions;
        });
        _registerModule(_modules, "masters/highcharts-more.src.js", [_modules["Core/Globals.js"], _modules["Core/Series/SeriesRegistry.js"], _modules["Series/Bubble/BubbleSeries.js"], _modules["Series/PackedBubble/PackedBubbleSeries.js"], _modules["Series/PolarComposition.js"]], function(Highcharts4, SeriesRegistry, BubbleSeries, PackedBubbleSeries, PolarAdditions) {
          var G = Highcharts4;
          BubbleSeries.compose(G.Axis, G.Chart, G.Legend, G.Series);
          PackedBubbleSeries.compose(G.Axis, G.Chart, G.Legend, G.Series);
          PolarAdditions.compose(G.Axis, G.Chart, G.Pointer, G.Series, G.Tick, SeriesRegistry.seriesTypes.areasplinerange, SeriesRegistry.seriesTypes.column, SeriesRegistry.seriesTypes.line, SeriesRegistry.seriesTypes.spline);
        });
      });
    }
  });

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/namespaces.js
  var xhtml = "http://www.w3.org/1999/xhtml";
  var namespaces_default = {
    svg: "http://www.w3.org/2000/svg",
    xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/namespace.js
  function namespace_default(name) {
    var prefix = name += "", i = prefix.indexOf(":");
    if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
      name = name.slice(i + 1);
    return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/creator.js
  function creatorInherit(name) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
    };
  }
  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator_default(name) {
    var fullname = namespace_default(name);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selector.js
  function none() {
  }
  function selector_default(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/select.js
  function select_default(select) {
    if (typeof select !== "function")
      select = selector_default(select);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node)
            subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/array.js
  function array(x) {
    return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selectorAll.js
  function empty() {
    return [];
  }
  function selectorAll_default(selector) {
    return selector == null ? empty : function() {
      return this.querySelectorAll(selector);
    };
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectAll.js
  function arrayAll(select) {
    return function() {
      return array(select.apply(this, arguments));
    };
  }
  function selectAll_default(select) {
    if (typeof select === "function")
      select = arrayAll(select);
    else
      select = selectorAll_default(select);
    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          subgroups.push(select.call(node, node.__data__, i, group));
          parents.push(node);
        }
      }
    }
    return new Selection(subgroups, parents);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/matcher.js
  function matcher_default(selector) {
    return function() {
      return this.matches(selector);
    };
  }
  function childMatcher(selector) {
    return function(node) {
      return node.matches(selector);
    };
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectChild.js
  var find = Array.prototype.find;
  function childFind(match) {
    return function() {
      return find.call(this.children, match);
    };
  }
  function childFirst() {
    return this.firstElementChild;
  }
  function selectChild_default(match) {
    return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/selectChildren.js
  var filter = Array.prototype.filter;
  function children() {
    return Array.from(this.children);
  }
  function childrenFilter(match) {
    return function() {
      return filter.call(this.children, match);
    };
  }
  function selectChildren_default(match) {
    return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/filter.js
  function filter_default(match) {
    if (typeof match !== "function")
      match = matcher_default(match);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/sparse.js
  function sparse_default(update) {
    return new Array(update.length);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/enter.js
  function enter_default() {
    return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
  }
  function EnterNode(parent, datum2) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum2;
  }
  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) {
      return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next) {
      return this._parent.insertBefore(child, next);
    },
    querySelector: function(selector) {
      return this._parent.querySelector(selector);
    },
    querySelectorAll: function(selector) {
      return this._parent.querySelectorAll(selector);
    }
  };

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/constant.js
  function constant_default(x) {
    return function() {
      return x;
    };
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/data.js
  function bindIndex(parent, group, enter, update, exit, data) {
    var i = 0, node, groupLength = group.length, dataLength = data.length;
    for (; i < dataLength; ++i) {
      if (node = group[i]) {
        node.__data__ = data[i];
        update[i] = node;
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }
    for (; i < groupLength; ++i) {
      if (node = group[i]) {
        exit[i] = node;
      }
    }
  }
  function bindKey(parent, group, enter, update, exit, data, key) {
    var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
    for (i = 0; i < groupLength; ++i) {
      if (node = group[i]) {
        keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i] = node;
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
      }
    }
    for (i = 0; i < dataLength; ++i) {
      keyValue = key.call(parent, data[i], i, data) + "";
      if (node = nodeByKeyValue.get(keyValue)) {
        update[i] = node;
        node.__data__ = data[i];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i] = new EnterNode(parent, data[i]);
      }
    }
    for (i = 0; i < groupLength; ++i) {
      if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
        exit[i] = node;
      }
    }
  }
  function datum(node) {
    return node.__data__;
  }
  function data_default(value, key) {
    if (!arguments.length)
      return Array.from(this, datum);
    var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
    if (typeof value !== "function")
      value = constant_default(value);
    for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
      var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
      bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
      for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i1)
            i1 = i0 + 1;
          while (!(next = updateGroup[i1]) && ++i1 < dataLength)
            ;
          previous._next = next || null;
        }
      }
    }
    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }
  function arraylike(data) {
    return typeof data === "object" && "length" in data ? data : Array.from(data);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/exit.js
  function exit_default() {
    return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/join.js
  function join_default(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    if (typeof onenter === "function") {
      enter = onenter(enter);
      if (enter)
        enter = enter.selection();
    } else {
      enter = enter.append(onenter + "");
    }
    if (onupdate != null) {
      update = onupdate(update);
      if (update)
        update = update.selection();
    }
    if (onexit == null)
      exit.remove();
    else
      onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/merge.js
  function merge_default(context) {
    var selection2 = context.selection ? context.selection() : context;
    for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Selection(merges, this._parents);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/order.js
  function order_default() {
    for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
      for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && node.compareDocumentPosition(next) ^ 4)
            next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/sort.js
  function sort_default(compare) {
    if (!compare)
      compare = ascending;
    function compareNode(a, b) {
      return a && b ? compare(a.__data__, b.__data__) : !a - !b;
    }
    for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          sortgroup[i] = node;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection(sortgroups, this._parents).order();
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/call.js
  function call_default() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/nodes.js
  function nodes_default() {
    return Array.from(this);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/node.js
  function node_default() {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
        var node = group[i];
        if (node)
          return node;
      }
    }
    return null;
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/size.js
  function size_default() {
    let size = 0;
    for (const node of this)
      ++size;
    return size;
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/empty.js
  function empty_default() {
    return !this.node();
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/each.js
  function each_default(callback) {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i])
          callback.call(node, node.__data__, i, group);
      }
    }
    return this;
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/attr.js
  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }
  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }
  function attrFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttribute(name);
      else
        this.setAttribute(name, v);
    };
  }
  function attrFunctionNS(fullname, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.removeAttributeNS(fullname.space, fullname.local);
      else
        this.setAttributeNS(fullname.space, fullname.local, v);
    };
  }
  function attr_default(name, value) {
    var fullname = namespace_default(name);
    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/window.js
  function window_default(node) {
    return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/style.js
  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }
  function styleFunction(name, value, priority) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        this.style.removeProperty(name);
      else
        this.style.setProperty(name, v, priority);
    };
  }
  function style_default(name, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
  }
  function styleValue(node, name) {
    return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/property.js
  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }
  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }
  function propertyFunction(name, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (v == null)
        delete this[name];
      else
        this[name] = v;
    };
  }
  function property_default(name, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/classed.js
  function classArray(string) {
    return string.trim().split(/^|\s+/);
  }
  function classList(node) {
    return node.classList || new ClassList(node);
  }
  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }
  ClassList.prototype = {
    add: function(name) {
      var i = this._names.indexOf(name);
      if (i < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i = this._names.indexOf(name);
      if (i >= 0) {
        this._names.splice(i, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };
  function classedAdd(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n)
      list.add(names[i]);
  }
  function classedRemove(node, names) {
    var list = classList(node), i = -1, n = names.length;
    while (++i < n)
      list.remove(names[i]);
  }
  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }
  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }
  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }
  function classed_default(name, value) {
    var names = classArray(name + "");
    if (arguments.length < 2) {
      var list = classList(this.node()), i = -1, n = names.length;
      while (++i < n)
        if (!list.contains(names[i]))
          return false;
      return true;
    }
    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/text.js
  function textRemove() {
    this.textContent = "";
  }
  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    };
  }
  function text_default(value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/html.js
  function htmlRemove() {
    this.innerHTML = "";
  }
  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }
  function htmlFunction(value) {
    return function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    };
  }
  function html_default(value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/raise.js
  function raise() {
    if (this.nextSibling)
      this.parentNode.appendChild(this);
  }
  function raise_default() {
    return this.each(raise);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/lower.js
  function lower() {
    if (this.previousSibling)
      this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function lower_default() {
    return this.each(lower);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/append.js
  function append_default(name) {
    var create2 = typeof name === "function" ? name : creator_default(name);
    return this.select(function() {
      return this.appendChild(create2.apply(this, arguments));
    });
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/insert.js
  function constantNull() {
    return null;
  }
  function insert_default(name, before) {
    var create2 = typeof name === "function" ? name : creator_default(name), select = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
    return this.select(function() {
      return this.insertBefore(create2.apply(this, arguments), select.apply(this, arguments) || null);
    });
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/remove.js
  function remove() {
    var parent = this.parentNode;
    if (parent)
      parent.removeChild(this);
  }
  function remove_default() {
    return this.each(remove);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/clone.js
  function selection_cloneShallow() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function selection_cloneDeep() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function clone_default(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/datum.js
  function datum_default(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/on.js
  function contextListener(listener) {
    return function(event) {
      listener.call(this, event, this.__data__);
    };
  }
  function parseTypenames(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0)
        name = t.slice(i + 1), t = t.slice(0, i);
      return { type: t, name };
    });
  }
  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on)
        return;
      for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
        if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.options);
        } else {
          on[++i] = o;
        }
      }
      if (++i)
        on.length = i;
      else
        delete this.__on;
    };
  }
  function onAdd(typename, value, options) {
    return function() {
      var on = this.__on, o, listener = contextListener(value);
      if (on)
        for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
      this.addEventListener(typename.type, listener, options);
      o = { type: typename.type, name: typename.name, value, listener, options };
      if (!on)
        this.__on = [o];
      else
        on.push(o);
    };
  }
  function on_default(typename, value, options) {
    var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;
    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on)
        for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
      return;
    }
    on = value ? onAdd : onRemove;
    for (i = 0; i < n; ++i)
      this.each(on(typenames[i], value, options));
    return this;
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/dispatch.js
  function dispatchEvent(node, type, params) {
    var window2 = window_default(node), event = window2.CustomEvent;
    if (typeof event === "function") {
      event = new event(type, params);
    } else {
      event = window2.document.createEvent("Event");
      if (params)
        event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
      else
        event.initEvent(type, false, false);
    }
    node.dispatchEvent(event);
  }
  function dispatchConstant(type, params) {
    return function() {
      return dispatchEvent(this, type, params);
    };
  }
  function dispatchFunction(type, params) {
    return function() {
      return dispatchEvent(this, type, params.apply(this, arguments));
    };
  }
  function dispatch_default(type, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/iterator.js
  function* iterator_default() {
    for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
        if (node = group[i])
          yield node;
      }
    }
  }

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/selection/index.js
  var root = [null];
  function Selection(groups, parents) {
    this._groups = groups;
    this._parents = parents;
  }
  function selection() {
    return new Selection([[document.documentElement]], root);
  }
  function selection_selection() {
    return this;
  }
  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: select_default,
    selectAll: selectAll_default,
    selectChild: selectChild_default,
    selectChildren: selectChildren_default,
    filter: filter_default,
    data: data_default,
    enter: enter_default,
    exit: exit_default,
    join: join_default,
    merge: merge_default,
    selection: selection_selection,
    order: order_default,
    sort: sort_default,
    call: call_default,
    nodes: nodes_default,
    node: node_default,
    size: size_default,
    empty: empty_default,
    each: each_default,
    attr: attr_default,
    style: style_default,
    property: property_default,
    classed: classed_default,
    text: text_default,
    html: html_default,
    raise: raise_default,
    lower: lower_default,
    append: append_default,
    insert: insert_default,
    remove: remove_default,
    clone: clone_default,
    datum: datum_default,
    on: on_default,
    dispatch: dispatch_default,
    [Symbol.iterator]: iterator_default
  };
  var selection_default = selection;

  // node_modules/.pnpm/d3-selection@3.0.0/node_modules/d3-selection/src/select.js
  function select_default2(selector) {
    return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
  }

  // node_modules/.pnpm/d3-dispatch@3.0.1/node_modules/d3-dispatch/src/dispatch.js
  var noop = { value: () => {
  } };
  function dispatch() {
    for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
      if (!(t = arguments[i] + "") || t in _ || /[\s.]/.test(t))
        throw new Error("illegal type: " + t);
      _[t] = [];
    }
    return new Dispatch(_);
  }
  function Dispatch(_) {
    this._ = _;
  }
  function parseTypenames2(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name = "", i = t.indexOf(".");
      if (i >= 0)
        name = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types.hasOwnProperty(t))
        throw new Error("unknown type: " + t);
      return { type: t, name };
    });
  }
  Dispatch.prototype = dispatch.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _ = this._, T = parseTypenames2(typename + "", _), t, i = -1, n = T.length;
      if (arguments.length < 2) {
        while (++i < n)
          if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
            return t;
        return;
      }
      if (callback != null && typeof callback !== "function")
        throw new Error("invalid callback: " + callback);
      while (++i < n) {
        if (t = (typename = T[i]).type)
          _[t] = set(_[t], typename.name, callback);
        else if (callback == null)
          for (t in _)
            _[t] = set(_[t], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy = {}, _ = this._;
      for (var t in _)
        copy[t] = _[t].slice();
      return new Dispatch(copy);
    },
    call: function(type, that) {
      if ((n = arguments.length - 2) > 0)
        for (var args = new Array(n), i = 0, n, t; i < n; ++i)
          args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type))
        throw new Error("unknown type: " + type);
      for (t = this._[type], i = 0, n = t.length; i < n; ++i)
        t[i].value.apply(that, args);
    },
    apply: function(type, that, args) {
      if (!this._.hasOwnProperty(type))
        throw new Error("unknown type: " + type);
      for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
        t[i].value.apply(that, args);
    }
  };
  function get(type, name) {
    for (var i = 0, n = type.length, c; i < n; ++i) {
      if ((c = type[i]).name === name) {
        return c.value;
      }
    }
  }
  function set(type, name, callback) {
    for (var i = 0, n = type.length; i < n; ++i) {
      if (type[i].name === name) {
        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null)
      type.push({ name, value: callback });
    return type;
  }
  var dispatch_default2 = dispatch;

  // node_modules/.pnpm/d3-timer@3.0.1/node_modules/d3-timer/src/timer.js
  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function")
        throw new TypeError("callback is not a function");
      time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail)
          taskTail._next = this;
        else
          taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    var t = new Timer();
    t.restart(callback, delay, time);
    return t;
  }
  function timerFlush() {
    now();
    ++frame;
    var t = taskHead, e;
    while (t) {
      if ((e = clockNow - t._time) >= 0)
        t._call.call(void 0, e);
      t = t._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now2 = clock.now(), delay = now2 - clockLast;
    if (delay > pokeDelay)
      clockSkew -= delay, clockLast = now2;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time)
          time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame)
      return;
    if (timeout)
      timeout = clearTimeout(timeout);
    var delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity)
        timeout = setTimeout(wake, time - clock.now() - clockSkew);
      if (interval)
        interval = clearInterval(interval);
    } else {
      if (!interval)
        clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  // node_modules/.pnpm/d3-timer@3.0.1/node_modules/d3-timer/src/timeout.js
  function timeout_default(callback, delay, time) {
    var t = new Timer();
    delay = delay == null ? 0 : +delay;
    t.restart((elapsed) => {
      t.stop();
      callback(elapsed + delay);
    }, delay, time);
    return t;
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/schedule.js
  var emptyOn = dispatch_default2("start", "end", "cancel", "interrupt");
  var emptyTween = [];
  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;
  function schedule_default(node, name, id2, index, group, timing) {
    var schedules = node.__transition;
    if (!schedules)
      node.__transition = {};
    else if (id2 in schedules)
      return;
    create(node, id2, {
      name,
      index,
      // For context during callback.
      group,
      // For context during callback.
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }
  function init(node, id2) {
    var schedule = get2(node, id2);
    if (schedule.state > CREATED)
      throw new Error("too late; already scheduled");
    return schedule;
  }
  function set2(node, id2) {
    var schedule = get2(node, id2);
    if (schedule.state > STARTED)
      throw new Error("too late; already running");
    return schedule;
  }
  function get2(node, id2) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id2]))
      throw new Error("transition not found");
    return schedule;
  }
  function create(node, id2, self) {
    var schedules = node.__transition, tween;
    schedules[id2] = self;
    self.timer = timer(schedule, 0, self.time);
    function schedule(elapsed) {
      self.state = SCHEDULED;
      self.timer.restart(start2, self.delay, self.time);
      if (self.delay <= elapsed)
        start2(elapsed - self.delay);
    }
    function start2(elapsed) {
      var i, j, n, o;
      if (self.state !== SCHEDULED)
        return stop();
      for (i in schedules) {
        o = schedules[i];
        if (o.name !== self.name)
          continue;
        if (o.state === STARTED)
          return timeout_default(start2);
        if (o.state === RUNNING) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("interrupt", node, node.__data__, o.index, o.group);
          delete schedules[i];
        } else if (+i < id2) {
          o.state = ENDED;
          o.timer.stop();
          o.on.call("cancel", node, node.__data__, o.index, o.group);
          delete schedules[i];
        }
      }
      timeout_default(function() {
        if (self.state === STARTED) {
          self.state = RUNNING;
          self.timer.restart(tick, self.delay, self.time);
          tick(elapsed);
        }
      });
      self.state = STARTING;
      self.on.call("start", node, node.__data__, self.index, self.group);
      if (self.state !== STARTING)
        return;
      self.state = STARTED;
      tween = new Array(n = self.tween.length);
      for (i = 0, j = -1; i < n; ++i) {
        if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
          tween[++j] = o;
        }
      }
      tween.length = j + 1;
    }
    function tick(elapsed) {
      var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
      while (++i < n) {
        tween[i].call(node, t);
      }
      if (self.state === ENDING) {
        self.on.call("end", node, node.__data__, self.index, self.group);
        stop();
      }
    }
    function stop() {
      self.state = ENDED;
      self.timer.stop();
      delete schedules[id2];
      for (var i in schedules)
        return;
      delete node.__transition;
    }
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/interrupt.js
  function interrupt_default(node, name) {
    var schedules = node.__transition, schedule, active, empty2 = true, i;
    if (!schedules)
      return;
    name = name == null ? null : name + "";
    for (i in schedules) {
      if ((schedule = schedules[i]).name !== name) {
        empty2 = false;
        continue;
      }
      active = schedule.state > STARTING && schedule.state < ENDING;
      schedule.state = ENDED;
      schedule.timer.stop();
      schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
      delete schedules[i];
    }
    if (empty2)
      delete node.__transition;
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/selection/interrupt.js
  function interrupt_default2(name) {
    return this.each(function() {
      interrupt_default(this, name);
    });
  }

  // node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition)
      prototype[key] = definition[key];
    return prototype;
  }

  // node_modules/.pnpm/d3-color@3.1.0/node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
  var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
  var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
  var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
  var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
  var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format3) {
    var m, l;
    format3 = (format3 + "").trim().toLowerCase();
    return (m = reHex.exec(format3)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format3)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format3)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format3)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format3)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format3)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format3)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba(r, g, b, a) {
    if (a <= 0)
      r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color))
      o = color(o);
    if (!o)
      return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h3, s, l, a) {
    if (a <= 0)
      h3 = s = l = NaN;
    else if (l <= 0 || l >= 1)
      h3 = s = NaN;
    else if (s <= 0)
      h3 = NaN;
    return new Hsl(h3, s, l, a);
  }
  function hslConvert(o) {
    if (o instanceof Hsl)
      return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color))
      o = color(o);
    if (!o)
      return new Hsl();
    if (o instanceof Hsl)
      return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h3 = NaN, s = max2 - min2, l = (max2 + min2) / 2;
    if (s) {
      if (r === max2)
        h3 = (g - b) / s + (g < b) * 6;
      else if (g === max2)
        h3 = (b - r) / s + 2;
      else
        h3 = (r - g) / s + 4;
      s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
      h3 *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h3;
    }
    return new Hsl(h3, s, l, o.opacity);
  }
  function hsl(h3, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h3) : new Hsl(h3, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl(h3, s, l, opacity) {
    this.h = +h3;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h3 = this.h % 360 + (this.h < 0) * 360, s = isNaN(h3) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h3 >= 240 ? h3 - 240 : h3 + 120, m1, m2),
        hsl2rgb(h3, m1, m2),
        hsl2rgb(h3 < 120 ? h3 + 240 : h3 - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h3, m1, m2) {
    return (h3 < 60 ? m1 + (m2 - m1) * h3 / 60 : h3 < 180 ? m2 : h3 < 240 ? m1 + (m2 - m1) * (240 - h3) / 60 : m1) * 255;
  }

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/basis.js
  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  function basis_default(values) {
    var n = values.length - 1;
    return function(t) {
      var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values) {
    var n = values.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/constant.js
  var constant_default2 = (x) => () => x;

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/color.js
  function linear(a, d) {
    return function(t) {
      return a + t * d;
    };
  }
  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }
  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant_default2(isNaN(a) ? b : a);
    };
  }
  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant_default2(isNaN(a) ? b : a);
  }

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y) {
    var color2 = gamma(y);
    function rgb2(start2, end) {
      var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.r = r(t);
        start2.g = g(t);
        start2.b = b(t);
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
      for (i = 0; i < n; ++i) {
        color2 = rgb(colors[i]);
        r[i] = color2.r || 0;
        g[i] = color2.g || 0;
        b[i] = color2.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color2.opacity = 1;
      return function(t) {
        color2.r = r(t);
        color2.g = g(t);
        color2.b = b(t);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/numberArray.js
  function numberArray_default(a, b) {
    if (!b)
      b = [];
    var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
    return function(t) {
      for (i = 0; i < n; ++i)
        c[i] = a[i] * (1 - t) + b[i] * t;
      return c;
    };
  }
  function isNumberArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/array.js
  function genericArray(a, b) {
    var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
    for (i = 0; i < na; ++i)
      x[i] = value_default(a[i], b[i]);
    for (; i < nb; ++i)
      c[i] = b[i];
    return function(t) {
      for (i = 0; i < na; ++i)
        c[i] = x[i](t);
      return c;
    };
  }

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/date.js
  function date_default(a, b) {
    var d = /* @__PURE__ */ new Date();
    return a = +a, b = +b, function(t) {
      return d.setTime(a * (1 - t) + b * t), d;
    };
  }

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/number.js
  function number_default(a, b) {
    return a = +a, b = +b, function(t) {
      return a * (1 - t) + b * t;
    };
  }

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/object.js
  function object_default(a, b) {
    var i = {}, c = {}, k;
    if (a === null || typeof a !== "object")
      a = {};
    if (b === null || typeof b !== "object")
      b = {};
    for (k in b) {
      if (k in a) {
        i[k] = value_default(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i)
        c[k] = i[k](t);
      return c;
    };
  }

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }
  function string_default(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i])
          s[i] += bs;
        else
          s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i])
          s[i] += bm;
        else
          s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({ i, x: number_default(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
      for (var i2 = 0, o; i2 < b; ++i2)
        s[(o = q[i2]).i] = o.x(t);
      return s.join("");
    });
  }

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/value.js
  function value_default(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant_default2(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
  }

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/decompose.js
  var degrees = 180 / Math.PI;
  var identity = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function decompose_default(a, b, c, d, e, f) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a * a + b * b))
      a /= scaleX, b /= scaleX;
    if (skewX = a * c + b * d)
      c -= a * skewX, d -= b * skewX;
    if (scaleY = Math.sqrt(c * c + d * d))
      c /= scaleY, d /= scaleY, skewX /= scaleY;
    if (a * d < b * c)
      a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e,
      translateY: f,
      rotate: Math.atan2(b, a) * degrees,
      skewX: Math.atan(skewX) * degrees,
      scaleX,
      scaleY
    };
  }

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/parse.js
  var svgNode;
  function parseCss(value) {
    const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
    return m.isIdentity ? identity : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
  }
  function parseSvg(value) {
    if (value == null)
      return identity;
    if (!svgNode)
      svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate()))
      return identity;
    value = value.matrix;
    return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
  }

  // node_modules/.pnpm/d3-interpolate@3.0.1/node_modules/d3-interpolate/src/transform/index.js
  function interpolateTransform(parse, pxComma, pxParen, degParen) {
    function pop(s) {
      return s.length ? s.pop() + " " : "";
    }
    function translate(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push("translate(", null, pxComma, null, pxParen);
        q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
      } else if (xb || yb) {
        s.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }
    function rotate(a, b, s, q) {
      if (a !== b) {
        if (a - b > 180)
          b += 360;
        else if (b - a > 180)
          a += 360;
        q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
      } else if (b) {
        s.push(pop(s) + "rotate(" + b + degParen);
      }
    }
    function skewX(a, b, s, q) {
      if (a !== b) {
        q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
      } else if (b) {
        s.push(pop(s) + "skewX(" + b + degParen);
      }
    }
    function scale(xa, ya, xb, yb, s, q) {
      if (xa !== xb || ya !== yb) {
        var i = s.push(pop(s) + "scale(", null, ",", null, ")");
        q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
      } else if (xb !== 1 || yb !== 1) {
        s.push(pop(s) + "scale(" + xb + "," + yb + ")");
      }
    }
    return function(a, b) {
      var s = [], q = [];
      a = parse(a), b = parse(b);
      translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
      rotate(a.rotate, b.rotate, s, q);
      skewX(a.skewX, b.skewX, s, q);
      scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
      a = b = null;
      return function(t) {
        var i = -1, n = q.length, o;
        while (++i < n)
          s[(o = q[i]).i] = o.x(t);
        return s.join("");
      };
    };
  }
  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/tween.js
  function tweenRemove(id2, name) {
    var tween0, tween1;
    return function() {
      var schedule = set2(this, id2), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name) {
            tween1 = tween1.slice();
            tween1.splice(i, 1);
            break;
          }
        }
      }
      schedule.tween = tween1;
    };
  }
  function tweenFunction(id2, name, value) {
    var tween0, tween1;
    if (typeof value !== "function")
      throw new Error();
    return function() {
      var schedule = set2(this, id2), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t = { name, value }, i = 0, n = tween1.length; i < n; ++i) {
          if (tween1[i].name === name) {
            tween1[i] = t;
            break;
          }
        }
        if (i === n)
          tween1.push(t);
      }
      schedule.tween = tween1;
    };
  }
  function tween_default(name, value) {
    var id2 = this._id;
    name += "";
    if (arguments.length < 2) {
      var tween = get2(this.node(), id2).tween;
      for (var i = 0, n = tween.length, t; i < n; ++i) {
        if ((t = tween[i]).name === name) {
          return t.value;
        }
      }
      return null;
    }
    return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
  }
  function tweenValue(transition2, name, value) {
    var id2 = transition2._id;
    transition2.each(function() {
      var schedule = set2(this, id2);
      (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
    });
    return function(node) {
      return get2(node, id2).value[name];
    };
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/interpolate.js
  function interpolate_default(a, b) {
    var c;
    return (typeof b === "number" ? number_default : b instanceof color ? rgb_default : (c = color(b)) ? (b = c, rgb_default) : string_default)(a, b);
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/attr.js
  function attrRemove2(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS2(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant2(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttribute(name);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrConstantNS2(fullname, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrFunction2(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null)
        return void this.removeAttribute(name);
      string0 = this.getAttribute(name);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attrFunctionNS2(fullname, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null)
        return void this.removeAttributeNS(fullname.space, fullname.local);
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attr_default2(name, value) {
    var fullname = namespace_default(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
    return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i, value));
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/attrTween.js
  function attrInterpolate(name, i) {
    return function(t) {
      this.setAttribute(name, i.call(this, t));
    };
  }
  function attrInterpolateNS(fullname, i) {
    return function(t) {
      this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
    };
  }
  function attrTweenNS(fullname, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t0 = (i0 = i) && attrInterpolateNS(fullname, i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween(name, value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t0 = (i0 = i) && attrInterpolate(name, i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function attrTween_default(name, value) {
    var key = "attr." + name;
    if (arguments.length < 2)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    var fullname = namespace_default(name);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/delay.js
  function delayFunction(id2, value) {
    return function() {
      init(this, id2).delay = +value.apply(this, arguments);
    };
  }
  function delayConstant(id2, value) {
    return value = +value, function() {
      init(this, id2).delay = value;
    };
  }
  function delay_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/duration.js
  function durationFunction(id2, value) {
    return function() {
      set2(this, id2).duration = +value.apply(this, arguments);
    };
  }
  function durationConstant(id2, value) {
    return value = +value, function() {
      set2(this, id2).duration = value;
    };
  }
  function duration_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/ease.js
  function easeConstant(id2, value) {
    if (typeof value !== "function")
      throw new Error();
    return function() {
      set2(this, id2).ease = value;
    };
  }
  function ease_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/easeVarying.js
  function easeVarying(id2, value) {
    return function() {
      var v = value.apply(this, arguments);
      if (typeof v !== "function")
        throw new Error();
      set2(this, id2).ease = v;
    };
  }
  function easeVarying_default(value) {
    if (typeof value !== "function")
      throw new Error();
    return this.each(easeVarying(this._id, value));
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/filter.js
  function filter_default2(match) {
    if (typeof match !== "function")
      match = matcher_default(match);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
        if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
          subgroup.push(node);
        }
      }
    }
    return new Transition(subgroups, this._parents, this._name, this._id);
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/merge.js
  function merge_default2(transition2) {
    if (transition2._id !== this._id)
      throw new Error();
    for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
      for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
        if (node = group0[i] || group1[i]) {
          merge[i] = node;
        }
      }
    }
    for (; j < m0; ++j) {
      merges[j] = groups0[j];
    }
    return new Transition(merges, this._parents, this._name, this._id);
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/on.js
  function start(name) {
    return (name + "").trim().split(/^|\s+/).every(function(t) {
      var i = t.indexOf(".");
      if (i >= 0)
        t = t.slice(0, i);
      return !t || t === "start";
    });
  }
  function onFunction(id2, name, listener) {
    var on0, on1, sit = start(name) ? init : set2;
    return function() {
      var schedule = sit(this, id2), on = schedule.on;
      if (on !== on0)
        (on1 = (on0 = on).copy()).on(name, listener);
      schedule.on = on1;
    };
  }
  function on_default2(name, listener) {
    var id2 = this._id;
    return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/remove.js
  function removeFunction(id2) {
    return function() {
      var parent = this.parentNode;
      for (var i in this.__transition)
        if (+i !== id2)
          return;
      if (parent)
        parent.removeChild(this);
    };
  }
  function remove_default2() {
    return this.on("end.remove", removeFunction(this._id));
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/select.js
  function select_default3(select) {
    var name = this._name, id2 = this._id;
    if (typeof select !== "function")
      select = selector_default(select);
    for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
        if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
          if ("__data__" in node)
            subnode.__data__ = node.__data__;
          subgroup[i] = subnode;
          schedule_default(subgroup[i], name, id2, i, subgroup, get2(node, id2));
        }
      }
    }
    return new Transition(subgroups, this._parents, name, id2);
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/selectAll.js
  function selectAll_default2(select) {
    var name = this._name, id2 = this._id;
    if (typeof select !== "function")
      select = selectorAll_default(select);
    for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          for (var children2 = select.call(node, node.__data__, i, group), child, inherit2 = get2(node, id2), k = 0, l = children2.length; k < l; ++k) {
            if (child = children2[k]) {
              schedule_default(child, name, id2, k, children2, inherit2);
            }
          }
          subgroups.push(children2);
          parents.push(node);
        }
      }
    }
    return new Transition(subgroups, parents, name, id2);
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/selection.js
  var Selection2 = selection_default.prototype.constructor;
  function selection_default2() {
    return new Selection2(this._groups, this._parents);
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/style.js
  function styleNull(name, interpolate) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
    };
  }
  function styleRemove2(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant2(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = styleValue(this, name);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function styleFunction2(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
      if (value1 == null)
        string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function styleMaybeRemove(id2, name) {
    var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
    return function() {
      var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
      if (on !== on0 || listener0 !== listener)
        (on1 = (on0 = on).copy()).on(event, listener0 = listener);
      schedule.on = on1;
    };
  }
  function style_default2(name, value, priority) {
    var i = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
    return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i, value), priority).on("end.style." + name, null);
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/styleTween.js
  function styleInterpolate(name, i, priority) {
    return function(t) {
      this.style.setProperty(name, i.call(this, t), priority);
    };
  }
  function styleTween(name, value, priority) {
    var t, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t = (i0 = i) && styleInterpolate(name, i, priority);
      return t;
    }
    tween._value = value;
    return tween;
  }
  function styleTween_default(name, value, priority) {
    var key = "style." + (name += "");
    if (arguments.length < 2)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/text.js
  function textConstant2(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction2(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }
  function text_default2(value) {
    return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/textTween.js
  function textInterpolate(i) {
    return function(t) {
      this.textContent = i.call(this, t);
    };
  }
  function textTween(value) {
    var t0, i0;
    function tween() {
      var i = value.apply(this, arguments);
      if (i !== i0)
        t0 = (i0 = i) && textInterpolate(i);
      return t0;
    }
    tween._value = value;
    return tween;
  }
  function textTween_default(value) {
    var key = "text";
    if (arguments.length < 1)
      return (key = this.tween(key)) && key._value;
    if (value == null)
      return this.tween(key, null);
    if (typeof value !== "function")
      throw new Error();
    return this.tween(key, textTween(value));
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/transition.js
  function transition_default() {
    var name = this._name, id0 = this._id, id1 = newId();
    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          var inherit2 = get2(node, id0);
          schedule_default(node, name, id1, i, group, {
            time: inherit2.time + inherit2.delay + inherit2.duration,
            delay: 0,
            duration: inherit2.duration,
            ease: inherit2.ease
          });
        }
      }
    }
    return new Transition(groups, this._parents, name, id1);
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/end.js
  function end_default() {
    var on0, on1, that = this, id2 = that._id, size = that.size();
    return new Promise(function(resolve, reject) {
      var cancel = { value: reject }, end = { value: function() {
        if (--size === 0)
          resolve();
      } };
      that.each(function() {
        var schedule = set2(this, id2), on = schedule.on;
        if (on !== on0) {
          on1 = (on0 = on).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end);
        }
        schedule.on = on1;
      });
      if (size === 0)
        resolve();
    });
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/transition/index.js
  var id = 0;
  function Transition(groups, parents, name, id2) {
    this._groups = groups;
    this._parents = parents;
    this._name = name;
    this._id = id2;
  }
  function transition(name) {
    return selection_default().transition(name);
  }
  function newId() {
    return ++id;
  }
  var selection_prototype = selection_default.prototype;
  Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: select_default3,
    selectAll: selectAll_default2,
    selectChild: selection_prototype.selectChild,
    selectChildren: selection_prototype.selectChildren,
    filter: filter_default2,
    merge: merge_default2,
    selection: selection_default2,
    transition: transition_default,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: on_default2,
    attr: attr_default2,
    attrTween: attrTween_default,
    style: style_default2,
    styleTween: styleTween_default,
    text: text_default2,
    textTween: textTween_default,
    remove: remove_default2,
    tween: tween_default,
    delay: delay_default,
    duration: duration_default,
    ease: ease_default,
    easeVarying: easeVarying_default,
    end: end_default,
    [Symbol.iterator]: selection_prototype[Symbol.iterator]
  };

  // node_modules/.pnpm/d3-ease@3.0.1/node_modules/d3-ease/src/cubic.js
  function cubicInOut(t) {
    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/selection/transition.js
  var defaultTiming = {
    time: null,
    // Set on use.
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };
  function inherit(node, id2) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id2])) {
      if (!(node = node.parentNode)) {
        throw new Error(`transition ${id2} not found`);
      }
    }
    return timing;
  }
  function transition_default2(name) {
    var id2, timing;
    if (name instanceof Transition) {
      id2 = name._id, name = name._name;
    } else {
      id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
    }
    for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
      for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
        if (node = group[i]) {
          schedule_default(node, name, id2, i, group, timing || inherit(node, id2));
        }
      }
    }
    return new Transition(groups, this._parents, name, id2);
  }

  // node_modules/.pnpm/d3-transition@3.0.1_d3-selection@3.0.0/node_modules/d3-transition/src/selection/index.js
  selection_default.prototype.interrupt = interrupt_default2;
  selection_default.prototype.transition = transition_default2;

  // node_modules/.pnpm/d3-dsv@3.0.1/node_modules/d3-dsv/src/dsv.js
  var EOL = {};
  var EOF = {};
  var QUOTE = 34;
  var NEWLINE = 10;
  var RETURN = 13;
  function objectConverter(columns) {
    return new Function("d", "return {" + columns.map(function(name, i) {
      return JSON.stringify(name) + ": d[" + i + '] || ""';
    }).join(",") + "}");
  }
  function customConverter(columns, f) {
    var object = objectConverter(columns);
    return function(row, i) {
      return f(object(row), i, columns);
    };
  }
  function inferColumns(rows) {
    var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
    rows.forEach(function(row) {
      for (var column in row) {
        if (!(column in columnSet)) {
          columns.push(columnSet[column] = column);
        }
      }
    });
    return columns;
  }
  function pad(value, width) {
    var s = value + "", length = s.length;
    return length < width ? new Array(width - length + 1).join(0) + s : s;
  }
  function formatYear(year) {
    return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
  }
  function formatDate(date) {
    var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
    return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z" : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
  }
  function dsv_default(delimiter) {
    var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
    function parse(text, f) {
      var convert, columns, rows = parseRows(text, function(row, i) {
        if (convert)
          return convert(row, i - 1);
        columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
      });
      rows.columns = columns || [];
      return rows;
    }
    function parseRows(text, f) {
      var rows = [], N = text.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
      if (text.charCodeAt(N - 1) === NEWLINE)
        --N;
      if (text.charCodeAt(N - 1) === RETURN)
        --N;
      function token() {
        if (eof)
          return EOF;
        if (eol)
          return eol = false, EOL;
        var i, j = I, c;
        if (text.charCodeAt(j) === QUOTE) {
          while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE)
            ;
          if ((i = I) >= N)
            eof = true;
          else if ((c = text.charCodeAt(I++)) === NEWLINE)
            eol = true;
          else if (c === RETURN) {
            eol = true;
            if (text.charCodeAt(I) === NEWLINE)
              ++I;
          }
          return text.slice(j + 1, i - 1).replace(/""/g, '"');
        }
        while (I < N) {
          if ((c = text.charCodeAt(i = I++)) === NEWLINE)
            eol = true;
          else if (c === RETURN) {
            eol = true;
            if (text.charCodeAt(I) === NEWLINE)
              ++I;
          } else if (c !== DELIMITER)
            continue;
          return text.slice(j, i);
        }
        return eof = true, text.slice(j, N);
      }
      while ((t = token()) !== EOF) {
        var row = [];
        while (t !== EOL && t !== EOF)
          row.push(t), t = token();
        if (f && (row = f(row, n++)) == null)
          continue;
        rows.push(row);
      }
      return rows;
    }
    function preformatBody(rows, columns) {
      return rows.map(function(row) {
        return columns.map(function(column) {
          return formatValue(row[column]);
        }).join(delimiter);
      });
    }
    function format3(rows, columns) {
      if (columns == null)
        columns = inferColumns(rows);
      return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
    }
    function formatBody(rows, columns) {
      if (columns == null)
        columns = inferColumns(rows);
      return preformatBody(rows, columns).join("\n");
    }
    function formatRows(rows) {
      return rows.map(formatRow).join("\n");
    }
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(value) {
      return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
    }
    return {
      parse,
      parseRows,
      format: format3,
      formatBody,
      formatRows,
      formatRow,
      formatValue
    };
  }

  // highcharts_theme.js
  var import_highcharts = __toESM(require_highcharts_src());
  var import_highcharts_more = __toESM(require_highcharts_more_src());
  (0, import_highcharts_more.default)(import_highcharts.default);
  window.Highcharts = import_highcharts.default;
  import_highcharts.default.theme = {
    colors: [
      "#B34C3C",
      "#2b908f",
      "#90ee7e",
      "#f45b5b",
      "#7798BF",
      "#aaeeee",
      "#ff0066",
      "#eeaaee",
      "#55BF3B",
      "#DF5353",
      "#7798BF",
      "#aaeeee"
    ],
    chart: {
      backgroundColor: "#1d1f21",
      plotBorderColor: "#606063"
    },
    title: {
      style: {
        color: "#c5c8c6",
        fontSize: "20px"
      }
    },
    xAxis: {
      gridLineColor: "#707073",
      labels: {
        style: {
          color: "#c5c8c6"
        }
      },
      lineColor: "#707073",
      minorGridLineColor: "#505053",
      tickColor: "#707073",
      title: {
        style: {
          color: "#c5c8c6"
        }
      }
    },
    yAxis: {
      gridLineColor: "#707073",
      labels: {
        style: {
          color: "#c5c8c6"
        }
      },
      lineColor: "#707073",
      minorGridLineColor: "#505053",
      tickColor: "#707073",
      tickWidth: 1,
      title: {
        style: {
          color: "#A0A0A3"
        }
      }
    },
    tooltip: {
      backgroundColor: "rgba(0, 0, 0, 0.85)",
      style: {
        color: "#c5c8c6"
      },
      pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y:,.2f}</b><br/>'
    },
    plotOptions: {
      series: {
        dataLabels: {
          color: "#B0B0B3"
        },
        marker: {
          lineColor: "#333"
        }
      },
      boxplot: {
        fillColor: "#505053"
      },
      candlestick: {
        lineColor: "white"
      },
      errorbar: {
        color: "white"
      }
    },
    legend: {
      itemStyle: {
        color: "#E0E0E3"
      },
      itemHoverStyle: {
        color: "#FFF"
      },
      itemHiddenStyle: {
        color: "#606063"
      }
    },
    credits: {
      style: {
        color: "#666"
      }
    },
    labels: {
      style: {
        color: "#707073"
      }
    },
    drilldown: {
      activeAxisLabelStyle: {
        color: "#F0F0F3"
      },
      activeDataLabelStyle: {
        color: "#F0F0F3"
      }
    },
    navigation: {
      buttonOptions: {
        symbolStroke: "#DDDDDD",
        theme: {
          fill: "#505053"
        }
      }
    },
    // scroll charts
    rangeSelector: {
      buttonTheme: {
        fill: "#505053",
        stroke: "#000000",
        style: {
          color: "#CCC"
        },
        states: {
          hover: {
            fill: "#707073",
            stroke: "#000000",
            style: {
              color: "white"
            }
          },
          select: {
            fill: "#000003",
            stroke: "#000000",
            style: {
              color: "white"
            }
          }
        }
      },
      inputBoxBorderColor: "#505053",
      inputStyle: {
        backgroundColor: "#333",
        color: "silver"
      },
      labelStyle: {
        color: "silver"
      }
    },
    navigator: {
      handles: {
        backgroundColor: "#666",
        borderColor: "#AAA"
      },
      outlineColor: "#CCC",
      maskFill: "rgba(255,255,255,0.1)",
      series: {
        color: "#7798BF",
        lineColor: "#A6C7ED"
      },
      xAxis: {
        gridLineColor: "#505053"
      }
    },
    scrollbar: {
      barBackgroundColor: "#808083",
      barBorderColor: "#808083",
      buttonArrowColor: "#CCC",
      buttonBackgroundColor: "#606063",
      buttonBorderColor: "#606063",
      rifleColor: "#FFF",
      trackBackgroundColor: "#404043",
      trackBorderColor: "#404043"
    },
    // special colors for some of the
    legendBackgroundColor: "rgba(0, 0, 0, 0.5)",
    background2: "#505053",
    dataLabelsColor: "#B0B0B3",
    textColor: "#C0C0C0",
    contrastTextColor: "#F0F0F3",
    maskColor: "rgba(255,255,255,0.3)"
  };
  import_highcharts.default.setOptions(import_highcharts.default.theme);

  // node_modules/.pnpm/crossfilter2@1.5.4/node_modules/crossfilter2/src/array.js
  var array8 = arrayUntyped;
  var array16 = arrayUntyped;
  var array32 = arrayUntyped;
  var arrayLengthen = arrayLengthenUntyped;
  var arrayWiden = arrayWidenUntyped;
  if (typeof Uint8Array !== "undefined") {
    array8 = function(n) {
      return new Uint8Array(n);
    };
    array16 = function(n) {
      return new Uint16Array(n);
    };
    array32 = function(n) {
      return new Uint32Array(n);
    };
    arrayLengthen = function(array2, length) {
      if (array2.length >= length)
        return array2;
      var copy = new array2.constructor(length);
      copy.set(array2);
      return copy;
    };
    arrayWiden = function(array2, width) {
      var copy;
      switch (width) {
        case 16:
          copy = array16(array2.length);
          break;
        case 32:
          copy = array32(array2.length);
          break;
        default:
          throw new Error("invalid array width!");
      }
      copy.set(array2);
      return copy;
    };
  }
  function arrayUntyped(n) {
    var array2 = new Array(n), i = -1;
    while (++i < n)
      array2[i] = 0;
    return array2;
  }
  function arrayLengthenUntyped(array2, length) {
    var n = array2.length;
    while (n < length)
      array2[n++] = 0;
    return array2;
  }
  function arrayWidenUntyped(array2, width) {
    if (width > 32)
      throw new Error("invalid array width!");
    return array2;
  }
  function bitarray(n) {
    this.length = n;
    this.subarrays = 1;
    this.width = 8;
    this.masks = {
      0: 0
    };
    this[0] = array8(n);
  }
  bitarray.prototype.lengthen = function(n) {
    var i, len;
    for (i = 0, len = this.subarrays; i < len; ++i) {
      this[i] = arrayLengthen(this[i], n);
    }
    this.length = n;
  };
  bitarray.prototype.add = function() {
    var m, w, one2, i, len;
    for (i = 0, len = this.subarrays; i < len; ++i) {
      m = this.masks[i];
      w = this.width - 32 * i;
      one2 = (~m & m + 1) >>> 0;
      if (w >= 32 && !one2) {
        continue;
      }
      if (w < 32 && one2 & 1 << w) {
        this[i] = arrayWiden(this[i], w <<= 1);
        this.width = 32 * i + w;
      }
      this.masks[i] |= one2;
      return {
        offset: i,
        one: one2
      };
    }
    this[this.subarrays] = array8(this.length);
    this.masks[this.subarrays] = 1;
    this.width += 8;
    return {
      offset: this.subarrays++,
      one: 1
    };
  };
  bitarray.prototype.copy = function(dest, src) {
    var i, len;
    for (i = 0, len = this.subarrays; i < len; ++i) {
      this[i][dest] = this[i][src];
    }
  };
  bitarray.prototype.truncate = function(n) {
    var i, len;
    for (i = 0, len = this.subarrays; i < len; ++i) {
      for (var j = this.length - 1; j >= n; j--) {
        this[i][j] = 0;
      }
    }
    this.length = n;
  };
  bitarray.prototype.zero = function(n) {
    var i, len;
    for (i = 0, len = this.subarrays; i < len; ++i) {
      if (this[i][n]) {
        return false;
      }
    }
    return true;
  };
  bitarray.prototype.zeroExcept = function(n, offset, zero2) {
    var i, len;
    for (i = 0, len = this.subarrays; i < len; ++i) {
      if (i === offset ? this[i][n] & zero2 : this[i][n]) {
        return false;
      }
    }
    return true;
  };
  bitarray.prototype.zeroExceptMask = function(n, mask) {
    var i, len;
    for (i = 0, len = this.subarrays; i < len; ++i) {
      if (this[i][n] & mask[i]) {
        return false;
      }
    }
    return true;
  };
  bitarray.prototype.only = function(n, offset, one2) {
    var i, len;
    for (i = 0, len = this.subarrays; i < len; ++i) {
      if (this[i][n] != (i === offset ? one2 : 0)) {
        return false;
      }
    }
    return true;
  };
  bitarray.prototype.onlyExcept = function(n, offset, zero2, onlyOffset, onlyOne) {
    var mask;
    var i, len;
    for (i = 0, len = this.subarrays; i < len; ++i) {
      mask = this[i][n];
      if (i === offset)
        mask = (mask & zero2) >>> 0;
      if (mask != (i === onlyOffset ? onlyOne : 0)) {
        return false;
      }
    }
    return true;
  };
  var array_default = {
    array8: arrayUntyped,
    array16: arrayUntyped,
    array32: arrayUntyped,
    arrayLengthen: arrayLengthenUntyped,
    arrayWiden: arrayWidenUntyped,
    bitarray
  };

  // node_modules/.pnpm/crossfilter2@1.5.4/node_modules/crossfilter2/src/filter.js
  var filterExact = (bisect3, value) => {
    return function(values) {
      var n = values.length;
      return [bisect3.left(values, value, 0, n), bisect3.right(values, value, 0, n)];
    };
  };
  var filterRange = (bisect3, range) => {
    var min2 = range[0], max2 = range[1];
    return function(values) {
      var n = values.length;
      return [bisect3.left(values, min2, 0, n), bisect3.left(values, max2, 0, n)];
    };
  };
  var filterAll = (values) => {
    return [0, values.length];
  };
  var filter_default3 = {
    filterExact,
    filterRange,
    filterAll
  };

  // node_modules/.pnpm/crossfilter2@1.5.4/node_modules/crossfilter2/src/identity.js
  var identity_default = (d) => {
    return d;
  };

  // node_modules/.pnpm/crossfilter2@1.5.4/node_modules/crossfilter2/src/null.js
  var null_default = () => {
    return null;
  };

  // node_modules/.pnpm/crossfilter2@1.5.4/node_modules/crossfilter2/src/zero.js
  var zero_default = () => {
    return 0;
  };

  // node_modules/.pnpm/crossfilter2@1.5.4/node_modules/crossfilter2/src/heap.js
  function heap_by(f) {
    function heap(a, lo, hi) {
      var n = hi - lo, i = (n >>> 1) + 1;
      while (--i > 0)
        sift(a, i, n, lo);
      return a;
    }
    function sort(a, lo, hi) {
      var n = hi - lo, t;
      while (--n > 0)
        t = a[lo], a[lo] = a[lo + n], a[lo + n] = t, sift(a, 1, n, lo);
      return a;
    }
    function sift(a, i, n, lo) {
      var d = a[--lo + i], x = f(d), child;
      while ((child = i << 1) <= n) {
        if (child < n && f(a[lo + child]) > f(a[lo + child + 1]))
          child++;
        if (x <= f(a[lo + child]))
          break;
        a[lo + i] = a[lo + child];
        i = child;
      }
      a[lo + i] = d;
    }
    heap.sort = sort;
    return heap;
  }
  var h = heap_by(identity_default);
  h.by = heap_by;
  var heap_default = h;

  // node_modules/.pnpm/crossfilter2@1.5.4/node_modules/crossfilter2/src/heapselect.js
  function heapselect_by(f) {
    var heap = heap_default.by(f);
    function heapselect(a, lo, hi, k) {
      var queue = new Array(k = Math.min(hi - lo, k)), min2, i, d;
      for (i = 0; i < k; ++i)
        queue[i] = a[lo++];
      heap(queue, 0, k);
      if (lo < hi) {
        min2 = f(queue[0]);
        do {
          if (f(d = a[lo]) > min2) {
            queue[0] = d;
            min2 = f(heap(queue, 0, k)[0]);
          }
        } while (++lo < hi);
      }
      return queue;
    }
    return heapselect;
  }
  var h2 = heapselect_by(identity_default);
  h2.by = heapselect_by;
  var heapselect_default = h2;

  // node_modules/.pnpm/crossfilter2@1.5.4/node_modules/crossfilter2/src/bisect.js
  function bisect_by(f) {
    function bisectLeft(a, x, lo, hi) {
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (f(a[mid]) < x)
          lo = mid + 1;
        else
          hi = mid;
      }
      return lo;
    }
    function bisectRight(a, x, lo, hi) {
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (x < f(a[mid]))
          hi = mid;
        else
          lo = mid + 1;
      }
      return lo;
    }
    bisectRight.right = bisectRight;
    bisectRight.left = bisectLeft;
    return bisectRight;
  }
  var bisect = bisect_by(identity_default);
  bisect.by = bisect_by;
  var bisect_default = bisect;

  // node_modules/.pnpm/crossfilter2@1.5.4/node_modules/crossfilter2/src/permute.js
  var permute_default = (array2, index, deep) => {
    for (var i = 0, n = index.length, copy = deep ? JSON.parse(JSON.stringify(array2)) : new Array(n); i < n; ++i) {
      copy[i] = array2[index[i]];
    }
    return copy;
  };

  // node_modules/.pnpm/crossfilter2@1.5.4/node_modules/crossfilter2/src/reduce.js
  var reduceIncrement = (p) => {
    return p + 1;
  };
  var reduceDecrement = (p) => {
    return p - 1;
  };
  var reduceAdd = (f) => {
    return function(p, v) {
      return p + +f(v);
    };
  };
  var reduceSubtract = (f) => {
    return function(p, v) {
      return p - f(v);
    };
  };
  var reduce_default = {
    reduceIncrement,
    reduceDecrement,
    reduceAdd,
    reduceSubtract
  };

  // node_modules/.pnpm/@ranfdev+deepobj@1.0.2/node_modules/@ranfdev/deepobj/dist/deepobj.m.js
  function deepobj_m_default(t, e, i, n, r) {
    for (r in n = (i = i.split(".")).splice(-1, 1), i)
      e = e[i[r]] = e[i[r]] || {};
    return t(e, n);
  }

  // node_modules/.pnpm/crossfilter2@1.5.4/node_modules/crossfilter2/src/result.js
  var get3 = (obj, prop) => {
    const value = obj[prop];
    return typeof value === "function" ? value.call(obj) : value;
  };
  var reg = /\[([\w\d]+)\]/g;
  var result_default = (obj, path) => {
    return deepobj_m_default(get3, obj, path.replace(reg, ".$1"));
  };

  // node_modules/.pnpm/crossfilter2@1.5.4/node_modules/crossfilter2/src/index.js
  var REMOVED_INDEX = -1;
  crossfilter.heap = heap_default;
  crossfilter.heapselect = heapselect_default;
  crossfilter.bisect = bisect_default;
  crossfilter.permute = permute_default;
  var src_default = crossfilter;
  function crossfilter() {
    var crossfilter2 = {
      add,
      remove: removeData,
      dimension,
      groupAll,
      size,
      all,
      allFiltered,
      onChange,
      isElementFiltered
    };
    var data = [], n = 0, filters, filterListeners = [], dataListeners = [], removeDataListeners = [], callbacks = [];
    filters = new array_default.bitarray(0);
    function add(newData) {
      var n0 = n, n1 = newData.length;
      if (n1) {
        data = data.concat(newData);
        filters.lengthen(n += n1);
        dataListeners.forEach(function(l) {
          l(newData, n0, n1);
        });
        triggerOnChange("dataAdded");
      }
      return crossfilter2;
    }
    function removeData(predicate) {
      var newIndex = new Array(n), removed = [], usePred = typeof predicate === "function", shouldRemove = function(i) {
        return usePred ? predicate(data[i], i) : filters.zero(i);
      };
      for (var index1 = 0, index2 = 0; index1 < n; ++index1) {
        if (shouldRemove(index1)) {
          removed.push(index1);
          newIndex[index1] = REMOVED_INDEX;
        } else {
          newIndex[index1] = index2++;
        }
      }
      filterListeners.forEach(function(l) {
        l(-1, -1, [], removed, true);
      });
      removeDataListeners.forEach(function(l) {
        l(newIndex);
      });
      for (var index3 = 0, index4 = 0; index3 < n; ++index3) {
        if (newIndex[index3] !== REMOVED_INDEX) {
          if (index3 !== index4)
            filters.copy(index4, index3), data[index4] = data[index3];
          ++index4;
        }
      }
      data.length = n = index4;
      filters.truncate(index4);
      triggerOnChange("dataRemoved");
    }
    function maskForDimensions(dimensions) {
      var n2, d, len, id2, mask = Array(filters.subarrays);
      for (n2 = 0; n2 < filters.subarrays; n2++) {
        mask[n2] = ~0;
      }
      for (d = 0, len = dimensions.length; d < len; d++) {
        id2 = dimensions[d].id();
        mask[id2 >> 7] &= ~(1 << (id2 & 63));
      }
      return mask;
    }
    function isElementFiltered(i, ignore_dimensions) {
      var mask = maskForDimensions(ignore_dimensions || []);
      return filters.zeroExceptMask(i, mask);
    }
    function dimension(value, iterable) {
      if (typeof value === "string") {
        var accessorPath = value;
        value = function(d) {
          return result_default(d, accessorPath);
        };
      }
      var dimension2 = {
        filter: filter2,
        filterExact: filterExact2,
        filterRange: filterRange2,
        filterFunction,
        filterAll: filterAll2,
        currentFilter,
        hasCurrentFilter,
        top,
        bottom,
        group,
        groupAll: groupAll2,
        dispose,
        remove: dispose,
        // for backwards-compatibility
        accessor: value,
        id: function() {
          return id2;
        }
      };
      var one2, zero2, offset, id2, values, index, newValues, newIndex, iterablesIndexCount, iterablesIndexFilterStatus, iterablesEmptyRows = [], sortRange = function(n2) {
        return cr_range(n2).sort(function(A, B) {
          var a = newValues[A], b = newValues[B];
          return a < b ? -1 : a > b ? 1 : A - B;
        });
      }, refilter = filter_default3.filterAll, refilterFunction, filterValue, filterValuePresent, indexListeners = [], dimensionGroups = [], lo0 = 0, hi0 = 0, t = 0, k;
      dataListeners.unshift(preAdd);
      dataListeners.push(postAdd);
      removeDataListeners.push(removeData2);
      var tmp = filters.add();
      offset = tmp.offset;
      one2 = tmp.one;
      zero2 = ~one2;
      id2 = offset << 7 | Math.log(one2) / Math.log(2);
      preAdd(data, 0, n);
      postAdd(data, 0, n);
      function preAdd(newData, n0, n1) {
        var newIterablesIndexCount, newIterablesIndexFilterStatus;
        if (iterable) {
          t = 0;
          j = 0;
          k = [];
          for (var i0 = 0; i0 < newData.length; i0++) {
            for (j = 0, k = value(newData[i0]); j < k.length; j++) {
              t++;
            }
          }
          newValues = [];
          newIterablesIndexCount = cr_range(newData.length);
          newIterablesIndexFilterStatus = cr_index(t, 1);
          var unsortedIndex = cr_range(t);
          for (var l = 0, index1 = 0; index1 < newData.length; index1++) {
            k = value(newData[index1]);
            if (!k.length) {
              newIterablesIndexCount[index1] = 0;
              iterablesEmptyRows.push(index1 + n0);
              continue;
            }
            newIterablesIndexCount[index1] = k.length;
            for (j = 0; j < k.length; j++) {
              newValues.push(k[j]);
              unsortedIndex[l] = index1;
              l++;
            }
          }
          var sortMap = sortRange(t);
          newValues = permute_default(newValues, sortMap);
          newIndex = permute_default(unsortedIndex, sortMap);
        } else {
          newValues = newData.map(value);
          newIndex = sortRange(n1);
          newValues = permute_default(newValues, newIndex);
        }
        var bounds = refilter(newValues), lo1 = bounds[0], hi1 = bounds[1];
        var index2, index3, index4;
        if (iterable) {
          n1 = t;
          if (refilterFunction) {
            for (index2 = 0; index2 < n1; ++index2) {
              if (!refilterFunction(newValues[index2], index2)) {
                if (--newIterablesIndexCount[newIndex[index2]] === 0) {
                  filters[offset][newIndex[index2] + n0] |= one2;
                }
                newIterablesIndexFilterStatus[index2] = 1;
              }
            }
          } else {
            for (index3 = 0; index3 < lo1; ++index3) {
              if (--newIterablesIndexCount[newIndex[index3]] === 0) {
                filters[offset][newIndex[index3] + n0] |= one2;
              }
              newIterablesIndexFilterStatus[index3] = 1;
            }
            for (index4 = hi1; index4 < n1; ++index4) {
              if (--newIterablesIndexCount[newIndex[index4]] === 0) {
                filters[offset][newIndex[index4] + n0] |= one2;
              }
              newIterablesIndexFilterStatus[index4] = 1;
            }
          }
        } else {
          if (refilterFunction) {
            for (index2 = 0; index2 < n1; ++index2) {
              if (!refilterFunction(newValues[index2], index2)) {
                filters[offset][newIndex[index2] + n0] |= one2;
              }
            }
          } else {
            for (index3 = 0; index3 < lo1; ++index3) {
              filters[offset][newIndex[index3] + n0] |= one2;
            }
            for (index4 = hi1; index4 < n1; ++index4) {
              filters[offset][newIndex[index4] + n0] |= one2;
            }
          }
        }
        if (!n0) {
          values = newValues;
          index = newIndex;
          iterablesIndexCount = newIterablesIndexCount;
          iterablesIndexFilterStatus = newIterablesIndexFilterStatus;
          lo0 = lo1;
          hi0 = hi1;
          return;
        }
        var oldValues = values, oldIndex = index, oldIterablesIndexFilterStatus = iterablesIndexFilterStatus, old_n0, i1 = 0;
        i0 = 0;
        if (iterable) {
          old_n0 = n0;
          n0 = oldValues.length;
          n1 = t;
        }
        values = iterable ? new Array(n0 + n1) : new Array(n);
        index = iterable ? new Array(n0 + n1) : cr_index(n, n);
        if (iterable)
          iterablesIndexFilterStatus = cr_index(n0 + n1, 1);
        if (iterable) {
          var oldiiclength = iterablesIndexCount.length;
          iterablesIndexCount = array_default.arrayLengthen(iterablesIndexCount, n);
          for (var j = 0; j + oldiiclength < n; j++) {
            iterablesIndexCount[j + oldiiclength] = newIterablesIndexCount[j];
          }
        }
        var index5 = 0;
        for (; i0 < n0 && i1 < n1; ++index5) {
          if (oldValues[i0] < newValues[i1]) {
            values[index5] = oldValues[i0];
            if (iterable)
              iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];
            index[index5] = oldIndex[i0++];
          } else {
            values[index5] = newValues[i1];
            if (iterable)
              iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];
            index[index5] = newIndex[i1++] + (iterable ? old_n0 : n0);
          }
        }
        for (; i0 < n0; ++i0, ++index5) {
          values[index5] = oldValues[i0];
          if (iterable)
            iterablesIndexFilterStatus[index5] = oldIterablesIndexFilterStatus[i0];
          index[index5] = oldIndex[i0];
        }
        for (; i1 < n1; ++i1, ++index5) {
          values[index5] = newValues[i1];
          if (iterable)
            iterablesIndexFilterStatus[index5] = newIterablesIndexFilterStatus[i1];
          index[index5] = newIndex[i1] + (iterable ? old_n0 : n0);
        }
        bounds = refilter(values), lo0 = bounds[0], hi0 = bounds[1];
      }
      function postAdd(newData, n0, n1) {
        indexListeners.forEach(function(l) {
          l(newValues, newIndex, n0, n1);
        });
        newValues = newIndex = null;
      }
      function removeData2(reIndex) {
        if (iterable) {
          for (var i0 = 0, i1 = 0; i0 < iterablesEmptyRows.length; i0++) {
            if (reIndex[iterablesEmptyRows[i0]] !== REMOVED_INDEX) {
              iterablesEmptyRows[i1] = reIndex[iterablesEmptyRows[i0]];
              i1++;
            }
          }
          iterablesEmptyRows.length = i1;
          for (i0 = 0, i1 = 0; i0 < n; i0++) {
            if (reIndex[i0] !== REMOVED_INDEX) {
              if (i1 !== i0)
                iterablesIndexCount[i1] = iterablesIndexCount[i0];
              i1++;
            }
          }
          iterablesIndexCount = iterablesIndexCount.slice(0, i1);
        }
        var n0 = values.length;
        for (var i = 0, j = 0, oldDataIndex; i < n0; ++i) {
          oldDataIndex = index[i];
          if (reIndex[oldDataIndex] !== REMOVED_INDEX) {
            if (i !== j)
              values[j] = values[i];
            index[j] = reIndex[oldDataIndex];
            if (iterable) {
              iterablesIndexFilterStatus[j] = iterablesIndexFilterStatus[i];
            }
            ++j;
          }
        }
        values.length = j;
        if (iterable)
          iterablesIndexFilterStatus = iterablesIndexFilterStatus.slice(0, j);
        while (j < n0)
          index[j++] = 0;
        var bounds = refilter(values);
        lo0 = bounds[0], hi0 = bounds[1];
      }
      function filterIndexBounds(bounds) {
        var lo1 = bounds[0], hi1 = bounds[1];
        if (refilterFunction) {
          refilterFunction = null;
          filterIndexFunction(function(d, i2) {
            return lo1 <= i2 && i2 < hi1;
          }, bounds[0] === 0 && bounds[1] === values.length);
          lo0 = lo1;
          hi0 = hi1;
          return dimension2;
        }
        var i, j, k2, added = [], removed = [], valueIndexAdded = [], valueIndexRemoved = [];
        if (lo1 < lo0) {
          for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
            added.push(index[i]);
            valueIndexAdded.push(i);
          }
        } else if (lo1 > lo0) {
          for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
            removed.push(index[i]);
            valueIndexRemoved.push(i);
          }
        }
        if (hi1 > hi0) {
          for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
            added.push(index[i]);
            valueIndexAdded.push(i);
          }
        } else if (hi1 < hi0) {
          for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
            removed.push(index[i]);
            valueIndexRemoved.push(i);
          }
        }
        if (!iterable) {
          for (i = 0; i < added.length; i++) {
            filters[offset][added[i]] ^= one2;
          }
          for (i = 0; i < removed.length; i++) {
            filters[offset][removed[i]] ^= one2;
          }
        } else {
          var newAdded = [];
          var newRemoved = [];
          for (i = 0; i < added.length; i++) {
            iterablesIndexCount[added[i]]++;
            iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;
            if (iterablesIndexCount[added[i]] === 1) {
              filters[offset][added[i]] ^= one2;
              newAdded.push(added[i]);
            }
          }
          for (i = 0; i < removed.length; i++) {
            iterablesIndexCount[removed[i]]--;
            iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;
            if (iterablesIndexCount[removed[i]] === 0) {
              filters[offset][removed[i]] ^= one2;
              newRemoved.push(removed[i]);
            }
          }
          added = newAdded;
          removed = newRemoved;
          if (refilter === filter_default3.filterAll) {
            for (i = 0; i < iterablesEmptyRows.length; i++) {
              if (filters[offset][k2 = iterablesEmptyRows[i]] & one2) {
                filters[offset][k2] ^= one2;
                added.push(k2);
              }
            }
          } else {
            for (i = 0; i < iterablesEmptyRows.length; i++) {
              if (!(filters[offset][k2 = iterablesEmptyRows[i]] & one2)) {
                filters[offset][k2] ^= one2;
                removed.push(k2);
              }
            }
          }
        }
        lo0 = lo1;
        hi0 = hi1;
        filterListeners.forEach(function(l) {
          l(one2, offset, added, removed);
        });
        triggerOnChange("filtered");
        return dimension2;
      }
      function filter2(range) {
        return range == null ? filterAll2() : Array.isArray(range) ? filterRange2(range) : typeof range === "function" ? filterFunction(range) : filterExact2(range);
      }
      function filterExact2(value2) {
        filterValue = value2;
        filterValuePresent = true;
        return filterIndexBounds((refilter = filter_default3.filterExact(bisect_default, value2))(values));
      }
      function filterRange2(range) {
        filterValue = range;
        filterValuePresent = true;
        return filterIndexBounds((refilter = filter_default3.filterRange(bisect_default, range))(values));
      }
      function filterAll2() {
        filterValue = void 0;
        filterValuePresent = false;
        return filterIndexBounds((refilter = filter_default3.filterAll)(values));
      }
      function filterFunction(f) {
        filterValue = f;
        filterValuePresent = true;
        refilterFunction = f;
        refilter = filter_default3.filterAll;
        filterIndexFunction(f, false);
        var bounds = refilter(values);
        lo0 = bounds[0], hi0 = bounds[1];
        return dimension2;
      }
      function filterIndexFunction(f, filterAll3) {
        var i, k2, x, added = [], removed = [], valueIndexAdded = [], valueIndexRemoved = [], indexLength = values.length;
        if (!iterable) {
          for (i = 0; i < indexLength; ++i) {
            if (!(filters[offset][k2 = index[i]] & one2) ^ !!(x = f(values[i], i))) {
              if (x)
                added.push(k2);
              else
                removed.push(k2);
            }
          }
        }
        if (iterable) {
          for (i = 0; i < indexLength; ++i) {
            if (f(values[i], i)) {
              added.push(index[i]);
              valueIndexAdded.push(i);
            } else {
              removed.push(index[i]);
              valueIndexRemoved.push(i);
            }
          }
        }
        if (!iterable) {
          for (i = 0; i < added.length; i++) {
            if (filters[offset][added[i]] & one2)
              filters[offset][added[i]] &= zero2;
          }
          for (i = 0; i < removed.length; i++) {
            if (!(filters[offset][removed[i]] & one2))
              filters[offset][removed[i]] |= one2;
          }
        } else {
          var newAdded = [];
          var newRemoved = [];
          for (i = 0; i < added.length; i++) {
            if (iterablesIndexFilterStatus[valueIndexAdded[i]] === 1) {
              iterablesIndexCount[added[i]]++;
              iterablesIndexFilterStatus[valueIndexAdded[i]] = 0;
              if (iterablesIndexCount[added[i]] === 1) {
                filters[offset][added[i]] ^= one2;
                newAdded.push(added[i]);
              }
            }
          }
          for (i = 0; i < removed.length; i++) {
            if (iterablesIndexFilterStatus[valueIndexRemoved[i]] === 0) {
              iterablesIndexCount[removed[i]]--;
              iterablesIndexFilterStatus[valueIndexRemoved[i]] = 1;
              if (iterablesIndexCount[removed[i]] === 0) {
                filters[offset][removed[i]] ^= one2;
                newRemoved.push(removed[i]);
              }
            }
          }
          added = newAdded;
          removed = newRemoved;
          if (filterAll3) {
            for (i = 0; i < iterablesEmptyRows.length; i++) {
              if (filters[offset][k2 = iterablesEmptyRows[i]] & one2) {
                filters[offset][k2] ^= one2;
                added.push(k2);
              }
            }
          } else {
            for (i = 0; i < iterablesEmptyRows.length; i++) {
              if (!(filters[offset][k2 = iterablesEmptyRows[i]] & one2)) {
                filters[offset][k2] ^= one2;
                removed.push(k2);
              }
            }
          }
        }
        filterListeners.forEach(function(l) {
          l(one2, offset, added, removed);
        });
        triggerOnChange("filtered");
      }
      function currentFilter() {
        return filterValue;
      }
      function hasCurrentFilter() {
        return filterValuePresent;
      }
      function top(k2, top_offset) {
        var array2 = [], i = hi0, j, toSkip = 0;
        if (top_offset && top_offset > 0)
          toSkip = top_offset;
        while (--i >= lo0 && k2 > 0) {
          if (filters.zero(j = index[i])) {
            if (toSkip > 0) {
              --toSkip;
            } else {
              array2.push(data[j]);
              --k2;
            }
          }
        }
        if (iterable) {
          for (i = 0; i < iterablesEmptyRows.length && k2 > 0; i++) {
            if (filters.zero(j = iterablesEmptyRows[i])) {
              if (toSkip > 0) {
                --toSkip;
              } else {
                array2.push(data[j]);
                --k2;
              }
            }
          }
        }
        return array2;
      }
      function bottom(k2, bottom_offset) {
        var array2 = [], i, j, toSkip = 0;
        if (bottom_offset && bottom_offset > 0)
          toSkip = bottom_offset;
        if (iterable) {
          for (i = 0; i < iterablesEmptyRows.length && k2 > 0; i++) {
            if (filters.zero(j = iterablesEmptyRows[i])) {
              if (toSkip > 0) {
                --toSkip;
              } else {
                array2.push(data[j]);
                --k2;
              }
            }
          }
        }
        i = lo0;
        while (i < hi0 && k2 > 0) {
          if (filters.zero(j = index[i])) {
            if (toSkip > 0) {
              --toSkip;
            } else {
              array2.push(data[j]);
              --k2;
            }
          }
          i++;
        }
        return array2;
      }
      function group(key) {
        var group2 = {
          top: top2,
          all: all2,
          reduce,
          reduceCount,
          reduceSum,
          order,
          orderNatural,
          size: size2,
          dispose: dispose2,
          remove: dispose2
          // for backwards-compatibility
        };
        dimensionGroups.push(group2);
        var groups, groupIndex, groupWidth = 8, groupCapacity = capacity(groupWidth), k2 = 0, select, heap, reduceAdd3, reduceRemove2, reduceInitial2, update = null_default, reset = null_default, resetNeeded = true, groupAll3 = key === null_default, n0old;
        if (arguments.length < 1)
          key = identity_default;
        filterListeners.push(update);
        indexListeners.push(add2);
        removeDataListeners.push(removeData3);
        add2(values, index, 0, n);
        function add2(newValues2, newIndex2, n0, n1) {
          if (iterable) {
            n0old = n0;
            n0 = values.length - newValues2.length;
            n1 = newValues2.length;
          }
          var oldGroups = groups, reIndex = iterable ? [] : cr_index(k2, groupCapacity), add3 = reduceAdd3, remove2 = reduceRemove2, initial = reduceInitial2, k0 = k2, i0 = 0, i1 = 0, j, g0, x0, x1, g, x;
          if (resetNeeded)
            add3 = initial = null_default;
          if (resetNeeded)
            remove2 = initial = null_default;
          groups = new Array(k2), k2 = 0;
          if (iterable) {
            groupIndex = k0 ? groupIndex : [];
          } else {
            groupIndex = k0 > 1 ? array_default.arrayLengthen(groupIndex, n) : cr_index(n, groupCapacity);
          }
          if (k0)
            x0 = (g0 = oldGroups[0]).key;
          while (i1 < n1 && !((x1 = key(newValues2[i1])) >= x1))
            ++i1;
          while (i1 < n1) {
            if (g0 && x0 <= x1) {
              g = g0, x = x0;
              reIndex[i0] = k2;
              g0 = oldGroups[++i0];
              if (g0)
                x0 = g0.key;
            } else {
              g = { key: x1, value: initial() }, x = x1;
            }
            groups[k2] = g;
            while (x1 <= x) {
              j = newIndex2[i1] + (iterable ? n0old : n0);
              if (iterable) {
                if (groupIndex[j]) {
                  groupIndex[j].push(k2);
                } else {
                  groupIndex[j] = [k2];
                }
              } else {
                groupIndex[j] = k2;
              }
              g.value = add3(g.value, data[j], true);
              if (!filters.zeroExcept(j, offset, zero2))
                g.value = remove2(g.value, data[j], false);
              if (++i1 >= n1)
                break;
              x1 = key(newValues2[i1]);
            }
            groupIncrement();
          }
          while (i0 < k0) {
            groups[reIndex[i0] = k2] = oldGroups[i0++];
            groupIncrement();
          }
          if (iterable) {
            for (var index1 = 0; index1 < n; index1++) {
              if (!groupIndex[index1]) {
                groupIndex[index1] = [];
              }
            }
          }
          if (k2 > i0) {
            if (iterable) {
              for (i0 = 0; i0 < n0old; ++i0) {
                for (index1 = 0; index1 < groupIndex[i0].length; index1++) {
                  groupIndex[i0][index1] = reIndex[groupIndex[i0][index1]];
                }
              }
            } else {
              for (i0 = 0; i0 < n0; ++i0) {
                groupIndex[i0] = reIndex[groupIndex[i0]];
              }
            }
          }
          j = filterListeners.indexOf(update);
          if (k2 > 1 || iterable) {
            update = updateMany;
            reset = resetMany;
          } else {
            if (!k2 && groupAll3) {
              k2 = 1;
              groups = [{ key: null, value: initial() }];
            }
            if (k2 === 1) {
              update = updateOne;
              reset = resetOne;
            } else {
              update = null_default;
              reset = null_default;
            }
            groupIndex = null;
          }
          filterListeners[j] = update;
          function groupIncrement() {
            if (iterable) {
              k2++;
              return;
            }
            if (++k2 === groupCapacity) {
              reIndex = array_default.arrayWiden(reIndex, groupWidth <<= 1);
              groupIndex = array_default.arrayWiden(groupIndex, groupWidth);
              groupCapacity = capacity(groupWidth);
            }
          }
        }
        function removeData3(reIndex) {
          if (k2 > 1 || iterable) {
            var oldK = k2, oldGroups = groups, seenGroups = cr_index(oldK, oldK), i, i0, j;
            if (!iterable) {
              for (i = 0, j = 0; i < n; ++i) {
                if (reIndex[i] !== REMOVED_INDEX) {
                  seenGroups[groupIndex[j] = groupIndex[i]] = 1;
                  ++j;
                }
              }
            } else {
              for (i = 0, j = 0; i < n; ++i) {
                if (reIndex[i] !== REMOVED_INDEX) {
                  groupIndex[j] = groupIndex[i];
                  for (i0 = 0; i0 < groupIndex[j].length; i0++) {
                    seenGroups[groupIndex[j][i0]] = 1;
                  }
                  ++j;
                }
              }
              groupIndex = groupIndex.slice(0, j);
            }
            groups = [], k2 = 0;
            for (i = 0; i < oldK; ++i) {
              if (seenGroups[i]) {
                seenGroups[i] = k2++;
                groups.push(oldGroups[i]);
              }
            }
            if (k2 > 1 || iterable) {
              if (!iterable) {
                for (i = 0; i < j; ++i)
                  groupIndex[i] = seenGroups[groupIndex[i]];
              } else {
                for (i = 0; i < j; ++i) {
                  for (i0 = 0; i0 < groupIndex[i].length; ++i0) {
                    groupIndex[i][i0] = seenGroups[groupIndex[i][i0]];
                  }
                }
              }
            } else {
              groupIndex = null;
            }
            filterListeners[filterListeners.indexOf(update)] = k2 > 1 || iterable ? (reset = resetMany, update = updateMany) : k2 === 1 ? (reset = resetOne, update = updateOne) : reset = update = null_default;
          } else if (k2 === 1) {
            if (groupAll3)
              return;
            for (var index3 = 0; index3 < n; ++index3)
              if (reIndex[index3] !== REMOVED_INDEX)
                return;
            groups = [], k2 = 0;
            filterListeners[filterListeners.indexOf(update)] = update = reset = null_default;
          }
        }
        function updateMany(filterOne, filterOffset, added, removed, notFilter) {
          if (filterOne === one2 && filterOffset === offset || resetNeeded)
            return;
          var i, j, k3, n2, g;
          if (iterable) {
            for (i = 0, n2 = added.length; i < n2; ++i) {
              if (filters.zeroExcept(k3 = added[i], offset, zero2)) {
                for (j = 0; j < groupIndex[k3].length; j++) {
                  g = groups[groupIndex[k3][j]];
                  g.value = reduceAdd3(g.value, data[k3], false, j);
                }
              }
            }
            for (i = 0, n2 = removed.length; i < n2; ++i) {
              if (filters.onlyExcept(k3 = removed[i], offset, zero2, filterOffset, filterOne)) {
                for (j = 0; j < groupIndex[k3].length; j++) {
                  g = groups[groupIndex[k3][j]];
                  g.value = reduceRemove2(g.value, data[k3], notFilter, j);
                }
              }
            }
            return;
          }
          for (i = 0, n2 = added.length; i < n2; ++i) {
            if (filters.zeroExcept(k3 = added[i], offset, zero2)) {
              g = groups[groupIndex[k3]];
              g.value = reduceAdd3(g.value, data[k3], false);
            }
          }
          for (i = 0, n2 = removed.length; i < n2; ++i) {
            if (filters.onlyExcept(k3 = removed[i], offset, zero2, filterOffset, filterOne)) {
              g = groups[groupIndex[k3]];
              g.value = reduceRemove2(g.value, data[k3], notFilter);
            }
          }
        }
        function updateOne(filterOne, filterOffset, added, removed, notFilter) {
          if (filterOne === one2 && filterOffset === offset || resetNeeded)
            return;
          var i, k3, n2, g = groups[0];
          for (i = 0, n2 = added.length; i < n2; ++i) {
            if (filters.zeroExcept(k3 = added[i], offset, zero2)) {
              g.value = reduceAdd3(g.value, data[k3], false);
            }
          }
          for (i = 0, n2 = removed.length; i < n2; ++i) {
            if (filters.onlyExcept(k3 = removed[i], offset, zero2, filterOffset, filterOne)) {
              g.value = reduceRemove2(g.value, data[k3], notFilter);
            }
          }
        }
        function resetMany() {
          var i, j, g;
          for (i = 0; i < k2; ++i) {
            groups[i].value = reduceInitial2();
          }
          if (iterable) {
            for (i = 0; i < n; ++i) {
              for (j = 0; j < groupIndex[i].length; j++) {
                g = groups[groupIndex[i][j]];
                g.value = reduceAdd3(g.value, data[i], true, j);
              }
            }
            for (i = 0; i < n; ++i) {
              if (!filters.zeroExcept(i, offset, zero2)) {
                for (j = 0; j < groupIndex[i].length; j++) {
                  g = groups[groupIndex[i][j]];
                  g.value = reduceRemove2(g.value, data[i], false, j);
                }
              }
            }
            return;
          }
          for (i = 0; i < n; ++i) {
            g = groups[groupIndex[i]];
            g.value = reduceAdd3(g.value, data[i], true);
          }
          for (i = 0; i < n; ++i) {
            if (!filters.zeroExcept(i, offset, zero2)) {
              g = groups[groupIndex[i]];
              g.value = reduceRemove2(g.value, data[i], false);
            }
          }
        }
        function resetOne() {
          var i, g = groups[0];
          g.value = reduceInitial2();
          for (i = 0; i < n; ++i) {
            g.value = reduceAdd3(g.value, data[i], true);
          }
          for (i = 0; i < n; ++i) {
            if (!filters.zeroExcept(i, offset, zero2)) {
              g.value = reduceRemove2(g.value, data[i], false);
            }
          }
        }
        function all2() {
          if (resetNeeded)
            reset(), resetNeeded = false;
          return groups;
        }
        function top2(k3) {
          var top3 = select(all2(), 0, groups.length, k3);
          return heap.sort(top3, 0, top3.length);
        }
        function reduce(add3, remove2, initial) {
          reduceAdd3 = add3;
          reduceRemove2 = remove2;
          reduceInitial2 = initial;
          resetNeeded = true;
          return group2;
        }
        function reduceCount() {
          return reduce(reduce_default.reduceIncrement, reduce_default.reduceDecrement, zero_default);
        }
        function reduceSum(value2) {
          return reduce(reduce_default.reduceAdd(value2), reduce_default.reduceSubtract(value2), zero_default);
        }
        function order(value2) {
          select = heapselect_default.by(valueOf);
          heap = heap_default.by(valueOf);
          function valueOf(d) {
            return value2(d.value);
          }
          return group2;
        }
        function orderNatural() {
          return order(identity_default);
        }
        function size2() {
          return k2;
        }
        function dispose2() {
          var i = filterListeners.indexOf(update);
          if (i >= 0)
            filterListeners.splice(i, 1);
          i = indexListeners.indexOf(add2);
          if (i >= 0)
            indexListeners.splice(i, 1);
          i = removeDataListeners.indexOf(removeData3);
          if (i >= 0)
            removeDataListeners.splice(i, 1);
          i = dimensionGroups.indexOf(group2);
          if (i >= 0)
            dimensionGroups.splice(i, 1);
          return group2;
        }
        return reduceCount().orderNatural();
      }
      function groupAll2() {
        var g = group(null_default), all2 = g.all;
        delete g.all;
        delete g.top;
        delete g.order;
        delete g.orderNatural;
        delete g.size;
        g.value = function() {
          return all2()[0].value;
        };
        return g;
      }
      function dispose() {
        dimensionGroups.forEach(function(group2) {
          group2.dispose();
        });
        var i = dataListeners.indexOf(preAdd);
        if (i >= 0)
          dataListeners.splice(i, 1);
        i = dataListeners.indexOf(postAdd);
        if (i >= 0)
          dataListeners.splice(i, 1);
        i = removeDataListeners.indexOf(removeData2);
        if (i >= 0)
          removeDataListeners.splice(i, 1);
        filters.masks[offset] &= zero2;
        return filterAll2();
      }
      return dimension2;
    }
    function groupAll() {
      var group = {
        reduce,
        reduceCount,
        reduceSum,
        value,
        dispose,
        remove: dispose
        // for backwards-compatibility
      };
      var reduceValue, reduceAdd3, reduceRemove2, reduceInitial2, resetNeeded = true;
      filterListeners.push(update);
      dataListeners.push(add2);
      add2(data, 0, n);
      function add2(newData, n0) {
        var i;
        if (resetNeeded)
          return;
        for (i = n0; i < n; ++i) {
          reduceValue = reduceAdd3(reduceValue, data[i], true);
          if (!filters.zero(i)) {
            reduceValue = reduceRemove2(reduceValue, data[i], false);
          }
        }
      }
      function update(filterOne, filterOffset, added, removed, notFilter) {
        var i, k, n2;
        if (resetNeeded)
          return;
        for (i = 0, n2 = added.length; i < n2; ++i) {
          if (filters.zero(k = added[i])) {
            reduceValue = reduceAdd3(reduceValue, data[k], notFilter);
          }
        }
        for (i = 0, n2 = removed.length; i < n2; ++i) {
          if (filters.only(k = removed[i], filterOffset, filterOne)) {
            reduceValue = reduceRemove2(reduceValue, data[k], notFilter);
          }
        }
      }
      function reset() {
        var i;
        reduceValue = reduceInitial2();
        for (i = 0; i < n; ++i) {
          reduceValue = reduceAdd3(reduceValue, data[i], true);
          if (!filters.zero(i)) {
            reduceValue = reduceRemove2(reduceValue, data[i], false);
          }
        }
      }
      function reduce(add3, remove2, initial) {
        reduceAdd3 = add3;
        reduceRemove2 = remove2;
        reduceInitial2 = initial;
        resetNeeded = true;
        return group;
      }
      function reduceCount() {
        return reduce(reduce_default.reduceIncrement, reduce_default.reduceDecrement, zero_default);
      }
      function reduceSum(value2) {
        return reduce(reduce_default.reduceAdd(value2), reduce_default.reduceSubtract(value2), zero_default);
      }
      function value() {
        if (resetNeeded)
          reset(), resetNeeded = false;
        return reduceValue;
      }
      function dispose() {
        var i = filterListeners.indexOf(update);
        if (i >= 0)
          filterListeners.splice(i, 1);
        i = dataListeners.indexOf(add2);
        if (i >= 0)
          dataListeners.splice(i, 1);
        return group;
      }
      return reduceCount();
    }
    function size() {
      return n;
    }
    function all() {
      return data;
    }
    function allFiltered(ignore_dimensions) {
      var array2 = [], i = 0, mask = maskForDimensions(ignore_dimensions || []);
      for (i = 0; i < n; i++) {
        if (filters.zeroExceptMask(i, mask)) {
          array2.push(data[i]);
        }
      }
      return array2;
    }
    function onChange(cb) {
      if (typeof cb !== "function") {
        console.warn("onChange callback parameter must be a function!");
        return;
      }
      callbacks.push(cb);
      return function() {
        callbacks.splice(callbacks.indexOf(cb), 1);
      };
    }
    function triggerOnChange(eventName) {
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i](eventName);
      }
    }
    return arguments.length ? add(arguments[0]) : crossfilter2;
  }
  function cr_index(n, m) {
    return (m < 257 ? array_default.array8 : m < 65537 ? array_default.array16 : array_default.array32)(n);
  }
  function cr_range(n) {
    var range = cr_index(n, n);
    for (var i = -1; ++i < n; )
      range[i] = i;
    return range;
  }
  function capacity(w) {
    return w === 8 ? 256 : w === 16 ? 65536 : 4294967296;
  }

  // node_modules/.pnpm/d3-array@3.2.4/node_modules/d3-array/src/ascending.js
  function ascending2(a, b) {
    return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // cf.js
  var cf = src_default();
  cf.addData = function(data) {
    cf.data = data;
    window.data = data;
    data.sort((a, b) => ascending2(a.DisciplineOrder, b.DisciplineOrder));
    cf.add(data);
  };
  var cf_default = cf;

  // node_modules/.pnpm/redugator@0.1.0/node_modules/redugator/index.js
  function reduceId() {
    return {
      reduceAdd(p) {
        return p;
      },
      reduceRemove(p) {
        return p;
      },
      reduceInitial(p = {}) {
        return p || {};
      }
    };
  }
  var Reducer = {
    empty: reduceId(),
    concat: concatReducer,
    concatAll: (...reducers) => {
      return reducers.reduce((p, v) => concatReducer(p, v), reduceId());
    },
    reduceGroup
  };
  function concatReducer(reducerA, reducerB) {
    return {
      reduceAdd(p, v) {
        p = reducerA.reduceAdd(p, v);
        return reducerB.reduceAdd(p, v);
      },
      reduceRemove(p, v) {
        p = reducerA.reduceRemove(p, v);
        return reducerB.reduceRemove(p, v);
      },
      reduceInitial(p) {
        p = reducerA.reduceInitial(p);
        return reducerB.reduceInitial(p);
      }
    };
  }
  function reduceGroup(reducer, group) {
    return group.reduce(
      reducer.reduceAdd,
      reducer.reduceRemove,
      reducer.reduceInitial
    );
  }

  // node_modules/.pnpm/redugator@0.1.0/node_modules/redugator/reducers/average.js
  function average(count = "count", sum2 = "sum", key = "avg") {
    return {
      reduceAdd(p) {
        p[key] = p[count] === 0 ? 0 : p[sum2] / p[count];
        return p;
      },
      reduceRemove(p) {
        p[key] = p[count] === 0 ? 0 : p[sum2] / p[count];
        return p;
      },
      reduceInitial(p = {}) {
        p[key] = 0;
        return p;
      }
    };
  }

  // node_modules/.pnpm/redugator@0.1.0/node_modules/redugator/reducers/bisect.js
  function bisect_by2(f) {
    function bisectLeft(a, x, lo, hi) {
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (f(a[mid]) < x)
          lo = mid + 1;
        else
          hi = mid;
      }
      return lo;
    }
    function bisectRight(a, x, lo, hi) {
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (x < f(a[mid]))
          hi = mid;
        else
          lo = mid + 1;
      }
      return lo;
    }
    bisectRight.right = bisectRight;
    bisectRight.left = bisectLeft;
    return bisectRight;
  }
  var bisect2 = bisect_by2((x) => x);
  bisect2.by = bisect_by2;

  // node_modules/.pnpm/redugator@0.1.0/node_modules/redugator/reducers/value-list.js
  function valueList(valueAccessor, key = "valueList") {
    return {
      reduceAdd(p, v) {
        const value = valueAccessor(v);
        const idx = bisect2.left(p[key], value, 0, p[key].length);
        p[key].splice(idx, 0, value);
        return p;
      },
      reduceRemove(p, v) {
        const value = valueAccessor(v);
        const idx = bisect2.left(p[key], value, 0, p[key].length);
        p[key].splice(idx, 1);
        return p;
      },
      reduceInitial(p = {}) {
        p[key] = [];
        return p;
      }
    };
  }

  // node_modules/.pnpm/redugator@0.1.0/node_modules/redugator/reducers/max.js
  var last = (l) => l[l.length - 1];
  function max(valueAccessor, key = "max") {
    const valuelist = key + "_valuelist";
    const valueListReducer = valueList(valueAccessor, valuelist);
    const maxReducer = {
      reduceAdd(p) {
        p[key] = last(p[valuelist]);
        return p;
      },
      reduceRemove(p) {
        if (p[valuelist].length === 0) {
          p[key] = void 0;
          return p;
        }
        p[key] = last(p[valuelist]);
        return p;
      },
      reduceInitial(p = {}) {
        p[key] = 0;
        return p;
      }
    };
    return Reducer.concat(valueListReducer, maxReducer);
  }

  // node_modules/.pnpm/redugator@0.1.0/node_modules/redugator/reducers/min.js
  function min(valueAccessor, key = "min") {
    const valuelist = key + "_valuelist";
    const valueListReducer = valueList(valueAccessor, valuelist);
    const minReducer = {
      reduceAdd(p) {
        p[key] = p[valuelist][0];
        return p;
      },
      reduceRemove(p) {
        if (p[valuelist].length === 0) {
          p[key] = void 0;
          return p;
        }
        p[key] = p[valuelist][0];
        return p;
      },
      reduceInitial(p = {}) {
        p[key] = 0;
        return p;
      }
    };
    return Reducer.concat(valueListReducer, minReducer);
  }

  // node_modules/.pnpm/redugator@0.1.0/node_modules/redugator/reducers/sum.js
  function sum(valueAccessor, key = "sum") {
    return {
      reduceAdd(p, v) {
        p[key] += valueAccessor(v);
        return p;
      },
      reduceRemove(p, v) {
        p[key] -= valueAccessor(v);
        return p;
      },
      reduceInitial(p = {}) {
        p[key] = 0;
        return p;
      }
    };
  }

  // reducers.js
  var averageScoreReducer = Reducer.concatAll(sum((x) => +x.Score), sum((_) => 1, "count"), average());
  function getPercentile(a, p) {
    let idx = p * a.length;
    return a[Math.floor(idx)] ?? 0;
  }
  var quartiles = (valueList2 = "valueList") => {
    function setQuartiles(p) {
      let l = p[valueList2];
      p.min = l[0];
      p.q1 = getPercentile(l, 0.25);
      p.median = getPercentile(l, 0.5);
      p.q3 = getPercentile(l, 0.75);
      p.max = l[l.length - 1];
    }
    return {
      reduceAdd(p) {
        setQuartiles(p);
        return p;
      },
      reduceRemove(p) {
        setQuartiles(p);
        return p;
      },
      reduceInitial(p = {}) {
        p.min = 0;
        p.q1 = 0;
        p.median = 0;
        p.q3 = 0;
        p.max = 0;
        return p;
      }
    };
  };

  // game_averages.js
  var PlayerGameChart = class {
    constructor() {
      this.dimension = cf_default.dimension((d) => {
        let game = +d.Game;
        let disc = d.Discipline;
        let discOrder = +d.Disciplineorder * 10;
        if (d.Block2 === "-1") {
          game += 3;
        }
        return [disc + ": " + game, discOrder + game, d.Gender];
      });
      this.group = Reducer.reduceGroup(averageScoreReducer, this.dimension.group());
      this.dimension2 = cf_default.dimension((d) => {
        let game = +d.Game;
        let discOrder = +d.Disciplineorder * 10;
        if (d.Block2 === "-1") {
          game += 3;
        }
        return discOrder + game;
      });
      this.group2 = Reducer.reduceGroup(averageScoreReducer, this.dimension2.group());
      this.initialTotal = this.group2.all().reduce((p, v) => p + v.value.sum, 0);
    }
    render() {
      let _all = this.group.all().sort((a, b) => ascending2(a.key[1], b.key[1]));
      let genders = /* @__PURE__ */ new Map();
      let categories = /* @__PURE__ */ new Set();
      for (let i = 0; i < _all.length; ++i) {
        let d = _all[i];
        let gender = d.key[2];
        if (!genders.has(gender))
          genders.set(gender, []);
        genders.get(gender).push(d.value.avg);
        categories.add(d.key[0]);
      }
      this.genderCount = genders.size;
      if (!_all.length)
        return;
      this.chart = new Highcharts.Chart({
        chart: {
          renderTo: document.getElementById("playerGameChart"),
          type: "line"
        },
        title: { text: "Game Averages" },
        xAxis: {
          categories: Array.from(categories),
          title: { text: null }
        },
        yAxis: {
          min: 0,
          title: { text: "Average" },
          labels: { overflow: "justify" }
        },
        series: Array.from(genders.keys()).map((gender, i) => ({
          name: gender + " Average",
          data: genders.get(gender),
          color: Highcharts.theme.colors[i + 1]
        }))
      });
    }
    redraw() {
      if (!this.chart)
        return this.render();
      let _all = this.group2.all();
      let data = [];
      let total = 0;
      for (let i = 0; i < _all.length; ++i) {
        let d = _all[i];
        data.push(d.value.avg);
        total += d.value.sum;
      }
      const lastIdx = this.chart.series.length - 1;
      const lastSeries = this.chart.series[lastIdx];
      if (total === this.initialTotal && lastSeries.name === "Filter Average") {
        lastSeries.remove(true);
        return;
      }
      if (lastSeries.name === "Filter Average") {
        lastSeries.setData(data);
      } else {
        this.chart.addSeries({
          name: "Filter Average",
          data,
          color: Highcharts.theme.colors[0]
        });
      }
    }
  };

  // scoreReducer.js
  function scoreReducer(group) {
    const g = Reducer.reduceGroup(averageScoreReducer, group);
    return {
      all: () => g.all().filter((d) => d.value.sum !== 0)
    };
  }

  // avgAll.js
  var bisectDescending = src_default.bisect.by((x) => -x.value.avg).right;
  function avgAll(all) {
    let result = [];
    for (let i = 0; i < all.length; ++i) {
      let x = all[i];
      if (x.value.avg !== 0) {
        const idx = bisectDescending(result, -x.value.avg, 0, result.length);
        result.splice(idx, 0, x);
      }
    }
    return result;
  }

  // chart_registry.js
  var _charts = [];
  var chart_registry_default = {
    register(c) {
      _charts.push(c);
    },
    deregister(c) {
      let idx = _charts.indexOf(c);
      if (~idx)
        _charts.splice(idx, 1);
    },
    redrawAll() {
      _charts.forEach((c) => c.redraw());
    },
    renderAll() {
      _charts.forEach((c) => c.render());
    },
    list() {
      return _charts.slice();
    }
  };

  // average_chart.js
  var AverageChart = class {
    constructor() {
      this.filters = [];
    }
    hasFilter(key) {
      if (!arguments.length) {
        return !!this.filters.length;
      }
      return !!~this.filters.indexOf(key);
    }
    filter(key) {
      if (this.hasFilter(key)) {
        this.filters.splice(this.filters.indexOf(key), 1);
      } else {
        this.filters.push(key);
      }
      if (this.filters.length === 0) {
        this.dimension.filter(null);
      } else if (this.filters.length === 1) {
        this.dimension.filterExact(this.filters[0]);
      } else {
        this.dimension.filterFunction((d) => {
          for (let i = 0; i < this.filters.length; ++i) {
            let filter2 = this.filters[i];
            if (filter2 <= d && filter2 >= d) {
              return true;
            }
          }
          return false;
        });
      }
    }
    data() {
      return avgAll(this.group.all());
    }
    render() {
      let _all = this.data();
      if (!_all.length)
        return;
      let _this = this;
      this.chart = new Highcharts.chart({
        chart: {
          type: this.options.type || "bar",
          renderTo: this.options.renderTo,
          height: this.options.height
        },
        plotOptions: {
          series: {
            cursor: "pointer",
            point: {
              events: {
                click() {
                  _this.filter(this.category);
                  chart_registry_default.redrawAll();
                }
              }
            }
          }
        },
        title: {
          text: this.options.title
        },
        xAxis: {
          categories: _all.map((d) => d.key),
          title: {
            text: null
          }
        },
        yAxis: {
          min: 0,
          title: {
            text: "Average"
          },
          labels: {
            overflow: "justify"
          }
        },
        legend: {
          enabled: false
        },
        series: [{
          name: "Average",
          data: _all.map((d) => d.value.avg)
        }]
      });
      if (this.postRender) {
        this.postRender();
      }
    }
    redraw() {
      let shouldRedraw = !this._redraw;
      if (!this.chart)
        return this.render();
      let _all = this.data();
      let keys = [];
      let values = [];
      for (let i = 0; i < _all.length; ++i) {
        let d = _all[i];
        keys.push(d.key);
        values.push({
          y: d.value.avg,
          color: this.getColor(d)
        });
      }
      this.chart.xAxis[0].setCategories(keys, false);
      this.chart.series[0].setData(values, shouldRedraw);
      if (this._redraw)
        this._redraw(_all);
      if (this.postRedraw)
        this.postRedraw();
    }
    getColor(d) {
      return !this.hasFilter() ? void 0 : this.hasFilter(d.key) ? void 0 : "#333333";
    }
  };

  // player_chart.js
  var PlayerGameChart2 = class extends AverageChart {
    constructor() {
      super();
      this.dimension = cf_default.dimension((d) => d.Playername);
      this.group = scoreReducer(this.dimension.group());
      let height = avgAll(this.group.all()).length * 19 + 182;
      this.options = {
        renderTo: document.getElementById("playerChart"),
        title: "Athlete Averages",
        height
      };
    }
    _redraw(_all) {
      this.chart.setSize(this.chart.chartWidth, 19 * _all.length + this.chart.marginBottom * 2);
    }
  };

  // country_chart.js
  var CountryChart = class extends AverageChart {
    constructor() {
      super();
      this.dimension = cf_default.dimension((d) => d.Federation);
      this.group = scoreReducer(this.dimension.group());
      let height = avgAll(this.group.all()).length * 20;
      this.options = {
        renderTo: document.getElementById("countryChart"),
        title: "Federation Averages",
        height
      };
    }
  };

  // discipline_chart.js
  var DisciplineChart = class extends AverageChart {
    constructor() {
      super();
      this.dimension = cf_default.dimension((d) => d.Discipline);
      this.group = scoreReducer(this.dimension.group());
      this.options = {
        renderTo: document.getElementById("disciplineChart"),
        title: "Discipline Averages"
      };
    }
  };

  // gender_chart.js
  var GenderChart = class extends AverageChart {
    constructor() {
      super();
      this.dimension = cf_default.dimension((d) => d.Gender);
      this.group = scoreReducer(this.dimension.group());
      this.options = {
        renderTo: document.getElementById("genderChart"),
        title: "Gender Averages"
      };
    }
  };

  // hand_chart.js
  var HandChart = class extends AverageChart {
    constructor() {
      super();
      this.dimension = cf_default.dimension((d) => d.Hand);
      this.group = scoreReducer(this.dimension.group());
      this.options = {
        renderTo: document.getElementById("handChart"),
        title: "Hand Averages"
      };
    }
  };

  // node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatDecimal.js
  function formatDecimal_default(x) {
    return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
  }
  function formatDecimalParts(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
      return null;
    var i, coefficient = x.slice(0, i);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  // node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/exponent.js
  function exponent_default(x) {
    return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
  }

  // node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatGroup.js
  function formatGroup_default(grouping, thousands) {
    return function(value, width) {
      var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width)
          g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width)
          break;
        g = grouping[j = (j + 1) % grouping.length];
      }
      return t.reverse().join(thousands);
    };
  }

  // node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatNumerals.js
  function formatNumerals_default(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatSpecifier.js
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier)))
      throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };

  // node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatTrim.js
  function formatTrim_default(s) {
    out:
      for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".":
            i0 = i1 = i;
            break;
          case "0":
            if (i0 === 0)
              i0 = i;
            i1 = i;
            break;
          default:
            if (!+s[i])
              break out;
            if (i0 > 0)
              i0 = 0;
            break;
        }
      }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  // node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatPrefixAuto.js
  var prefixExponent;
  function formatPrefixAuto_default(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d)
      return x + "";
    var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
  }

  // node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatRounded.js
  function formatRounded_default(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d)
      return x + "";
    var coefficient = d[0], exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  // node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/formatTypes.js
  var formatTypes_default = {
    "%": (x, p) => (x * 100).toFixed(p),
    "b": (x) => Math.round(x).toString(2),
    "c": (x) => x + "",
    "d": formatDecimal_default,
    "e": (x, p) => x.toExponential(p),
    "f": (x, p) => x.toFixed(p),
    "g": (x, p) => x.toPrecision(p),
    "o": (x) => Math.round(x).toString(8),
    "p": (x, p) => formatRounded_default(x * 100, p),
    "r": formatRounded_default,
    "s": formatPrefixAuto_default,
    "X": (x) => Math.round(x).toString(16).toUpperCase(),
    "x": (x) => Math.round(x).toString(16)
  };

  // node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/identity.js
  function identity_default2(x) {
    return x;
  }

  // node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/locale.js
  var map = Array.prototype.map;
  var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function locale_default(locale2) {
    var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default2 : formatGroup_default(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default2 : formatNumerals_default(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
      if (type === "n")
        comma = true, type = "g";
      else if (!formatTypes_default[type])
        precision === void 0 && (precision = 12), trim = true, type = "g";
      if (zero2 || fill === "0" && align === "=")
        zero2 = true, fill = "0", align = "=";
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
      var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
      precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
      function format3(value) {
        var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;
          var valueNegative = value < 0 || 1 / value < 0;
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
          if (trim)
            value = formatTrim_default(value);
          if (valueNegative && +value === 0 && sign !== "+")
            valueNegative = false;
          valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }
        if (comma && !zero2)
          value = group(value, Infinity);
        var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
        if (comma && zero2)
          value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding;
            break;
          case "=":
            value = valuePrefix + padding + value + valueSuffix;
            break;
          case "^":
            value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
            break;
          default:
            value = padding + valuePrefix + value + valueSuffix;
            break;
        }
        return numerals(value);
      }
      format3.toString = function() {
        return specifier + "";
      };
      return format3;
    }
    function formatPrefix2(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
      return function(value2) {
        return f(k * value2) + prefix;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }

  // node_modules/.pnpm/d3-format@3.1.0/node_modules/d3-format/src/defaultLocale.js
  var locale;
  var format;
  var formatPrefix;
  defaultLocale({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale(definition) {
    locale = locale_default(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  // number.js
  var format2 = format(",.0f");
  var universal_dim = cf_default.dimension((_) => "all");
  var NumberContainer = class {
    constructor({ anchor, description, reducer, accessor }) {
      this.el = select_default2(anchor);
      this.group = Reducer.reduceGroup(reducer, universal_dim.group());
      this.description = description;
      this.accessor = accessor;
      this._value = 0;
    }
    render() {
      if (!this.group.all()[0])
        return;
      let _value = this.accessor(this.group.all()[0]);
      let _sel = this.el.selectAll(".number").data([_value]);
      _sel.enter().append("span").attr("class", "number").text(this._value);
      _sel.enter().append("span").attr("class", "description").text(this.description);
      _sel.exit().remove();
      this.el.selectAll(".number").transition().duration(375).tween("text", (d) => {
        const i = value_default(this._value, d);
        this._value = d;
        return function(t) {
          this.textContent = format2(i(t));
        };
      });
    }
    redraw() {
      this.render();
    }
  };

  // lane_pair_chart.js
  var LanePairChart = class extends AverageChart {
    constructor() {
      super();
      this.dimension = cf_default.dimension((d) => d.GameLanePair);
      const reducer = Reducer.concatAll(
        averageScoreReducer,
        valueList((x) => +x.Score),
        quartiles()
      );
      this.group = Reducer.reduceGroup(reducer, this.dimension.group());
      this.sorter = (arr) => arr.sort((a, b) => parseInt(a.key, 10) - parseInt(b.key, 10));
      this.options = {
        type: "boxplot",
        renderTo: document.getElementById("lanePairChart"),
        title: "Lane Pair Averages",
        height: 300
      };
    }
    data() {
      let _all = this.group.all();
      this.sorter(_all);
      return _all;
    }
    postRender() {
      let _all = this.data();
      this.chart.series[0].remove();
      this.chart.addSeries({
        name: "Lane Quartiles",
        color: Highcharts.theme.colors[0],
        data: _all.map((d) => {
          return {
            category: d.key,
            low: d.value.min,
            q1: d.value.q1,
            median: d.value.median,
            q3: d.value.q3,
            high: d.value.max,
            color: this.getColor(d) || Highcharts.theme.colors[0]
          };
        }),
        colorByPoint: true
      });
    }
    postRedraw() {
      let _all = this.data();
      this.chart.series[0].setData(_all.map((d) => {
        let q = this.getQuartiles(d);
        return {
          category: d.key,
          low: q[0],
          q1: q[1],
          median: q[2],
          q3: q[3],
          high: q[4],
          color: this.getColor(d) || Highcharts.theme.colors[0]
        };
      }), false);
      this.chart.render();
    }
  };

  // table.js
  var formatNumber = format(",.2f");
  function reduceAdd2(p, v) {
    let game = +v.Game;
    if (v.Block2 === "-1") {
      game += 3;
    }
    p["G" + game] = +v.Score;
    p.order = +v.Disciplineorder;
    p.Name = v.Playername;
    p.Discipline = v.Discipline;
    p.Gender = v.Gender;
    ++p.count;
    p.sum += +v.Score;
    p.Average = p.count ? p.sum / p.count : 0;
    return p;
  }
  function reduceRemove(p, v) {
    --p.count;
    p.sum -= +v.Score;
    p.Average = p.count ? p.sum / p.count : 0;
    return p;
  }
  function reduceInitial() {
    return {
      Name: "",
      Discipline: "",
      Gender: "",
      order: 0,
      G1: 0,
      G2: 0,
      G3: 0,
      G4: 0,
      G5: 0,
      G6: 0,
      count: 0,
      sum: 0,
      Average: 0
    };
  }
  var headings = ["Name", "Discipline", "Gender", "G1", "G2", "G3", "G4", "G5", "G6", "Average"];
  var Table = class {
    constructor() {
      this.dimension = cf_default.dimension((d) => [d.Playername, d.Discipline]);
      this.group = this.dimension.group().reduce(
        reduceAdd2,
        reduceRemove,
        reduceInitial
      );
      this.el = select_default2("#table > tbody");
    }
    render() {
      let data = this.group.all().filter((d) => d.value.sum !== 0).map((d) => d.value);
      let _sel = this.el.selectAll("tr").data(data, (d) => d.Name + d.Discipline);
      _sel.exit().remove();
      _sel.enter().append("tr").selectAll("td").data((row) => headings.map((k) => row[k])).enter().append("td").html((d, i) => headings[i] == "Average" ? formatNumber(d) : d);
      _sel.sort((a, b) => {
        const sorts = [ascending2(a.order, b.order), ascending2(a.Gender, b.Gender), descending(a.Average, b.Average)];
        for (let i = 0; i < sorts.length; ++i) {
          if (sorts[i] !== 0)
            return sorts[i];
        }
        return 0;
      });
    }
    redraw() {
      this.render();
    }
  };

  // stats.js
  var ssv = dsv_default(";");
  function init2(data) {
    cf_default.addData(data);
    chart_registry_default.register(new PlayerGameChart());
    chart_registry_default.register(new PlayerGameChart2());
    chart_registry_default.register(new CountryChart());
    chart_registry_default.register(new DisciplineChart());
    chart_registry_default.register(new GenderChart());
    chart_registry_default.register(new HandChart());
    chart_registry_default.register(new LanePairChart());
    chart_registry_default.register(new Table());
    chart_registry_default.register(new NumberContainer({
      anchor: "#lowGame",
      description: "Low",
      reducer: min((x) => +x.Score),
      accessor: (d) => d ? d.value.min : 0
    }));
    chart_registry_default.register(new NumberContainer({
      anchor: "#highGame",
      description: "High",
      reducer: max((x) => +x.Score),
      accessor: (d) => d ? d.value.max : 0
    }));
    chart_registry_default.register(new NumberContainer({
      anchor: "#avgGame",
      description: "Average",
      reducer: averageScoreReducer,
      accessor: (d) => d ? d.value.avg : 0
    }));
    chart_registry_default.register(new NumberContainer({
      anchor: "#totalScore",
      description: "Total",
      reducer: sum((x) => +x.Score),
      accessor: (d) => d ? d.value.sum : 0
    }));
    chart_registry_default.renderAll();
  }
  fetch("playerstats.csv").then((response) => response.text()).then(ssv.parse).then(init2);
})();
/*! Bundled license information:

highcharts/highcharts.src.js:
  (**
   * @license Highcharts JS v10.3.3 (2023-01-20)
   *
   * (c) 2009-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)

highcharts/highcharts-more.src.js:
  (**
   * @license Highcharts JS v10.3.3 (2023-01-20)
   *
   * (c) 2009-2021 Torstein Honsi
   *
   * License: www.highcharts.com/license
   *)
*/
//# sourceMappingURL=app.min.js.map

{"version":3,"sources":["node_modules/gsap/ScrollToPlugin.js"],"names":["_doc","_gsScope","document","documentElement","_window","_max","element","axis","dim","scroll","client","body","Math","max","_unwrapElement","value","TweenLite","selector","length","style","nodeType","_buildGetter","e","p","pageXOffset","toUpperCase","_getOffset","container","rect","getBoundingClientRect","b","isRoot","cRect","top","clientTop","window","pageYOffset","scrollTop","left","clientLeft","scrollLeft","offsets","x","y","_parseVal","target","type","isNaN","charAt","min","parseFloat","ScrollToPlugin","_gsDefine","plugin","propName","API","global","version","init","tween","_wdw","_target","_tween","vars","_autoKill","autoKill","getX","getY","xPrev","yPrev","_addTween","offsetX","_overwriteProps","push","skipX","offsetY","skipY","set","v","_super","setRatio","call","yDif","xDif","threshold","autoKillThreshold","kill","onAutoKill","apply","onAutoKillScope","onAutoKillParams","scrollTo","prototype","getOffset","buildGetter","_kill","lookup","scrollTo_x","scrollTo_y"],"mappings":"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","file":"ScrollToPlugin.28dc3b5a.map","sourceRoot":"..","sourcesContent":["/*!\n * VERSION: 1.9.1\n * DATE: 2018-05-30\n * UPDATES AND DOCS AT: http://greensock.com\n *\n * @license Copyright (c) 2008-2018, GreenSock. All rights reserved.\n * This work is subject to the terms at http://greensock.com/standard-license or for\n * Club GreenSock members, the software agreement that was issued with your membership.\n * \n * @author: Jack Doyle, jack@greensock.com\n **/\nimport { _gsScope } from \"./TweenLite.js\";\n\n\nvar _doc = (_gsScope.document || {}).documentElement,\n\t\t_window = _gsScope,\n\t\t_max = function(element, axis) {\n\t\t\tvar dim = (axis === \"x\") ? \"Width\" : \"Height\",\n\t\t\t\tscroll = \"scroll\" + dim,\n\t\t\t\tclient = \"client\" + dim,\n\t\t\t\tbody = document.body;\n\t\t\treturn (element === _window || element === _doc || element === body) ? Math.max(_doc[scroll], body[scroll]) - (_window[\"inner\" + dim] || _doc[client] || body[client]) : element[scroll] - element[\"offset\" + dim];\n\t\t},\n\t\t_unwrapElement = function(value) {\n\t\t\tif (typeof(value) === \"string\") {\n\t\t\t\tvalue = TweenLite.selector(value);\n\t\t\t}\n\t\t\tif (value.length && value !== _window && value[0] && value[0].style && !value.nodeType) {\n\t\t\t\tvalue = value[0];\n\t\t\t}\n\t\t\treturn (value === _window || (value.nodeType && value.style)) ? value : null;\n\t\t},\n\t\t_buildGetter = function(e, axis) { //pass in an element and an axis (\"x\" or \"y\") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.\n\t\t\tvar p = \"scroll\" + ((axis === \"x\") ? \"Left\" : \"Top\");\n\t\t\tif (e === _window) {\n\t\t\t\tif (e.pageXOffset != null) {\n\t\t\t\t\tp = \"page\" + axis.toUpperCase() + \"Offset\";\n\t\t\t\t} else if (_doc[p] != null) {\n\t\t\t\t\te = _doc;\n\t\t\t\t} else {\n\t\t\t\t\te = document.body;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn function() {\n\t\t\t\treturn e[p];\n\t\t\t};\n\t\t},\n\t\t_getOffset = function(element, container) {\n\t\t\tvar rect = _unwrapElement(element).getBoundingClientRect(),\n\t\t\t\tb = document.body,\n\t\t\t\tisRoot = (!container || container === _window || container === b),\n\t\t\t\tcRect = isRoot ? {top:_doc.clientTop - (window.pageYOffset || _doc.scrollTop || b.scrollTop || 0), left:_doc.clientLeft - (window.pageXOffset || _doc.scrollLeft || b.scrollLeft || 0)} : container.getBoundingClientRect(),\n\t\t\t\toffsets = {x: rect.left - cRect.left, y: rect.top - cRect.top};\n\t\t\tif (!isRoot && container) { //only add the current scroll position if it's not the window/body.\n\t\t\t\toffsets.x += _buildGetter(container, \"x\")();\n\t\t\t\toffsets.y += _buildGetter(container, \"y\")();\n\t\t\t}\n\t\t\treturn offsets;\n\t\t\t/*\tPREVIOUS\n\t\t\tvar rect = _unwrapElement(element).getBoundingClientRect(),\n\t\t\t\tisRoot = (!container || container === _window || container === document.body),\n\t\t\t\tcRect = (isRoot ? _doc : container).getBoundingClientRect(),\n\t\t\t\toffsets = {x: rect.left - cRect.left, y: rect.top - cRect.top};\n\t\t\tif (!isRoot && container) { //only add the current scroll position if it's not the window/body.\n\t\t\t\toffsets.x += _buildGetter(container, \"x\")();\n\t\t\t\toffsets.y += _buildGetter(container, \"y\")();\n\t\t\t}\n\t\t\treturn offsets;\n\t\t\t*/\n\t\t},\n\t\t_parseVal = function(value, target, axis) {\n\t\t\tvar type = typeof(value);\n\t\t\treturn !isNaN(value) ? parseFloat(value) : (type === \"number\" || (type === \"string\" && value.charAt(1) === \"=\")) ? value : (value === \"max\") ? _max(target, axis) : Math.min(_max(target, axis), _getOffset(value, target)[axis]);\n\t\t},\n\n\t\tScrollToPlugin = _gsScope._gsDefine.plugin({\n\t\t\tpropName: \"scrollTo\",\n\t\t\tAPI: 2,\n\t\t\tglobal: true,\n\t\t\tversion:\"1.9.1\",\n\n\t\t\t//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.\n\t\t\tinit: function(target, value, tween) {\n\t\t\t\tthis._wdw = (target === _window);\n\t\t\t\tthis._target = target;\n\t\t\t\tthis._tween = tween;\n\t\t\t\tif (typeof(value) !== \"object\") {\n\t\t\t\t\tvalue = {y:value}; //if we don't receive an object as the parameter, assume the user intends \"y\".\n\t\t\t\t\tif (typeof(value.y) === \"string\" && value.y !== \"max\" && value.y.charAt(1) !== \"=\") {\n\t\t\t\t\t\tvalue.x = value.y;\n\t\t\t\t\t}\n\t\t\t\t} else if (value.nodeType) {\n\t\t\t\t\tvalue = {y:value, x:value};\n\t\t\t\t}\n\t\t\t\tthis.vars = value;\n\t\t\t\tthis._autoKill = (value.autoKill !== false);\n\t\t\t\tthis.getX = _buildGetter(target, \"x\");\n\t\t\t\tthis.getY = _buildGetter(target, \"y\");\n\t\t\t\tthis.x = this.xPrev = this.getX();\n\t\t\t\tthis.y = this.yPrev = this.getY();\n\t\t\t\tif (value.x != null) {\n\t\t\t\t\tthis._addTween(this, \"x\", this.x, _parseVal(value.x, target, \"x\") - (value.offsetX || 0), \"scrollTo_x\", true);\n\t\t\t\t\tthis._overwriteProps.push(\"scrollTo_x\");\n\t\t\t\t} else {\n\t\t\t\t\tthis.skipX = true;\n\t\t\t\t}\n\t\t\t\tif (value.y != null) {\n\t\t\t\t\tthis._addTween(this, \"y\", this.y, _parseVal(value.y, target, \"y\") - (value.offsetY || 0), \"scrollTo_y\", true);\n\t\t\t\t\tthis._overwriteProps.push(\"scrollTo_y\");\n\t\t\t\t} else {\n\t\t\t\t\tthis.skipY = true;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)\n\t\t\tset: function(v) {\n\t\t\t\tthis._super.setRatio.call(this, v);\n\n\t\t\t\tvar x = (this._wdw || !this.skipX) ? this.getX() : this.xPrev,\n\t\t\t\t\ty = (this._wdw || !this.skipY) ? this.getY() : this.yPrev,\n\t\t\t\t\tyDif = y - this.yPrev,\n\t\t\t\t\txDif = x - this.xPrev,\n\t\t\t\t\tthreshold = ScrollToPlugin.autoKillThreshold;\n\n\t\t\t\tif (this.x < 0) { //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)\n\t\t\t\t\tthis.x = 0;\n\t\t\t\t}\n\t\t\t\tif (this.y < 0) {\n\t\t\t\t\tthis.y = 0;\n\t\t\t\t}\n\t\t\t\tif (this._autoKill) {\n\t\t\t\t\t//note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.\n\t\t\t\t\tif (!this.skipX && (xDif > threshold || xDif < -threshold) && x < _max(this._target, \"x\")) {\n\t\t\t\t\t\tthis.skipX = true; //if the user scrolls separately, we should stop tweening!\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.skipY && (yDif > threshold || yDif < -threshold) && y < _max(this._target, \"y\")) {\n\t\t\t\t\t\tthis.skipY = true; //if the user scrolls separately, we should stop tweening!\n\t\t\t\t\t}\n\t\t\t\t\tif (this.skipX && this.skipY) {\n\t\t\t\t\t\tthis._tween.kill();\n\t\t\t\t\t\tif (this.vars.onAutoKill) {\n\t\t\t\t\t\t\tthis.vars.onAutoKill.apply(this.vars.onAutoKillScope || this._tween, this.vars.onAutoKillParams || []);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this._wdw) {\n\t\t\t\t\t_window.scrollTo((!this.skipX) ? this.x : x, (!this.skipY) ? this.y : y);\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.skipY) {\n\t\t\t\t\t\tthis._target.scrollTop = this.y;\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.skipX) {\n\t\t\t\t\t\tthis._target.scrollLeft = this.x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.xPrev = this.x;\n\t\t\t\tthis.yPrev = this.y;\n\t\t\t}\n\n\t\t}),\n\t\tp = ScrollToPlugin.prototype;\n\n\tScrollToPlugin.max = _max;\n\tScrollToPlugin.getOffset = _getOffset;\n\tScrollToPlugin.buildGetter = _buildGetter;\n\tScrollToPlugin.autoKillThreshold = 7;\n\n\tp._kill = function(lookup) {\n\t\tif (lookup.scrollTo_x) {\n\t\t\tthis.skipX = true;\n\t\t}\n\t\tif (lookup.scrollTo_y) {\n\t\t\tthis.skipY = true;\n\t\t}\n\t\treturn this._super._kill.call(this, lookup);\n\t};\n\n\nexport { ScrollToPlugin, ScrollToPlugin as default };"]}